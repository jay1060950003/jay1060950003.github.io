<!DOCTYPE html>
<html lang="zh-CN">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#5.8.0'>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="Volantis" content="5.8.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="http://jay1060950003.github.io/2022/05/05/计算机基础知识/操作系统/"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  <link rel="stylesheet" href="https://unpkg.com/katex@0.16.0/dist/katex.css" integrity="sha384-1IGr2Yb8xuHjwTG+WoGjj2+I/a/N6z0gDD5YIGCQxywPROOKc3+orbn/R7arWQxD" crossorigin="anonymous">
<script src="https://unpkg.com/katex@0.16.0/dist/katex.js" integrity="sha384-I2b1Pcl48X93GxEkGkaMo1hrd6n+IX8H2wgSsMimGbkZoGTve/87h1FjaDNvlpQi" crossorigin="anonymous"></script>
  <!-- Custom Files headBegin end-->
  <!-- front-matter head_begin begin -->
  <!-- front-matter head_begin end -->
    <link rel="shortcut icon" type='image/x-icon' href="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed//favicon.ico">
  <link rel="preload" href="/css/style.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
  <!-- 页面元数据 -->
  <title>操作系统 - CodingStudio</title>
  <meta name="keywords" content="Basic,C++,Java,Qt,OpenCV,后端,开发者,程序猿,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder, 摄影">
  <meta desc name="description" content=" 引言

《极客时间操作系统45讲》学习笔记
 - jay1060950003 - CodingStudio">
  
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://jay1060950003.github.io/2022/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="CodingStudio">
<meta property="og:description" content="引言  《极客时间操作系统45讲》学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2022-05-05T07:53:37.000Z">
<meta property="article:modified_time" content="2023-05-06T16:12:59.036Z">
<meta property="article:author" content="jay1060950003">
<meta property="article:tag" content="Basic">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
.post-story + .post-story {
  content-visibility: auto;
  contain-intrinsic-size: 10px 500px;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #30ad91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #2092ec;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-bg {
  position: absolute;
  width: 100%;
  height: 100%;
  background-position: center;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
}
.cover-wrapper .cover-bg.lazyload:not(.loaded) {
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
}
.cover-wrapper .cover-bg.lazyload.loaded {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
.cover-wrapper #parallax-window {
  position: absolute;
  width: 100%;
  height: 100%;
  background: transparent;
}
.parallax-mirror {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media (prefers-color-scheme: dark) {
  :root {
    --color-mode: 'dark';
  }
  :root:not([color-scheme]) {
    --color-site-body: #121212;
    --color-read-bkg: #1f1f1f;
    --color-read-post: #262626;
    --color-site-bg: #1f1f1f;
    --color-site-inner: rgba(238,238,238,0.871);
    --color-site-footer: rgba(170,170,170,0.871);
    --color-card: #262626;
    --color-text: rgba(238,238,238,0.871);
    --color-block: #434343;
    --color-codeblock: #1f1f1f;
    --color-inlinecode: #d56d28;
    --color-h1: rgba(255,255,255,0.871);
    --color-h2: rgba(255,255,255,0.871);
    --color-h3: rgba(255,255,255,0.6);
    --color-h4: rgba(255,255,255,0.6);
    --color-h5: rgba(255,255,255,0.6);
    --color-h6: rgba(255,255,255,0.6);
    --color-p: rgba(217,217,217,0.871);
    --color-list: rgba(217,217,217,0.871);
    --color-list-hl: #63e0c4;
    --color-meta: rgba(191,191,191,0.871);
    --color-link: rgba(191,191,191,0.871);
    --color-copyright-bkg: #21252b;
  }
  :root:not([color-scheme]) img {
    filter: brightness(70%) !important;
  }
  :root:not([color-scheme]) .blur {
    background: rgba(31,31,31,0.9) !important;
  }
  :root:not([color-scheme]) .white-box.blur {
    background: rgba(38,38,38,0.9) !important;
  }
  :root:not([color-scheme]) .nav-main .u-search-input {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a:hover {
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) .article blockquote {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .article-title a {
    color: var(--color-h1) !important;
  }
  :root:not([color-scheme]) details>summary {
    color: var(--color-p) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) details {
    border: 1px solid var(--color-site-bg) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) #u-search .modal,
  :root:not([color-scheme]) #u-search .modal-header,
  :root:not([color-scheme]) #u-search .modal-body {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #u-search .modal-body .modal-results .result:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:focus {
    background: var(--color-site-body) !important;
  }
}
[color-scheme='dark'] {
  --color-site-body: #121212;
  --color-read-bkg: #1f1f1f;
  --color-read-post: #262626;
  --color-site-bg: #1f1f1f;
  --color-site-inner: rgba(238,238,238,0.871);
  --color-site-footer: rgba(170,170,170,0.871);
  --color-card: #262626;
  --color-text: rgba(238,238,238,0.871);
  --color-block: #434343;
  --color-codeblock: #1f1f1f;
  --color-inlinecode: #d56d28;
  --color-h1: rgba(255,255,255,0.871);
  --color-h2: rgba(255,255,255,0.871);
  --color-h3: rgba(255,255,255,0.6);
  --color-h4: rgba(255,255,255,0.6);
  --color-h5: rgba(255,255,255,0.6);
  --color-h6: rgba(255,255,255,0.6);
  --color-p: rgba(217,217,217,0.871);
  --color-list: rgba(217,217,217,0.871);
  --color-list-hl: #63e0c4;
  --color-meta: rgba(191,191,191,0.871);
  --color-link: rgba(191,191,191,0.871);
  --color-copyright-bkg: #21252b;
}
[color-scheme='dark'] img {
  filter: brightness(70%) !important;
}
[color-scheme='dark'] .blur {
  background: rgba(31,31,31,0.9) !important;
}
[color-scheme='dark'] .white-box.blur {
  background: rgba(38,38,38,0.9) !important;
}
[color-scheme='dark'] .nav-main .u-search-input {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a {
  background: var(--color-block) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a:hover {
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] .article blockquote {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .article-title a {
  color: var(--color-h1) !important;
}
[color-scheme='dark'] details>summary {
  color: var(--color-p) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] details {
  border: 1px solid var(--color-site-bg) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] #u-search .modal,
[color-scheme='dark'] #u-search .modal-header,
[color-scheme='dark'] #u-search .modal-body {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #u-search .modal-body .modal-results .result:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:focus {
  background: var(--color-site-body) !important;
}
@media screen and (max-width: 500px) {
  [color-scheme='dark'] .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1080px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #3dd9b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #3dd9b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #3dd9b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1080px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1112px;
    left: calc((100% - 1112px) * 0.5);
  }
}
@media screen and (max-width: 1112px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}
@media screen and (prefers-color-scheme: dark) and (max-width: 500px) {
  .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
    <script>
      let userColorScheme=localStorage.getItem("color-scheme")
      if(userColorScheme){
        document.documentElement.setAttribute("color-scheme", userColorScheme);
      }
    </script>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>`+
        `<span class="kill-c">微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>了解详情 ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>
        <span class="kill-c">本页面需要浏览器支持（启用）JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = "false"; // 调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    debug: false,
    cdn: {"js":{"app":"/js/app.js","parallax":"/js/plugins/parallax.js","rightMenu":"/js/plugins/rightMenu.js","rightMenus":"/js/plugins/rightMenus.js","sites":"/js/plugins/tags/sites.js","friends":"/js/plugins/tags/friends.js","contributors":"/js/plugins/tags/contributors.js","search":"/js/search/hexo.js"},"css":{"style":"/css/style.css"}},
    default: {"avatar":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg","link":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/link/8f277b4ee0ecd.svg","cover":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg","image":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/image/2659360.svg"},
    lastupdate: new Date(1702470597376),
    sidebar: {
      for_page: ["blogger","category","tagcloud","webinfo","lastupdate","donate"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2021/09/20",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js","icon":{"default":"fa-light fa-info-circle light-blue","quection":"fa-light fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"fa-brands fa-creative-commons light-blue"},"aplayer":{"enable":true,"play":"fa-light fa-play light-blue","pause":"fa-light fa-pause light-blue","error":"fa-light fa-exclamation-square red"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      
      aplayer: {
        id: 5062959861,
        enable:true
      },
      
      
      
      rightmenus: {"enable":true,"order":["plugins.navigation","hr","plugins.inputBox","plugins.seletctText","plugins.elementCheck","plugins.elementImage","hr","menus.darkMode","hr","plugins.articlePage","hr","music"],"options":{"iconPrefix":"fa-duotone PETERRIVE","articleShowLink":true,"musicAlwaysShow":true},"plugins":{"navigation":[{"id":"left","name":"转到上一页","icon":"fa-duotone fa-arrow-left PETERRIVE","event":"history.back()","group":"navigation"},{"id":"right","name":"转到下一页","icon":"fa-duotone fa-arrow-right PETERRIVE","event":"history.forward()","group":"navigation"},{"id":"redo","name":"刷新当前页面","icon":"fa-duotone fa-redo PETERRIVE","event":"window.location.reload()","group":"navigation"},{"id":"home","name":"回到首页","icon":"fa-duotone fa-home PETERRIVE","link":"/","group":"navigation"},{"id":"up","name":"回到顶部","icon":"fa-duotone fa-arrow-up PETERRIVE","event":"VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)","group":"navigation"}],"inputBox":[{"id":"copyPaste","name":"粘贴文本","icon":"fa-duotone PETERRIVE fa-paste","event":"copyPaste","group":"inputBox"},{"id":"copyAll","name":"全选文本","icon":"fa-duotone PETERRIVE fa-object-ungroup","event":"copyAll","group":"inputBox"},{"id":"copyCut","name":"剪切文本","icon":"fa-duotone PETERRIVE fa-cut","event":"copyCut","group":"inputBox"}],"seletctText":[{"id":"copyText","name":"复制文本","icon":"fa-duotone PETERRIVE fa-copy","event":"copyText","group":"seletctText"},{"id":"searchWord","name":"站内搜索","icon":"fa-duotone PETERRIVE fa-search","event":"OpenSearch(__text__)","group":"seletctText"},{"id":"bingSearch","name":"必应搜索","icon":"fa-duotone PETERRIVE fa-search","event":"window.open(`https://cn.bing.com/search?q=${__text__}`)","group":"seletctText"}],"elementCheck":[{"id":"openTab","name":"新标签页打开","icon":"fa-duotone PETERRIVE fa-external-link-square-alt","event":"window.open(__link__)","group":"elementCheck"},{"id":"copyLink","name":"复制链接地址","icon":"fa-duotone PETERRIVE fa-link","event":"copyLink","group":"elementCheck"}],"elementImage":[{"id":"copyImg","name":"复制图片","icon":"fa-duotone PETERRIVE fa-image","event":"copyImg","group":"elementImage"},{"id":"googleImg","name":"谷歌识图","icon":"fa-duotone PETERRIVE fa-images","event":"window.open(`https://www.google.com/searchbyimage?image_url=${__link__}`)","group":"elementImage"}],"articlePage":[{"id":"printMode","name":"打印页面","icon":"fa-duotone fa-print TURQUOISE","event":"printMode","group":"articlePage"},{"id":"readMode","name":"阅读模式","icon":"fa-duotone fa-book-open EMERALD","event":"readMode","group":"articlePage"}]},"menus":{"link":[{"id":"help","name":"常见问题","icon":"fa-solid fa-question","link":"https://volantis.js.org/faqs/","group":"link"},{"id":"examples","name":"示例博客","icon":"fa-solid fa-rss","link":"https://volantis.js.org/examples/","group":"link"},{"id":"contributors","name":"加入社区","icon":"fa-solid fa-fan","link":"https://volantis.js.org/contributors/","group":"link"},"hr",{"id":"source_docs","name":"本站源码","icon":"fa-solid fa-code-branch","link":"https://github.com/volantis-x/volantis-docs/","group":"link"},{"id":"source_theme","name":"主题源码","icon":"fa-solid fa-code-branch","link":"https://github.com/volantis-x/hexo-theme-volantis/","group":"link"}],"darkMode":[{"id":"darkMode","name":"暗黑模式","icon":"fa-duotone fa-eclipse-alt WISTERIA","event":"volantis.dark.toggle()","group":"darkMode"}]}}
      
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = Object.assign(volantis.pjax, {
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  });
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list=[]
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  volantis.scroll.ele = null;
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) => {
    if (!ele) return;
    volantis.scroll.ele = ele;
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(() => {
        if (volantis.scroll.ele != ele) {
          return
        }
        volantis.scroll.unengine.push(() => {
          let me = ele.getBoundingClientRect().top
          if(!(me >= -option.observerDic && me <= option.observerDic)){
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        },"unengineObserver")
      },1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = ()=>{
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e=>{
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
  <!-- front-matter head_end begin -->
  <!-- front-matter head_end end -->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <!-- import body_begin begin-->
    <!-- import body_begin end-->
    <!-- Custom Files bodyBegin begin-->
    
    <!-- Custom Files bodyBegin end-->
    <!-- front-matter body_begin begin -->
    <!-- front-matter body_begin end -->
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto shadow floatable blur " style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            CodingStudio <sup style="color:#ff9800">alpha</sup>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="文档"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-duotone fa-book faa-tada fa-fw'></i>文档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-duotone fa-play-circle faa-tada fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-duotone fa-question-circle faa-tada fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-duotone fa-heart fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="更多"
                  
                  
                  >
                  <i class='fa-duotone fa-ellipsis-v fa-fw'></i>更多
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-solid fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
                    
                      
            
              
                <li>
                  <a class="menuitem flat-box">
                    <i class='fa-solid fa-compact-disc fa-fw music'></i>背景音乐
                  </a>
                  <ul class="list-v">
                    <li>
                      <div class="aplayer-container">
                        

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.4'
      loop='all'
      order='random'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5062959861'
      list-folded='true'>
    </meting-js>
  


                      </div>
                    </li>
                  </ul>
                <li>
              
            
          
                    
                  </ul>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="文档"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-duotone fa-book faa-tada fa-fw'></i>文档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-duotone fa-play-circle faa-tada fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-duotone fa-question-circle faa-tada fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-duotone fa-heart fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="更多"
                  
                  
                  >
                  <i class='fa-duotone fa-ellipsis-v fa-fw'></i>更多
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-solid fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
                    
                      
            
              
            
          
                    
                  </ul>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="half" class='cover-wrapper post search' style="display: ;">
        
  <div id="parallax-window"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">CodingStudio</p>
    
    
      <p class="subtitle">努力进步</p>
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="搜一下" />
          <i class="icon fa-solid fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow floatable blur article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="http://jay1060950003.github.io/2022/05/05/计算机基础知识/操作系统/">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="CodingStudio">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="CodingStudio">
    <meta itemprop="description" content="自己的创作及学习空间">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title" itemprop="name headline">
        操作系统
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author' itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a itemprop="url" class='author' target="_blank" href="https://github.com/jay1060950003" rel="nofollow noopener">
    <img itemprop="image" src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/apple-touch-icon.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/apple-touch-icon.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
    <p itemprop="name">jay1060950003</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <i class="fa-solid fa-folder-open fa-fw" aria-hidden="true"></i>
    <a class="category-link" href="/categories/Basic/">Basic</a>
    
      <span hidden itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/Basic/" itemprop="url"><span itemprop="name">Basic</span></a>
      </span>
    
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateCreated datePublished" datetime="2022-05-05T15:53:37+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2022年5月5日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fa-solid fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>字数：127.7k 字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fa-solid fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>时长：525 分钟</p>
    </a>
  </div>


          
        
          
            


<div class="new-meta-item browse">
  <a class='notlink'>
    <p>
      <i class="fa-solid fa-eye fa-fw" aria-hidden="true"></i>
      
      <span id="busuanzi_value_page_pv"><i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i></span>
      
      <span>次浏览</span>
    </p>
  </a>
</div>


          
        
        <!-- Custom Files topMeta begin-->
        
        <!-- Custom Files topMeta end-->
      </div>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<ul>
<li>《极客时间操作系统45讲》学习笔记</li>
</ul>
<span id="more"></span>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-05-15-56-25.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-05-15-56-25.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="操纵系统课程图解" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-05-15-57-16.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-05-15-57-16.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="操作系统核心子部门" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-05-15-55-37.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-05-15-55-37.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="操作系统知识体系图" /></p>
<hr />
<h1 id="1-从hello到另一个hello"><a class="markdownIt-Anchor" href="#1-从hello到另一个hello"></a> 1 从hello到另一个hello</h1>
<div class="story post-story"><h2 id="11-程序的运行过程从代码到机器运行"><a class="markdownIt-Anchor" href="#11-程序的运行过程从代码到机器运行"></a> 1.1 程序的运行过程:从代码到机器运行</h2>
<h3 id="程序编译过程"><a class="markdownIt-Anchor" href="#程序编译过程"></a> 程序编译过程</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;studio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译</span></span><br><span class="line">gcc HelloWorld.c -o HelloWorld</span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line">./HelloWorld</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用命令编译:gcc HelloWorld.c -o HelloWorld</p>
<ul>
<li>gcc只是完成编译工作的驱动程序,根据编译流程分别调用预处理程序,编译程序,汇编程序,链接程序来完成具体工作</li>
<li>手动控制编译流程
<ul>
<li>gcc -E HelloWorld.c -o HelloWorld.i预处理,加入头文件,替换宏</li>
<li>gcc -S HelloWorld.i -o HelloWorld.s编译,包含预处理,将C转换成汇编程序</li>
<li>gcc -c HelloWorld.s -o HelloWorld.o汇编,包含预处理和编译,将汇编程序转换成可链接的二进制程序</li>
<li>gcc HelloWorld.o -o HelloWorld…链接,包含以上所有操作,将可链接的二进制程序和其他库链接形成可执行的程序文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-05-17-09-57.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-05-17-09-57.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="编译流程" /></p>
</li>
</ul>
<h3 id="程序装载执行"><a class="markdownIt-Anchor" href="#程序装载执行"></a> 程序装载执行</h3>
<ul>
<li>冯诺依曼体系计算机结构
<ul>
<li>输入设备</li>
<li>存储器</li>
<li>运算器</li>
<li>控制器</li>
<li>输出设备</li>
</ul>
</li>
</ul>
<h3 id="更形象地将helloworld程序装入原型计算机"><a class="markdownIt-Anchor" href="#更形象地将helloworld程序装入原型计算机"></a> 更形象地将HelloWorld程序装入原型计算机</h3>
<ul>
<li>使用gcc -Og -S HelloWorld可得到汇编代码
<ul>
<li>使用objdump -d HelloWorld,得到/lesson01/HelloWorld.dump,其中含有库代码</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="12-实现一个最简单的内核"><a class="markdownIt-Anchor" href="#12-实现一个最简单的内核"></a> 1.2 实现一个最简单的内核</h2>
<h3 id="pc机的引导流程"><a class="markdownIt-Anchor" href="#pc机的引导流程"></a> PC机的引导流程</h3>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-10-51-57.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-10-51-57.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Hello OS的引导流程" /></p>
<ul>
<li>PC上电后,执行BIOS固件程序,<mark>负责检测和初始化CPU,内存及主板平台</mark>,然后加载引导设备的第一个扇区数据,到0x7c00地址开始的内存空间,再跳转到0x7c00处执行指令</li>
</ul>
<h3 id="hello-os引导汇编代码"><a class="markdownIt-Anchor" href="#hello-os引导汇编代码"></a> Hello OS引导汇编代码</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">MBT_HDR_FLAGS EQU <span class="number">0x00010003</span></span><br><span class="line">MBT_HDR_MAGIC EQU <span class="number">0x1BADB002</span> ;多引导协议头魔数</span><br><span class="line">MBT_HDR2_MAGIC EQU <span class="number">0xe85250d6</span> ;第二版多引导协议头魔数</span><br><span class="line">global _start ;导出_start符号</span><br><span class="line"><span class="keyword">extern</span> main ;导入外部的main函数符号</span><br><span class="line">[section .start.text] ;定义.start.text代码节</span><br><span class="line">[bits <span class="number">32</span>] ;汇编成<span class="number">32</span>位代码</span><br><span class="line">_start:</span><br><span class="line">jmp _entry</span><br><span class="line">ALIGN <span class="number">8</span></span><br><span class="line">mbt_hdr:</span><br><span class="line">dd MBT_HDR_MAGIC</span><br><span class="line">dd MBT_HDR_FLAGS</span><br><span class="line">dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)</span><br><span class="line">dd mbt_hdr</span><br><span class="line">dd _start</span><br><span class="line">dd <span class="number">0</span></span><br><span class="line">dd <span class="number">0</span></span><br><span class="line">dd _entry</span><br><span class="line">;以上是GRUB所需要的头</span><br><span class="line">ALIGN <span class="number">8</span></span><br><span class="line">mbt2_hdr:</span><br><span class="line">DD MBT_HDR2_MAGIC</span><br><span class="line">DD <span class="number">0</span></span><br><span class="line">DD mbt2_hdr_end - mbt2_hdr</span><br><span class="line">DD -(MBT_HDR2_MAGIC + <span class="number">0</span> + (mbt2_hdr_end - mbt2_hdr))</span><br><span class="line">DW <span class="number">2</span>, <span class="number">0</span></span><br><span class="line">DD <span class="number">24</span></span><br><span class="line">DD mbt2_hdr</span><br><span class="line">DD _start</span><br><span class="line">DD <span class="number">0</span></span><br><span class="line">DD <span class="number">0</span></span><br><span class="line">DW <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">DD <span class="number">12</span></span><br><span class="line">DD _entry</span><br><span class="line">DD <span class="number">0</span></span><br><span class="line">DW <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">DD <span class="number">8</span></span><br><span class="line">mbt2_hdr_end:</span><br><span class="line">;以上是GRUB2所需要的头</span><br><span class="line">;包含两个头是为了同时兼容GRUB、GRUB2</span><br><span class="line">ALIGN <span class="number">8</span></span><br><span class="line">_entry:</span><br><span class="line">;关中断</span><br><span class="line">cli</span><br><span class="line">;关不可屏蔽中断</span><br><span class="line">in al, <span class="number">0x70</span></span><br><span class="line">or al, <span class="number">0x80</span></span><br><span class="line">out <span class="number">0x70</span>,al</span><br><span class="line">;重新加载GDT</span><br><span class="line">lgdt [GDT_PTR]</span><br><span class="line">jmp dword <span class="number">0x8</span> :_32bits_mode</span><br><span class="line">_32bits_mode:</span><br><span class="line">;下面初始化C语言可能会用到的寄存器</span><br><span class="line">mov ax, <span class="number">0x10</span></span><br><span class="line">mov ds, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov fs, ax</span><br><span class="line">mov gs, ax</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor edi,edi</span><br><span class="line">xor esi,esi</span><br><span class="line">xor ebp,ebp</span><br><span class="line">xor esp,esp</span><br><span class="line">;初始化栈,C语言需要栈才能工作</span><br><span class="line">mov esp,<span class="number">0x9000</span></span><br><span class="line">;调用C语言函数main</span><br><span class="line">call main</span><br><span class="line">;让CPU停止执行指令</span><br><span class="line">halt_step:</span><br><span class="line">halt</span><br><span class="line">jmp halt_step</span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq <span class="number">0</span></span><br><span class="line">kcode_dsc: dq <span class="number">0x00cf9e000000ffff</span></span><br><span class="line">kdata_dsc: dq <span class="number">0x00cf92000000ffff</span></span><br><span class="line">k16cd_dsc: dq <span class="number">0x00009e000000ffff</span></span><br><span class="line">k16da_dsc: dq <span class="number">0x000092000000ffff</span></span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN dw GDT_END-GDT_START<span class="number">-1</span></span><br><span class="line">GDTBASE dd GDT_START</span><br></pre></td></tr></table></figure>
<ul>
<li>代码分为4个部分
<ul>
<li>1-40行:汇编定义GRUB多引导协议头</li>
<li>44-52行:关闭中断,设定CPU的工作模式</li>
<li>54-73行:初始化CPU寄存器和C语言的运行环境</li>
<li>78-87行,GDT_START开始的,是CPU工作模式需要的数据</li>
</ul>
</li>
</ul>
<h3 id="hello-os的主函数"><a class="markdownIt-Anchor" href="#hello-os的主函数"></a> Hello OS的主函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vgastr.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello OS!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><mark>需要自己实现printf函数(在vgastr.h中)</mark></li>
</ul>
<h3 id="控制计算机屏幕"><a class="markdownIt-Anchor" href="#控制计算机屏幕"></a> 控制计算机屏幕</h3>
<ul>
<li><strong>显卡支持VESA标准</strong>
<ul>
<li>该标准具有两种工作模式:字符模式和图形模式</li>
<li><strong>显卡为了兼容这种标准,需要提供VGABIOS固件程序</strong></li>
</ul>
</li>
<li>字符模式的工作细节
<ul>
<li>将屏幕分成24行,每行80个字节,将24*80个位置映射到以0xb8000地址开始的内存中,每两个字节对应一个字符,其中一个字节是字符的ASCII码,另一个字节为字符的颜色值</li>
</ul>
</li>
<li><mark>C语言是UTF8编码,对ASCII编码兼容,英文字符的ASCII编码和UTF8编码相等</mark></li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-20-17-07.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-20-17-07.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="计算机显卡文本模式" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _strwrite(<span class="type">char</span>* <span class="built_in">string</span>)&#123;</span><br><span class="line">  <span class="type">char</span>* p_strdst = (<span class="type">char</span>*)(<span class="number">0xb8000</span>);</span><br><span class="line">  <span class="keyword">while</span>(*<span class="built_in">string</span>)&#123;</span><br><span class="line">    *p_strdst = *<span class="built_in">string</span>++;</span><br><span class="line">    p_strdst +=<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf</span><span class="params">(<span class="type">char</span>* fmt,...)</span>&#123;</span><br><span class="line">  _strwrite(fmt);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译和安装hello-os"><a class="markdownIt-Anchor" href="#编译和安装hello-os"></a> 编译和安装Hello OS</h3>
<ul>
<li>编译使用四条命令完成 <a href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B">跳转至命令</a></li>
</ul>
<h3 id="make工具"><a class="markdownIt-Anchor" href="#make工具"></a> make工具</h3>
<ul>
<li>使用make工具程序,读取makefile文件,该文件写好了构建软件的程序,根据规则自动化构建程序</li>
<li>makefile文件的规则
<ul>
<li>首先由一个或者多个构建目标称为target</li>
<li>目标后面紧跟着用于构建该目标所需要的文件,目标下面是构建该目标所需要的命令及参数</li>
</ul>
</li>
<li>第一次构建目标后,下一次执行make时,会根据该目标所依赖的文件是否更新决定是否编译该目标
<ul>
<li><mark>若依赖文件没有更新,则不构建目标</mark></li>
</ul>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc <span class="comment">#定义一个宏CC 等于gcc</span></span><br><span class="line">CFLAGS = -c <span class="comment">#定义一个宏 CFLAGS 等于-c</span></span><br><span class="line">OBJS_FILE = <span class="keyword">file</span>.c file1.c file2.c file3.c file4.c <span class="comment">#定义一个宏</span></span><br><span class="line">.PHONY : all everything <span class="comment">#定义两个伪目标all、everything</span></span><br><span class="line">all:everything <span class="comment">#伪目标all依赖于伪目标everything</span></span><br><span class="line">everything :$( OBJS_FILE) <span class="comment">#伪目标everything依赖于OBJS_FILE,而OBJS_FILE是宏会被</span></span><br><span class="line"><span class="comment">#替换成file.c file1.c file2.c file3.c file4.c</span></span><br><span class="line">%.o : %.c</span><br><span class="line">$(CC) $(CFLAGS) -o $@ $&lt;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码解释
<ul>
<li>make规定#后面为注释</li>
<li>makefile定义宏
<ul>
<li>字符串后面跟一个=或:=</li>
<li><strong>引用宏时使用$(宏名)</strong>,宏最终会在宏出现的地方替换成相应的字符串</li>
</ul>
</li>
<li>.PHONY表示定义伪目标
<ul>
<li>伪目标不代表一个真正的文件名,在执行 make 时可以指定这个目标来执行其所在规则定义的命令.但是伪目标可以依赖于另一个伪目标或者文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-20-40-59.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-20-40-59.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="编译过程" /></p>
<h3 id="安装hello-os"><a class="markdownIt-Anchor" href="#安装hello-os"></a> 安装Hello OS</h3>
<ul>
<li>得到Hello OS.bin,在计算机启动时加载该文件,该过程称为<strong>安装</strong></li>
<li>GRUB在启动时加载一个grub.cfg的文本文件,根据其中的内容执行相应的操作,<strong>其中包含启动项</strong>
<ul>
<li>将启动代码插入到/boot/grub/grub.cfg文件中,然后将Hello OS.bin复制到/boot/目录下,最终可启动Hello OS</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;HelloOS&#x27;</span> &#123;</span><br><span class="line">insmod part_msdos #GRUB加载分区模块识别分区</span><br><span class="line">insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统</span><br><span class="line"><span class="built_in">set</span> root=<span class="string">&#x27;hd0,msdos4&#x27;</span> #注意boot目录挂载的分区,这是我机器上的情况</span><br><span class="line">multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin</span><br><span class="line">boot #GRUB启动HelloOS.bin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="2-设计"><a class="markdownIt-Anchor" href="#2-设计"></a> 2 设计</h1>
</div><div class="story post-story"><h2 id="21-内核结构与设计"><a class="markdownIt-Anchor" href="#21-内核结构与设计"></a> 2.1 内核结构与设计</h2>
<ul>
<li>内核是计算机资源的管理者
<ul>
<li>计算机资源分为<strong>硬件资源</strong>和<strong>软件资源</strong></li>
<li>硬件资源包括,总线,CPU,内存,硬盘,网卡,显卡和各种IO</li>
<li>软件资源表示为计算机中的各种形式的数据</li>
</ul>
</li>
<li>内核作为硬件资源和软件资源的管理者,内部组成在逻辑上大致为
<ul>
<li><strong>管理CPU</strong>,由于CPU是执行程序的,而内核把运行时的程序抽象成进程,为<strong>进程管理</strong></li>
<li><strong>管理内存</strong>,分配释放内存</li>
<li><strong>管理磁盘</strong>,合理组织文件形成文件系统</li>
<li><strong>管理显卡</strong>,负责显示信息</li>
<li><strong>管理网卡</strong>,完成网络通信,在内核中形成网络协议栈(网络组件)</li>
<li><strong>管理各种IO设备</strong></li>
</ul>
</li>
<li><strong>驱动程序</strong>:内核管理和控制硬件编写的对应与不同计算机的代码</li>
<li><strong>宏内核结构</strong>
<ul>
<li>宏内核把管理进程的代码,管理内存的代码,管理各种IO设备的代码,文件系统的代码,图形系统代码以及其他功能模块的代码经过编译,最后链接在一起,形成一个大的可执行程序</li>
<li>该程序向用户应用软件提供一些接口(系统API函数)</li>
<li><mark>该大程序在系统的特权模式下运行,该模式称为宏内核模式</mark></li>
<li>宏内核提供内存分配功能的服务过程
<ul>
<li>应用程序调用内存分配的API函数</li>
<li>处理器切换到特权模式,开始运行内核代码</li>
<li>内核里的内存管理代码按照特定的算法,分配一块内存</li>
<li>把分配的内存块的首地址,返回给内存分配的API函数</li>
<li>内存分配的API函数返回,处理器开始运行用户模式下的应用程序,应用程序得到内存的首地址,使用这块内存</li>
</ul>
</li>
<li><strong>优点</strong>:性能极高,<mark>但目前没有人使用</mark></li>
<li><strong>缺点:没有模块化,没有扩展性,没有移植性,高度耦合,一旦一个组件有漏洞,内核的所有组件都可能出现问题</strong></li>
</ul>
</li>
<li><strong>微内核结构</strong>
<ul>
<li>微内核架构<strong>内核功能尽可能少</strong>,只有进度调度,处理中断,内存空间映射,进程间通信等功能(不完成实际的功能)</li>
<li>实际的进程管理,内存管理,设备管理,文件管理等服务功能做成服务进程(<strong>实现宏内核提供的功能</strong>)</li>
<li>微内核定义了良好的进程间通信的机制：<strong>消息机制</strong>
<ul>
<li>应用程序请求相关服务,就向微内核发送一条与此服务对应的消息,微内核再将消息转发给相关的服务进程,服务进程完成相应的服务</li>
<li><mark>服务进程的编程模式就是循环处理来自其他进程的消息,完成相关的服务功能</mark></li>
</ul>
</li>
<li>微内核提供内存分配功能的服务过程
<ul>
<li>应用程序发送内存分配的消息</li>
<li>处理器切换到特权模式,开始运行内核代码</li>
<li>微内核代码让当前进程停止运行,并根据消息包中的数据,确定消息发送给谁,分配内存的消息发送给内存管理进程</li>
<li>内存管理服务进程收到消息,分配一块内存</li>
<li>内存管理服务进程通过消息的形式返回分配内存块的地址给内核,等待下一条消息</li>
<li>微内核把包含内存地址的消息返回给发送内存分配消息的应用程序</li>
<li>处理器开始运行用户模式下的应用程序</li>
</ul>
</li>
<li><strong>优点</strong>:系统结构清晰利于协作开发,移植性好,代码量少,伸缩性好,扩展性好</li>
<li><strong>缺点</strong>:性能较差</li>
</ul>
</li>
<li>分离硬件的相关性
<ul>
<li>windows内核的HAL层,Linux内核的arch层是系统内核的一个分层</li>
<li><mark>分层的目的和好处:屏蔽底层细节,使上层开发更加简单</mark></li>
<li>分层的基本方法是增加一个<strong>抽象层</strong>,从而使得抽象层的上下两层地理发展
<ul>
<li><strong>软件抽象层</strong>,分离硬件的相关性,将操作硬件和处理硬件功能差异的代码抽离,对外提供相应的接口,方便上层开发</li>
</ul>
</li>
<li><strong>进程调度模块(例子)</strong>
<ul>
<li>进程,操作系统为实现多任务而提出的能让每个进程在CPU上运行一小段时间,实现多任务同时运行的家乡</li>
<li>进程调度:从众多进程中选择一个将要运行的进程,轮转算法,优先级算法</li>
<li>进程切换:停止当前进程,运行新的进程,主要动作是保存当前进程上机器上下文,装载新进程的机器上下文</li>
<li>对于ARM硬件或x86硬件,进程切换相关的代码因为硬件平台的机器上下文不同而不同,故将进程切换放在一个独立的层中实现(硬件平台相关层),不同硬件平台只需要修改硬件相关层的代码即可,提高<strong>移植性</strong></li>
</ul>
</li>
<li><mark>分离硬件相关性,将所有硬件平台相关的代码抽离放在独立硬件相关层中实现定义相关调用接口,在此层之上开发内核的其他代码,移植性增强</mark></li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-21-32-54.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-21-32-54.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="宏内核结构图" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-21-33-18.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-21-33-18.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="微内核结构图" /></p>
<ul>
<li><strong>混合内核结构</strong>
<ul>
<li>分为3个层:内核接口层,内核功能层,内核硬件层</li>
<li>内核接口层,定义了一系列的接口</li>
<li>内核功能层,主要完成各种实际功能的各种模块
<ul>
<li>进程管理：主要是实现进程的创建、销毁、调度进程,设计几套数据结构用于表示进程和组织进程,实现进程调度算法</li>
<li>内存管理:在内核功能层中只有内存池管理,分两种内存池：页面内存池和任意大小的内存池</li>
<li>中断管理:中断回调函数安插到相关的数据结构中,发生中断就调用该函数</li>
<li>设备管理:用数据结构表示驱动程序模块、驱动程序本身、驱动程序创建的设备,最后把它们组织在一起,还要实现创建设备、销毁设备、访问设备的代码,这些代码最终会调用设备驱动程序,达到操作设备的目的</li>
</ul>
</li>
<li>内核硬件层,具体硬件平台相关的代码</li>
</ul>
</li>
<li>区别
<ul>
<li>操作系统内核没有任何设备驱动程序,甚至没有文件系统和网络组件,内核所实现的功能很少.吸取了微内核的优势,内核小出问题的可能性就少,扩展性就越强</li>
<li>同时,把文件系统、网络组件、其它功能组件作为虚拟设备交由设备管理,比如需要文件系统时就写一个文件系统虚拟设备的驱动,完成文件系统的功能,需要网络时就开发一个网络虚拟设备的驱动,完成网络功能</li>
<li>驱动一旦被装载,就是内核的一部分了,并不是像微内核一样作为服务进程运行.吸取了宏内核的优势,代码高度耦合,性能强劲</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-21-54-40.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-06-21-54-40.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="混合内核结构" /></p>
</div><div class="story post-story"><h2 id="22-业界成熟的内核架构"><a class="markdownIt-Anchor" href="#22-业界成熟的内核架构"></a> 2.2 业界成熟的内核架构</h2>
<ul>
<li>Linux,全称GNU/Linux,支持类UNIX,POSIX标准接口,也支持多用户,多进程,多线程可以在多CPU的机器上运行
<ul>
<li>基本思想是,一起都是文件,每个文件都有确定的用途,包括用户数据,命令,配置参数,硬件设备等对于操作系统内核而言都被视为各种类型的文件</li>
</ul>
</li>
<li>Linux系统的五大重要组件
<ul>
<li>系统</li>
<li>进程</li>
<li>内存</li>
<li>储存</li>
<li>网络</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-16-17-21.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-16-17-21.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Linux系统的五大重要组件" /></p>
<ul>
<li>Darwin-XNU内核
<ul>
<li>苹果公司在2000年开发的开放源代码的操作系统</li>
<li>Darwin具有两个内核层:<strong>Mach层</strong>与<strong>BSD层</strong>
<ul>
<li>两套内核的原因:
<ul>
<li>单纯的Mach内核出现性能瓶颈,为了兼容之前Mach开发的应用和设备驱动,保留了Mach内核,同时加入了BSD内核</li>
<li>Mach内核提供十分简单的进程,县城,IPC通信,虚拟内存设备驱动相关的功能服务</li>
<li>BSD内核提供强大的安全特性,完善的网络服务,各种文件系统的支持,同时对Mach的进程,线程,IPC,虚拟内核组件进行细化,扩展延伸</li>
</ul>
</li>
<li><mark>使用Darwin系统的服务,应用会同感用户层的框架和库来请求Darwin系统的服务,调用Darwin系统的API</mark>
<ul>
<li>在调用Darwin系统API时,传入一个API号,索引Mach陷入中断服务表中的函数,若API号小于0,则请求的是Mach内核的服务,若大于0表示请求的是BSD内核的服务,提供了一套完整的POSIX接口</li>
</ul>
</li>
<li>组件Linkern库,提供底层的操作函数,同时支持C++运行环境
<ul>
<li>IOKit依赖此库,管理所有的设备驱动和内核功能扩展模块,驱动程序可以使用C++开发驱动</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-16-21-23.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-16-21-23.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Darwin架构图" /></p>
<ul>
<li>Windows NT内核
<ul>
<li>NT内核在设计上清晰明了,各组件之间界限耦合程度很低</li>
<li>在HAL层上定义一个小内核,小内核之下是硬件抽象层HAL
<ul>
<li>HAL存在,不同的硬件平台只要提供对应的HAL就可以移植系统</li>
</ul>
</li>
<li>小内核之上是各种内核组件,为内核执行体,其互相独立,只对外提供相应的接口,其执行体要通过内核模式可调用接口和其他执行体通信完成相应的功能服务</li>
<li>所有的设备驱动和文件系统都有IO管理器统一管理,驱动程序堆叠形成IO驱动栈,功能请求封装成IO包</li>
<li><mark>属于微内核结构,但从权限角度看为宏内核,属于混合内核</mark></li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-18-39-42.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-18-39-42.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="NT内核架构图" /></p>
<hr />
<h1 id="3-硬件"><a class="markdownIt-Anchor" href="#3-硬件"></a> 3 硬件</h1>
</div><div class="story post-story"><h2 id="31-执行程序的三种模式"><a class="markdownIt-Anchor" href="#31-执行程序的三种模式"></a> 3.1 执行程序的三种模式</h2>
<ul>
<li>CPU的工作模式
<ul>
<li>按x86_CPU功能升级迭代的顺序,工作模式分为<strong>实模式</strong>,<strong>保护模式</strong>,<strong>长模式</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span>* addr = (<span class="type">int</span>*)<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cli</span>();  <span class="comment">//关中断</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    *addr = <span class="number">0</span>;</span><br><span class="line">    addr++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从一段死循环的代码说起</strong>
<ul>
<li>上述代码关闭CPU中断,进入死循环,最后从内存0地址开始写入0</li>
<li><mark>锁住CPU,清空内存</mark></li>
<li><strong>在实模式下,代码可正常运行</strong>
<ul>
<li>计算机资源太少,单道程序运行,没有操作系统的概念</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="311-实模式"><a class="markdownIt-Anchor" href="#311-实模式"></a> 3.1.1 实模式</h3>
<ul>
<li><strong>实模式</strong>
<ul>
<li>实地址模式,运行真实的指令,对指令的动作不做区分,直接执行指令的真实功能;发往内存的地址是真实的,对任何地址不加限制</li>
</ul>
</li>
<li><strong>实模式寄存器</strong>,表中的每个寄存器都是16位的</li>
</ul>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AX,BX,CX,DX,DI,SI,BP</td>
<td>通用寄存器,可以存放数据,地址,参与运算</td>
</tr>
<tr>
<td>IP</td>
<td>程序指针寄存器,始终指向下一条指针的地址</td>
</tr>
<tr>
<td>SP</td>
<td>栈指针寄存器</td>
</tr>
<tr>
<td>CS,DS,ES,SS</td>
<td>段寄存器,里面存放一个内存段的基地址</td>
</tr>
<tr>
<td>FLAGS</td>
<td>CPU标志寄存器,里面存放CPU执行运算指令产生的状态位</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>实模式下访问内存</strong>
<ul>
<li>需要把数据装载进寄存器中才能操作,还要有获取指令的动作,都要访问内存</li>
<li><strong>分段内存管理模型</strong>:所有的内存地址都是由段寄存器左移4位,再加上一个通用寄存器中的值或者常数形式形成地址,然后由这个地址去访问内存
<ul>
<li>代码段是由CS和IP确定的,而栈段是由SS和SP确定的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-19-48-04.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-19-48-04.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="取指" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-19-48-25.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-19-48-25.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="访问内部数据" /></p>
<ul>
<li><strong>实模式中断</strong>
<ul>
<li>中断即中止执行当前程序,转而跳转到另一个特定的地址上,运行特定的代码</li>
<li>在实模式下,实现过程是先保存CS和IP寄存器,然后装载新的CS和IP寄存器</li>
<li>中断分为:<strong>硬件中断</strong>和<strong>软件中断</strong>
<ul>
<li>硬件中断是中断控制器给CPU发送电子信号,CPU对中断信号作出应答,随后中断控制器将中断号发给CPU</li>
<li>软件中断是CPU执行INT指令,该指令跟随软中断号</li>
</ul>
</li>
<li>为了实现中断,需要在内存中存放一个中断向量表,该表的地址和长度由CPU的特定寄存器IDTR指向
<ul>
<li><mark>实模式下,表中的一个条目由代码段地址和段内偏移组成</mark></li>
</ul>
</li>
<li>利用中断号,CPU根据IDTR寄存器中的信息,计算出中断向量的条目,装载CS,IP寄存器,最终响应中断</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-04-15.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-04-15.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="实模式中断表" /></p>
<h3 id="312-保护模式"><a class="markdownIt-Anchor" href="#312-保护模式"></a> 3.1.2 保护模式</h3>
<ul>
<li>CPU保护模式,将CPU寄存器和运算单元扩展成32位,<strong>解决了寻址问题</strong>,并且解决了实模式下,CPU对任何指令不加区分执行,对访问内存不加限制的问题</li>
<li><strong>保护模式寄存器</strong>
<ul>
<li>增加了控制寄存器和段寄存器,扩展通用寄存器的位宽,所有的通用寄存器都是32位寄存器</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>EAX,EBX,ECX,EDX,EDI,ESI,EBP</td>
<td>32位通用寄存器,可以存放数据,地址,参与运算</td>
</tr>
<tr>
<td>EIP</td>
<td>32位程序指针寄存器,始终指向下一条指针的地址</td>
</tr>
<tr>
<td>ESP</td>
<td>栈寄存器</td>
</tr>
<tr>
<td>CS,DS,ES,SS,FS,GS</td>
<td>16位段寄存器,里面存放一个内存段的描述符索引</td>
</tr>
<tr>
<td>EFLAGS</td>
<td>32位CPU标志寄存器,里面存放CPU执行运算指令产生的状态位</td>
</tr>
<tr>
<td>CR0,CR1,CR2,CR3</td>
<td>32位CPU控制寄存器,控制CPU的功能控制特性</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>保护模式特权级</strong>
<ul>
<li>为了区分指令和资源可以被访问,CPU实现了特权级</li>
<li>特权级分为4级,R0~R3,每个特权级执行指令的数量不同
<ul>
<li>R0可以执行所有指令</li>
<li>R1,R2,R3依次递减,只能执行上一次指令数量的自己</li>
<li><mark>内存的访问是靠段描述符和特权级相互配合实现</mark></li>
</ul>
</li>
</ul>
</li>
<li><strong>保护模式段描述符</strong>
<ul>
<li>内存目前位分段模型,要对内存进行保护即对段进行保护</li>
<li>由于CPU扩展导致32位段基地址和段内偏移,16位段寄存器放不下,<strong>将描述段的信息封装成特定格式的段描述符放在内存中</strong></li>
<li>段描述符由64位8字节数据,包含了段基地址,段长度,段权限,段类型,段是否可读写,可执行等信息</li>
<li>多个段描述符在内存中形成<strong>全局段描述符表</strong>,该表的基地址和长度由CPU和GDTR寄存器指示
<ul>
<li>段寄存器不存放段基地址,存放<strong>具体段描述符的索引</strong>,访问一个内存地址时,段寄存器中索引首先会结合GDTR寄存器找到内存中的段描述符,再根据其中段信息判断是否能访问成功</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-18-06.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-18-06.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="保护模式段描述符" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-21-52.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-21-52.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="全局段描述符表" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-27-49.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-27-49.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="保护模式段选择子" /></p>
<ul>
<li><strong>保护模式段选择子</strong>
<ul>
<li>CS,DS,ES,SS,FS,GS段寄存器,由影子寄存器,段描述符索引,描述符表索引,权限级别组成</li>
<li>影子寄存器靠硬件操作,对系统程序员不可见,高性能(64位8字节)</li>
<li>CS和SS中RPL组成CPL(当前权限级别),常常是RPL=CPL
<ul>
<li>CPL表示发起访问者以什么权限访问目标段,当CPL大于目标段DPL时,CPU禁止访问</li>
</ul>
</li>
</ul>
</li>
<li><strong>保护模式平坦模型</strong>
<ul>
<li>分段模型存在很多缺陷,现代使用<strong>分页模型</strong>
<ul>
<li>X86CPU不能直接使用分页模型,需要在分段的前提下根据决定是否开启分页</li>
</ul>
</li>
<li><strong>保护模式的平坦模型,使分段成为虚设</strong></li>
<li>CPU 32位的寄存器最多只能产生4GB大小的地址,而一段长度只能是4GB,所以把所有段的基地址设为0,段的长度设为0xFFFFF,段长度的粒度设为4KB,这样所有段都指向同一个字节大小的地址空间</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq <span class="number">0</span></span><br><span class="line">;第一个段描述符CPU硬件规定必须为<span class="number">0</span></span><br><span class="line">kcode_dsc: dq <span class="number">0x00cf9e000000ffff</span></span><br><span class="line">;段基地址=<span class="number">0</span>,段长度=<span class="number">0xfffff</span></span><br><span class="line">;G=<span class="number">1</span>,D/B=<span class="number">1</span>,L=<span class="number">0</span>,AVL=<span class="number">0</span></span><br><span class="line">;P=<span class="number">1</span>,DPL=<span class="number">0</span>,S=<span class="number">1</span></span><br><span class="line">;T=<span class="number">1</span>,C=<span class="number">1</span>,R=<span class="number">1</span>,A=<span class="number">0</span></span><br><span class="line">kdata_dsc: dq <span class="number">0x00cf92000000ffff</span></span><br><span class="line">;段基地址=<span class="number">0</span>,段长度=<span class="number">0xfffff</span></span><br><span class="line">;G=<span class="number">1</span>,D/B=<span class="number">1</span>,L=<span class="number">0</span>,AVL=<span class="number">0</span></span><br><span class="line">;P=<span class="number">1</span>,DPL=<span class="number">0</span>,S=<span class="number">1</span></span><br><span class="line">;T=<span class="number">0</span>,C=<span class="number">0</span>,R=<span class="number">1</span>,A=<span class="number">0</span></span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN dw GDT_END-GDT_START<span class="number">-1</span></span><br><span class="line">GDTBASE dd GDT_START</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>段长度需要和G位配合,若G位为1,则段长度等于0xfffff个4KB</p>
<ul>
<li>上面段描述符的DPL=0,说明需要最高权限即CPL=0才能访问</li>
</ul>
</li>
<li>
<p><strong>保护模式中断</strong></p>
<ul>
<li>保护模式下的中断要权限检查,特权级切换,需要扩展中断向量表的信息,即每个中断用一个中断门描述符表示</li>
<li>保护模式要实现中断,在内存中有中断向量表,由IDTR寄存器指示,只不过中断向量表中的条目变成了中断门描述符
<ul>
<li>产生中断后,CPU会检查中断号是否大于最后一个中断门描述符,x86CPU支持256个中断源,然后检查描述符类型,是否为系统描述符,是不是存在于内存中</li>
<li>检查中断门描述符中的段选择子指向的段描述符</li>
<li>最后,<strong>权限检查</strong>,若CPL小于等于中断门的DPL并且CPL大于等于中断门中的段选择子,就指向段描述符的DPL
<ul>
<li>CPL等于中断门中的DPL,则为同级权限不进行栈切换,若进行栈切换,还需要从TSS中加载具体权限的SS,ESP</li>
</ul>
</li>
<li>做完检查之后,CPU才会加载中断门描述符中目标代码段选择子到CS寄存器中,把目标代码段偏移加载道EIP寄存器中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-46-29.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-46-29.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="保护模式中断门描述" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-47-53.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-20-47-53.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="保护模式段中断表" /></p>
<ul>
<li><strong>切换到保护模式</strong>
<ul>
<li>x86CPU在第一次加电和每次reset后,都会自动进入实模式,要想进入保护模式,就需要切换到保护模式
<ul>
<li>第一步,准备全局段描述符表</li>
<li>第二步,加载设置GDTR寄存器,使之指向全局段描述符表</li>
<li>第三步,设置CR0寄存器,开启保护模式</li>
<li>第四步,进行长跳转,加载CS段寄存器,即段选择子</li>
</ul>
</li>
<li><strong>长跳转的原因</strong>
<ul>
<li>因为无法直接或间接mov一个数据到CS寄存器中,因为刚刚开启保护模式,CS的影子寄存器还是实模式下的指,故需要告诉CPU加载新的段信息</li>
<li>CPU发现CR0寄存器第0位的值是1,就会按GDTR的指示找到全局描述符表,然后根据索引指8,将新的段描述符信息加载到CS影子寄存器</li>
<li>到此为止CPU进入保护模式,可以处理32位</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="313-长模式"><a class="markdownIt-Anchor" href="#313-长模式"></a> 3.1.3 长模式</h3>
<ul>
<li><strong>长模式</strong>,完成64位的数据运算,也能寻址64位的地址空间</li>
<li><strong>长模式寄存器</strong>
<ul>
<li>相比于保护模式,增加了一些通用寄存器,并扩宽通用寄存器的位宽</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>RAX,RBX,RCX,RDX,RDI,RSI,RBP,R8~R15</td>
<td>64位通用寄存器,可以存放数据,地址,参与运算</td>
</tr>
<tr>
<td>RIP</td>
<td>64位程序指针寄存器,始终指向下一条指针的地址</td>
</tr>
<tr>
<td>RSP</td>
<td>栈寄存器</td>
</tr>
<tr>
<td>CS,DS,ES,SS,FS,GS</td>
<td>16位段寄存器,里面存放一个内存段的描述符索引</td>
</tr>
<tr>
<td>RFLAGS</td>
<td>64位CPU标志寄存器,里面存放CPU执行运算指令产生的状态位</td>
</tr>
<tr>
<td>CR0,CR1,CR2,CR3</td>
<td>CR0为32位CPU控制寄存器,控制CPU的功能控制特性,其他的都是64位寄存器</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>长模式段描述符</strong>
<ul>
<li>长模式下,CPU不再对段基址和段长度进行检查,支队DPL进行相关检查</li>
<li>当描述符中L=1,D/B=0时,就是64位代码段,DPL还是0～3特权级,多个段描述在内存中形成一个全局段描述符表,同样由CPU的GDTR寄存器指向</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-21-15-44.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-21-15-44.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="长模式段描述符" /></p>
<ul>
<li><strong>长模式中断</strong>
<ul>
<li>长模式支持64位内存寻址,中断门描述符进行了修改和扩展</li>
<li><strong>长模式下中断门描述符的格式变化</strong>
<ul>
<li>为支持64位寻址中断门描述符在原有基础上增加8字节,用于存放目标段偏移的高32位值</li>
<li>其次,目标代码段选择子对应的代码段描述符必须是64位的代码段</li>
<li>其中的IST是64位TSS中的IST指针(不使用该特性,不做详细介绍)</li>
</ul>
</li>
<li><mark>长模式的中断门描述符表,表中的条目为16字节,最多支持256个中断源</mark></li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-21-17-24.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-14-21-17-24.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="长模式中断门描述符" /></p>
<ul>
<li><strong>切换到长模式</strong>
<ul>
<li>第一步,准备长模式全局段描述符表</li>
<li>第二步,准备长模式下MMU(内存管理单元)页表(为了开启分页模式,切换到长模式必须要开启分页)
<ul>
<li>长模式下不对段基址和段长度进行检查,在长模式下内存地址空间的保护交给MMU,MMU依赖页表对地址进行转换,页表有特定的格式存放在内存中,其地址由CPU的CR3寄存器指向</li>
</ul>
</li>
<li>第三步,加载GDTR寄存器,使之指向全局段描述表</li>
<li>第四步,开启长模式,同时开启保护模式和分页模式
<ul>
<li>在实现长模式时定义了MSR寄存器,需要用专用的指令 rdmsr、wrmsr 进行读写,IA32_EFER 寄存器的地址为0xC0000080,它的第8位决定了是否开启长模式</li>
</ul>
</li>
<li>第五步,进行跳转,加载CS寄存器,刷新其影子寄存器</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="32-程序中的地址如何转换"><a class="markdownIt-Anchor" href="#32-程序中的地址如何转换"></a> 3.2 程序中的地址如何转换</h2>
<ul>
<li>虚拟地址和物理地址的关系和转换机制
<ul>
<li>采用虚拟地址的方法可以解决多程序并发的处理场景</li>
</ul>
</li>
<li><strong>虚拟地址</strong>
<ul>
<li>虚拟地址是逻辑上存在的一个数据值</li>
<li>虚拟地址是链接器产生的,在开发软件经过编译步骤后,需要链接成可执行文件才可以运行
<ul>
<li><strong>链接器</strong>的主要工作就是把多个代码模块组装在一起,解决模块之间的引用,即处理程序代码间的地址引用,形成程序运行的静态内存空间视图</li>
</ul>
</li>
</ul>
</li>
<li>物理地址
<ul>
<li>物理地址在逻辑上也是一个数据,不过数据被地址译码器等电子器件变成电子信号,放在地址总线上</li>
<li>地址总线电子信号的各种组合可以选择到内存的储存单元
<ul>
<li>但地址总线上的信号,也可以选择到别的设备的储存单元</li>
</ul>
</li>
</ul>
</li>
<li><strong>虚拟地址到物理地址的转换</strong>
<ul>
<li>转换机制相当于函数p=f(v),输入虚拟地址v,输出物理地址p</li>
<li><strong>采用软硬件结合的方式实现,即MMU(内存管理单元)</strong>
<ul>
<li>MMU可以接收软件给出的地址对应关系数据,进行地址转换</li>
</ul>
</li>
<li>32位地址空间下,4GB虚拟地址的地址关系转换表把整个32位物理地址空间用完,显然不行,<strong>采用把虚拟地址空间和物理地址空间都分成同等大小的块,称为页,按照虚拟页和物理页进行转换(分页模型)</strong>
<ul>
<li>页的大小可以设置为4KB,2MB,4MB,1GB</li>
<li>一个虚拟页对应一个物理页,由于页大小一经配置就是固定的,所以<strong>只要存放虚拟页地址对应的物理页地址</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-09-40-52.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-09-40-52.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="MMU工作原理图" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-09-56-20.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-09-56-20.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="分页模型框架图" /></p>
<ul>
<li><strong>MMU</strong>
<ul>
<li>MMU即内存管理单元,是用硬件电路逻辑实现的一个地址转换器件,负责接受虚拟地址和地址关系转换表,以及输出物理地址</li>
<li>使用保护模式的平坦模式,绕过了分段模式</li>
<li><strong>地址产生过程</strong>
<ul>
<li>程序代码中的虚拟地址,经过CPU的分段机制产生了线性地址,平坦模式和长模式下线性地址和虚拟地址相等</li>
</ul>
</li>
<li>不开启MMU,在保护模式下可以关闭MMU,线性地址就是物理地址</li>
<li>长模式下的分段弱化了地址空间的隔离,故<strong>必须开启MMU</strong></li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-10-01-16.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-10-01-16.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CPU地址转换图" /></p>
<ul>
<li><strong>MMU页表</strong>
<ul>
<li><strong>页表(地址关系转换表)</strong>,描述了虚拟地址到物理地址的转换关系</li>
<li>页表不存放虚拟地址和物理地址的对应关系,只存放物理页面的地址,MMU以虚拟地址为索引去查表返回物理页面地址</li>
<li>页表是分级的,分为三个部分:一个顶级页目录,多个中级页目录,最后才是页表</li>
<li>第一个位段索引顶级目录中的一个项,该项指向一个中级页目录,然后用第二个位段去索引中级页目录中的一个项,该项指向一个页目录,再用第三个位段去索引页目录中的项,该项指向一个物理页地址,最后用第四个位段作为该物理页的偏移去访问物理内存</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-10-04-27.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-10-04-27.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="MMU页表原理图" /></p>
<ul>
<li><strong>保护模式下的分页——4KB页</strong>
<ul>
<li>保护模式下只有32位地址空间,32位虚拟地址经过分段机制后得到线性地址,使用平坦模式,所以线性地址和虚拟地址相同</li>
<li>保护模式下分页大小通常为4KB或4MB,分页大小的不同会导致虚拟地址位段的分隔和页目录的层级不同,但虚拟页和物理页的大小始终是等同的
<ul>
<li>CR3是CPU中的一个32位寄存器,MMU根据该寄存器找到页目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-32-48.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-32-48.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="保护模式下的4KB分页" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-33-49.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-33-49.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="相关寄存器的格式" /></p>
<ul>
<li><strong>保护模式下的分页——4MB</strong>
<ul>
<li>32位虚拟地址被分为两个位段:<strong>页表索引</strong>,<strong>页内偏移</strong></li>
<li>只有一级页目录,其中包含1024个条目,其中一个条目指向一个物理页,每个物理页4MB
<ul>
<li>CR3还是32位寄存器,但不再指向顶级页目录,指向一个4KB大小的页表,该页表要4KB地址对齐,其中包含1024个页表项</li>
<li>4MB大小的页面下,页表项还是4字节32位,但只需要用高10位来保存物理页面的基地址就可以,但每个物理页面都是4MB,故低22位始终为0(为了兼容4MB页表低8位和4KB页表项,但第七位变成了PS位,且必须位1,PAT位移动到了12位)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-35-42.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-35-42.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="保护模式下4MB分页" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-37-12.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-37-12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="相关寄存器的格式" /></p>
<ul>
<li><strong>长模式下的分页</strong>
<ul>
<li><strong>开启了长模式</strong>就必须开启<strong>分页模式</strong>,长模式扩宽了CPU的位宽,使得CPU能使用64位的超大内存地址空间,故长模式下的虚拟地址必须等于线性地址且为64位</li>
<li>长模式下的分页大小有4KB和2MB大小的页</li>
</ul>
</li>
<li><strong>长模式下的分页——4KB页</strong>
<ul>
<li>该分页方式下,64位虚拟地址被分为6个位段,分别是保留位段,顶级页目录索引,页目录指针索引,页目录索引,页表索引,页内偏移,顶级页目录,页目录指针,页目录,页表各占有4KB大小,其中含有512个条目,每个条目8字节64位大小</li>
<li>CR3是64位CPU寄存器,指向一个顶级页目录,里面的顶级页目项指向页目录指针</li>
<li><mark>虚拟地址48到63这6位是根据第47位来决定的,47位为1,就为0,否则为0</mark>
<ul>
<li>x86CPU并没有实现全64位的地址总线,而是只实现了48位,但是CPU的寄存器却是64位的</li>
</ul>
</li>
<li>长模式下4KB分页下,由一个顶级目录,二级中间层目录和一层页表组成了64位地址翻译过程
<ul>
<li>顶级页目录项指向页目录指针页,页目录指针项指向页目录页,页目录项指向页表页,页表项指向一个4KB大小的物理页,各级页目录项中和页表项中仍然存在各种属性位</li>
<li>XD位,可以控制代码页面是否能够运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-48-54.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-48-54.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="长模式下的4KB分页" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-50-10.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-50-10.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="相关寄存器的格式" /></p>
<ul>
<li><strong>长模式下的分页——2MB页</strong>
<ul>
<li>64位虚拟地址被分为5个位段：保留位段,顶级页目录索引,页目录指针索引,页目录索引,页内偏移,顶级页目录,页目录指针</li>
<li>2MB分页下是页目录项直接指向了2MB大小的物理页面,<strong>放弃了页表项</strong>,然后把虚拟地址的低21位作为页内偏移,21位正好索引2MB大小的地址空间</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-58-50.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-11-58-50.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="长模式下2MB分页" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-12-00-58.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-12-00-58.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="相关寄存器的格式" /></p>
<ul>
<li><strong>开启MMU</strong>
<ul>
<li><mark>使CPU进入保护模式或长模式(前提)</mark></li>
<li>准备好页表数据,这包含顶级页目录,中间层页目录,页表</li>
<li>把顶级页目录的物理内存地址赋值给CR3寄存器</li>
<li>设置CPU的CR0的PE位为1,这样就开启了MMU</li>
</ul>
</li>
<li><strong>MMU地址转换失败执行的操作</strong>
<ul>
<li>MMU停止转换地址</li>
<li>MMU把转换失败的虚拟地址写入CPU的CR2寄存器</li>
<li>MMU触发CPU的14号中断,使CPU停止执行当前指令</li>
<li>CPU开始执行14号中断的处理代码,代码会检查原因,处理好页表数据返回</li>
<li>CPU中断返回继续执行MMU地址转换失败时的指令</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="33-cache与内存程序放在哪儿"><a class="markdownIt-Anchor" href="#33-cache与内存程序放在哪儿"></a> 3.3 Cache与内存:程序放在哪儿</h2>
<ul>
<li>Cache是解决内存瓶颈的神来之笔</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//九九乘法表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;studio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%2d  &quot;</span>,i,j,i*j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从经典代码看局部性原理</strong>
<ul>
<li><strong>程序局部性原理</strong>,CPU在大多数时间在执行相同的指令或者与此相邻的指令</li>
</ul>
</li>
<li><strong>内存</strong>
<ul>
<li>内存为DRAM,即动态随机存储器
<ul>
<li>内存储存颗粒芯片中的存储单元是由电容和相关原件组成的,电容存储电荷的多少代表数字信号0和1</li>
<li>由于电容存在漏电现象,会导致电荷不同,故DRAM需要周期性刷新以保持电荷状态</li>
</ul>
</li>
<li>控制内存刷新和内存读写的是<strong>内存控制器</strong>,其集中在<strong>北桥芯片</strong>,现集成在CPU芯片中</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-12-39-42.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-12-39-42.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="DDR内存逻辑结构连接图" /></p>
<ul>
<li><strong>CPU到内存的性能瓶颈</strong>
<ul>
<li>CPU和内存条的数据吞吐量天差地别,且多核心CPU同时访问内存会导致总线争用问题,数据吞吐量会进一步下降</li>
<li><strong>内存是决定系统整体性能的关键</strong></li>
</ul>
</li>
<li><strong>Cache</strong>
<ul>
<li>CPU大多数时间在访问相同或者与之相邻的地址,那么立马就可以想到用一块小而快的储存器放在CPU和内存之间,可以利用程序的局部性原理来缓解CPU和内存之间的性能瓶颈,<strong>小而快的储存器就是Cache,即高速缓存</strong></li>
<li>Cache中存放了内存中的一部分数据,CPU在访问内存时要先访问Cache,若Cache中有需要的数据就直接从Cache中取出,若没有则需要从内存中读取数据,并同时把这块数据放入Cache中;但由于程序的局部性原理,在一段时间内,CPU总能从Cache中读取到自己想要的数据</li>
<li>Cache可目前主要集中在X86CPU内部,主要由高速的静态储存器,地址转换模块和Cache行替换模块组成
<ul>
<li>Cache把高速静态储存器和内存分成大小相同的行(<strong>Cahce和内存交换数据的最小单位</strong>),一行大小通常为32字节或64字节</li>
</ul>
</li>
<li><strong>Cache的逻辑工作流程</strong>
<ul>
<li>CPU发出的地址由Cache的地址转换模块分为3段：组号,行号,行内偏移</li>
<li>Cache会根据组号,行号查找高速静态储存器中对应的行</li>
<li>若没有新行,就进入行替换逻辑,即找出一个Cache行写回内存,腾出空间,替换行有相关算法(<strong>替换算法为了让替换的代价最小化</strong>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-12-55-31.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-12-55-31.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cache结构框架图" /></p>
<ul>
<li><strong>Cache带来的问题,数据一致性问题</strong>
<ul>
<li>三级Cache,第一级Cache是指令和数据分开的,第二级Cache是独立于CPU核心的,第三级Cache是所有CPU核心共享的</li>
<li><strong>一致性问题的三个方面</strong>
<ul>
<li>一个CPU核心中的指令Cache和数据Cache的一致性问题</li>
<li>多个CPU核心各自的2级Cache的一致性问题</li>
<li>CPU的3级Cache与设备内存之间的一致性问题</li>
</ul>
</li>
<li>典型的多核心Cache数据同步协议有MESI和MOESI</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-13-03-05.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-13-03-05.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="x86CPU的Cache结构图" /></p>
<ul>
<li><strong>Cache的MESI协议</strong>
<ul>
<li>MESI协议定义了4种基本状态:M(修改),E(独占),S(共享),I(无效)
<ul>
<li>M修改:当前Cache的内容有效,数据已经被修改而且与内存中的数据不一致,数据只有在当前Cache里存在</li>
<li>E独占:当前Cache中的内容有效,数据与内存中的数据一致,数据只在当前Cache里存在</li>
<li>S共享:当前Cache中的内容有效,Cache中的数据与内存中的数据一致,数据在多个CPU核心的Cache里面存在</li>
<li>I无效:当前Cache无效</li>
</ul>
</li>
<li>Cache硬件会监控所有CPU上Cache的操作,根据相应的操作使得Cache里的数据行在状态之间切换
<ul>
<li>Cache虽提升了系统性能,但带来了很多问题,问题硬件自动完成,对软件而言透明的,但在程序设计时需要规避这些问题,否则会导致程序运行的效能大大下降</li>
</ul>
</li>
</ul>
</li>
<li><strong>开启Cache</strong>
<ul>
<li>x86CPU上默认是关闭Cache的,需要在初始化时将其开启</li>
<li>需要将CR0寄存器中CD,NW位同时清0即可
<ul>
<li>CD=1表示Cache关闭</li>
<li>NW=2时CPU不维护内存数据一致</li>
<li><strong>CD=0,NW=0的组合是开启Cache的正确方法</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启Cache的汇编代码</span></span><br><span class="line">mov eax, cr0</span><br><span class="line">;开启Cache</span><br><span class="line">btr eax,<span class="number">29</span>;CR0.NW=<span class="number">0</span></span><br><span class="line">btr eax,<span class="number">30</span>;CR0.CD=<span class="number">0</span></span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>获取内存视图</strong>
<ul>
<li><strong>关键是获取哪些物理地址空间是可以读写的内存</strong>,获取内存有多大没用</li>
<li>物理地址空间是由北桥芯片控制管理的,在x86平台上利用BIOS提供的实模式下中断服务(int指令后跟着一个常数的形式)</li>
<li>由于PC机上电后由BIOS执行硬件初始化,中断向量表是由BIOS设置的,故执行中断自然执行BIOS服务</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断服务是int 15h</span></span><br><span class="line"><span class="comment">// 但在执行int 15h之前需要对特定寄存器设置一些值</span></span><br><span class="line">_getmemmap:</span><br><span class="line">xor ebx,ebx ;ebx设为<span class="number">0</span></span><br><span class="line">mov edi,E80MAP_ADR ;edi设为存放输出结果的<span class="number">1</span>MB内的物理内存地址</span><br><span class="line">loop:</span><br><span class="line">mov eax,<span class="number">0e820</span>h ;eax必须为<span class="number">0e820</span>h</span><br><span class="line">mov ecx,<span class="number">20</span> ;输出结果数据项的大小为<span class="number">20</span>字节：<span class="number">8</span>字节内存基地址,<span class="number">8</span>字节内存长度,<span class="number">4</span>字节内存类型</span><br><span class="line">mov edx,<span class="number">0534</span>d4150h ;edx必须为<span class="number">0534</span>d4150h</span><br><span class="line"><span class="type">int</span> <span class="number">15</span>h ;执行中断</span><br><span class="line">jc error ;如果flags寄存器的C位置<span class="number">1</span>,则表示出错</span><br><span class="line">add edi,<span class="number">20</span>;更新下一次输出结果的地址</span><br><span class="line">cmp ebx,<span class="number">0</span> ;如ebx为<span class="number">0</span>,则表示循环迭代结束</span><br><span class="line">jne loop ;还有结果项,继续迭代</span><br><span class="line">ret</span><br><span class="line">error:;出错处理</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在迭代中执行中断,每次中断都输出一个20字节大小的数据项,最终形成一个该数据项的数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_USABLE 1 <span class="comment">//可用内存</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_RESERV 2 <span class="comment">//保留内存不可使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_ACPIREC 3 <span class="comment">//ACPI表相关的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_ACPINVS 4 <span class="comment">//ACPI NVS空间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_AREACON 5 <span class="comment">//包含坏内存</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_e820</span>&#123;</span></span><br><span class="line">  <span class="type">u64_t</span> saddr; <span class="comment">/* 内存开始地址 */</span></span><br><span class="line">  <span class="type">u64_t</span> lsize; <span class="comment">/* 内存大小 */</span></span><br><span class="line">  <span class="type">u32_t</span> type; <span class="comment">/* 内存类型 */</span></span><br><span class="line">&#125;<span class="type">e820map_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>系统地认识了硬件模型</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-15-35-56.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-15-35-56.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="操作系统的硬件模型" /></p>
<hr />
<h1 id="4-基本法同步原语"><a class="markdownIt-Anchor" href="#4-基本法同步原语"></a> 4 基本法:同步原语</h1>
</div><div class="story post-story"><h2 id="41-锁并发操作中解决数据同步的四种方法"><a class="markdownIt-Anchor" href="#41-锁并发操作中解决数据同步的四种方法"></a> 4.1 锁:并发操作中,解决数据同步的四种方法</h2>
<ul>
<li>几种常见的锁:原子变量,关中断,信号量,自旋锁</li>
</ul>
<h3 id="411-方法1原子操作-拿下单体变量"><a class="markdownIt-Anchor" href="#411-方法1原子操作-拿下单体变量"></a> 4.1.1 方法1:原子操作 拿下单体变量</h3>
<ul>
<li><strong>将a++变成原子操作</strong>,原子时不可分隔的,即a++操作不可分隔,要么不执行,要么一口气执行完</li>
<li>编译器不能自动生成原子操作,在x86平台支持很多原子指令,只需要应用指令即可
<ul>
<li>现代C语言支持嵌入汇编代码,可以在C语言中按照特定的方式嵌入汇编代码</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个原子类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_ATOMIC</span>&#123;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">s32_t</span> a_count; <span class="comment">//在变量前加上volatile,是为了禁止编译器优化,使其每次都从</span></span><br><span class="line">&#125;<span class="type">atomic_t</span>;</span><br><span class="line"><span class="comment">//原子读</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">s32_t</span> <span class="title function_">atomic_read</span><span class="params">(<span class="type">const</span> <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//x86平台取地址处是原子</span></span><br><span class="line"><span class="keyword">return</span> (*(<span class="keyword">volatile</span> <span class="type">u32_t</span>*)&amp;(v)-&gt;a_count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子写</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_write</span><span class="params">(<span class="type">atomic_t</span> *v, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//x86平台把一个值写入一个地址处也是原子的</span></span><br><span class="line">v-&gt;a_count = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子加上一个整数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;lock;&quot;</span> <span class="string">&quot;addl %1,%0&quot;</span></span><br><span class="line">: <span class="string">&quot;+m&quot;</span> (v-&gt;a_count)</span><br><span class="line">: <span class="string">&quot;ir&quot;</span> (i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子减去一个整数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_sub</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;lock;&quot;</span> <span class="string">&quot;subl %1,%0&quot;</span></span><br><span class="line">: <span class="string">&quot;+m&quot;</span> (v-&gt;a_count)</span><br><span class="line">: <span class="string">&quot;ir&quot;</span> (i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子加1</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_inc</span><span class="params">(<span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;lock;&quot;</span> <span class="string">&quot;incl %0&quot;</span></span><br><span class="line">: <span class="string">&quot;+m&quot;</span> (v-&gt;a_count));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子减1</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_dec</span><span class="params">(<span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__ __volatile__(<span class="string">&quot;lock;&quot;</span> <span class="string">&quot;decl %0&quot;</span></span><br><span class="line">: <span class="string">&quot;+m&quot;</span> (v-&gt;a_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加上lock前缀的指令都是原子操作</span></span><br><span class="line"><span class="comment">// lock前缀表示锁定总线</span></span><br></pre></td></tr></table></figure>
<ul>
<li>GCC支持嵌入汇编代码的模板:规定了汇编代码嵌入的形式和嵌入汇编代码需要由几部分构成
<ul>
<li>代码模板从_<em>asm__开始,紧跟着_<em>volatile</em></em>,然后是跟着一对括号,最后以分号结束</li>
<li>括号内的4部分
<ul>
<li>汇编代码部分,实际嵌入的汇编代码</li>
<li>输出列表部分,让GCC能够处理C语言左值表达式与汇编代码的结合</li>
<li>输入列表部分,让GCC能够处理C语言表达式,变量,常量,让它们能够输入到汇编代码中去</li>
<li>损坏列表部分,告诉GCC汇编代码用到了哪些寄存器,以便GCC在汇编代码运算前,生成保存的代码,在生成的汇编代码运行后恢复寄存器的代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>_<em>asm</em>_ _<em>volatile</em>_(代码部分:输出部分列表:输入部分列表:损坏部分列表);</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用原子操作</span></span><br><span class="line"><span class="type">atomic_t</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_handle</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">atomic_inc</span>(&amp;a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_func</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">atomic_inc</span>(&amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="412-方法2中断控制-搞定复杂变量"><a class="markdownIt-Anchor" href="#412-方法2中断控制-搞定复杂变量"></a> 4.1.2 方法2:中断控制 搞定复杂变量</h3>
<ul>
<li><strong>原子操作只适用于单体变量</strong>
<ul>
<li>x86CPU上关闭,开启中断有专门的指令,即cli,sti指令
<ul>
<li>主要对CPU的eflags寄存器的IF位(第9位)进行清除和设置,CPU通过该位来相应中断信号</li>
<li>两条指令只能Ring0权限才能执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hal_cli</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;cli&quot;</span>: : :<span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开启中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hal_sti</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;sti&quot;</span>: : :<span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用场景</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  hal_cli();</span><br><span class="line">  <span class="comment">//操作数据……</span></span><br><span class="line">  hal_sti();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  hal_cli();</span><br><span class="line">  <span class="comment">//操作数据……</span></span><br><span class="line">  hal_sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hal_cli,hal_sti无法嵌套使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  hal_cli();</span><br><span class="line">  <span class="comment">//操作数据第一步……</span></span><br><span class="line">  hal_sti();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  hal_cli();</span><br><span class="line">  foo();</span><br><span class="line">  <span class="comment">//操作数据第二步……</span></span><br><span class="line">  hal_sti();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bar函数在关中断的情况下调用foo函数,foo函数中先关掉中断,处理好数据然后开启中断,回到bar函数中,bar函数以为中断是关闭的,接着处理数据,以为不会被中断抢占</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改:在关闭中断函数中先保存 eflags 寄存器,然后执行 cli 指令,在开启中断函数中直接恢复之前保存的 eflags 寄存器就行了</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">u32_t</span> <span class="type">cpuflg_t</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hal_save_flags_cli</span><span class="params">(<span class="type">cpuflg_t</span>* flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;pushfl \t\n&quot;</span> <span class="comment">//把eflags寄存器压入当前栈顶</span></span><br><span class="line">    <span class="string">&quot;cli \t\n&quot;</span> <span class="comment">//关闭中断</span></span><br><span class="line">    <span class="string">&quot;popl %0 \t\n&quot;</span><span class="comment">//把当前栈顶弹出到flags为地址的内存中</span></span><br><span class="line">    : <span class="string">&quot;=m&quot;</span>(*flags)</span><br><span class="line">    :</span><br><span class="line">    : <span class="string">&quot;memory&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hal_restore_flags_sti</span><span class="params">(<span class="type">cpuflg_t</span>* flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;pushl %0 \t\n&quot;</span><span class="comment">//把flags为地址处的值寄存器压入当前栈顶</span></span><br><span class="line">    <span class="string">&quot;popfl \t\n&quot;</span> <span class="comment">//把当前栈顶弹出到flags寄存器中</span></span><br><span class="line">    :</span><br><span class="line">    : <span class="string">&quot;m&quot;</span>(*flags)</span><br><span class="line">    : <span class="string">&quot;memory&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pushfl指令把eflags寄存器压入当前栈顶,popfl把当前栈顶的数据弹出到eflags寄存器中</span></span><br><span class="line"><span class="comment">// hal_restore_flags_sti() 函数的执行,是否开启中断完全取决于上一次 eflags 寄存器中的值,并且 popfl 指令只会影响 eflags 寄存器中的 IF 位</span></span><br></pre></td></tr></table></figure>
<h3 id="413-方法3自旋锁协调多核心cpu"><a class="markdownIt-Anchor" href="#413-方法3自旋锁协调多核心cpu"></a> 4.1.3 方法3:自旋锁,协调多核心CPU</h3>
<ul>
<li>多核心CPU系统中存在多条代码执行流,控制中断只能控制本地CPU的中断,无法控制其他CPU核心的中断</li>
<li><strong>自旋锁的原理</strong>
<ul>
<li>首先读取锁变量,判断其值是否已经加锁</li>
<li>如果未加锁则执行加锁,然后返回表示加锁成功</li>
<li>如果已经加锁,就要返回第一步继续执行后续步骤,因而得名自旋锁</li>
</ul>
</li>
<li><mark>要想正确执行,需要保证读取锁变量和判断并加锁的原子操作是原子执行的</mark>
<ul>
<li>否则,CPU0在读取锁变量之后,CPU1读取锁变量判断未加锁执行加锁,然后CPU0也判断未加锁执行加锁,发现两个CPU都加锁成功,因此算法出错</li>
<li><mark>需要硬件解决方案</mark>,X86CPU提供原子交换指令xchg可以让寄存器里的一个值跟内存空间中的一个值交换</li>
</ul>
</li>
<li><strong>使用自旋锁时需要注意中断</strong>
<ul>
<li>要写的自旋锁函数必须适应这样的中断环境,也就是说,它需要在处理中断的过程中也能使用</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-16-49-37.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-15-16-49-37.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="自旋锁原理示意图" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现自旋锁</span></span><br><span class="line"><span class="comment">//自旋锁结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">u32_t</span> lock;<span class="comment">//volatile可以防止编译器优化,保证其它代码始终从内存加载lock变</span></span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br><span class="line"><span class="comment">//锁初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">x86_spin_lock_init</span><span class="params">(<span class="type">spinlock_t</span> * lock)</span></span><br><span class="line">&#123;</span><br><span class="line">  lock-&gt;lock = <span class="number">0</span>;<span class="comment">//锁值初始化为0是未加锁状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加锁函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">x86_spin_lock</span><span class="params">(<span class="type">spinlock_t</span> * lock)</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm__ __volatile__ (</span><br><span class="line">    <span class="string">&quot;1: \n&quot;</span></span><br><span class="line">    <span class="string">&quot;lock; xchg %0, %1 \n&quot;</span><span class="comment">//把值为1的寄存器和lock内存中的值进行交换</span></span><br><span class="line">    <span class="string">&quot;cmpl $0, %0 \n&quot;</span> <span class="comment">//用0和交换回来的值进行比较</span></span><br><span class="line">    <span class="string">&quot;jnz 2f \n&quot;</span> <span class="comment">//不等于0则跳转后面2标号处运行</span></span><br><span class="line">    <span class="string">&quot;jmp 3f \n&quot;</span> <span class="comment">//若等于0则跳转后面3标号处返回</span></span><br><span class="line">    <span class="string">&quot;2: \n&quot;</span></span><br><span class="line">    <span class="string">&quot;cmpl $0, %1 \n&quot;</span><span class="comment">//用0和lock内存中的值进行比较</span></span><br><span class="line">    <span class="string">&quot;jne 2b \n&quot;</span><span class="comment">//若不等于0则跳转到前面2标号处运行继续比较</span></span><br><span class="line">    <span class="string">&quot;jmp 1b \n&quot;</span><span class="comment">//若等于0则跳转到前面1标号处运行,交换并加锁</span></span><br><span class="line">    <span class="string">&quot;3: \n&quot;</span> :</span><br><span class="line">    : <span class="string">&quot;r&quot;</span>(<span class="number">1</span>), <span class="string">&quot;m&quot;</span>(*lock));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解锁函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">x86_spin_unlock</span><span class="params">(<span class="type">spinlock_t</span> * lock)</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;movl $0, %0\n&quot;</span><span class="comment">//解锁把lock内存中的值设为0就行</span></span><br><span class="line">    :</span><br><span class="line">    : <span class="string">&quot;m&quot;</span>(*lock));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了关中断下获取自旋锁,以及恢复中断状态释放自旋锁</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">x86_spin_lock_disable_irq</span><span class="params">(<span class="type">spinlock_t</span> * lock,<span class="type">cpuflg_t</span>* flags</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  __asm__ __volatile__(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;pushfq \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;cli \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;popq %0 \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;1: \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;lock; xchg %1, %2 \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;cmpl $0,%1 \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;jnz 2f \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;jmp 3f \n&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;2: \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;cmpl $0,%2 \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;jne 2b \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;jmp 1b \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;3: \n&quot;</span></span></span><br><span class="line"><span class="params">    :<span class="string">&quot;=m&quot;</span>(*flags)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;r&quot;</span>(<span class="number">1</span>), <span class="string">&quot;m&quot;</span>(*lock));</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> x86_spin_unlock_enabled_irq(<span class="type">spinlock_t</span>* lock,<span class="type">cpuflg_t</span>* flag</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  __asm__ __volatile__(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl $0, %0\n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;pushq %1 \n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;popfq \n\t&quot;</span></span></span><br><span class="line"><span class="params">    :</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;m&quot;</span>(*lock), <span class="string">&quot;m&quot;</span>(*flags));</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="414-方法4信号量-cpu时间管理大师"><a class="markdownIt-Anchor" href="#414-方法4信号量-cpu时间管理大师"></a> 4.1.4 方法4:信号量 CPU时间管理大师</h3>
<ul>
<li>原子操作和自旋锁不适合长时间等待的操作,因为很多资源有一定的时间性,使用自旋锁访问这种资源对CPU时间是巨大的浪费</li>
<li>使用信号量解决等待,互斥,唤醒(即重新激活等待的代码执行流)问题
<ul>
<li>需要一种全新的数据结构来解决这些问题,该数据结构至少需要一个变量来表示互斥,比如大于 0 则代码执行流可以继续运行,等于 0 则让代码执行流进入等待状态.还需要一个等待链,用于保存等待的代码执行流</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据结构的实现代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_FLG_MUTEX 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_FLG_MULTI 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_MUTEX_ONE_LOCK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_MULTI_LOCK 0</span></span><br><span class="line"><span class="comment">//等待链数据结构,用于挂载等待代码执行流（线程）的结构,里面有用于挂载代码执行流的链表和计数器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_KWLST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> wl_lock;</span><br><span class="line">  <span class="type">uint_t</span> wl_tdnr;</span><br><span class="line">  <span class="type">list_h_t</span> wl_list;</span><br><span class="line">&#125;<span class="type">kwlst_t</span>;</span><br><span class="line"><span class="comment">//信号量数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_SEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> sem_lock;<span class="comment">//维护sem_t自身数据的自旋锁</span></span><br><span class="line">  <span class="type">uint_t</span> sem_flg;<span class="comment">//信号量相关的标志</span></span><br><span class="line">  <span class="type">sint_t</span> sem_count;<span class="comment">//信号量计数值</span></span><br><span class="line">  <span class="type">kwlst_t</span> sem_waitlst;<span class="comment">//用于挂载等待代码执行流（线程）结构</span></span><br><span class="line">&#125;<span class="type">sem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意信号量在使用之前需要先进行初始化</span></span><br><span class="line"><span class="comment">// 这里假定信号量数据结构中的 sem_count 初始化为 1,sem_waitlst 等待链初始化为空</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用信号量的步骤</strong>
<ul>
<li>第一步,获取信号量
<ul>
<li>首先对用于保护信号量自身的自旋锁sem_lock进行加锁</li>
<li>对信号值sem_count执行“减1”操作,并检查其值是否小于0</li>
<li>检查sem_count如果小于0,进程进入等待状态并将其挂入sem_waitlst中,然后调度其它进程运行;否则表示获取信号量成功,最后需要对自旋锁sem_lock进行解锁</li>
</ul>
</li>
<li>第二步,代码执行流开始执行相关操作</li>
<li>第三步,释放信号量
<ul>
<li>首先对用于保护信号量自身的自旋锁sem_lock进行加锁</li>
<li>对信号值sem_count执行“加1”操作,并检查其值是否大于0</li>
<li>上步中检查sem_count值如果大于0,就执行唤醒sem_waitlst中进程的操作,并且需要调度进程时就执行进程调度操作,不管sem_count是否大于0(通常会大于0)都标记信号量释放成功.最后对自旋锁sem_lock进行解锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量的两个操作,down, up</span></span><br><span class="line"><span class="comment">//获取信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">krlsem_down</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">cpuflg_t</span> cpufg;</span><br><span class="line">  start_step:</span><br><span class="line">  krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">  <span class="keyword">if</span>(sem-&gt;sem_count&lt;<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//如果信号量值小于1,则让代码执行流（线程）睡眠</span></span><br><span class="line">    krlwlst_wait(&amp;sem-&gt;sem_waitlst);</span><br><span class="line">    krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">    krlschedul();<span class="comment">//切换代码执行流,下次恢复执行时依然从下一行开始执行,所以要goto开始</span></span><br><span class="line">    <span class="keyword">goto</span> start_step;</span><br><span class="line">  &#125;</span><br><span class="line">  sem-&gt;sem_count--;<span class="comment">//信号量值减1,表示成功获取信号量</span></span><br><span class="line">  krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">krlsem_up</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">cpuflg_t</span> cpufg;</span><br><span class="line">  krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">  sem-&gt;sem_count++;<span class="comment">//释放信号量</span></span><br><span class="line">  <span class="keyword">if</span>(sem-&gt;sem_count&lt;<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//如果小于1,则说数据结构出错了,挂起系统</span></span><br><span class="line">    krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">    hal_sysdie(<span class="string">&quot;sem up err&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//唤醒该信号量上所有等待的代码执行流（线程）</span></span><br><span class="line">  krlwlst_allup(&amp;sem-&gt;sem_waitlst);</span><br><span class="line">  krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);</span><br><span class="line">  krlsched_set_schedflgs();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="42-linux的自旋锁和信号量如何实现"><a class="markdownIt-Anchor" href="#42-linux的自旋锁和信号量如何实现"></a> 4.2 Linux的自旋锁和信号量如何实现</h2>
<h3 id="421-linux的原子变量"><a class="markdownIt-Anchor" href="#421-linux的原子变量"></a> 4.2.1 Linux的原子变量</h3>
<ul>
<li>在文件描述符中,需要包含一个简单的计数器,表示有多少个应用程序打开了文件
<ul>
<li>在文件系统的open函数中将计数器变量加1;close函数中将计数器变量减1</li>
<li>多个进程同时打开或关闭文件,会导致计数器变量容易出现错误</li>
<li><strong>使用原子类型变量atomic_t</strong></li>
</ul>
</li>
<li>Linux的实现采用了X86CPU的原子指令
<ul>
<li>LOCK_PREFIX为一个宏,根据需要展开成&quot;lock&quot;或空串
<ul>
<li><mark>单核心CPU是不需要lock前缀的,只要在多核心CPU下才需要加上lock前缀</mark></li>
</ul>
</li>
<li>__READ_ONCE,__WRITE_ONCE两个宏,是对代码封装并利用GCC特性对代码进行检查,显现错误在编译阶段
<ul>
<li>volatile int* 是为了提醒编译器,是对内存地址读写,不要有优化动作,每次都必须强制写入内存或从内存读取</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子类型变量atomic_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;<span class="comment">//常用的32位的原子变量类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  s64 counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;<span class="comment">//64位的原子变量类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux提供的基本的接口函数</span></span><br><span class="line"><span class="comment">//原子读取变量中的值</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">arch_atomic_read</span><span class="params">(<span class="type">const</span> <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __READ_ONCE((v)-&gt;counter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子写入一个具体的值</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_atomic_set</span><span class="params">(<span class="type">atomic_t</span> *v, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">  __WRITE_ONCE(v-&gt;counter, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子加上一个具体的值</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;addl %1,%0&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;ir&quot;</span> (i) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子减去一个具体的值</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_atomic_sub</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;subl %1,%0&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span></span><br><span class="line"><span class="params">    : <span class="string">&quot;ir&quot;</span> (i) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子加1</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_atomic_inc</span><span class="params">(<span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;incl %0&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;+m&quot;</span> (v-&gt;counter) :: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子减1</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_atomic_dec</span><span class="params">(<span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;decl %0&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;+m&quot;</span> (v-&gt;counter) :: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __READ_ONCE,__WRITE_ONCE两个宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __READ_ONCE(x) \</span></span><br><span class="line"><span class="meta">  (*(const volatile __unqual_scalar_typeof(x) *)&amp;(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WRITE_ONCE(x, val) \</span></span><br><span class="line"><span class="meta">  do &#123;*(volatile typeof(x) *)&amp;(x) = (val);&#125; while (0)</span></span><br><span class="line"><span class="comment">//__unqual_scalar_typeof表示声明一个非限定的标量类型,非标量类型保持不变.即返回x</span></span><br><span class="line"><span class="comment">//如果 x 是int类型则返回“int”</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __READ_ONCE(x) \</span></span><br><span class="line"><span class="meta">  (*(const volatile int *)&amp;(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WRITE_ONCE(x, val) \</span></span><br><span class="line"><span class="meta">  do &#123;*(volatile int *)&amp;(x) = (val);&#125; while (0)</span></span><br></pre></td></tr></table></figure>
<h3 id="422-linux控制中断"><a class="markdownIt-Anchor" href="#422-linux控制中断"></a> 4.2.2 Linux控制中断</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Linux控制CPU响应中断的函数</span></span><br><span class="line"><span class="comment">//实际保存eflags寄存器</span></span><br><span class="line"><span class="keyword">extern</span> __always_inline <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">native_save_fl</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;# __raw_save_flags\n\t&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;pushf ; pop %0&quot;</span>:<span class="string">&quot;=rm&quot;</span>(flags)::<span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际恢复eflags寄存器</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">native_restore_fl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags)</span>&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;push %0 ; popf&quot;</span>::<span class="string">&quot;g&quot;</span>(flags):<span class="string">&quot;memory&quot;</span>,<span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际关中断</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">native_irq_disable</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;cli&quot;</span>:::<span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际开启中断</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">native_irq_enable</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti&quot;</span>:::<span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//arch层关中断</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_local_irq_disable</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  native_irq_disable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//arch层开启中断</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_local_irq_enable</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  native_irq_enable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//arch层保存eflags寄存器</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_local_save_flags</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> native_save_fl();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//arch层恢复eflags寄存器</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_local_irq_restore</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags)</span>&#123;</span><br><span class="line">  native_restore_fl(flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际保存eflags寄存器并关中断</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_local_irq_save</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags = arch_local_save_flags();</span><br><span class="line">  arch_local_irq_disable();</span><br><span class="line">  <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//raw层关闭开启中断宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_local_irq_disable() arch_local_irq_disable()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_local_irq_enable() arch_local_irq_enable()</span></span><br><span class="line"><span class="comment">//raw层保存恢复eflags寄存器宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_local_irq_save(flags) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">  typecheck(unsigned long, flags); \</span></span><br><span class="line"><span class="meta">  flags = arch_local_irq_save(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_local_irq_restore(flags) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">  typecheck(unsigned long, flags); \</span></span><br><span class="line"><span class="meta">arch_local_irq_restore(flags); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_local_save_flags(flags) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">typecheck(unsigned long, flags); \</span></span><br><span class="line"><span class="meta">flags = arch_local_save_flags(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用层接口宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_irq_enable() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">  raw_local_irq_enable(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_irq_disable() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">  raw_local_irq_disable(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_irq_save(flags) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">  raw_local_irq_save(flags); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_irq_restore(flags) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">  raw_local_irq_restore(flags); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Linux通过定义的方式对一些底层函数进行包装</li>
<li>编译Linux代码时,编译器对宏进行展开</li>
</ul>
<h3 id="423-linux自旋锁"><a class="markdownIt-Anchor" href="#423-linux自旋锁"></a> 4.2.3 Linux自旋锁</h3>
<ul>
<li>Linux需要自旋锁来对系统中的共享资源进行保护,同一时刻,获取了锁的进程才能使用共享资源</li>
<li>自旋锁不会引起加锁进程睡眠,如果自旋锁已经被别的进程持有,加锁进程需要一直循环,查看是否该自旋锁的持有者已经释放锁</li>
<li>Linux有多种自旋锁,重点介绍<strong>原始自旋锁</strong>和<strong>排队自旋锁</strong></li>
<li><strong>Linux原始自旋锁</strong>
<ul>
<li>Linux原始自旋锁本质上用一个整数表示,值1表示锁未被占用,值0或负数表示未被占用
<ul>
<li>当某个CPU核心执行进程请求加锁时,若锁是未加锁状态,则加锁,然后操作共享资源,最后释放锁</li>
<li>若锁已被加锁,则进程不会转入睡眠状态,而是循环等待该锁,一旦锁被释放,则第一个感知此信息的进程获得锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-16-18-03-05.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-16-18-03-05.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="自旋锁原理示意图" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Linux底层的自旋锁数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> lock;  <span class="comment">//真正的锁值变量</span></span><br><span class="line">  <span class="comment">// Linux原始自旋锁数据结构封装一个unsigned long类型变量</span></span><br><span class="line">&#125;<span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋锁接口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spin_unlock_string \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;movb $1,%0&quot;</span> \ <span class="comment">//写入1表示解锁</span></span></span><br><span class="line">  :<span class="string">&quot;=m&quot;</span> (lock-&gt;lock) : : <span class="string">&quot;memory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spin_lock_string \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;\n1:\t&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;lock ; decb %0\n\t&quot;</span> \ <span class="comment">//原子减1</span></span></span><br><span class="line">  <span class="string">&quot;js 2f\n&quot;</span> \ <span class="comment">//当结果小于0则跳转到标号2处,表示加锁失败</span></span><br><span class="line">    <span class="string">&quot;.section .text.lock,\&quot;ax\&quot;\n&quot;</span> \ <span class="comment">//重新定义一个代码段,这是优化技术,避免后面的代码</span></span><br><span class="line">  <span class="string">&quot;2:\t&quot;</span> \</span><br><span class="line">    <span class="string">&quot;cmpb $0,%0\n\t&quot;</span> \ <span class="comment">//和0比较</span></span><br><span class="line">    <span class="string">&quot;rep;nop\n\t&quot;</span> \ <span class="comment">//空指令</span></span><br><span class="line">    <span class="string">&quot;jle 2b\n\t&quot;</span> \ <span class="comment">//小于或等于0跳转到标号2</span></span><br><span class="line">    <span class="string">&quot;jmp 1b\n&quot;</span> \ <span class="comment">//跳转到标号1</span></span><br><span class="line">    <span class="string">&quot;.previous&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取自旋锁</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span>*lock)</span>&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    spin_lock_string</span><br><span class="line">    :<span class="string">&quot;=m&quot;</span>(lock-&gt;lock)::<span class="string">&quot;memory&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放自旋锁</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">spin_unlock</span><span class="params">(<span class="type">spinlock_t</span>*lock)</span>&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    spin_unlock_string</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spin_lock_string、spin_unlock_string 两个宏,定义了获取、释放自旋锁的汇编指令</span></span><br><span class="line"><span class="comment">// spin_unlock_string 只是简单将锁值变量设置成 1,表示释放自旋锁</span></span><br><span class="line"><span class="comment">// spin_lock_string 中并没有像Cosmos一样使用xchg指令,而是使用了decb指令,这条指令也能原子地执行减1操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始锁值变量为 1 时,执行 decb 指令就变成了 0,0 就表示加锁成功</span></span><br><span class="line"><span class="comment">// 如果小于 0,则表示有其它进程已经加锁了,就会导致循环比较</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Linux排队自旋锁</strong>
<ul>
<li>在多个进程获取自旋锁时,必须等待,该获取次序依赖哪个CPU核心能最先访问内存,哪个CPU核心可以访问内存是由<strong>总线仲裁协议</strong>决定的</li>
<li>为了<strong>解决排队公平性问题</strong>,开发了<strong>排队自旋锁</strong>,通过保存进程申请获得锁的先后次序,就能公平地调度进程</li>
</ul>
</li>
<li>slock域被分成两部分:<strong>锁持有者</strong>和<strong>未来锁申请者</strong>
<ul>
<li>只有next域与owner域相等时,才表示自旋锁处于未使用的状态</li>
<li>在排队自旋锁初始化时,slock被置为0,即next和owner被置为0,Linux进程执行申请自旋锁时,原子地将next域加0,并将原值返回作为自己的序号</li>
<li>如果返回的序号等于申请时的owner值,说明自旋锁处于未使用的状态,则进程直接获得锁;否则,该进程循环检查owner域是否等于自己持有的序号,一旦相等,则表明锁轮到自己获取</li>
<li>进程释放自旋锁时,原子地将owner域加1即可,下一个进程将会从循环状态中退出.进程将严格地按照申请顺序依次获取排队自旋锁</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RAW层的自旋锁数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span>&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> slock;<span class="comment">//真正的锁值变量</span></span><br><span class="line">&#125;<span class="type">raw_spinlock_t</span>;</span><br><span class="line"><span class="comment">//最上层的自旋锁数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line">&#125;<span class="type">spinlock_t</span>;</span><br><span class="line"><span class="comment">//Linux没有这样的结构,这只是为了描述方便</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> slock;<span class="comment">//真正的锁值变量</span></span><br><span class="line">    u16 owner;</span><br><span class="line">    u16 next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="type">raw_spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock(<span class="type">raw_spinlock_t</span>*lock)&#123;</span><br><span class="line">  <span class="type">int</span> inc = <span class="number">0x00010000</span>;</span><br><span class="line">  <span class="type">int</span> tmp;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;lock ; xaddl %0, %1\n&quot;</span> <span class="comment">//将inc和slock交换,然后 inc=inc+slock</span></span><br><span class="line">    <span class="comment">//相当于原子读取next和owner并对next+1</span></span><br><span class="line">    <span class="string">&quot;movzwl %w0, %2\n\t&quot;</span><span class="comment">//将inc的低16位做0扩展后送tmp tmp=(u16)inc</span></span><br><span class="line">    <span class="string">&quot;shrl $16, %0\n\t&quot;</span> <span class="comment">//将inc右移16位 inc=inc&gt;&gt;16</span></span><br><span class="line">    <span class="string">&quot;1:\t&quot;</span></span><br><span class="line">    <span class="string">&quot;cmpl %0, %2\n\t&quot;</span> <span class="comment">//比较inc和tmp,即比较next和owner</span></span><br><span class="line">    <span class="string">&quot;je 2f\n\t&quot;</span> <span class="comment">//相等则跳转到标号2处返回</span></span><br><span class="line">    <span class="string">&quot;rep ; nop\n\t&quot;</span> <span class="comment">//空指令</span></span><br><span class="line">    <span class="string">&quot;movzwl %1, %2\n\t&quot;</span> <span class="comment">//将slock的低16位做0扩展后送tmp 即tmp=owner</span></span><br><span class="line">    <span class="string">&quot;jmp 1b\n&quot;</span> <span class="comment">//跳转到标号1处继续比较</span></span><br><span class="line">    <span class="string">&quot;2:&quot;</span></span><br><span class="line">    :<span class="string">&quot;+Q&quot;</span>(inc),<span class="string">&quot;+m&quot;</span>(lock-&gt;slock),<span class="string">&quot;=r&quot;</span>(tmp)</span><br><span class="line">    ::<span class="string">&quot;memory&quot;</span>,<span class="string">&quot;cc&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNLOCK_LOCK_PREFIX LOCK_PREFIX</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_unlock(<span class="type">raw_spinlock_t</span>*lock)&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    UNLOCK_LOCK_PREFIX<span class="string">&quot;incw %0&quot;</span><span class="comment">//将slock的低16位加1 即owner+1</span></span><br><span class="line">    :<span class="string">&quot;+m&quot;</span>(lock-&gt;slock)</span><br><span class="line">    ::<span class="string">&quot;memory&quot;</span>,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Linux为了避免差异性,在spinlock_t结构体中包含了raw_spinlock_t,而在raw_spinlock_t结构体中并没使用next和owner字段,而是在代码中直接操作slock的高16位和低16位来实现的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个进程发现另一个进程已经拥有自己所请求地自旋锁时,就自愿放弃,转而做其他的工作,不循环等待浪费时间</span></span><br><span class="line"><span class="comment">// Linux提供的自旋锁接口</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __raw_spin_trylock(<span class="type">raw_spinlock_t</span>*lock)&#123;</span><br><span class="line">  <span class="type">int</span> tmp;</span><br><span class="line">  <span class="type">int</span> new;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl %2,%0\n\t&quot;</span><span class="comment">//tmp=slock</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl %0,%1\n\t&quot;</span><span class="comment">//new=tmp</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;roll $16, %0\n\t&quot;</span><span class="comment">//tmp循环左移16位,即next和owner交换了</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;cmpl %0,%1\n\t&quot;</span><span class="comment">//比较tmp和new即（owner、next）？=（next、owner）</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;jne 1f\n\t&quot;</span> <span class="comment">//不等则跳转到标号1处</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;addl $0x00010000, %1\n\t&quot;</span><span class="comment">//相当于next+1</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;lock ; cmpxchgl %1,%2\n\t&quot;</span><span class="comment">//new和slock交换比较</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;1:&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;sete %b1\n\t&quot;</span> <span class="comment">//new = eflags.ZF位,ZF取决于前面的判断是否相等</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;movzbl %b1,%0\n\t&quot;</span> <span class="comment">//tmp = new</span></span></span><br><span class="line"><span class="params">    :<span class="string">&quot;=&amp;a&quot;</span>(tmp),<span class="string">&quot;=Q&quot;</span>(new),<span class="string">&quot;+m&quot;</span>(lock-&gt;slock)</span></span><br><span class="line"><span class="params">    ::<span class="string">&quot;memory&quot;</span>,<span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _spin_trylock 返回1表示尝试加锁成功,可以安全的地问共享资源了</span></span><br><span class="line"><span class="comment">// 返回值为 0 则表示尝试加锁失败,不能操作共享资源,应该等一段时间,再次尝试加锁</span></span><br><span class="line"><span class="type">int</span> __lockfunc _spin_trylock(<span class="type">spinlock_t</span>*lock)&#123;</span><br><span class="line">  preempt_disable();</span><br><span class="line">  <span class="keyword">if</span>(_raw_spin_trylock(lock))&#123;</span><br><span class="line">    spin_acquire(&amp;lock-&gt;dep_map,<span class="number">0</span>,<span class="number">1</span>,_RET_IP_);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  preempt_enable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// _cond_lock 只用代码静态检查工作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spin_trylock(lock) __cond_lock(lock, _spin_trylock(lock))</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Linux信号量</strong>
<ul>
<li>Linux信号量被用来保护共享资源,能保证资源在一个时刻只有一个进程使用,是单值信号量,也可以用来作为资源计数器,为多值信号量</li>
<li>信号量的值为正时,所申请的进程可以锁定使用它</li>
<li>若为0表示被其他进程占用,申请的进程要进入睡眠队列中,等待被唤醒</li>
<li>信号量的最大优势:<mark>既可以使申请失败的进程睡眠,还可以作为资源计数器使用</mark></li>
<li>在Linux源代码的kernel/printk.c中,使用宏DEFINE_SEMAPHORE声明了一个单值信号量console_sem,也可以说是互斥锁,用于保护console驱动列表console_drivers以及同步对整个console驱动的访问
<ul>
<li>其中定义了宏down_console_sem()来获得信号量console_sem</li>
<li>定义了宏up_console_sem()来释放信号量console_sem</li>
<li>console_lock 和 console_unlock 函数是用于互斥访问 console 驱动的,核心操作就是调用前面定义两个宏</li>
</ul>
</li>
<li>代码描述了信号量的工作原理,详见代码
<ul>
<li>一个进程进入了__down 函数中,设置了一个不可中断的等待状态,然后执行了schedule_timeout函数.这个执行了进程的调度器,就直接调度到别的进程运行了</li>
<li>这时,这个进程就不会返回了,直到下一次它被up函数唤醒.执行了wake_up_process函数以后,重新调度它就会回到schedule_timeout函数下一行代码,沿着调用路经返回,最后从__down函数中出来,即进程睡醒</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Linux实习信号量的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line">  <span class="type">raw_spinlock_t</span> lock;<span class="comment">//保护信号量自身的自旋锁</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> count;<span class="comment">//信号量值</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">wait_list</span>;</span><span class="comment">//挂载睡眠等待进程的链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux信号量接口函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> down_console_sem() do &#123; \</span></span><br><span class="line"><span class="meta">  down(&amp;console_sem);\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __up_console_sem(<span class="type">unsigned</span> <span class="type">long</span> ip) &#123;</span><br><span class="line">  up(&amp;console_sem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> up_console_sem() __up_console_sem(_RET_IP_)</span></span><br><span class="line"><span class="comment">//加锁console</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_lock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  might_sleep();</span><br><span class="line">  down_console_sem();<span class="comment">//获取信号量console_sem</span></span><br><span class="line">  <span class="keyword">if</span> (console_suspended)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  console_locked = <span class="number">1</span>;</span><br><span class="line">  console_may_schedule = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解锁console</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_unlock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> ext_text[CONSOLE_EXT_LOG_MAX];</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> text[LOG_LINE_MAX + PREFIX_MAX];</span><br><span class="line">  <span class="comment">//……删除了很多代码</span></span><br><span class="line">  up_console_sem();<span class="comment">//释放信号量console_sem</span></span><br><span class="line">  raw_spin_lock(&amp;logbuf_lock);</span><br><span class="line">  <span class="comment">//……删除了很多代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// down_console_sem() 和 up_console_sem() 宏的核心主要是调用了信号量的接口函数 down、up 函数,完成获取、释放信号量的核心操作</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __sched __down_common(<span class="keyword">struct</span> semaphore *sem, <span class="type">long</span> state,<span class="type">long</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> semaphore_waiter waiter;</span><br><span class="line"><span class="comment">//把waiter加入sem-&gt;wait_list的头部</span></span><br><span class="line">list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list);</span><br><span class="line">waiter.task = current;<span class="comment">//current表示当前进程,即调用该函数的进程</span></span><br><span class="line">waiter.up = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (signal_pending_state(state, current))</span><br><span class="line"><span class="keyword">goto</span> interrupted;</span><br><span class="line"><span class="keyword">if</span> (unlikely(timeout &lt;= <span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> timed_out;</span><br><span class="line">__set_current_state(state);<span class="comment">//设置当前进程的状态,进程睡眠,即先前__down函数中</span></span><br><span class="line">raw_spin_unlock_irq(&amp;sem-&gt;lock);<span class="comment">//释放在down函数中加的锁</span></span><br><span class="line">timeout = schedule_timeout(timeout);<span class="comment">//真正进入睡眠</span></span><br><span class="line">raw_spin_lock_irq(&amp;sem-&gt;lock);<span class="comment">//进程下次运行会回到这里,所以要加锁</span></span><br><span class="line"><span class="keyword">if</span> (waiter.up)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">timed_out:</span><br><span class="line">list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> -ETIME;</span><br><span class="line">interrupted:</span><br><span class="line">list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line"><span class="comment">//为了简单起见处理进程信号（signal）和超时的逻辑代码我已经删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进入睡眠等待</span></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __down(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取信号量</span></span><br><span class="line"><span class="type">void</span> down(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="comment">//对信号量本身加锁并关中断,必须另一段代码也在操作该信号量</span></span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">sem-&gt;count--;<span class="comment">//如果信号量值大于0,则对其减1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__down(sem);<span class="comment">//否则让当前进程进入睡眠</span></span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际唤醒进程</span></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __up(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> semaphore_waiter *waiter = list_first_entry(&amp;sem-&gt;wait_list, <span class="keyword">struct</span></span><br><span class="line"><span class="comment">//获取信号量等待链表中的第一个数据结构semaphore_waiter,它里面保存着睡眠进程的指针</span></span><br><span class="line">list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">waiter-&gt;up = <span class="literal">true</span>;</span><br><span class="line">wake_up_process(waiter-&gt;task);<span class="comment">//唤醒进程重新加入调度队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line"><span class="type">void</span> up(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="comment">//对信号量本身加锁并关中断,必须另一段代码也在操作该信号量</span></span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list)))</span><br><span class="line">sem-&gt;count++;<span class="comment">//如果信号量等待链表中为空,则对信号量值加1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__up(sem);<span class="comment">//否则执行唤醒进程相关的操作</span></span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Linux读写锁</strong>
<ul>
<li>在操作系统中,读取共享数据时,加锁会大大浪费时间,降低进程的运行效率,<mark>可共享访问解决</mark>;在写时,加锁解锁,大量进程等待,降低系统性能</li>
<li><strong>读写锁(共享-独占)</strong>,当读写锁用读取模式加锁时,以共享模式上锁,写入修改模式加锁时,以独占模式上锁(互斥)
<ul>
<li><mark>非常适用于读取数据的频率远大于修改数据的频率的场景</mark>,</li>
<li><mark>读写锁读取时不能写入,写入时不能读取,而且读取和写入竞争锁时,写会优先得到锁</mark></li>
</ul>
</li>
<li><strong>步骤</strong>
<ol>
<li>当共享数据没有锁的时候,读取的加锁操作和写入的加锁操作都可以满足</li>
<li>当共享数据有读锁的时候,所有的读取加锁操作都可以满足,写入的加锁操作不能满足,读写是互斥的</li>
<li>当共享数据有写锁的时候,所有的读取的加锁操作都不能满足,所有的写入的加锁操作也不能满足,读与写之间是互斥的,写与写之间也是互斥的</li>
</ol>
</li>
<li><strong>Linux中读写锁本质上时自旋锁的变种</strong></li>
<li><strong>Linux读写锁的原理本质上时基于计数器</strong>,初始值为0x01000000
<ul>
<li>获取读锁时对其减1,结果不小于0表示读锁成功,获取写锁时直接减去0x01000000
<ul>
<li>**减初值的原因:**只有当锁值为初始值时,减去初始值结果才可以是 0,这是唯一没有进程持有任何锁的情况,这样才能保证获取写锁时是互斥的</li>
</ul>
</li>
</ul>
</li>
<li>读写锁其实是带计数的特殊自旋锁,能同时被多个读取数据的进程占有或一个修改数据的进程占有,但不能同时被读取数据的进程和修改数据的进程占有</li>
</ul>
</li>
<li>获取,释放读写锁的流程
<ol>
<li>获取读锁时,锁值变量 lock 计数减去 1,判断结果的符号位是否为 1.若结果符号位为0 时,获取读锁成功,即表示 lock 大于 0</li>
<li>获取读锁时,锁值变量 lock 计数减去 1,判断结果的符号位是否为 1.若结果符号位为1 时,获取读锁失败,表示此时读写锁被修改数据的进程占有,此时调用__read_lock_failed 失败处理函数,循环测试 lock+1 的值,直到结果的值大于等于 1</li>
<li>获取写锁时,锁值变量 lock 计数减去 RW_LOCK_BIAS_STR,即 lock-0x01000000,判断结果是否为 0.若结果为 0 时,表示获取写锁成功</li>
<li>获取写锁时,锁值变量 lock 计数减去 RW_LOCK_BIAS_STR,即 lock-0x01000000,判断结果是否为 0.若结果不为 0 时,获取写锁失败,表示此时有读取数据的进程占有读锁或有修改数据的进程占有写锁,此时调用 __write_lock_failed 失败处理函数,循环测试lock+0x01000000,直到结果的值等于 0x01000000</li>
</ol>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-16-22-10-50.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-16-22-10-50.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="读写锁的步骤" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读写锁初始化锁值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_LOCK_BIAS 0x01000000</span></span><br><span class="line"><span class="comment">//读写锁的底层数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> lock;</span><br><span class="line">&#125;<span class="type">arch_rwlock_t</span>;</span><br><span class="line"><span class="comment">//释放读锁</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_read_unlock</span><span class="params">(<span class="type">arch_rwlock_t</span>*rw)</span>&#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">LOCK_PREFIX<span class="string">&quot;incl %0&quot;</span> <span class="comment">//原子对lock加1</span></span></span><br><span class="line"><span class="params">:<span class="string">&quot;+m&quot;</span>(rw-&gt;lock)::<span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放写锁</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_write_unlock</span><span class="params">(<span class="type">arch_rwlock_t</span>*rw)</span>&#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">LOCK_PREFIX<span class="string">&quot;addl %1, %0&quot;</span><span class="comment">//原子对lock加上RW_LOCK_BIAS</span></span></span><br><span class="line"><span class="params">:<span class="string">&quot;+m&quot;</span>(rw-&gt;lock):<span class="string">&quot;i&quot;</span>(RW_LOCK_BIAS):<span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取写锁失败时调用</span></span><br><span class="line">ENTRY(__write_lock_failed)</span><br><span class="line"><span class="comment">//(%eax)表示由eax指向的内存空间是调用者传进来的</span></span><br><span class="line"><span class="number">2</span>:LOCK_PREFIX addl $ RW_LOCK_BIAS,(%eax)</span><br><span class="line"><span class="number">1</span>:rep;nop<span class="comment">//空指令</span></span><br><span class="line">cmpl $RW_LOCK_BIAS,(%eax)</span><br><span class="line"><span class="comment">//不等于初始值则循环比较,相等则表示有进程释放了写锁</span></span><br><span class="line">jne <span class="number">1b</span></span><br><span class="line"><span class="comment">//执行加写锁</span></span><br><span class="line">LOCK_PREFIX subl $ RW_LOCK_BIAS,(%eax)</span><br><span class="line">jnz <span class="number">2b</span> <span class="comment">//不为0则继续测试,为0则表示加写锁成功</span></span><br><span class="line">ret <span class="comment">//返回</span></span><br><span class="line">ENDPROC(__write_lock_failed)</span><br><span class="line"><span class="comment">//获取读锁失败时调用</span></span><br><span class="line">ENTRY(__read_lock_failed)</span><br><span class="line"><span class="comment">//(%eax)表示由eax指向的内存空间是调用者传进来的</span></span><br><span class="line"><span class="number">2</span>:LOCK_PREFIX <span class="title function_">incl</span><span class="params">(%eax)</span><span class="comment">//原子加1</span></span><br><span class="line">1: rep; nop<span class="comment">//空指令</span></span><br><span class="line">cmpl $<span class="number">1</span>,(%eax) <span class="comment">//和1比较 小于0则</span></span><br><span class="line">js <span class="number">1b</span> <span class="comment">//为负则继续循环比较</span></span><br><span class="line">LOCK_PREFIX <span class="title function_">decl</span><span class="params">(%eax)</span> <span class="comment">//加读锁</span></span><br><span class="line">js 2b <span class="comment">//为负则继续加1并比较,否则返回</span></span><br><span class="line">ret <span class="comment">//返回</span></span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(__read_lock_failed)</span></span><br><span class="line"><span class="comment">//获取读锁</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_read_lock</span><span class="params">(<span class="type">arch_rwlock_t</span>*rw)</span>&#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">LOCK_PREFIX<span class="string">&quot; subl $1,(%0)\n\t&quot;</span><span class="comment">//原子对lock减1</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;jns 1f\n&quot;</span><span class="comment">//不为小于0则跳转标号1处,表示获取读锁成功</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;call __read_lock_failed\n\t&quot;</span><span class="comment">//调用__read_lock_failed</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;1:\n&quot;</span></span></span><br><span class="line"><span class="params">::LOCK_PTR_REG(rw):<span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取写锁</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_write_lock</span><span class="params">(<span class="type">arch_rwlock_t</span>*rw)</span>&#123;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">LOCK_PREFIX<span class="string">&quot;subl %1,(%0)\n\t&quot;</span><span class="comment">//原子对lock减去RW_LOCK_BIAS</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;jz 1f\n&quot;</span><span class="comment">//为0则跳转标号1处</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;call __write_lock_failed\n\t&quot;</span><span class="comment">//调用__write_lock_failed</span></span></span><br><span class="line"><span class="params"><span class="string">&quot;1:\n&quot;</span></span></span><br><span class="line"><span class="params">::LOCK_PTR_REG(rw),<span class="string">&quot;i&quot;</span>(RW_LOCK_BIAS):<span class="string">&quot;memory&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-16-22-21-49.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-16-22-21-49.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Linux的自旋锁与信号量" /></p>
<hr />
<h1 id="5-启动初始化"><a class="markdownIt-Anchor" href="#5-启动初始化"></a> 5 启动初始化</h1>
</div><div class="story post-story"><h2 id="51-建立计算机"><a class="markdownIt-Anchor" href="#51-建立计算机"></a> 5.1 建立计算机</h2>
<ul>
<li>把多个文件变成一个文件就需要封装,即把多个文件组装形成一个文件,这个文件称为<strong>内核映像文件</strong>
<ul>
<li><strong>内核映像文件</strong>包含二级引导器的模块,内核模块,图片和字库文件</li>
<li>GRUB头有4KB大小,GRUB通过一小段代码来识别映像文件,根据映像文件描述符和文件头描述符里的信息,并且还可以解析映像文件中的其他文件</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-17-15-37-44.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-17-15-37-44.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内核映像文件格式" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映像文件头描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_mlosrddsc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">u64_t</span> mdc_mgic; <span class="comment">//映像文件标识</span></span><br><span class="line"><span class="type">u64_t</span> mdc_sfsum;<span class="comment">//未使用</span></span><br><span class="line"><span class="type">u64_t</span> mdc_sfsoff;<span class="comment">//未使用</span></span><br><span class="line"><span class="type">u64_t</span> mdc_sfeoff;<span class="comment">//未使用</span></span><br><span class="line"><span class="type">u64_t</span> mdc_sfrlsz;<span class="comment">//未使用</span></span><br><span class="line"><span class="type">u64_t</span> mdc_ldrbk_s;<span class="comment">//映像文件中二级引导器的开始偏移</span></span><br><span class="line"><span class="type">u64_t</span> mdc_ldrbk_e;<span class="comment">//映像文件中二级引导器的结束偏移</span></span><br><span class="line"><span class="type">u64_t</span> mdc_ldrbk_rsz;<span class="comment">//映像文件中二级引导器的实际大小</span></span><br><span class="line"><span class="type">u64_t</span> mdc_ldrbk_sum;<span class="comment">//映像文件中二级引导器的校验和</span></span><br><span class="line"><span class="type">u64_t</span> mdc_fhdbk_s;<span class="comment">//映像文件中文件头描述的开始偏移</span></span><br><span class="line"><span class="type">u64_t</span> mdc_fhdbk_e;<span class="comment">//映像文件中文件头描述的结束偏移</span></span><br><span class="line"><span class="type">u64_t</span> mdc_fhdbk_rsz;<span class="comment">//映像文件中文件头描述的实际大小</span></span><br><span class="line"><span class="type">u64_t</span> mdc_fhdbk_sum;<span class="comment">//映像文件中文件头描述的校验和</span></span><br><span class="line"><span class="type">u64_t</span> mdc_filbk_s;<span class="comment">//映像文件中文件数据的开始偏移</span></span><br><span class="line"><span class="type">u64_t</span> mdc_filbk_e;<span class="comment">//映像文件中文件数据的结束偏移</span></span><br><span class="line"><span class="type">u64_t</span> mdc_filbk_rsz;<span class="comment">//映像文件中文件数据的实际大小</span></span><br><span class="line"><span class="type">u64_t</span> mdc_filbk_sum;<span class="comment">//映像文件中文件数据的校验和</span></span><br><span class="line"><span class="type">u64_t</span> mdc_ldrcodenr;<span class="comment">//映像文件中二级引导器的文件头描述符的索引号</span></span><br><span class="line"><span class="type">u64_t</span> mdc_fhdnr;<span class="comment">//映像文件中文件头描述符有多少个</span></span><br><span class="line"><span class="type">u64_t</span> mdc_filnr;<span class="comment">//映像文件中文件头有多少个</span></span><br><span class="line"><span class="type">u64_t</span> mdc_endgic;<span class="comment">//映像文件结束标识</span></span><br><span class="line"><span class="type">u64_t</span> mdc_rv;<span class="comment">//映像文件版本</span></span><br><span class="line">&#125;<span class="type">mlosrddsc_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FHDSC_NMAX 192 <span class="comment">//文件名长度</span></span></span><br><span class="line"><span class="comment">//文件头描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_fhdsc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">u64_t</span> fhd_type;<span class="comment">//文件类型</span></span><br><span class="line"><span class="type">u64_t</span> fhd_subtype;<span class="comment">//文件子类型</span></span><br><span class="line"><span class="type">u64_t</span> fhd_stuts;<span class="comment">//文件状态</span></span><br><span class="line"><span class="type">u64_t</span> fhd_id;<span class="comment">//文件id</span></span><br><span class="line"><span class="type">u64_t</span> fhd_intsfsoff;<span class="comment">//文件在映像文件位置开始偏移</span></span><br><span class="line"><span class="type">u64_t</span> fhd_intsfend;<span class="comment">//文件在映像文件的结束偏移</span></span><br><span class="line"><span class="type">u64_t</span> fhd_frealsz;<span class="comment">//文件实际大小</span></span><br><span class="line"><span class="type">u64_t</span> fhd_fsum;<span class="comment">//文件校验和</span></span><br><span class="line"><span class="type">char</span> fhd_name[FHDSC_NMAX];<span class="comment">//文件名</span></span><br><span class="line">&#125;<span class="type">fhdsc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux命令行下的打包映像的工具</span></span><br><span class="line">lmoskrlimg -m k -lhf GRUB头文件 -o 映像文件 -f 输入的文件列表</span><br><span class="line">-m 表示模式 只能是k内核模式</span><br><span class="line">-lhf 表示后面跟上GRUB头文件</span><br><span class="line">-o 表示输出的映像文件名</span><br><span class="line">-f 表示输入文件列表</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用虚拟机建立虚拟电脑</strong>
<ul>
<li><strong>需要手工生产磁盘,使用dd命令</strong></li>
</ul>
</li>
<li>Linux在文件上建立文件系统
<ul>
<li>第一步,把虚拟磁盘文件变成Linux下的回环设备,用losetup命令,将hd.img变成Linux的回环设备</li>
<li>第二步,将losetup命令用于设置回环设备.回环设备可以把文件虚拟成Linux块设备,用来模拟整个文件系统,让用户可以将其看作硬盘、光驱或软驱等设备,并且可用mount命令挂载当作目录来使用</li>
<li>第三步,用Linux下的mount命令,将hd.img文件当作块设备,把它挂载到事先建立的hdisk目录下,并在其中建立一个boot
<ul>
<li><strong>mount命令只能识别在纯二进制文件上建立的文件系统,如果使用虚拟机自己生成的磁盘文件,mount无法识别文件系统</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>安装GRUB</strong>
<ul>
<li>通过GRUB的安装程序,将GRUB安装到指定的虚拟磁盘上</li>
<li>/hdisk/boot/目录下创建了grub目录,表示GRUB安装成功
<ul>
<li>在/hdisk/boot/grub/目录下建立一个<strong>grub.cfg文本文件</strong>,GRUB正是通过这个文件内容,查找到操作系统映像文件的</li>
</ul>
</li>
</ul>
</li>
<li><strong>转换虚拟磁盘格式供虚拟机识别</strong>
<ul>
<li>使用专用的转化格式工具</li>
</ul>
</li>
<li><strong>安装虚拟磁盘</strong>
<ul>
<li>生成VDI格式的虚拟磁盘后,使用hd.vdi文件和虚拟机软件联系</li>
<li>配置虚拟磁盘分两步：第一步,配置硬盘控制器,其控制器是intelAHCI;第二步,挂载虚拟硬盘文件</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Linux下dd命令</span></span><br><span class="line"><span class="comment">// 用指定大小的块拷贝一个文件,并在拷贝的同时进行指定的转换</span></span><br><span class="line">dd bs=<span class="number">512</span> <span class="keyword">if</span>=/dev/zero of=hd.img count=<span class="number">204800</span></span><br><span class="line">;bs:表示块大小,这里是<span class="number">512</span>字节</span><br><span class="line">;<span class="keyword">if</span>：表示输入文件,/dev/zero就是Linux下专门返回<span class="number">0</span>数据的设备文件,读取它就返回<span class="number">0</span></span><br><span class="line">;of：表示输出文件,即我们的硬盘文件.</span><br><span class="line">;count：表示输出多少块</span><br><span class="line"></span><br><span class="line">sudo losetup /dev/loop0 hd.img</span><br><span class="line"></span><br><span class="line">sudo mkfs.ext4 -q /dev/loop0</span><br><span class="line"></span><br><span class="line">sudo mount -o loop ./hd.img ./hdisk/ ;挂载硬盘文件</span><br><span class="line">sudo mkdir ./hdisk/boot/ ;建立boot目录</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装GRUB</span></span><br><span class="line">第一步挂载虚拟硬盘文件为loop0回环设备</span><br><span class="line">sudo losetup /dev/loop0 hd.img</span><br><span class="line">sudo mount -o loop ./hd.img ./hdisk/ ;挂载硬盘文件</span><br><span class="line">第二步安装GRUB</span><br><span class="line">sudo grub-install --boot-directory=./hdisk/boot/ --force --allow-floppy /dev/l</span><br><span class="line">;--boot-directory 指向先前我们在虚拟硬盘中建立的boot目录.</span><br><span class="line">;--force --allow-floppy ：指向我们的虚拟硬盘设备文件/dev/loop0</span><br><span class="line"></span><br><span class="line"><span class="comment">// grub.cfg</span></span><br><span class="line">menuentry <span class="string">&#x27;HelloOS&#x27;</span> &#123;</span><br><span class="line">insmod part_msdos</span><br><span class="line">insmod ext2</span><br><span class="line"><span class="built_in">set</span> root=<span class="string">&#x27;hd0,msdos1&#x27;</span> #我们的硬盘只有一个分区所以是<span class="string">&#x27;hd0,msdos1&#x27;</span></span><br><span class="line">multiboot2 /boot/HelloOS.eki #加载boot目录下的HelloOS.eki文件</span><br><span class="line">boot #引导启动</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span> timeout_style=menu</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$&#123;timeout&#125;&quot;</span> = <span class="number">0</span> ]; then</span><br><span class="line"><span class="built_in">set</span> timeout=<span class="number">10</span> #等待<span class="number">10</span>秒钟自动启动</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换虚拟磁盘格式</span></span><br><span class="line">VBoxManage convertfromraw ./hd.img --format VDI ./hd.vdi</span><br><span class="line">;convertfromraw 指向原始格式文件</span><br><span class="line">;--format VDI 表示转换成虚拟需要的VDI格式</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装虚拟磁盘</span></span><br><span class="line">#第一步 SATA的硬盘其控制器是intelAHCI</span><br><span class="line">VBoxManage storagectl HelloOS --name <span class="string">&quot;SATA&quot;</span> --add sata --controller IntelAhci</span><br><span class="line">#第二步</span><br><span class="line">VBoxManage closemedium disk ./hd.vdi #删除虚拟硬盘UUID并重新分配</span><br><span class="line">#将虚拟硬盘挂到虚拟机的硬盘控制器</span><br><span class="line">VBoxManage storageattach HelloOS --storagectl <span class="string">&quot;SATA&quot;</span> --port <span class="number">1</span> --device <span class="number">0</span> --typ</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="52-建造二级引导器"><a class="markdownIt-Anchor" href="#52-建造二级引导器"></a> 5.2 建造二级引导器</h2>
<ul>
<li>二级引导器作为操作系统的先驱,需要收集机器信息,确定这个计算机能不能运行操作系统,对CPU,内存,显卡进行初级配置,放置内核相关的文件
<ul>
<li>二级引导器不执行具体的加载任务,而是解析内核文件,收集机器环境信息</li>
</ul>
</li>
<li><strong>设计机器信息结构</strong>
<ul>
<li>二级引导器收集的信息放在内存1MB的地方,方便传给操作系统</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放信息的数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MACHBSTART</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">u64_t</span> mb_krlinitstack;<span class="comment">//内核栈地址</span></span><br><span class="line"><span class="type">u64_t</span> mb_krlitstacksz;<span class="comment">//内核栈大小</span></span><br><span class="line"><span class="type">u64_t</span> mb_imgpadr;<span class="comment">//操作系统映像</span></span><br><span class="line"><span class="type">u64_t</span> mb_imgsz;<span class="comment">//操作系统映像大小</span></span><br><span class="line"><span class="type">u64_t</span> mb_bfontpadr;<span class="comment">//操作系统字体地址</span></span><br><span class="line"><span class="type">u64_t</span> mb_bfontsz;<span class="comment">//操作系统字体大小</span></span><br><span class="line"><span class="type">u64_t</span> mb_fvrmphyadr;<span class="comment">//机器显存地址</span></span><br><span class="line"><span class="type">u64_t</span> mb_fvrmsz;<span class="comment">//机器显存大小</span></span><br><span class="line"><span class="type">u64_t</span> mb_cpumode;<span class="comment">//机器CPU工作模式</span></span><br><span class="line"><span class="type">u64_t</span> mb_memsz;<span class="comment">//机器内存大小</span></span><br><span class="line"><span class="type">u64_t</span> mb_e820padr;<span class="comment">//机器e820数组地址</span></span><br><span class="line"><span class="type">u64_t</span> mb_e820nr;<span class="comment">//机器e820数组元素个数</span></span><br><span class="line"><span class="type">u64_t</span> mb_e820sz;<span class="comment">//机器e820数组大小</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="type">u64_t</span> mb_pml4padr;<span class="comment">//机器页表数据地址</span></span><br><span class="line"><span class="type">u64_t</span> mb_subpageslen;<span class="comment">//机器页表个数</span></span><br><span class="line"><span class="type">u64_t</span> mb_kpmapphymemsz;<span class="comment">//操作系统映射空间大小</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="type">graph_t</span> mb_ghparm;<span class="comment">//图形信息</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">machbstart_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>规划二级引导器
<ul>
<li>整体划分二级引导器的功能模块</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-17-16-38-45.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-17-16-38-45.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="二级引导器功能划分表" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-17-16-39-08.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-17-16-39-08.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="二级引导器编译过程示意图" /></p>
<ul>
<li><strong>实现GRUB头</strong>
<ul>
<li>GRUB头有两个文件组成
<ul>
<li>imginithead.asm汇编文件:能让GRUB识别,又能设置C语言运行环境,调用C函数
<ul>
<li>主要工作是初始化CPU寄存器,加载GDT,切换到CPU的保护模式</li>
</ul>
</li>
<li>inithead.c文件:查找二级引导器的核心文件(initdrkrl.bin),将它放置到特定的内存地址上</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GRUB1和GRUB2需要的两个头结构</span></span><br><span class="line">MBT_HDR_FLAGS EQU <span class="number">0x00010003</span></span><br><span class="line">MBT_HDR_MAGIC EQU <span class="number">0x1BADB002</span></span><br><span class="line">MBT2_MAGIC EQU <span class="number">0xe85250d6</span></span><br><span class="line">global _start</span><br><span class="line"><span class="keyword">extern</span> inithead_entry</span><br><span class="line">[section .text]</span><br><span class="line">[bits <span class="number">32</span>]</span><br><span class="line">_start:</span><br><span class="line">jmp _entry</span><br><span class="line">align <span class="number">4</span></span><br><span class="line">mbt_hdr:</span><br><span class="line">dd MBT_HDR_MAGIC</span><br><span class="line">dd MBT_HDR_FLAGS</span><br><span class="line">dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)</span><br><span class="line">dd mbt_hdr</span><br><span class="line">dd _start</span><br><span class="line">dd <span class="number">0</span></span><br><span class="line">dd <span class="number">0</span></span><br><span class="line">dd _entry</span><br><span class="line">ALIGN <span class="number">8</span></span><br><span class="line">mbhdr:</span><br><span class="line">DD <span class="number">0xE85250D6</span></span><br><span class="line">DD <span class="number">0</span></span><br><span class="line">DD mhdrend - mbhdr</span><br><span class="line">DD -(<span class="number">0xE85250D6</span> + <span class="number">0</span> + (mhdrend - mbhdr))</span><br><span class="line">DW <span class="number">2</span>, <span class="number">0</span></span><br><span class="line">DD <span class="number">24</span></span><br><span class="line">DD mbhdr</span><br><span class="line">DD _start</span><br><span class="line">DD <span class="number">0</span></span><br><span class="line">DD <span class="number">0</span></span><br><span class="line">DW <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">DD <span class="number">12</span></span><br><span class="line">DD _entry</span><br><span class="line">DD <span class="number">0</span></span><br><span class="line">DW <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">DD <span class="number">8</span></span><br><span class="line">mhdrend:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关中断并加载GDT</span></span><br><span class="line">_entry:</span><br><span class="line">  cli ;关中断</span><br><span class="line">  in al, <span class="number">0x70</span></span><br><span class="line">  or al, <span class="number">0x80</span></span><br><span class="line">  out <span class="number">0x70</span>,al ;关掉不可屏蔽中断</span><br><span class="line">  lgdt [GDT_PTR] ;加载GDT地址到GDTR寄存器</span><br><span class="line">  jmp dword <span class="number">0x8</span> :_32bits_mode ;长跳转刷新CS影子寄存器</span><br><span class="line">  ;………………</span><br><span class="line">;GDT全局段描述符表</span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq <span class="number">0</span></span><br><span class="line">kcode_dsc: dq <span class="number">0x00cf9e000000ffff</span></span><br><span class="line">kdata_dsc: dq <span class="number">0x00cf92000000ffff</span></span><br><span class="line">k16cd_dsc: dq <span class="number">0x00009e000000ffff</span> ;<span class="number">16</span>位代码段描述符</span><br><span class="line">k16da_dsc: dq <span class="number">0x000092000000ffff</span> ;<span class="number">16</span>位数据段描述符</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN dw GDT_END-GDT_START<span class="number">-1</span> ;GDT界限</span><br><span class="line">GDTBASE dd GDT_ST</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化段寄存器和通用寄存器,栈寄存器</span></span><br><span class="line"><span class="comment">// 给调用inithead_entry函数做准备</span></span><br><span class="line">_32bits_mode：</span><br><span class="line">  mov ax, <span class="number">0x10</span></span><br><span class="line">  mov ds, ax</span><br><span class="line">  mov ss, ax</span><br><span class="line">  mov es, ax</span><br><span class="line">  mov fs, ax</span><br><span class="line">  mov gs, ax</span><br><span class="line">  xor eax,eax</span><br><span class="line">  xor ebx,ebx</span><br><span class="line">  xor ecx,ecx</span><br><span class="line">  xor edx,edx</span><br><span class="line">  xor edi,edi</span><br><span class="line">  xor esi,esi</span><br><span class="line">  xor ebp,ebp</span><br><span class="line">  xor esp,esp</span><br><span class="line">  mov esp,<span class="number">0x7c00</span> ;设置栈顶为<span class="number">0x7c00</span></span><br><span class="line">  call inithead_entry ;调用inithead_entry函数在inithead.c中实现</span><br><span class="line">  jmp <span class="number">0x200000</span> ;跳转到<span class="number">0x200000</span>地址</span><br><span class="line"></span><br><span class="line"><span class="comment">// inithead.c文件中实现inithead_entry函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MDC_ENDGIC 0xaaffaaffaaffaaff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MDC_RVGIC 0xffaaffaaffaaffaa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REALDRV_PHYADR 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMGFILE_PHYADR 0x4000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMGKRNL_PHYADR 0x2000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDRFILEADR IMGFILE_PHYADR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOSDSC_OFF (0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MRDDSC_ADR (mlosrddsc_t*)(LDRFILEADR+0x1000)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inithead_entry</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">write_realintsvefile();</span><br><span class="line">write_ldrkrlfile();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写initldrsve.bin文件到特定的内存中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_realintsvefile</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">fhdsc_t</span> *fhdscstart = find_file(<span class="string">&quot;initldrsve.bin&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fhdscstart == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">error(<span class="string">&quot;not file initldrsve.bin&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">m2mcopy((<span class="type">void</span> *)((<span class="type">u32_t</span>)(fhdscstart-&gt;fhd_intsfsoff) + LDRFILEADR),</span><br><span class="line">(<span class="type">void</span> *)REALDRV_PHYADR, (<span class="type">sint_t</span>)fhdscstart-&gt;fhd_frealsz);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写initldrkrl.bin文件到特定的内存中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_ldrkrlfile</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">fhdsc_t</span> *fhdscstart = find_file(<span class="string">&quot;initldrkrl.bin&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fhdscstart == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">error(<span class="string">&quot;not file initldrkrl.bin&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">m2mcopy((<span class="type">void</span> *)((<span class="type">u32_t</span>)(fhdscstart-&gt;fhd_intsfsoff) + LDRFILEADR),</span><br><span class="line">(<span class="type">void</span> *)ILDRKRL_PHYADR, (<span class="type">sint_t</span>)fhdscstart-&gt;fhd_frealsz);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在映像文件中查找对应的文件</span></span><br><span class="line"><span class="type">fhdsc_t</span> *<span class="title function_">find_file</span><span class="params">(<span class="type">char_t</span> *fname)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">mlosrddsc_t</span> *mrddadrs = MRDDSC_ADR;</span><br><span class="line"><span class="keyword">if</span> (mrddadrs-&gt;mdc_endgic != MDC_ENDGIC ||</span><br><span class="line">mrddadrs-&gt;mdc_rv != MDC_RVGIC ||</span><br><span class="line">mrddadrs-&gt;mdc_fhdnr &lt; <span class="number">2</span> ||</span><br><span class="line">mrddadrs-&gt;mdc_filnr &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">error(<span class="string">&quot;no mrddsc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">s64_t</span> rethn = <span class="number">-1</span>;</span><br><span class="line"><span class="type">fhdsc_t</span> *fhdscstart = (<span class="type">fhdsc_t</span> *)((<span class="type">u32_t</span>)(mrddadrs-&gt;mdc_fhdbk_s) + LDRFILE</span><br><span class="line"><span class="keyword">for</span> (<span class="type">u64_t</span> i = <span class="number">0</span>; i &lt; mrddadrs-&gt;mdc_fhdnr; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (strcmpl(fname, fhdscstart[i].fhd_name) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">rethn = (<span class="type">s64_t</span>)i;</span><br><span class="line"><span class="keyword">goto</span> ok_l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rethn = <span class="number">-1</span>;</span><br><span class="line">ok_l:</span><br><span class="line"><span class="keyword">if</span> (rethn &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">error(<span class="string">&quot;not find file&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;fhdscstart[rethn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inithead_entry函数</span></span><br><span class="line"><span class="comment">// 工作:分别调用write_realintsvefile();write_ldrkrlfile()函数,把映像文件中的initldrsve.bin和initldrkrl.bin文件写入特定的内存地址空间中</span></span><br><span class="line">  <span class="comment">// find_file 函数负责扫描映像文件中的文件头描述符,对比其中的文件名,然后返回对应的文件头描述符的地址,这样就可以得到文件在映像文件中的位置和大小了</span></span><br><span class="line">  <span class="comment">// m2mcopy函数负责把映像文件复制到具体的内存空间里</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>进入二级引导器</strong>
<ul>
<li>在GRUB头imghead.asm文件中jmp 0x200000跳转到物理内存0x200000地址处
<ul>
<li><strong>物理地址</strong>,此地址是inithead.c中由write_ldrkrlfile()函数放置的initldrkrl.bin文件,跳转进入了二级引导器的主模块</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块改变,需要汇编代码,建立initldr32.asm文件</span></span><br><span class="line"><span class="comment">// 加载GDTR和IDTR寄存器,然后初始化CPU相关寄存器</span></span><br><span class="line">_entry:</span><br><span class="line">  cli</span><br><span class="line">  lgdt [GDT_PTR];加载GDT地址到GDTR寄存器</span><br><span class="line">  lidt [IDT_PTR];加载IDT地址到IDTR寄存器</span><br><span class="line">  jmp dword <span class="number">0x8</span> :_32bits_mode;长跳转刷新CS影子寄存器</span><br><span class="line">_32bits_mode:</span><br><span class="line">  mov ax, <span class="number">0x10</span> ; 数据段选择子(目的)</span><br><span class="line">  mov ds, ax</span><br><span class="line">  mov ss, ax</span><br><span class="line">  mov es, ax</span><br><span class="line">  mov fs, ax</span><br><span class="line">  mov gs, ax</span><br><span class="line">  xor eax,eax</span><br><span class="line">  xor ebx,ebx</span><br><span class="line">  xor ecx,ecx</span><br><span class="line">  xor edx,edx</span><br><span class="line">  xor edi,edi</span><br><span class="line">  xor esi,esi</span><br><span class="line">  xor ebp,ebp</span><br><span class="line">  xor esp,esp</span><br><span class="line">  mov esp,<span class="number">0x90000</span> ;使得栈底指向了<span class="number">0x90000</span></span><br><span class="line">  call ldrkrl_entry ;调用ldrkrl_entry函数</span><br><span class="line">  xor ebx,ebx</span><br><span class="line">  jmp <span class="number">0x2000000</span> ;跳转到<span class="number">0x2000000</span>的内存地址</span><br><span class="line">  jmp $</span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq <span class="number">0</span></span><br><span class="line">kcode_dsc: dq <span class="number">0x00cf9a000000ffff</span> ;a-e</span><br><span class="line">kdata_dsc: dq <span class="number">0x00cf92000000ffff</span></span><br><span class="line">k16cd_dsc: dq <span class="number">0x00009a000000ffff</span> ;<span class="number">16</span>位代码段描述符</span><br><span class="line">k16da_dsc: dq <span class="number">0x000092000000ffff</span> ;<span class="number">16</span>位数据段描述符</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN dw GDT_END-GDT_START<span class="number">-1</span> ;GDT界限</span><br><span class="line">GDTBASE dd GDT_START</span><br><span class="line">IDT_PTR:</span><br><span class="line">IDTLEN dw <span class="number">0x3ff</span></span><br><span class="line">IDTBAS dd <span class="number">0</span> ;这是BIOS中断表的地址和长度</span><br><span class="line"><span class="comment">// 把 GDT,IDT寄存器重新初始化,最后再去调用二级引导器的主函数 ldrkrl_entry</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>巧妙调用BIOS中断</strong>
<ul>
<li>获得内存信息以及设置显卡图形模式依赖<strong>BIOS提供的中断服务</strong></li>
<li>C语言代码工作在32位保护模式下,BIOS中断工作在16位的实模式</li>
</ul>
</li>
<li>C语言调用BIOS中断需要处理的问题
<ul>
<li>保存C语言环境的上下文</li>
<li>切换回实模式,调用BIOS中断,把BIOS中断返回的结果保存在内存中</li>
<li>切换回保护模式,重新加载第一步中的数据</li>
<li><strong>将汇编函数写在initldr32.asm中</strong></li>
</ul>
</li>
<li>之前write_realintsvefile()函数的功能与意义
<ul>
<li>把映像文件中的initldrsve.bin文件写入到特定的内存地址空间中</li>
<li>initldrsve.bin是由上面的realintsve.asm文件编译而成的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">realadr_call_entry:</span><br><span class="line">  pushad ;保存通用寄存器</span><br><span class="line">  push ds</span><br><span class="line">  push es</span><br><span class="line">  push fs ;保存<span class="number">4</span>个段寄存器</span><br><span class="line">  push gs</span><br><span class="line">  call save_eip_jmp ;调用save_eip_jmp</span><br><span class="line">  pop gs</span><br><span class="line">  pop fs</span><br><span class="line">  pop es ;恢复<span class="number">4</span>个段寄存器</span><br><span class="line">  pop ds</span><br><span class="line">  popad ;恢复通用寄存器</span><br><span class="line">  ret</span><br><span class="line">save_eip_jmp:</span><br><span class="line">  pop esi ;弹出call save_eip_jmp时保存的eip到esi寄存器中,</span><br><span class="line">  mov [PM32_EIP_OFF],esi ;把eip保存到特定的内存空间中</span><br><span class="line">  mov [PM32_ESP_OFF],esp ;把esp保存到特定的内存空间中</span><br><span class="line">  jmp dword far [cpmty_mode]</span><br><span class="line">;长跳转这里表示把cpmty_mode处的第一个<span class="number">4</span>字节装入eip</span><br><span class="line">;把<span class="number">0x18</span>：<span class="number">0x1000</span> 装入到 CS：EIP 中</span><br><span class="line">cpmty_mode:</span><br><span class="line">  dd <span class="number">0x1000</span></span><br><span class="line">  dw <span class="number">0x18</span></span><br><span class="line">  jmp $</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x18就是段描述索引指向GDT中的16位代码段描述符</span></span><br><span class="line"><span class="comment">// 0x1000 代表段内的偏移地址,必须放一段代码指令</span></span><br><span class="line"><span class="comment">// 建立realintsve.asm</span></span><br><span class="line">[bits <span class="number">16</span>]</span><br><span class="line">_start:</span><br><span class="line">_16_mode:</span><br><span class="line">  mov bp,<span class="number">0x20</span> ;<span class="number">0x20</span>是指向GDT中的<span class="number">16</span>位数据段描述符</span><br><span class="line">  mov ds, bp</span><br><span class="line">  mov es, bp</span><br><span class="line">  mov ss, bp</span><br><span class="line">  mov ebp, cr0</span><br><span class="line">  and ebp, <span class="number">0xfffffffe</span></span><br><span class="line">  mov cr0, ebp ;CR0.P=<span class="number">0</span> 关闭保护模式</span><br><span class="line">  jmp <span class="number">0</span>:real_entry ;刷新CS影子寄存器,真正进入实模式</span><br><span class="line">real_entry:</span><br><span class="line">  mov bp, cs</span><br><span class="line">  mov ds, bp</span><br><span class="line">  mov es, bp</span><br><span class="line">  mov ss, bp ;重新设置实模式下的段寄存器 都是CS中值,即为<span class="number">0</span></span><br><span class="line">  mov sp, <span class="number">08000</span>h ;设置栈</span><br><span class="line">  mov bp,func_table</span><br><span class="line">  add bp,ax</span><br><span class="line">  call [bp] ;调用函数表中的汇编函数,ax是C函数中传递进来的</span><br><span class="line">  cli</span><br><span class="line">  call disable_nmi</span><br><span class="line">  mov ebp, cr0</span><br><span class="line">  or ebp, <span class="number">1</span></span><br><span class="line">  mov cr0, ebp ;CR0.P=<span class="number">1</span> 开启保护模式</span><br><span class="line">  jmp dword <span class="number">0x8</span> :_32bits_mode</span><br><span class="line">[BITS <span class="number">32</span>]</span><br><span class="line">_32bits_mode:</span><br><span class="line">  mov bp, <span class="number">0x10</span></span><br><span class="line">  mov ds, bp</span><br><span class="line">  mov ss, bp;重新设置保护模式下的段寄存器<span class="number">0x10</span>是<span class="number">32</span>位数据段描述符的索引</span><br><span class="line">  mov esi,[PM32_EIP_OFF];加载先前保存的EIP</span><br><span class="line">  mov esp,[PM32_ESP_OFF];加载先前保存的ESP</span><br><span class="line">  jmp esi ;eip=esi 回到了realadr_call_entry函数中</span><br><span class="line">  func_table: ;函数表</span><br><span class="line">  dw _getmmap ;获取内存布局视图的函数</span><br><span class="line">  dw _read ;读取硬盘的函数</span><br><span class="line">  dw _getvbemode ;获取显卡VBE模式</span><br><span class="line">  dw _getvbeonemodeinfo ;获取显卡VBE模式的数据</span><br><span class="line">  dw _setvbemode ;设置显卡VBE模式</span><br><span class="line"><span class="comment">// 首先从_16_mode:标号处进入实模式,然后根据传递进来(由ax寄存器传入)的函数号,到函数表中调用对应的函数,里面的函数执行完成后,再次进入保护模式,加载EIP和ESP寄存器从而回到realadr_call_entry函数中</span></span><br><span class="line"><span class="comment">// GDT还是imghead.asm汇编代码文件中的GDT,因为它是由GDTR寄存器指向的</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>二级引导器主函数</strong>
<ul>
<li>二级引导器主函数使用C来写</li>
<li>代码中的ldrkrl_entry函数在initldr32.asm文件中被调用</li>
<li>从callldrkrl_entry指令开始进入了ldrkrl_entry()函数,在其中调用了**init_bstartparm()**函数
<ul>
<li>**init_bstartparm()**负责处理开始参数的,位手机机器环境信息的主函数</li>
</ul>
</li>
</ul>
</li>
<li><mark>将处理操作系统运行环境的工作独立出来,交给二级引导器做,大大降低开发操作系统的难度,增加操作系统的通用性</mark></li>
</ul>
</div><div class="story post-story"><h2 id="53-探查和收集信息"><a class="markdownIt-Anchor" href="#53-探查和收集信息"></a> 5.3 探查和收集信息</h2>
<ul>
<li>完成具体的二级引导器的工作
<ul>
<li>检查CPU是否支持64位的工作模式</li>
<li>收集内存布局信息</li>
<li>是否符合操作系统的最低运行要求</li>
<li>设置操作系统需要的MMU页表</li>
<li>设置显卡模式</li>
<li>释放中文字体</li>
</ul>
</li>
<li><strong>检查与收集机器信息</strong>
<ul>
<li>为了使代码清晰,不直接在ldrkrl__entry()中实现,在bstartparm.c文件中实现init_bstartparm()</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化machbstart_t结构体,清0,并设置一个标志</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">machbstart_t_init</span><span class="params">(<span class="type">machbstart_t</span>* initp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(initp,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">machbstart_t</span>));</span><br><span class="line">  initp-&gt;mb_migc=MBS_MIGC;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_bstartparm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">machbstart_t</span>* mbsp = MBSPADR;<span class="comment">//1MB的内存地址</span></span><br><span class="line">  machbstart_t_init(mbsp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用了一个machbstart_t_init()函数</span></span><br><span class="line"><span class="comment">// 在1MB内存地址处初始化了一个机器信息结构machbstart_t</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>检查CPU</strong>:init_chkcpu()
<ul>
<li>要CPUID指令检查CPU是否支持64位长模式,所以需要chk_cpuid,chk_cpu_longmode开实现检查CPU是否支持CPUID指令,以及检查CPU支持64位长模式</li>
<li><strong>最后设置机器信息结构中的mb_cpumode字段为64,mbsp正是传递进来的机器信息machbstart_t 结构体的指针</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过改写Eflags寄存器的第21位,观察其位的变化判断是否支持CPUID</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chk_cpuid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> rets = <span class="number">0</span>;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;pushfl \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;popl %%eax \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;movl %%eax,%%ebx \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;xorl $0x0200000,%%eax \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;pushl %%eax \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;popfl \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;pushfl \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;popl %%eax \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;xorl %%ebx,%%eax \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;jz 1f \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;movl $1,%0 \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp 2f \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;1: movl $0,%0 \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;2: \n\t&quot;</span></span><br><span class="line">    : <span class="string">&quot;=c&quot;</span>(rets)</span><br><span class="line">    :</span><br><span class="line">  :);</span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查CPU是否支持长模式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chk_cpu_longmode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> rets = <span class="number">0</span>;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;movl $0x80000000,%%eax \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;cpuid \n\t&quot;</span> <span class="comment">//把eax中放入0x80000000调用CPUID指令</span></span><br><span class="line">    <span class="string">&quot;cmpl $0x80000001,%%eax \n\t&quot;</span><span class="comment">//看eax中返回结果</span></span><br><span class="line">    <span class="string">&quot;setnb %%al \n\t&quot;</span> <span class="comment">//不为0x80000001,则不支持0x80000001号功能</span></span><br><span class="line">    <span class="string">&quot;jb 1f \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;movl $0x80000001,%%eax \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;cpuid \n\t&quot;</span><span class="comment">//把eax中放入0x800000001调用CPUID指令,检查edx中的返回数据</span></span><br><span class="line">    <span class="string">&quot;bt $29,%%edx \n\t&quot;</span> <span class="comment">//长模式 支持位 是否为1</span></span><br><span class="line">    <span class="string">&quot;setcb %%al \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;1: \n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;movzx %%al,%%eax \n\t&quot;</span></span><br><span class="line">    : <span class="string">&quot;=a&quot;</span>(rets)</span><br><span class="line">    :</span><br><span class="line">    :);</span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查CPU主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_chkcpu</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!chk_cpuid())</span><br><span class="line">  &#123;</span><br><span class="line">    kerror(<span class="string">&quot;Your CPU is not support CPUID sys is die!&quot;</span>);</span><br><span class="line">    CLI_HALT();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!chk_cpu_longmode())</span><br><span class="line">  &#123;</span><br><span class="line">    kerror(<span class="string">&quot;Your CPU is not support 64bits mode sys is die!&quot;</span>);</span><br><span class="line">    CLI_HALT();</span><br><span class="line">  &#125;</span><br><span class="line">  mbsp-&gt;mb_cpumode = <span class="number">0x40</span>;<span class="comment">//如果成功则设置机器信息结构的cpu模式为64位</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查CPU是否支持CPUID指令和检查CPU是否支持长模式,只要其中一步检查失败,就打印一条相应的提示信息,然后主动死机</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>获取内存布局</strong>
<ul>
<li>物理内存在物理地址空间中是一段一段的,描述一段内存有一个数据结构</li>
<li>获取内存布局信息就是获取结构体的数组,交给init_mem函数来干
<ul>
<li>完成获取上述这个结构体数组,并且检查内存</li>
</ul>
</li>
<li>实现init_mem函数中最难写的是mmap函数,<strong>只要调用BIOS中断,就能获取e820map结构数组</strong></li>
<li>init_mem函数在调用mmap函数后,就会得到e820map结构数组,其首地址和数组元素个数由retemp,retemnr两个变量分别提供</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_USABLE 1 <span class="comment">//可用内存</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_RESERV 2 <span class="comment">//保留内存不可使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_ACPIREC 3 <span class="comment">//ACPI表相关的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_ACPINVS 4 <span class="comment">//ACPI NVS空间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_AREACON 5 <span class="comment">//包含坏内存</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_e820</span>&#123;</span></span><br><span class="line">  <span class="type">u64_t</span> saddr; <span class="comment">/* 内存开始地址 */</span></span><br><span class="line">  <span class="type">u64_t</span> lsize; <span class="comment">/* 内存大小 */</span></span><br><span class="line">  <span class="type">u32_t</span> type; <span class="comment">/* 内存类型 */</span></span><br><span class="line">&#125;<span class="type">e820map_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现init_mem函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETYBAK_ADR 0x2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PM32_EIP_OFF (ETYBAK_ADR)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PM32_ESP_OFF (ETYBAK_ADR+4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E80MAP_NR (ETYBAK_ADR+64)<span class="comment">//保存e820map_t结构数组元素个数的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E80MAP_ADRADR (ETYBAK_ADR+68) <span class="comment">//保存e820map_t结构数组的开始地址</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mem</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">e820map_t</span> *retemp;</span><br><span class="line">  <span class="type">u32_t</span> retemnr = <span class="number">0</span>;</span><br><span class="line">  mmap(&amp;retemp, &amp;retemnr);</span><br><span class="line">  <span class="keyword">if</span> (retemnr == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  kerror(<span class="string">&quot;no e820map\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据e820map_t结构数据检查内存大小</span></span><br><span class="line">  <span class="keyword">if</span> (chk_memsize(retemp, retemnr, <span class="number">0x100000</span>, <span class="number">0x8000000</span>) == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  kerror(<span class="string">&quot;Your computer is low on memory, the memory cannot be less than</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  mbsp-&gt;mb_e820padr = (u64_t)((u32_t)(retemp));//把e820map_t结构数组的首地址传给</span></span><br><span class="line"><span class="string">  mbsp-&gt;mb_e820nr = (u64_t)retemnr;//把e820map_t结构数组元素个数传给mbsp-&gt;mb_e82</span></span><br><span class="line"><span class="string">  mbsp-&gt;mb_e820sz = retemnr * (sizeof(e820map_t));//把e820map_t结构数组大小传给</span></span><br><span class="line"><span class="string">  mbsp-&gt;mb_memsz = get_memsize(retemp, retemnr);//根据e820map_t结构数据计算内存大</span></span><br><span class="line"><span class="string">  return;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// mmap函数调用关系</span></span><br><span class="line"><span class="string">// realadr_call_entry 函数,来调用实模式下的_getmmap 函数的,并且在 _getmmap 函数中调用 BIOS 中断的</span></span><br><span class="line"><span class="string">void mmap(e820map_t **retemp, u32_t *retemnr)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  realadr_call_entry(RLINTNR(0), 0, 0);</span></span><br><span class="line"><span class="string">  *retemnr = *((u32_t *)(E80MAP_NR));</span></span><br><span class="line"><span class="string">  *retemp = (e820map_t *)(*((u32_t *)(E80MAP_ADRADR)));</span></span><br><span class="line"><span class="string">  return;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">_getmmap:</span></span><br><span class="line"><span class="string">  push ds</span></span><br><span class="line"><span class="string">  push es</span></span><br><span class="line"><span class="string">  push ss</span></span><br><span class="line"><span class="string">  mov esi,0</span></span><br><span class="line"><span class="string">  mov dword[E80MAP_NR],esi</span></span><br><span class="line"><span class="string">  mov dword[E80MAP_ADRADR],E80MAP_ADR ;e820map结构体开始地址</span></span><br><span class="line"><span class="string">  xor ebx,ebx</span></span><br><span class="line"><span class="string">  mov edi,E80MAP_ADR</span></span><br><span class="line"><span class="string">loop:</span></span><br><span class="line"><span class="string">  mov eax,0e820h ;获取e820map结构参数</span></span><br><span class="line"><span class="string">  mov ecx,20 ;e820map结构大小</span></span><br><span class="line"><span class="string">  mov edx,0534d4150h ;获取e820map结构参数必须是这个数据</span></span><br><span class="line"><span class="string">  int 15h ;BIOS的15h中断</span></span><br><span class="line"><span class="string">  jc .1</span></span><br><span class="line"><span class="string">  add edi,20</span></span><br><span class="line"><span class="string">  cmp edi,E80MAP_ADR+0x1000</span></span><br><span class="line"><span class="string">  jg .1</span></span><br><span class="line"><span class="string">  inc esi</span></span><br><span class="line"><span class="string">  cmp ebx,0</span></span><br><span class="line"><span class="string">  jne loop ;循环获取e820map结构</span></span><br><span class="line"><span class="string">  jmp .2</span></span><br><span class="line"><span class="string">.1:</span></span><br><span class="line"><span class="string">  mov esi,0 ;出错处理,e820map结构数组元素个数为0</span></span><br><span class="line"><span class="string">.2:</span></span><br><span class="line"><span class="string">  mov dword[E80MAP_NR],esi ;e820map结构数组元素个数</span></span><br><span class="line"><span class="string">  pop ss</span></span><br><span class="line"><span class="string">  pop es</span></span><br><span class="line"><span class="string">  pop ds</span></span><br><span class="line"><span class="string">  ret</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化内核栈</strong>
<ul>
<li>给即将运行的内核初始化一个栈,就是在机器信息结构machbstart_t中,记录一个栈地址和栈大小,供内核在启动时使用</li>
<li>init_krlinitstack函数非常简单,但其中调用链一个move_krlimg函数负责判断一个地址空间是否和内存中存放的内容有冲突</li>
<li><mark>因为内存中放置了机器信息结构,内存视窗结构数组,二级引导器,内核映像文件,故在处理内存空间时不能和内存中已经存在的冲突,否则就要覆盖数据</mark>
<ul>
<li>0x8f000-(0x8f000+0x1001)是内核栈空间,需要检测它是否和其它空间有冲突</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IKSTACK_PHYADR (0x90000-0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IKSTACK_SIZE 0x1000</span></span><br><span class="line"><span class="comment">//初始化内核栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krlinitstack</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &gt; move_krlimg(mbsp, (<span class="type">u64_t</span>)(<span class="number">0x8f000</span>), <span class="number">0x1001</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    kerror(<span class="string">&quot;iks_moveimg err&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mbsp-&gt;mb_krlinitstack = IKSTACK_PHYADR;<span class="comment">//栈顶地址</span></span><br><span class="line">  mbsp-&gt;mb_krlitstacksz = IKSTACK_SIZE; <span class="comment">//栈大小是4KB</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>放置内核文件与字库文件</strong>
<ul>
<li>内核已经编译成一个独立的二进制程序,和其它文件一起被打包到映像文件中,故必须要从映像中将它解压出来,将其放在特定的物理内存空间中才可以</li>
<li><strong>放置字库文件和放置内核文件的原理一样</strong></li>
<li><mark>内核是代码数据,所以必须要复制到指定的内存空间中</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放置内核文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krlfile</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在映像中查找相应的文件,并复制到对应的地址,并返回文件的大小,这里是查找kernel.bin文件</span></span><br><span class="line">  <span class="type">u64_t</span> sz = r_file_to_padr(mbsp, IMGKRNL_PHYADR, <span class="string">&quot;kernel.bin&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == sz)</span><br><span class="line">  &#123;</span><br><span class="line">  kerror(<span class="string">&quot;r_file_to_padr err&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//放置完成后更新机器信息结构中的数据</span></span><br><span class="line">  mbsp-&gt;mb_krlimgpadr = IMGKRNL_PHYADR;</span><br><span class="line">  mbsp-&gt;mb_krlsz = sz;</span><br><span class="line">  <span class="comment">//mbsp-&gt;mb_nextwtpadr始终要保持指向下一段空闲内存的首地址</span></span><br><span class="line">  mbsp-&gt;mb_nextwtpadr = P4K_ALIGN(mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz);</span><br><span class="line">  mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//放置字库文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_defutfont</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u64_t</span> sz = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//获取下一段空闲内存空间的首地址</span></span><br><span class="line">  <span class="type">u32_t</span> dfadr = (<span class="type">u32_t</span>)mbsp-&gt;mb_nextwtpadr;</span><br><span class="line"><span class="comment">//在映像中查找相应的文件,并复制到对应的地址,并返回文件的大小,这里是查找font.fnt文件</span></span><br><span class="line">  sz = r_file_to_padr(mbsp, dfadr, <span class="string">&quot;font.fnt&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == sz)</span><br><span class="line">  &#123;</span><br><span class="line">  kerror(<span class="string">&quot;r_file_to_padr err&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//放置完成后更新机器信息结构中的数据</span></span><br><span class="line">  mbsp-&gt;mb_bfontpadr = (<span class="type">u64_t</span>)(dfadr);</span><br><span class="line">  mbsp-&gt;mb_bfontsz = sz;</span><br><span class="line">  <span class="comment">//更新机器信息结构中下一段空闲内存的首地址</span></span><br><span class="line">  mbsp-&gt;mb_nextwtpadr = P4K_ALIGN((<span class="type">u32_t</span>)(dfadr) + sz);</span><br><span class="line">  mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_bfontpadr + mbsp-&gt;mb_bfontsz;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>建立MMU页表数据</strong>
<ul>
<li>在二级引导器中建立MMU页表数据,目的就是要在内核加载运行之初开启长模式,MMU需要的页表数据已经准备好了</li>
<li>内核虚拟地址空间从0xffff800000000000开始,所以这个虚拟地址映射到从物理地址 0 开始,大小都是 0x400000000即16GB
<ul>
<li>虚拟地址空间：0xffff800000000000～0xffff800400000000映射到物理地址空间0～0x400000000</li>
</ul>
</li>
<li><strong>映射的核心逻辑由两重循环控制</strong>,外层循环控制页目录指针顶,只有16项,其中每一项都指向一个页目录,每个页目录中有512个物理页地址</li>
<li><mark>内核在启动初期,虚拟地址和物理地址保持相同</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用长模式下2MB分页方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KINITPAGE_PHYADR 0x1000000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_bstartpages</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//顶级页目录</span></span><br><span class="line">  <span class="type">u64_t</span> *p = (<span class="type">u64_t</span> *)(KINITPAGE_PHYADR);<span class="comment">//16MB地址处</span></span><br><span class="line">  <span class="comment">//页目录指针</span></span><br><span class="line">  <span class="type">u64_t</span> *pdpte = (<span class="type">u64_t</span> *)(KINITPAGE_PHYADR + <span class="number">0x1000</span>);</span><br><span class="line">  <span class="comment">//页目录</span></span><br><span class="line">  <span class="type">u64_t</span> *pde = (<span class="type">u64_t</span> *)(KINITPAGE_PHYADR + <span class="number">0x2000</span>);</span><br><span class="line">  <span class="comment">//物理地址从0开始</span></span><br><span class="line">  <span class="type">u64_t</span> adr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &gt; move_krlimg(mbsp, (<span class="type">u64_t</span>)(KINITPAGE_PHYADR), (<span class="number">0x1000</span> * <span class="number">16</span> + <span class="number">0x2000</span></span><br><span class="line">  &#123;</span><br><span class="line">    kerror(<span class="string">&quot;move_krlimg err&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将顶级页目录、页目录指针的空间清0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> mi = <span class="number">0</span>; mi &lt; PGENTY_SIZE; mi++)</span><br><span class="line">  &#123;</span><br><span class="line">    p[mi] = <span class="number">0</span>;</span><br><span class="line">    pdpte[mi] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//映射</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> pdei = <span class="number">0</span>; pdei &lt; <span class="number">16</span>; pdei++)</span><br><span class="line">  &#123;</span><br><span class="line">    pdpte[pdei] = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)pde | KPDPTE_RW | KPDPTE_P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint_t</span> pdeii = <span class="number">0</span>; pdeii &lt; PGENTY_SIZE; pdeii++)</span><br><span class="line">    &#123;<span class="comment">//大页KPDE_PS 2MB,可读写KPDE_RW,存在KPDE_P</span></span><br><span class="line">      pde[pdeii] = <span class="number">0</span> | adr | KPDE_PS | KPDE_RW | KPDE_P;</span><br><span class="line">      adr += <span class="number">0x200000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pde = (<span class="type">u64_t</span> *)((<span class="type">u32_t</span>)pde + <span class="number">0x1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//让顶级页目录中第0项和第((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff</span></span><br><span class="line">  p[((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; <span class="number">0x1ff</span>] = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)</span><br><span class="line">  p[<span class="number">0</span>] = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)pdpte | KPML4_RW | KPML4_P);</span><br><span class="line">  <span class="comment">//把页表首地址保存在机器信息结构中</span></span><br><span class="line">  mbsp-&gt;mb_pml4padr = (<span class="type">u64_t</span>)(KINITPAGE_PHYADR);</span><br><span class="line">  mbsp-&gt;mb_subpageslen = (<span class="type">u64_t</span>)(<span class="number">0x1000</span> * <span class="number">16</span> + <span class="number">0x2000</span>);</span><br><span class="line">  mbsp-&gt;mb_kpmapphymemsz = (<span class="type">u64_t</span>)(<span class="number">0x400000000</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>设置图形模式</strong>
<ul>
<li>在计算机加电启动时,计算机显卡进入文本模式,文本模式只能显示ASCII字符,不能显示汉字和图形,所以要让显卡切换到图形模式</li>
<li><strong>切换显卡模式依然用BIOS中断</strong></li>
<li><strong>VBE是显卡的一个图形规范标准</strong>
<ul>
<li>定义了显卡的集中图形模式,每个模式包括屏幕分辨率,像素格式与大小,显存大小</li>
<li>调用BIOS 10h中断可以返回这些数据结构</li>
</ul>
</li>
<li>VBE的118h模式,该模式下屏幕分辨率为1024*768,显存大小是16.8MB,现存开始地址为0xe0000000
<ul>
<li>屏幕分为768行,每行1024个像素点,每个像素点占用显存的32位数据(4字节,红,绿,蓝,透明各占8位)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_graph</span><span class="params">(<span class="type">machbstart_t</span>* mbsp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化图形数据结构</span></span><br><span class="line">  graph_t_init(&amp;mbsp-&gt;mb_ghparm);</span><br><span class="line">  <span class="comment">//获取VBE模式,通过BIOS中断</span></span><br><span class="line">  get_vbemode(mbsp);</span><br><span class="line">  <span class="comment">//获取一个具体VBE模式的信息,通过BIOS中断</span></span><br><span class="line">  get_vbemodeinfo(mbsp);</span><br><span class="line">  <span class="comment">//设置VBE模式,通过BIOS中断</span></span><br><span class="line">  set_vbemodeinfo();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个像素点的数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_PIXCL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">u8_t</span> cl_b; <span class="comment">//蓝</span></span><br><span class="line">  <span class="type">u8_t</span> cl_g; <span class="comment">//绿</span></span><br><span class="line">  <span class="type">u8_t</span> cl_r; <span class="comment">//红</span></span><br><span class="line">  <span class="type">u8_t</span> cl_a; <span class="comment">//透明</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">pixcl_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BGRA(r,g,b) ((0|(r&lt;&lt;16)|(g&lt;&lt;8)|b))</span></span><br><span class="line"><span class="comment">//通常情况下用pixl_t 和 BGRA宏</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">u32_t</span> <span class="type">pixl_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕像素点和显存位置对应的计算方式</span></span><br><span class="line"><span class="type">u32_t</span>* dispmem = (<span class="type">u32_t</span>*)mbsp-&gt;mb_ghparm.gh_framphyadr;</span><br><span class="line">dispmem[x + (y * <span class="number">1024</span>)] = pix;</span><br><span class="line"><span class="comment">//x,y是像素的位置</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>串联</strong>
<ul>
<li>在init_bstartparm函数中将各个工作函数串联
<ul>
<li>按照事件的先后顺序依次调用完成工作,实现检查,收集机器信息,设置工作环境</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_bstartparm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">machbstart_t</span> *mbsp = MBSPADR;</span><br><span class="line">  machbstart_t_init(mbsp);</span><br><span class="line">  <span class="comment">//检查CPU</span></span><br><span class="line">  init_chkcpu(mbsp);</span><br><span class="line">  <span class="comment">//获取内存布局</span></span><br><span class="line">  init_mem(mbsp);</span><br><span class="line">  <span class="comment">//初始化内核栈</span></span><br><span class="line">  init_krlinitstack(mbsp);</span><br><span class="line">  <span class="comment">//放置内核文件</span></span><br><span class="line">  init_krlfile(mbsp);</span><br><span class="line">  <span class="comment">//放置字库文件</span></span><br><span class="line">  init_defutfont(mbsp);</span><br><span class="line">  init_meme820(mbsp);</span><br><span class="line">  <span class="comment">//建立MMU页表</span></span><br><span class="line">  init_bstartpages(mbsp);</span><br><span class="line">  <span class="comment">//设置图形模式</span></span><br><span class="line">  init_graph(mbsp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>显示logo</strong>
<ul>
<li>logo文件是24位的位图文件
<ul>
<li>在图格式的文件中,除了文件头的数据就是图形像素点的数据</li>
<li>只不过24位的位图每个像素占用3字节,并且位置是倒排的,依次将位图文件的数据倒排次序写入显存中,就可以显示了</li>
</ul>
</li>
<li>随后的工作
<ul>
<li>将二级引导器文件和logo文件打包成映像文件,放在虚拟磁盘中</li>
<li>复制文件到虚拟磁盘中,需要先mount,然后复制,最后转换成VDI格式的虚拟硬盘,挂载到虚拟机上启动</li>
</ul>
</li>
</ul>
</li>
<li><strong>进入Cosmos系统</strong>
<ul>
<li>调用C函数之前,需要写汇编代码切换CPU到长模式,初始化CPU寄存器和C语言要用的栈</li>
<li>目前代码执行流在二级引导器中,进入到Cosmos中二级引导器初始化过的东西不能用了</li>
<li>CPU进入长模式,寄存器的位宽发生变化,需要重新初始化</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">[section .start.text]</span><br><span class="line">[BITS <span class="number">32</span>]</span><br><span class="line">_start:</span><br><span class="line">cli</span><br><span class="line">mov ax,<span class="number">0x10</span></span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov gs,ax</span><br><span class="line">lgdt [eGdtPtr]</span><br><span class="line">;开启 PAE</span><br><span class="line">mov eax, cr4</span><br><span class="line">bts eax, <span class="number">5</span> ; CR4.PAE = <span class="number">1</span></span><br><span class="line">mov cr4, eax</span><br><span class="line">mov eax, PML4T_BADR ;加载MMU顶级页目录</span><br><span class="line">mov cr3, eax</span><br><span class="line">;开启 <span class="number">64b</span>its <span class="type">long</span>-mode</span><br><span class="line">mov ecx, IA32_EFER</span><br><span class="line">rdmsr</span><br><span class="line">bts eax, <span class="number">8</span> ; IA32_EFER.LME =<span class="number">1</span></span><br><span class="line">wrmsr</span><br><span class="line">;开启 PE 和 paging</span><br><span class="line">mov eax, cr0</span><br><span class="line">bts eax, <span class="number">0</span> ; CR0.PE =<span class="number">1</span></span><br><span class="line">bts eax, <span class="number">31</span></span><br><span class="line">;开启 CACHE</span><br><span class="line">btr eax,<span class="number">29</span> ; CR0.NW=<span class="number">0</span></span><br><span class="line">btr eax,<span class="number">30</span> ; CR0.CD=<span class="number">0</span> CACHE</span><br><span class="line">mov cr0, eax ; IA32_EFER.LMA = <span class="number">1</span></span><br><span class="line">jmp <span class="number">08</span>:entry64</span><br><span class="line">[BITS <span class="number">64</span>]</span><br><span class="line">entry64:</span><br><span class="line">mov ax,<span class="number">0x10</span></span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov gs,ax</span><br><span class="line">xor rax,rax</span><br><span class="line">xor rbx,rbx</span><br><span class="line">xor rbp,rbp</span><br><span class="line">xor rcx,rcx</span><br><span class="line">xor rdx,rdx</span><br><span class="line">xor rdi,rdi</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor r8,r8</span><br><span class="line">xor r9,r9</span><br><span class="line">xor r10,r10</span><br><span class="line">xor r11,r11</span><br><span class="line">xor r12,r12</span><br><span class="line">xor r13,r13</span><br><span class="line">xor r14,r14</span><br><span class="line">xor r15,r15</span><br><span class="line">mov rbx,MBSP_ADR</span><br><span class="line">mov rax,KRLVIRADR</span><br><span class="line">mov rcx,[rbx+KINITSTACK_OFF]</span><br><span class="line">add rax,rcx</span><br><span class="line">xor rcx,rcx</span><br><span class="line">xor rbx,rbx</span><br><span class="line">mov rsp,rax</span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push <span class="number">0x8</span></span><br><span class="line">mov rax,hal_start ;调用内核主函数</span><br><span class="line">push rax</span><br><span class="line">dw <span class="number">0xcb48</span></span><br><span class="line">jmp $</span><br><span class="line">[section .start.data]</span><br><span class="line">[BITS <span class="number">32</span>]</span><br><span class="line">x64_GDT:</span><br><span class="line">enull_x64_dsc: dq <span class="number">0</span></span><br><span class="line">ekrnl_c64_dsc: dq <span class="number">0x0020980000000000</span> ; <span class="number">64</span>-bit 内核代码段</span><br><span class="line">ekrnl_d64_dsc: dq <span class="number">0x0000920000000000</span> ; <span class="number">64</span>-bit 内核数据段</span><br><span class="line">euser_c64_dsc: dq <span class="number">0x0020f80000000000</span> ; <span class="number">64</span>-bit 用户代码段</span><br><span class="line">euser_d64_dsc: dq <span class="number">0x0000f20000000000</span> ; <span class="number">64</span>-bit 用户数据段</span><br><span class="line">eGdtLen equ $ - enull_x64_dsc ; GDT长度</span><br><span class="line">eGdtPtr: dw eGdtLen - <span class="number">1</span> ; GDT界限</span><br><span class="line">dq ex64 GDT</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最关键的是63～66行,它开始把8和hal_start函数的地址压入栈中</span></span><br><span class="line"><span class="comment">//dw 0xcb48是直接写一条指令的机器码0xcb48,这是一条返回指令,会把栈中的数据分别弹出到RIP,CS寄存器,这正是为了调用Cosmos的第一个C函数hal_start</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>二级引导器总结</strong>
<ol>
<li>二级引导器彻底摆脱了GRUB的控制之后,就开始检查CPU,获取内存布局信息,确认是不是要求的CPU和内存大小,接着初始化内核栈、放置好内核文件和字库文件,建立MMU页表数据和设置好图形模式,为后面运行内核做好准备</li>
<li>当二级引导器完成了上述功能后,就会显示操作系统的logo,标志着二级引导器所有的工作一切正常</li>
<li>进入Cosmos,二级引导器通过跳转到Cosmos的入口,二级引导器结束使命,Cosmos 的入口是一小段汇编代码,主要是开启CPU的长模式,最后调用了Cosmos的第一个C函数hal_start</li>
</ol>
</li>
</ul>
</div><div class="story post-story"><h2 id="54-第一个c函数如何实现板级初始化"><a class="markdownIt-Anchor" href="#54-第一个c函数如何实现板级初始化"></a> 5.4 第一个C函数:如何实现板级初始化</h2>
<ul>
<li>在hal_start函数中
<ul>
<li>首先执行板级初始化(hal层(硬件抽象层)初始化),其中执行平台初始化,hal层的内存初始化,中断初始化,最后是内核层的初始化</li>
</ul>
</li>
<li>第一个C函数
<ul>
<li>初始化函数,在Cosmos/hal/x86下建立hal_start.c文件</li>
<li>该函数第一步是初始化hal层,第二部是初始化内核层
<ul>
<li><strong>死循环是避免函数返回</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hal_start.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hal_start</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//第一步：初始化hal层</span></span><br><span class="line">  <span class="comment">//第二步：初始化内核层</span></span><br><span class="line">  <span class="keyword">for</span>(;;);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>hal层初始化</strong>
<ul>
<li>分离硬件,将硬件相关的操作集中在hal层,并向上提供接口,目的是让上层不用关注硬件相关的细节,方便以后的移植和扩展</li>
<li>完成初始化平台,初始化内存,初始化中断的功能函数</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cosmos/hal/x86/halinit.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_hal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化平台</span></span><br><span class="line">  <span class="comment">//初始化内存</span></span><br><span class="line">  <span class="comment">//初始化中断</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化平台</strong>
<ul>
<li>把二级引导器建立的机器信息结构复制到hal层中的一个全局变量中,方便内核中的其他代码使用里面的信息,之后二级引导器建立的数据所占用的内存都会被释放</li>
<li>初始化图形显示驱动,内核在运行过程中输出信息</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cosmos/hal/x86/halplatform.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">machbstart_t_init</span><span class="params">(<span class="type">machbstart_t</span> *initp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//清零</span></span><br><span class="line">  <span class="built_in">memset</span>(initp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">machbstart_t</span>));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_machbstart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">machbstart_t</span> *kmbsp = &amp;kmachbsp;</span><br><span class="line">  <span class="comment">// kmachbsp位结构体变量,类型位machbstart_t,与二级引导器所使用的一样</span></span><br><span class="line">  <span class="type">machbstart_t</span> *smbsp = MBSPADR;<span class="comment">//物理地址1MB处</span></span><br><span class="line">  machbstart_t_init(kmbsp);</span><br><span class="line">  <span class="comment">//复制,要把地址转换成虚拟地址</span></span><br><span class="line">  memcopy((<span class="type">void</span> *)phyadr_to_viradr((<span class="type">adr_t</span>)smbsp), (<span class="type">void</span> *)kmbsp, <span class="keyword">sizeof</span>(mach</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//平台初始化函数</span></span><br><span class="line"><span class="type">void</span> init_halplaltform()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//复制机器信息结构</span></span><br><span class="line">  init_machbstart();</span><br><span class="line">  <span class="comment">//初始化图形显示驱动</span></span><br><span class="line">  init_bdvideo();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hal层的全局变量</span></span><br><span class="line"><span class="comment">// Cosmos/hal/x86/halglobal.c</span></span><br><span class="line"><span class="comment">//全局变量定义变量放在data段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_DEFGLOB_VARIABLE(vartype,varname) \</span></span><br><span class="line"><span class="meta">EXTERN __attribute__((section(<span class="string">&quot;.data&quot;</span>))) vartype varname</span></span><br><span class="line">HAL_DEFGLOB_VARIABLE(<span class="type">machbstart_t</span>,kmachbsp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cosmos/hal/x86/bdvideo.c</span></span><br><span class="line"><span class="comment">// 添加init_bdvideo函数</span></span><br><span class="line"><span class="type">void</span> init_bdvideo()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">dftgraph_t</span> *kghp = &amp;kdftgh;</span><br><span class="line">  <span class="comment">//初始化图形数据结构,里面放有图形模式,分辨率,图形驱动函数指针</span></span><br><span class="line">  init_dftgraph();</span><br><span class="line">  <span class="comment">//初始bga图形显卡的函数指针</span></span><br><span class="line">  init_bga();</span><br><span class="line">  <span class="comment">//初始vbe图形显卡的函数指针</span></span><br><span class="line">  init_vbe();</span><br><span class="line">  <span class="comment">//清空屏幕 为黑色</span></span><br><span class="line">  fill_graph(kghp, BGRA(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="comment">//显示背景图片</span></span><br><span class="line">  set_charsdxwflush(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  hal_background();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init_defgraph函数初始化了dftgraph_t结构体类型变量kdftgh</span></span><br><span class="line"><span class="comment">// 在halglobal.c文件中定义该变量,结构类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> s_DFTGRAPH</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u64_t</span> gh_mode; <span class="comment">//图形模式</span></span><br><span class="line">  <span class="type">u64_t</span> gh_x; <span class="comment">//水平像素点</span></span><br><span class="line">  <span class="type">u64_t</span> gh_y; <span class="comment">//垂直像素点</span></span><br><span class="line">  <span class="type">u64_t</span> gh_framphyadr; <span class="comment">//显存物理地址</span></span><br><span class="line">  <span class="type">u64_t</span> gh_fvrmphyadr; <span class="comment">//显存虚拟地址</span></span><br><span class="line">  <span class="type">u64_t</span> gh_fvrmsz; <span class="comment">//显存大小</span></span><br><span class="line">  <span class="type">u64_t</span> gh_onepixbits; <span class="comment">//一个像素字占用的数据位数</span></span><br><span class="line">  <span class="type">u64_t</span> gh_onepixbyte;</span><br><span class="line">  <span class="type">u64_t</span> gh_vbemodenr; <span class="comment">//vbe模式号</span></span><br><span class="line">  <span class="type">u64_t</span> gh_bank; <span class="comment">//显存的bank数</span></span><br><span class="line">  <span class="type">u64_t</span> gh_curdipbnk; <span class="comment">//当前bank</span></span><br><span class="line">  <span class="type">u64_t</span> gh_nextbnk; <span class="comment">//下一个bank</span></span><br><span class="line">  <span class="type">u64_t</span> gh_banksz; <span class="comment">//bank大小</span></span><br><span class="line">  <span class="type">u64_t</span> gh_fontadr; <span class="comment">//字库地址</span></span><br><span class="line">  <span class="type">u64_t</span> gh_fontsz; <span class="comment">//字库大小</span></span><br><span class="line">  <span class="type">u64_t</span> gh_fnthight; <span class="comment">//字体高度</span></span><br><span class="line">  <span class="type">u64_t</span> gh_nxtcharsx; <span class="comment">//下一字符显示的x坐标</span></span><br><span class="line">  <span class="type">u64_t</span> gh_nxtcharsy; <span class="comment">//下一字符显示的y坐标</span></span><br><span class="line">  <span class="type">u64_t</span> gh_linesz; <span class="comment">//字符行高</span></span><br><span class="line">  <span class="type">pixl_t</span> gh_deffontpx; <span class="comment">//默认字体大小</span></span><br><span class="line">  <span class="type">u64_t</span> gh_chardxw;</span><br><span class="line">  <span class="type">u64_t</span> gh_flush;</span><br><span class="line">  <span class="type">u64_t</span> gh_framnr;</span><br><span class="line">  <span class="type">u64_t</span> gh_fshdata; <span class="comment">//刷新相关的</span></span><br><span class="line">  <span class="type">dftghops_t</span> gh_opfun; <span class="comment">//图形驱动操作函数指针结构体</span></span><br><span class="line">&#125;<span class="type">dftgraph_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> s_DFTGHOPS</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//读写显存数据</span></span><br><span class="line">  <span class="type">size_t</span> (*dgo_read)(<span class="type">void</span>* ghpdev,<span class="type">void</span>* outp,<span class="type">size_t</span> rdsz);</span><br><span class="line">  <span class="type">size_t</span> (*dgo_write)(<span class="type">void</span>* ghpdev,<span class="type">void</span>* inp,<span class="type">size_t</span> wesz);</span><br><span class="line">  <span class="type">sint_t</span> (*dgo_ioctrl)(<span class="type">void</span>* ghpdev,<span class="type">void</span>* outp,<span class="type">uint_t</span> iocode);</span><br><span class="line">  <span class="comment">//刷新</span></span><br><span class="line">  <span class="type">void</span> (*dgo_flush)(<span class="type">void</span>* ghpdev);</span><br><span class="line">  <span class="type">sint_t</span> (*dgo_set_bank)(<span class="type">void</span>* ghpdev, <span class="type">sint_t</span> bnr);</span><br><span class="line">  <span class="comment">//读写像素</span></span><br><span class="line">  <span class="type">pixl_t</span> (*dgo_readpix)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span> x,<span class="type">uint_t</span> y);</span><br><span class="line">  <span class="type">void</span> (*dgo_writepix)(<span class="type">void</span>* ghpdev,<span class="type">pixl_t</span> pix,<span class="type">uint_t</span> x,<span class="type">uint_t</span> y);</span><br><span class="line">  <span class="comment">//直接读写像素</span></span><br><span class="line">  <span class="type">pixl_t</span> (*dgo_dxreadpix)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span> x,<span class="type">uint_t</span> y);</span><br><span class="line">  <span class="type">void</span> (*dgo_dxwritepix)(<span class="type">void</span>* ghpdev,<span class="type">pixl_t</span> pix,<span class="type">uint_t</span> x,<span class="type">uint_t</span> y);</span><br><span class="line">  <span class="comment">//设置x,y坐标和偏移</span></span><br><span class="line">  <span class="type">sint_t</span> (*dgo_set_xy)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span> x,<span class="type">uint_t</span> y);</span><br><span class="line">  <span class="type">sint_t</span> (*dgo_set_vwh)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span> vwt,<span class="type">uint_t</span> vhi);</span><br><span class="line">  <span class="type">sint_t</span> (*dgo_set_xyoffset)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span> xoff,<span class="type">uint_t</span> yoff);</span><br><span class="line">  <span class="comment">//获取x,y坐标和偏移</span></span><br><span class="line">  <span class="type">sint_t</span> (*dgo_get_xy)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span>* rx,<span class="type">uint_t</span>* ry);</span><br><span class="line">  <span class="type">sint_t</span> (*dgo_get_vwh)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span>* rvwt,<span class="type">uint_t</span>* rvhi);</span><br><span class="line">  <span class="type">sint_t</span> (*dgo_get_xyoffset)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span>* rxoff,<span class="type">uint_t</span>* ryoff);</span><br><span class="line">&#125;<span class="type">dftghops_t</span>;</span><br><span class="line"><span class="comment">//刷新显存</span></span><br><span class="line"><span class="type">void</span> flush_videoram(<span class="type">dftgraph_t</span> *kghp)</span><br><span class="line">&#123;</span><br><span class="line">  kghp-&gt;gh_opfun.dgo_flush(kghp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把实际的图形驱动函数的地址填入该结构体中</span></span><br><span class="line"><span class="comment">// 然后通过这个结构体,可调用相应的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数调用起来</span></span><br><span class="line"><span class="comment">// halinit.c</span></span><br><span class="line"><span class="type">void</span> init_hal()&#123;</span><br><span class="line">  init_halplaltform();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hal_start.c</span></span><br><span class="line"><span class="type">void</span> hal_start()</span><br><span class="line">&#123;</span><br><span class="line">  init_hal();<span class="comment">//初始化hal层,其中会调用初始化平台函数,在那里会调用初始化图形驱动</span></span><br><span class="line">  <span class="keyword">for</span>(;;);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化内存</strong>
<ul>
<li>在Cosmos/hal/x86下建立halmm.c文件,用于初始化内存,位后面的内存管理器作准备</li>
<li>hal层的初始化只要向内存管理器提供内存空间布局信息即可
<ul>
<li>Cosmos的内存管理器需要保存更多信息,最好是<strong>顺序的内存布局信息</strong>,可以增加额外的功能属性,同时降低代码的复杂度</li>
<li><strong>以BIOS提供的结构为基础,设计新的数据结构</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的数据结构保存信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_T_OSAPUSERRAM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_T_RESERVRAM 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_T_HWUSERRAM 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_T_ARACONRAM 0xf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_T_BUGRAM 0xff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_F_X86_32 (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_F_X86_64 (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_F_ARM_32 (1&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_F_ARM_64 (1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_F_HAL_MASK 0xff</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_PHYMMARGE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> pmr_lock;<span class="comment">//保护这个结构是自旋锁</span></span><br><span class="line">  <span class="type">u32_t</span> pmr_type; <span class="comment">//内存地址空间类型</span></span><br><span class="line">  <span class="type">u32_t</span> pmr_stype;</span><br><span class="line">  <span class="type">u32_t</span> pmr_dtype; <span class="comment">//内存地址空间的子类型,见上面的宏</span></span><br><span class="line">  <span class="type">u32_t</span> pmr_flgs; <span class="comment">//结构的标志与状态</span></span><br><span class="line">  <span class="type">u32_t</span> pmr_stus;</span><br><span class="line">  <span class="type">u64_t</span> pmr_saddr; <span class="comment">//内存空间的开始地址</span></span><br><span class="line">  <span class="type">u64_t</span> pmr_lsize; <span class="comment">//内存空间的大小</span></span><br><span class="line">  <span class="type">u64_t</span> pmr_end; <span class="comment">//内存空间的结束地址</span></span><br><span class="line">  <span class="type">u64_t</span> pmr_rrvmsaddr;<span class="comment">//内存保留空间的开始地址</span></span><br><span class="line">  <span class="type">u64_t</span> pmr_rrvmend; <span class="comment">//内存保留空间的结束地址</span></span><br><span class="line">  <span class="type">void</span>* pmr_prip; <span class="comment">//结构的私有数据指针,以后扩展所用</span></span><br><span class="line">  <span class="type">void</span>* pmr_extp; <span class="comment">//结构的扩展数据指针,以后扩展所用</span></span><br><span class="line">&#125;<span class="type">phymmarge_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作内存</span></span><br><span class="line"><span class="type">u64_t</span> <span class="title function_">initpmrge_core</span><span class="params">(<span class="type">e820map_t</span> *e8sp, <span class="type">u64_t</span> e8nr, <span class="type">phymmarge_t</span> *pmargesp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">u64_t</span> retnr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">u64_t</span> i = <span class="number">0</span>; i &lt; e8nr; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//根据一个e820map_t结构建立一个phymmarge_t结构</span></span><br><span class="line">    <span class="keyword">if</span> (init_one_pmrge(&amp;e8sp[i], &amp;pmargesp[i]) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> retnr;</span><br><span class="line">    &#125;</span><br><span class="line">      retnr++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> retnr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_phymmarge</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">machbstart_t</span> *mbsp = &amp;kmachbsp;</span><br><span class="line">  <span class="type">phymmarge_t</span> *pmarge_adr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">u64_t</span> pmrgesz = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//根据machbstart_t机器信息结构计算获得phymmarge_t结构的开始地址和大小</span></span><br><span class="line">  ret_phymmarge_adrandsz(mbsp, &amp;pmarge_adr, &amp;pmrgesz);</span><br><span class="line">  <span class="type">u64_t</span> tmppmrphyadr = mbsp-&gt;mb_nextwtpadr;</span><br><span class="line">  <span class="type">e820map_t</span> *e8p = (<span class="type">e820map_t</span> *)((<span class="type">adr_t</span>)(mbsp-&gt;mb_e820padr));</span><br><span class="line">  <span class="comment">//建立phymmarge_t结构</span></span><br><span class="line">  <span class="type">u64_t</span> ipmgnr = initpmrge_core(e8p, mbsp-&gt;mb_e820nr, pmarge_adr);</span><br><span class="line">  <span class="comment">//把phymmarge_t结构的地址大小个数保存machbstart_t机器信息结构中</span></span><br><span class="line">  mbsp-&gt;mb_e820expadr = tmppmrphyadr;</span><br><span class="line">  mbsp-&gt;mb_e820exnr = ipmgnr;</span><br><span class="line">  mbsp-&gt;mb_e820exsz = ipmgnr * <span class="keyword">sizeof</span>(<span class="type">phymmarge_t</span>);</span><br><span class="line">  mbsp-&gt;mb_nextwtpadr = PAGE_ALIGN(mbsp-&gt;mb_e820expadr + mbsp-&gt;mb_e820exsz);</span><br><span class="line">  <span class="comment">//phymmarge_t结构中地址空间从低到高进行排序,我已经帮你写好了</span></span><br><span class="line">  phymmarge_sort(pmarge_adr, ipmgnr);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据e820map_t结构数组建立phymmarge_t结构数组</span></span><br><span class="line"><span class="comment">// init_one_pmrge将e820map_t结构中的信息复制到phymmarge_t结构中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总管函数init_halmm,被init_hal函数调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_halmm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  init_phymmarge();</span><br><span class="line">  <span class="comment">//init_memmgr();      //调用该函数为内存管理器初始化函数</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化中断</strong>
<ul>
<li>中断被分为两类
<ul>
<li>异常,同步的(若不修改程序中的错误,下次运行程序同样会发生异常)</li>
<li>中断,异步的(外部事件而产生的)
<ul>
<li>由于不确定何种设备何时发出中断信号,所以是异步的</li>
<li>X86CPU上支持256个中断,需要准备256个中断门描述符和256个中断处理程序的入口</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>中断表为gate_t的数组,由CPU的IDTR寄存器指向,IDTMAX为256</li>
<li>将数据填入中断门描述符中,有了中断门之后,需要中断处理程序
<ul>
<li>保护CPU寄存器,即中断发生时的程序运行的上下文</li>
<li>调用中断处理程序(可以是修复异常的,可以是设备驱动程序中对设备响应的程序)</li>
<li>恢复CPU寄存器(恢复中断时程序运行的上下文使程序继续运行)</li>
</ul>
</li>
<li><strong>中断处理程序需要用汇编代码编写</strong>,以kernel.asm命名</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_GATE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">u16_t</span> offset_low; <span class="comment">/* 偏移 */</span></span><br><span class="line"><span class="type">u16_t</span> selector; <span class="comment">/* 段选择子 */</span></span><br><span class="line"><span class="type">u8_t</span> dcount; <span class="comment">/* 该字段只在调用门描述符中有效.如果在利用调用门调用子</span></span><br><span class="line"><span class="comment">u8_t attr; /* P(1) DPL(2) DT(1) TYPE(4) */</span></span><br><span class="line"><span class="type">u16_t</span> offset_high; <span class="comment">/* 偏移的高位段 */</span></span><br><span class="line"><span class="type">u32_t</span> offset_high_h;</span><br><span class="line"><span class="type">u32_t</span> offset_resv;</span><br><span class="line">&#125;__attribute__((packed)) <span class="type">gate_t</span>;</span><br><span class="line"><span class="comment">//定义中断表</span></span><br><span class="line">HAL_DEFGLOB_VARIABLE(<span class="type">gate_t</span>,x64_idt)[IDTMAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置gate_t结构数组中的数据</span></span><br><span class="line"><span class="comment">// halsgdidt.c</span></span><br><span class="line"><span class="comment">// 将数据填入中断门描述符中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_idt_desc</span><span class="params">(<span class="type">u8_t</span> <span class="built_in">vector</span>, <span class="type">u8_t</span> desc_type, <span class="type">inthandler_t</span> handler, <span class="type">u8_t</span> priv</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//vector 向量也是中断号</span></span></span><br><span class="line"><span class="params">  <span class="comment">//desc_type 中断门类型,中断门,陷阱门</span></span></span><br><span class="line"><span class="params">  <span class="comment">//handler 中断处理程序的入口地址</span></span></span><br><span class="line"><span class="params">  <span class="comment">//privilege 中断门的权限级别</span></span></span><br><span class="line"><span class="params">  <span class="type">gate_t</span> *p_gate = &amp;x64_idt[<span class="built_in">vector</span>];</span></span><br><span class="line"><span class="params">  <span class="type">u64_t</span> base = (<span class="type">u64_t</span>)handler;</span></span><br><span class="line"><span class="params">  p_gate-&gt;offset_low = base &amp; <span class="number">0xFFFF</span>;</span></span><br><span class="line"><span class="params">  p_gate-&gt;selector = SELECTOR_KERNEL_CS;</span></span><br><span class="line"><span class="params">  p_gate-&gt;dcount = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  p_gate-&gt;attr = (<span class="type">u8_t</span>)(desc_type | (privilege &lt;&lt; <span class="number">5</span>));</span></span><br><span class="line"><span class="params">  p_gate-&gt;offset_high = (<span class="type">u16_t</span>)((base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>);</span></span><br><span class="line"><span class="params">  p_gate-&gt;offset_high_h = (<span class="type">u32_t</span>)((base &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffffffff</span>);</span></span><br><span class="line"><span class="params">  p_gate-&gt;offset_resv = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 中断处理程序</span></span></span><br><span class="line"><span class="params"><span class="comment">// kernel.asm</span></span></span><br><span class="line"><span class="params"><span class="comment">// 保存中断后的寄存器</span></span></span><br><span class="line"><span class="params">%macro SAVEALL <span class="number">0</span></span></span><br><span class="line"><span class="params">  push rax</span></span><br><span class="line"><span class="params">  push rbx</span></span><br><span class="line"><span class="params">  push rcx</span></span><br><span class="line"><span class="params">  push rdx</span></span><br><span class="line"><span class="params">  push rbp</span></span><br><span class="line"><span class="params">  push rsi</span></span><br><span class="line"><span class="params">  push rdi</span></span><br><span class="line"><span class="params">  push r8</span></span><br><span class="line"><span class="params">  push r9</span></span><br><span class="line"><span class="params">  push r10</span></span><br><span class="line"><span class="params">  push r11</span></span><br><span class="line"><span class="params">  push r12</span></span><br><span class="line"><span class="params">  push r13</span></span><br><span class="line"><span class="params">  push r14</span></span><br><span class="line"><span class="params">  push r15</span></span><br><span class="line"><span class="params">  xor r14,r14</span></span><br><span class="line"><span class="params">  mov r14w,ds</span></span><br><span class="line"><span class="params">  push r14</span></span><br><span class="line"><span class="params">  mov r14w,es</span></span><br><span class="line"><span class="params">  push r14</span></span><br><span class="line"><span class="params">  mov r14w,fs</span></span><br><span class="line"><span class="params">  push r14</span></span><br><span class="line"><span class="params">  mov r14w,gs</span></span><br><span class="line"><span class="params">  push r14</span></span><br><span class="line"><span class="params">%endmacro</span></span><br><span class="line"><span class="params"><span class="comment">//恢复中断后寄存器</span></span></span><br><span class="line"><span class="params">%macro RESTOREALL <span class="number">0</span></span></span><br><span class="line"><span class="params">  pop r14</span></span><br><span class="line"><span class="params">  mov gs,r14w</span></span><br><span class="line"><span class="params">  pop r14</span></span><br><span class="line"><span class="params">  mov fs,r14w</span></span><br><span class="line"><span class="params">  pop r14</span></span><br><span class="line"><span class="params">  mov es,r14w</span></span><br><span class="line"><span class="params">  pop r14</span></span><br><span class="line"><span class="params">  mov ds,r14w</span></span><br><span class="line"><span class="params">  pop r15</span></span><br><span class="line"><span class="params">  pop r14</span></span><br><span class="line"><span class="params">  pop r13</span></span><br><span class="line"><span class="params">  pop r12</span></span><br><span class="line"><span class="params">  pop r11</span></span><br><span class="line"><span class="params">  pop r10</span></span><br><span class="line"><span class="params">  pop r9</span></span><br><span class="line"><span class="params">  pop r8</span></span><br><span class="line"><span class="params">  pop rdi</span></span><br><span class="line"><span class="params">  pop rsi</span></span><br><span class="line"><span class="params">  pop rbp</span></span><br><span class="line"><span class="params">  pop rdx</span></span><br><span class="line"><span class="params">  pop rcx</span></span><br><span class="line"><span class="params">  pop rbx</span></span><br><span class="line"><span class="params">  pop rax</span></span><br><span class="line"><span class="params">  iretq</span></span><br><span class="line"><span class="params">%endmacro</span></span><br><span class="line"><span class="params"><span class="comment">//保存异常下的寄存器</span></span></span><br><span class="line"><span class="params">%macro SAVEALLFAULT <span class="number">0</span></span></span><br><span class="line"><span class="params">  push rax</span></span><br><span class="line"><span class="params">  push rbx</span></span><br><span class="line"><span class="params">  push rcx</span></span><br><span class="line"><span class="params">  push rdx</span></span><br><span class="line"><span class="params">  push rbp</span></span><br><span class="line"><span class="params">  push rsi</span></span><br><span class="line"><span class="params">  push rdi</span></span><br><span class="line"><span class="params">  push r8</span></span><br><span class="line"><span class="params">  push r9</span></span><br><span class="line"><span class="params">  push r10</span></span><br><span class="line"><span class="params">  push r11</span></span><br><span class="line"><span class="params">  push r12</span></span><br><span class="line"><span class="params">  push r13</span></span><br><span class="line"><span class="params">  push r14</span></span><br><span class="line"><span class="params">  push r15</span></span><br><span class="line"><span class="params">  xor r14,r14</span></span><br><span class="line"><span class="params">  mov r14w,ds</span></span><br><span class="line"><span class="params">  push r14</span></span><br><span class="line"><span class="params">  mov r14w,es</span></span><br><span class="line"><span class="params">  push r14</span></span><br><span class="line"><span class="params">  mov r14w,fs</span></span><br><span class="line"><span class="params">  push r14</span></span><br><span class="line"><span class="params">  mov r14w,gs</span></span><br><span class="line"><span class="params">  push r14</span></span><br><span class="line"><span class="params">%endmacro</span></span><br><span class="line"><span class="params"><span class="comment">//恢复异常下寄存器</span></span></span><br><span class="line"><span class="params">%macro RESTOREALLFAULT <span class="number">0</span></span></span><br><span class="line"><span class="params">  pop r14</span></span><br><span class="line"><span class="params">  mov gs,r14w</span></span><br><span class="line"><span class="params">  pop r14</span></span><br><span class="line"><span class="params">  mov fs,r14w</span></span><br><span class="line"><span class="params">  pop r14</span></span><br><span class="line"><span class="params">  mov es,r14w</span></span><br><span class="line"><span class="params">  pop r14</span></span><br><span class="line"><span class="params">  mov ds,r14w</span></span><br><span class="line"><span class="params">  pop r15</span></span><br><span class="line"><span class="params">  pop r14</span></span><br><span class="line"><span class="params">  pop r13</span></span><br><span class="line"><span class="params">  pop r12</span></span><br><span class="line"><span class="params">  pop r11</span></span><br><span class="line"><span class="params">  pop r10</span></span><br><span class="line"><span class="params">  pop r9</span></span><br><span class="line"><span class="params">  pop r8</span></span><br><span class="line"><span class="params">  pop rdi</span></span><br><span class="line"><span class="params">  pop rsi</span></span><br><span class="line"><span class="params">  pop rbp</span></span><br><span class="line"><span class="params">  pop rdx</span></span><br><span class="line"><span class="params">  pop rcx</span></span><br><span class="line"><span class="params">  pop rbx</span></span><br><span class="line"><span class="params">  pop rax</span></span><br><span class="line"><span class="params">  add rsp,<span class="number">8</span></span></span><br><span class="line"><span class="params">  iretq</span></span><br><span class="line"><span class="params">%endmacro</span></span><br><span class="line"><span class="params"><span class="comment">//没有错误码CPU异常</span></span></span><br><span class="line"><span class="params">%macro SRFTFAULT <span class="number">1</span></span></span><br><span class="line"><span class="params">  push _NOERRO_CODE</span></span><br><span class="line"><span class="params">  SAVEALLFAULT</span></span><br><span class="line"><span class="params">  mov r14w,<span class="number">0x10</span></span></span><br><span class="line"><span class="params">  mov ds,r14w</span></span><br><span class="line"><span class="params">  mov es,r14w</span></span><br><span class="line"><span class="params">  mov fs,r14w</span></span><br><span class="line"><span class="params">  mov gs,r14w</span></span><br><span class="line"><span class="params">  mov rdi,%<span class="number">1</span> ;rdi, rsi</span></span><br><span class="line"><span class="params">  mov rsi,rsp</span></span><br><span class="line"><span class="params">  call hal_fault_allocator</span></span><br><span class="line"><span class="params">  RESTOREALLFAULT</span></span><br><span class="line"><span class="params">%endmacro</span></span><br><span class="line"><span class="params"><span class="comment">//CPU异常</span></span></span><br><span class="line"><span class="params">%macro SRFTFAULT_ECODE <span class="number">1</span></span></span><br><span class="line"><span class="params">  SAVEALLFAULT</span></span><br><span class="line"><span class="params">  mov r14w,<span class="number">0x10</span></span></span><br><span class="line"><span class="params">  mov ds,r14w</span></span><br><span class="line"><span class="params">  mov es,r14w</span></span><br><span class="line"><span class="params">  mov fs,r14w</span></span><br><span class="line"><span class="params">  mov gs,r14w</span></span><br><span class="line"><span class="params">  mov rdi,%<span class="number">1</span></span></span><br><span class="line"><span class="params">  mov rsi,rsp</span></span><br><span class="line"><span class="params">  call hal_fault_allocator</span></span><br><span class="line"><span class="params">  RESTOREALLFAULT</span></span><br><span class="line"><span class="params">%endmacro</span></span><br><span class="line"><span class="params"><span class="comment">//硬件中断</span></span></span><br><span class="line"><span class="params">%macro HARWINT <span class="number">1</span></span></span><br><span class="line"><span class="params">  SAVEALL</span></span><br><span class="line"><span class="params">  mov r14w,<span class="number">0x10</span></span></span><br><span class="line"><span class="params">  mov ds,r14w</span></span><br><span class="line"><span class="params">  mov es,r14w</span></span><br><span class="line"><span class="params">  mov fs,r14w</span></span><br><span class="line"><span class="params">  mov gs,r14w</span></span><br><span class="line"><span class="params">  mov rdi, %<span class="number">1</span></span></span><br><span class="line"><span class="params">  mov rsi,rsp</span></span><br><span class="line"><span class="params">  call hal_intpt_allocator</span></span><br><span class="line"><span class="params">  RESTOREALL</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// kernel.asm中,中断异常的处理程序入口点函数</span></span></span><br><span class="line"><span class="params"><span class="comment">//除法错误异常 比如除0</span></span></span><br><span class="line"><span class="params">exc_divide_error:</span></span><br><span class="line"><span class="params">SRFTFAULT <span class="number">0</span></span></span><br><span class="line"><span class="params"><span class="comment">//单步执行异常</span></span></span><br><span class="line"><span class="params">exc_single_step_exception:</span></span><br><span class="line"><span class="params">SRFTFAULT <span class="number">1</span></span></span><br><span class="line"><span class="params">exc_nmi:</span></span><br><span class="line"><span class="params">SRFTFAULT <span class="number">2</span></span></span><br><span class="line"><span class="params"><span class="comment">//调试断点异常</span></span></span><br><span class="line"><span class="params">exc_breakpoint_exception:</span></span><br><span class="line"><span class="params">SRFTFAULT <span class="number">3</span></span></span><br><span class="line"><span class="params"><span class="comment">//溢出异常</span></span></span><br><span class="line"><span class="params">exc_overflow:</span></span><br><span class="line"><span class="params">SRFTFAULT <span class="number">4</span></span></span><br><span class="line"><span class="params"><span class="comment">//段不存在异常</span></span></span><br><span class="line"><span class="params">exc_segment_not_present:</span></span><br><span class="line"><span class="params">SRFTFAULT_ECODE <span class="number">11</span></span></span><br><span class="line"><span class="params"><span class="comment">//栈异常</span></span></span><br><span class="line"><span class="params">exc_stack_exception:</span></span><br><span class="line"><span class="params">SRFTFAULT_ECODE <span class="number">12</span></span></span><br><span class="line"><span class="params"><span class="comment">//通用异常</span></span></span><br><span class="line"><span class="params">exc_general_protection:</span></span><br><span class="line"><span class="params">SRFTFAULT_ECODE <span class="number">13</span></span></span><br><span class="line"><span class="params"><span class="comment">//缺页异常</span></span></span><br><span class="line"><span class="params">exc_page_fault:</span></span><br><span class="line"><span class="params">SRFTFAULT_ECODE <span class="number">14</span></span></span><br><span class="line"><span class="params">hxi_exc_general_intpfault:</span></span><br><span class="line"><span class="params">SRFTFAULT <span class="number">256</span></span></span><br><span class="line"><span class="params"><span class="comment">//硬件1～7号中断</span></span></span><br><span class="line"><span class="params">hxi_hwint00:</span></span><br><span class="line"><span class="params">HARWINT (INT_VECTOR_IRQ0+<span class="number">0</span>)</span></span><br><span class="line"><span class="params">hxi_hwint01:</span></span><br><span class="line"><span class="params">HARWINT (INT_VECTOR_IRQ0+<span class="number">1</span>)</span></span><br><span class="line"><span class="params">hxi_hwint02:</span></span><br><span class="line"><span class="params">HARWINT (INT_VECTOR_IRQ0+<span class="number">2</span>)</span></span><br><span class="line"><span class="params">hxi_hwint03:</span></span><br><span class="line"><span class="params">HARWINT (INT_VECTOR_IRQ0+<span class="number">3</span>)</span></span><br><span class="line"><span class="params">hxi_hwint04:</span></span><br><span class="line"><span class="params">HARWINT (INT_VECTOR_IRQ0+<span class="number">4</span>)</span></span><br><span class="line"><span class="params">hxi_hwint05:</span></span><br><span class="line"><span class="params">HARWINT (INT_VECTOR_IRQ0+<span class="number">5</span>)</span></span><br><span class="line"><span class="params">hxi_hwint06:</span></span><br><span class="line"><span class="params">HARWINT (INT_VECTOR_IRQ0+<span class="number">6</span>)</span></span><br><span class="line"><span class="params">hxi_hwint07:</span></span><br><span class="line"><span class="params">HARWINT (INT_VECTOR_IRQ0+<span class="number">7</span>)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 在halsgdidt.c文件写出函数设置中断门描述符</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> init_idt_descriptor()</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//一开始把所有中断的处理程序设置为保留的通用处理程序</span></span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (<span class="type">u16_t</span> intindx = <span class="number">0</span>; intindx &lt;= <span class="number">255</span>; intindx++)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    set_idt_desc((<span class="type">u8_t</span>)intindx, DA_386IGate, hxi_exc_general_intpfault, PRIVILEGE_KRNL);</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  set_idt_desc(INT_VECTOR_DIVIDE, DA_386IGate, exc_divide_error, PRIVILEGE_KRNL);</span></span><br><span class="line"><span class="params">  set_idt_desc(INT_VECTOR_DEBUG, DA_386IGate, exc_single_step_exception, PRIVILEGE_KRNL);</span></span><br><span class="line"><span class="params">  set_idt_desc(INT_VECTOR_NMI, DA_386IGate, exc_nmi, PRIVILEGE_KRNL);</span></span><br><span class="line"><span class="params">  set_idt_desc(INT_VECTOR_BREAKPOINT, DA_386IGate, exc_breakpoint_exception,PRIVILEGE_KRNL);</span></span><br><span class="line"><span class="params">  set_idt_desc(INT_VECTOR_OVERFLOW, DA_386IGate, exc_overflow, PRIVILEGE_USE);</span></span><br><span class="line"><span class="params">  <span class="comment">//篇幅所限,未全部展示</span></span></span><br><span class="line"><span class="params">  set_idt_desc(INT_VECTOR_PAGE_FAULT, DA_386IGate, exc_page_fault, PRIVILEGE);</span></span><br><span class="line"><span class="params">  set_idt_desc(INT_VECTOR_IRQ0 + <span class="number">0</span>, DA_386IGate, hxi_hwint00, PRIVILEGE_KRNL);</span></span><br><span class="line"><span class="params">  set_idt_desc(INT_VECTOR_IRQ0 + <span class="number">1</span>, DA_386IGate, hxi_hwint01, PRIVILEGE_KRNL);</span></span><br><span class="line"><span class="params">  set_idt_desc(INT_VECTOR_IRQ0 + <span class="number">2</span>, DA_386IGate, hxi_hwint02, PRIVILEGE_KRNL);</span></span><br><span class="line"><span class="params">  set_idt_desc(INT_VECTOR_IRQ0 + <span class="number">3</span>, DA_386IGate, hxi_hwint03, PRIVILEGE_KRNL);</span></span><br><span class="line"><span class="params">  <span class="comment">//篇幅所限,未全部展示</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">// 将所有中断的处理程序设置为保留的通用处理程序,避免未知中断异常发生了CPU无处可去</span></span></span><br><span class="line"><span class="params"><span class="comment">// 然后对已知的中断和异常进一步设置,覆盖之前的通用处理程序</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// halintput.c</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> init_halintupt()</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  init_idt_descriptor();</span></span><br><span class="line"><span class="params">  init_intfltdsc();</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>CPU体系层面的中断初始化完成</strong>
<ul>
<li>在init_halinput函数中还调用init_intfltdsc()函数
<ul>
<li>init_intfltdsc()函数处理中断</li>
</ul>
</li>
<li>中断异常描述为一个表,在C语言中使结构数组
<ul>
<li>结构中记录了中断优先级,中断号,中断计数等统计信息</li>
<li>中断可以由线程方式执行,也可以是一个回调函数,该函数的地址放在另一个结构体中
<ul>
<li>如果内核或者设备驱动程序要安装一个中断处理函数,就要先申请一个intserdsc_t结构体,然后把中断函数的地址写入其中,最后把这个结构挂载到对应的intfltdsc_t结构中的i_serfisrlst链表中</li>
</ul>
</li>
<li>**将中断处理函数放在结构中的原因:**中断控制器最多只能产生几十号中断号,而设备不止几十个,会有多个设备共享一根中断信号线,让设备驱动程序来决定是哪个设备产生的中断,使用结构上所有中断处理函数都依次执行,查看是不是自己的设备产生了中断,如果是就处理,否则略过</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-18-16-59-53.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-18-16-59-53.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="中断框架设计图" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断异常描述</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_INTFLTDSC</span>&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> i_lock;</span><br><span class="line">  <span class="type">u32_t</span> i_flg;</span><br><span class="line">  <span class="type">u32_t</span> i_stus;</span><br><span class="line">  <span class="type">uint_t</span> i_prity; <span class="comment">//中断优先级</span></span><br><span class="line">  <span class="type">uint_t</span> i_irqnr; <span class="comment">//中断号</span></span><br><span class="line">  <span class="type">uint_t</span> i_deep; <span class="comment">//中断嵌套深度</span></span><br><span class="line">  <span class="type">u64_t</span> i_indx; <span class="comment">//中断计数</span></span><br><span class="line">  <span class="type">list_h_t</span> i_serlist; <span class="comment">//也可以使用中断回调函数的方式</span></span><br><span class="line">  <span class="type">uint_t</span> i_sernr; <span class="comment">//中断回调函数个数</span></span><br><span class="line">  <span class="type">list_h_t</span> i_serthrdlst; <span class="comment">//中断线程链表头</span></span><br><span class="line">  <span class="type">uint_t</span> i_serthrdnr; <span class="comment">//中断线程个数</span></span><br><span class="line">  <span class="type">void</span>* i_onethread; <span class="comment">//只有一个中断线程时直接用指针</span></span><br><span class="line">  <span class="type">void</span>* i_rbtreeroot; <span class="comment">//如果中断线程太多则按优先级组成红黑树</span></span><br><span class="line">  <span class="type">list_h_t</span> i_serfisrlst;</span><br><span class="line">  <span class="type">uint_t</span> i_serfisrnr;</span><br><span class="line">  <span class="type">void</span>* i_msgmpool; <span class="comment">//可能的中断消息池</span></span><br><span class="line">  <span class="type">void</span>* i_privp;</span><br><span class="line">  <span class="type">void</span>* i_extp;</span><br><span class="line">&#125;<span class="type">intfltdsc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断回调函数的地址的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">drvstus_t</span> <span class="params">(*<span class="type">intflthandle_t</span>)</span><span class="params">(<span class="type">uint_t</span> ift_nr,<span class="type">void</span>* device,<span class="type">void</span>* sframe)</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_INTSERDSC</span>&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> s_list; <span class="comment">//在中断异常描述符中的链表</span></span><br><span class="line">  <span class="type">list_h_t</span> s_indevlst; <span class="comment">//在设备描述描述符中的链表</span></span><br><span class="line">  <span class="type">u32_t</span> s_flg;</span><br><span class="line">  <span class="type">intfltdsc_t</span>* s_intfltp; <span class="comment">//指向中断异常描述符</span></span><br><span class="line">  <span class="type">void</span>* s_device; <span class="comment">//指向设备描述符</span></span><br><span class="line">  <span class="type">uint_t</span> s_indx;</span><br><span class="line">  <span class="type">intflthandle_t</span> s_handle; <span class="comment">//中断处理的回调函数指针</span></span><br><span class="line">&#125;<span class="type">intserdsc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// halglobal.c文件中定义intfltdsc_t结构</span></span><br><span class="line"><span class="comment">//定义intfltdsc_t结构数组大小为256</span></span><br><span class="line">HAL_DEFGLOB_VARIABLE(<span class="type">intfltdsc_t</span>,machintflt)[IDTMAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现中断,异常分发器函数</span></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hal_do_hwint</span><span class="params">(<span class="type">uint_t</span> intnumb, <span class="type">void</span> *krnlsframp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">intfltdsc_t</span> *ifdscp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">cpuflg_t</span> cpuflg;</span><br><span class="line">  <span class="comment">//根据中断号获取中断异常描述符地址</span></span><br><span class="line">  ifdscp = hal_retn_intfltdsc(intnumb);</span><br><span class="line">  <span class="comment">//对断异常描述符加锁并中断</span></span><br><span class="line">  hal_spinlock_saveflg_cli(&amp;ifdscp-&gt;i_lock, &amp;cpuflg);</span><br><span class="line">  ifdscp-&gt;i_indx++;</span><br><span class="line">  ifdscp-&gt;i_deep++;</span><br><span class="line">  <span class="comment">//运行中断处理的回调函数</span></span><br><span class="line">  hal_run_intflthandle(intnumb, krnlsframp);</span><br><span class="line">  ifdscp-&gt;i_deep--;</span><br><span class="line">  <span class="comment">//解锁并恢复中断状态</span></span><br><span class="line">  hal_spinunlock_restflg_sti(&amp;ifdscp-&gt;i_lock, &amp;cpuflg);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异常分发器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hal_fault_allocator</span><span class="params">(<span class="type">uint_t</span> faultnumb, <span class="type">void</span> *krnlsframp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//异常处理回调函数也是放在中断异常描述符中的</span></span><br><span class="line">  hal_do_hwint(faultnumb, krnlsframp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中断分发器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hal_hwint_allocator</span><span class="params">(<span class="type">uint_t</span> intnumb, <span class="type">void</span> *krnlsframp)</span></span><br><span class="line">&#123;</span><br><span class="line">  hal_do_hwint(intnumb, krnlsframp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现hal_run_intflthandle函数,负责调用中断处理的回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hal_run_intflthandle</span><span class="params">(<span class="type">uint_t</span> ifdnr, <span class="type">void</span> *sframe)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">intserdsc_t</span> *isdscp;</span><br><span class="line">  <span class="type">list_h_t</span> *lst;</span><br><span class="line">  <span class="comment">//根据中断号获取中断异常描述符地址</span></span><br><span class="line">  <span class="type">intfltdsc_t</span> *ifdscp = hal_retn_intfltdsc(ifdnr);</span><br><span class="line">  <span class="comment">//遍历i_serlist链表</span></span><br><span class="line">  list_for_each(lst, &amp;ifdscp-&gt;i_serlist)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//获取i_serlist链表上对象即intserdsc_t结构</span></span><br><span class="line">    isdscp = list_entry(lst, <span class="type">intserdsc_t</span>, s_list);</span><br><span class="line">    <span class="comment">//调用中断处理回调函数</span></span><br><span class="line">    isdscp-&gt;s_handle(ifdnr, isdscp-&gt;s_device, sframe);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历intfltdsc_t结构中,i_serlis 链表上所有挂载的intserdsc_t结构,然后调用intserdsc_t结构中的中断处理的回调函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化中断控制器</strong>
<ul>
<li>CPU端的中断解决之后,设备端的中断交给设备驱动程序,但<mark>CPU和设备之间的中断控制器需要解决</mark></li>
<li><strong>中断控制器</strong>:多个设备的中断信号线都会连接到中断控制器上,中断控制器可以决定启用或屏蔽哪些设备的中断,决定设备中断之间的优先线
<ul>
<li>x86上的中断控制器最开始是8259A,然后是IOAPIC,最新的是MSI-X</li>
<li>8259A在任何x86平台上都可以使用,使用了两片8259A芯片,以级联的方式存在,拥有15个中断源</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-18-19-27-38.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-18-19-27-38.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="8259A在系统的框架图" /></p>
<ul>
<li>8259A在系统的框架
<ul>
<li>与CPU连接的是主8259A,下面的是8259A</li>
<li>每个8259A都有两个IO端口,可进行编程
<ul>
<li>主8259A的端口地址为0x20,0x21</li>
<li>从8259A的端口地址为0xA0,0xA1</li>
</ul>
</li>
<li>ICW用来实现8259A芯片的初始化</li>
<li>OCW用来向8259A发布命令,对其进行控制,在初始化后的任何时候被使用</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_i8259</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化主从8259a</span></span><br><span class="line">  out_u8_p(ZIOPT, ICW1);</span><br><span class="line">  out_u8_p(SIOPT, ICW1);</span><br><span class="line">  out_u8_p(ZIOPT1, ZICW2);</span><br><span class="line">  out_u8_p(SIOPT1, SICW2);</span><br><span class="line">  out_u8_p(ZIOPT1, ZICW3);</span><br><span class="line">  out_u8_p(SIOPT1, SICW3);</span><br><span class="line">  out_u8_p(ZIOPT1, ICW4);</span><br><span class="line">  out_u8_p(SIOPT1, ICW4);</span><br><span class="line">  <span class="comment">//屏蔽全部中断源</span></span><br><span class="line">  out_u8_p(ZIOPT1, <span class="number">0xff</span>);</span><br><span class="line">  out_u8_p(SIOPT1, <span class="number">0xff</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在init_halintupt函数的最后调用int_i8259函数
<ul>
<li>在初始化中断控制器后屏蔽所有的中断源,Cosmos在初始化阶段还不能处理中断</li>
<li>内存管理器的初始化之后介绍</li>
</ul>
</li>
<li><strong>进入内核层</strong>:编写内核初始化
<ul>
<li><mark>由于内核层从hal层进入,必须在hal_start()函数中调用</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内核初始化函数</span></span><br><span class="line"><span class="comment">// init_krl()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//禁止函数返回</span></span><br><span class="line">  die(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hal_start()函数中调用init_krl()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hal_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化Cosmos的hal层</span></span><br><span class="line">  init_hal();</span><br><span class="line">  <span class="comment">//初始化Cosmos的内核层</span></span><br><span class="line">  init_krl();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="55-linux初始化grub与vmlinuz的结构"><a class="markdownIt-Anchor" href="#55-linux初始化grub与vmlinuz的结构"></a> 5.5 Linux初始化:GRUB与vmlinuz的结构</h2>
<ul>
<li>Linux的启动的整体流程
<ul>
<li>Linux在GRUB是怎样启动及vmlinuz是如何产生和运转的</li>
<li>从setup.bin文件的_start函数入手,研究Linux初始化流程</li>
</ul>
</li>
<li><strong>全局流程</strong>
<ul>
<li>在机器加电后,BIOS会进行自检,然后由BIOS加载引导设备中引导扇区.在安装有Linux操作系统的情况下,在引导扇区里,通常是安装的GRUB的一小段程序(安装windows的情况不同).最后,GRUB会加载Linux的内核映像vmlinuz</li>
<li>引导设备通常是机器中的硬盘;BIOS会自动读取保存在CMOS中的引导设备信息</li>
</ul>
</li>
<li><strong>从BIOS到GRUB</strong>
<ul>
<li>CPU被设计成只能运行内存中的程序,没有办法直接运行储存在硬盘或U盘中的操作系统程序
<ul>
<li>想要运行硬盘或U盘中的程序,就必须先加载到内存(RAM)中运行</li>
</ul>
</li>
<li>BIOS启动,在设计CPU时硬性地规定在加点瞬间强制将CS寄存器的值设置为0xF000,IP寄存器的值设置为0xFFF0
<ul>
<li>CS:IP指向了0xFFF0物理地址,该物理地址连接了主板上的一小块ROM芯片(<strong>只读芯片</strong>),BIOS程序固化在该芯片中,此时BIOS程序开始启动</li>
</ul>
</li>
<li>BIOS一开始会初始化CPU,接着检查并初始化内存,然后将自己的一部分复制到内存,最后跳转到内存中运行,BIOS的下一步就是枚举本地设备进行初始化,并进行相关的检查,检查硬件是否损坏,这期间BIOS会调用其他设备上的固件程序</li>
<li>当设备初始化和检查步骤之后,<strong>BIOS会在内存中建立中断表和中断服务程序</strong>
<ul>
<li>建立中断表和中断服务程序:BIOS从内存地址开始用1KB的内存空间构建中断表,在紧接着中断表的位置,用256KB的内存空间构建BIOS数据区,并在0x0e05b的地址加载8KB大小的与中断表对应的中断服务程序</li>
<li>中断表中有256个条目,每个条目占用4个字节,其中两个字节时CS寄存器的值,两个字节时IP寄存器的值;每个条目都指向一个具体的中断服务程序</li>
</ul>
</li>
</ul>
</li>
<li>为了启动外部存储器中的程序,BIOS会搜索可引导设备
<ul>
<li>Linux通常是从硬盘中启动的.硬盘上的第1个扇区(每个扇区512字节空间),被称为MBR(主启动记录),其中包含有基本的GRUB启动程序和分区表,安装GRUB时会自动写入到这个扇区,当MBR被BIOS装载到0x7c00地址开始的内存空间中后,BIOS就会将控制权转交给了MBR(<strong>其实是交给了GRUB</strong>)</li>
</ul>
</li>
<li><strong>GRUB是如何启动的</strong>
<ul>
<li>BIOS只会加载硬盘上的第1个扇区,该扇区仅有512字节,其中有64字节的分区表加2字节的启动标志,剩余空间无法装得下GRUB通用引导器</li>
<li>GRUB的加载分成多个步骤,同时GRUB分成多个文件,其中两个重要的文件boot.img和core.img
<ul>
<li>boot.img被GRUB的安装程序写入到硬盘的MBR中,同时在boot.img文件中的一个位置写入core.img文件占用的第一个扇区的扇区号</li>
<li>core.img是由GRUB安装程序根据安装时环境信息,用其它GRUB的模块文件动态生成的
<ul>
<li>如果从硬盘启动core.img中的第一个扇区的内容就是diskboot.img文件</li>
<li>diskboot.img文件的作用是读取core.img中剩余的部分到内存中</li>
<li>由于此时diskboot.img文件不识别文件系统,所以将core.img文件的全部位置都用文件块列表的方式保存到diskboot.img文件中,确保diskboot.img文件找到core.img文件的剩余内容,最后将控制权交给kernel.img文件</li>
<li>因为此时core.img文件中嵌入了足够多的功能模块,所以可以保证GRUB识别出硬盘分区上文件系统,能够访问/boot/grub目录,并且可以加载相关的配置文件和功能模块,来实现相关的功能</li>
</ul>
</li>
</ul>
</li>
<li>GRUB2大量使用了动态加载功能模块,使得core.img文件的体积变得足够小,<mark>而GRUB的core.img文件一旦开始工作,就可以加载Linux系统的vmlinuz内核文件</mark></li>
</ul>
</li>
<li><strong>详解vmlinuz文件结构</strong>
<ul>
<li>在/boot目录下由vmlinuz文件,该文件是由Linux编译生成bzlmage文件复制而来的</li>
<li>一致把Linux源码解压到一个Linux目录中,切换代码目录执行make ARCH=x86_64,再执行make install,就会产生vmlinuz文件</li>
<li>生成 bzImage 文件需要三个依赖文件：setup.bin,vmlinux.bin,linux/arch/x86/boot/tools目录下的 build
<ul>
<li>setup.bin是由objcopy命令根据setup.elf生成的
<ul>
<li>setup.bin文件由/arch/x86/boot/目录下一系列对应的程序源代码文件编译链接产生,其中的<strong>head.S文件和main.c文件</strong>格外重要</li>
</ul>
</li>
<li>vmlinux.bin
<ul>
<li>vmlinux.bin文件依赖于linux/arch/x86/boot/compressed/目录下的vmlinux目标,是由 objcopy 工具通过vmlinux目标生成. vmlinux目标没有任何修饰前缀和依赖的目标,这说明它就是最顶层目录下的一个 vmlinux 文件</li>
<li>linux/arch/x86/boot/compressed目录下的vmlinux是由该目录下的head_32.o或者head_64.o、cpuflags.o,error.o,kernel.o,misc.o,string.o,cmdline.o,early_serial_console.o等文件以及 piggy.o链接而成的</li>
</ul>
</li>
<li>piggy.o是由piggy.S汇编代码生成而来,而piggy.S是编译Linux内核时由mkpiggy工作(HOST OS下的应用程序)动态创建的
<ul>
<li>piggy.S的第一个依赖文件vmlinux.bin.$(suffix-y)中的suffix-y,表示内核压缩方式对应的后缀</li>
<li>piggy.S 中还定义了解压vmlinux.bin.gz 时需要的各种信息,包括压缩内核映像的长度、解压后的长度等信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>vmlinux文件时如何创建的</strong>
<ul>
<li>vmlinux文件就是编译整个Linux内核源代码文件生成的,Linux的代码分布在各个代码目录下,这些目录之下又存在目录,Linux的kbuild(内核编译)系统,会递归进入到每个目录,由该目录下的Makefile决定要编译哪些文件</li>
<li>在编译完具体文件之后,就会在该目录下,把已经编译了的文件链接成一个该目录下的built-in.o文件,这个built-in.o文件也会与上层目录的built-in.o文件链接在一起</li>
<li>层层目录返回到顶层目录,所有的built-in.o文件会链接生成一个vmlinux文件,该文件会通过前面的方法转换成vmlinux.bin文件.但是注意vmlinux.bin文件依然是ELF格式的文件</li>
<li>最后,工具软件会压缩成vmlinux.bin.gz文件,以gzip方式压缩</li>
</ul>
</li>
<li>piggy.S的信息和vmlinux.bin.gz文件,它们一起生成了piggy.o文件,然后piggy.o文件和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>u</mi><mi>x</mi><mo>−</mo><mi>o</mi><mi>b</mi><mi>j</mi><mi>s</mi><mo>−</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(vmlinux-objs-y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>(efi-obj-y)中的目标文件一起链接生成,最终生成了linux/arch/x86/boot/compressed 目录下的vmlinux</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#linux/arch/x86/boot/Makefile</span></span><br><span class="line"><span class="section">install: sh <span class="variable">$(srctree)</span>/<span class="variable">$(src)</span>/install.sh <span class="variable">$(KERNELRELEASE)</span> <span class="variable">$(obj)</span>/bzImage \</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bzlmage文件再Makefile中的生成规则</span></span><br><span class="line"><span class="comment">#linux/arch/x86/boot/Makefile</span></span><br><span class="line"><span class="variable">$(obj)</span>/bzImage: <span class="variable">$(obj)</span>/setup.bin <span class="variable">$(obj)</span>/vmlinux.bin <span class="variable">$(obj)</span>/tools/build FORCE</span><br><span class="line"></span><br><span class="line"><span class="comment">#setup.bin是由objcopy命令根据setup.elf生成的</span></span><br><span class="line"><span class="comment">#这些目标文件正是由/arch/x86/boot/目录下对应的程序源代码文件编译产生</span></span><br><span class="line">setup-y += a20.o bioscall.o cmdline.o copy.o cpu.o cpuflags.o cpucheck.o</span><br><span class="line">setup-y += early_serial_console.o edd.o header.o main.o memory.o</span><br><span class="line">setup-y += pm.o pmjump.o printf.o regs.o string.o tty.o video.o</span><br><span class="line">setup-y += video-mode.o version.o</span><br><span class="line"><span class="comment">#……</span></span><br><span class="line">SETUP_OBJS = <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(setup-y)</span>)</span><br><span class="line"><span class="comment">#……</span></span><br><span class="line">LDFLAGS_setup.elf := -m elf_i386 -T<span class="variable">$(obj)</span>/setup.elf: <span class="variable">$(src)</span>/setup.ld <span class="variable">$(SETUP</span></span><br><span class="line"><span class="variable">#……</span></span><br><span class="line"><span class="variable">OBJCOPYFLAGS_setup.bin := -O binary<span class="variable">$(obj)</span>/setup.bin: <span class="variable">$(obj)</span>/setup.elf FORCE</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable"># vmlinux.bin</span></span><br><span class="line"><span class="variable">#linux/arch/x86/boot/Makefile</span></span><br><span class="line"><span class="variable">OBJCOPYFLAGS_vmlinux.bin := -O binary -R .note -R .comment -S<span class="variable">$(obj)</span>/vmlinux.bin</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable"># makefile文件</span></span><br><span class="line"><span class="variable">#linux/arch/x86/boot/compressed/Makefile</span></span><br><span class="line"><span class="variable">#……</span></span><br><span class="line"><span class="variable">#这些目标文件正是由/arch/x86/boot/compressed/目录下对应的程序源代码文件编译产生<span class="variable">$(BITS)</span>取</span></span><br><span class="line"><span class="variable">vmlinux-objs-y := <span class="variable">$(obj)</span>/vmlinux.lds <span class="variable">$(obj)</span>/kernel_info.o <span class="variable">$(obj)</span>/head_<span class="variable">$(BITS)</span>.</span></span><br><span class="line"><span class="variable">vmlinux-objs-<span class="variable">$(CONFIG_EARLY_PRINTK)</span> += <span class="variable">$(obj)</span>/early_serial_console.o</span></span><br><span class="line"><span class="variable">vmlinux-objs-<span class="variable">$(CONFIG_RANDOMIZE_BASE)</span> += <span class="variable">$(obj)</span>/kaslr.o</span></span><br><span class="line"><span class="variable">ifdef CONFIG_X86_64</span></span><br><span class="line"><span class="variable">vmlinux-objs-y += <span class="variable">$(obj)</span>/ident_map_64.o</span></span><br><span class="line"><span class="variable">vmlinux-objs-y += <span class="variable">$(obj)</span>/idt_64.o <span class="variable">$(obj)</span>/idt_handlers_64.o vmlinux-objs-y +</span></span><br><span class="line"><span class="variable">vmlinux-objs-y += <span class="variable">$(obj)</span>/pgtable_64.o</span></span><br><span class="line"><span class="variable">vmlinux-objs-<span class="variable">$(CONFIG_AMD_MEM_ENCRYPT)</span> += <span class="variable">$(obj)</span>/sev-es.o</span></span><br><span class="line"><span class="variable">endif</span></span><br><span class="line"><span class="variable">#……</span></span><br><span class="line"><span class="variable"><span class="variable">$(obj)</span>/vmlinux: $(vmlinux-objs-y)</span> $(efi-obj-y) FORCE</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> if_changed,ld)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#linux/arch/x86/boot/compressed/Makefile</span></span><br><span class="line"><span class="comment">#……</span></span><br><span class="line">vmlinux.bin.all-y := <span class="variable">$(obj)</span>/vmlinux.bin</span><br><span class="line">vmlinux.bin.all-<span class="variable">$(CONFIG_X86_NEED_RELOCS)</span> += <span class="variable">$(obj)</span>/vmlinux.relocs</span><br><span class="line"><span class="variable">$(obj)</span>/vmlinux.bin.gz: $(vmlinux.bin.all-y) FORCE</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> if_changed,gzip)</span></span><br><span class="line"><span class="variable">$(obj)</span>/vmlinux.bin.bz2: $(vmlinux.bin.all-y) FORCE</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> if_changed,bzip2)</span></span><br><span class="line"><span class="variable">$(obj)</span>/vmlinux.bin.lzma: $(vmlinux.bin.all-y) FORCE</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> if_changed,lzma)</span></span><br><span class="line"><span class="variable">$(obj)</span>/vmlinux.bin.xz: $(vmlinux.bin.all-y) FORCE</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> if_changed,xzkern)</span></span><br><span class="line"><span class="variable">$(obj)</span>/vmlinux.bin.lzo: $(vmlinux.bin.all-y) FORCE</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> if_changed,lzo)</span></span><br><span class="line"><span class="variable">$(obj)</span>/vmlinux.bin.lz4: $(vmlinux.bin.all-y) FORCE</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> if_changed,lz4)</span></span><br><span class="line"><span class="variable">$(obj)</span>/vmlinux.bin.zst: $(vmlinux.bin.all-y) FORCE</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> if_changed,zstd22)</span></span><br><span class="line">suffix-<span class="variable">$(CONFIG_KERNEL_GZIP)</span> := gz</span><br><span class="line">suffix-<span class="variable">$(CONFIG_KERNEL_BZIP2)</span> := bz2</span><br><span class="line">suffix-<span class="variable">$(CONFIG_KERNEL_LZMA)</span> := lzma</span><br><span class="line">suffix-<span class="variable">$(CONFIG_KERNEL_XZ)</span> := xz</span><br><span class="line">suffix-<span class="variable">$(CONFIG_KERNEL_LZO)</span> := lzo</span><br><span class="line">suffix-<span class="variable">$(CONFIG_KERNEL_LZ4)</span> := lz4</span><br><span class="line">suffix-<span class="variable">$(CONFIG_KERNEL_ZSTD)</span> := zst</span><br><span class="line"></span><br><span class="line"><span class="comment">#linux/arch/x86/boot/compressed/Makefile</span></span><br><span class="line"><span class="comment">#……</span></span><br><span class="line">OBJCOPYFLAGS_vmlinux.bin := -R .comment -S</span><br><span class="line"><span class="variable">$(obj)</span>/vmlinux.bin: vmlinux FORCE</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> if_changed,objcopy)</span></span><br><span class="line"><span class="comment"># arch/x86/boot/compressed目录下的vmlinux.bin,它是由objcopy工具通过vmlinux目标生成</span></span><br><span class="line"><span class="comment"># 而vmlinux目标没有任何修饰前缀和依赖的目标,这说明它就是最顶层目录下的一个vmlinux文件</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="56-linux初始化从_start到第一个进程"><a class="markdownIt-Anchor" href="#56-linux初始化从_start到第一个进程"></a> 5.6 Linux初始化:从_start到第一个进程</h2>
<ul>
<li>如何解压内核,Linux内核第一个C函数,然后建立Linux的第一个用户进程</li>
<li><strong>解压后内核初始化</strong>
<ul>
<li>从setup.bin文件的入口_start开始,了解启动信息结构,然后由16位main函数切换CPU到保护模式,然后跳入vmlinux.bin文件中的startup_32函数重新加载段描述符</li>
<li>64位系统,进入startup_64函数,切换到CPU长模式,最后调用extract_kernel函数解压linux内核,并进入内核的startup_64函数,Linux内核开始运行</li>
</ul>
</li>
<li><strong>为何从_start开始</strong>
<ul>
<li>vmlinux.bin是由linux/arch/x86/boot/compressed目录下的一些目标文件,以及piggy.S包含的一个vmlinux.bin.gz的压缩文件一起生成的
<ul>
<li>vmlinux.bin.gz是由编译的Linux内核所生成的elf格式的vmlinux文件,去掉了文件的符号信息和重定位信息后,压缩得到的</li>
<li>CPU无法识别压缩文件中的指令直接运行的,必须先进行解压后,然后解析elf格式的vmlinux吻技安,去掉了文件的符号信息和重定位信息后,压缩得到的</li>
<li>_start是setup.bin文件的入口,在head.S文件中定义</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#linux/arch/x86/boot/head.S</span></span><br><span class="line">.code16</span><br><span class="line">.section <span class="string">&quot;.bstext&quot;</span>, <span class="string">&quot;ax&quot;</span></span><br><span class="line">.global bootsect_start</span><br><span class="line"><span class="section">bootsect_start:</span></span><br><span class="line">ljmp $BOOTSEG, $start2</span><br><span class="line"><span class="section">start2:</span></span><br><span class="line"><span class="comment">#……</span></span><br><span class="line"><span class="comment">#这里的512字段bootsector对于硬盘启动是用不到的</span></span><br><span class="line"><span class="comment">#……</span></span><br><span class="line">.globl _start</span><br><span class="line"><span class="section">_start:</span></span><br><span class="line">.byte 0xeb <span class="comment"># short (2-byte) jump</span></span><br><span class="line">.byte start_of_setup-1f <span class="comment">#这指令是用.byte定义出来的,跳转start_of_setup-1f</span></span><br><span class="line"><span class="comment">#……</span></span><br><span class="line"><span class="comment">#这里是一个庞大的数据结构,没展示出来</span></span><br><span class="line"><span class="comment">#……</span></span><br><span class="line"><span class="section">start_of_setup:</span></span><br><span class="line">movw %ds, %ax</span><br><span class="line">movw %ax, %es <span class="comment">#ds = es</span></span><br><span class="line">cld <span class="comment">#主要指定si、di寄存器的自增方向,即si++ di++</span></span><br><span class="line">movw %ss, %dx</span><br><span class="line">cmpw %ax, %dx <span class="comment"># ds 是否等于 ss</span></span><br><span class="line">movw %sp, %dx</span><br><span class="line">je 2f</span><br><span class="line"><span class="comment"># 如果ss为空则建立新栈</span></span><br><span class="line">movw $_end, %dx</span><br><span class="line">testb $CAN_USE_HEAP, loadflags</span><br><span class="line">jz 1f</span><br><span class="line">movw heap_end_ptr, %dx</span><br><span class="line"><span class="section">1: addw $STACK_SIZE, %dx</span></span><br><span class="line">jnc 2f</span><br><span class="line">xorw %dx, %dx</span><br><span class="line"><span class="section">2:</span></span><br><span class="line">andw $~3, %dx</span><br><span class="line">jnz 3f</span><br><span class="line">movw $0xfffc, %dx</span><br><span class="line"><span class="section">3: movw %ax, %ss</span></span><br><span class="line">movzwl %dx, %esp</span><br><span class="line">sti <span class="comment"># 栈已经初始化好,开中断</span></span><br><span class="line">pushw %ds</span><br><span class="line">pushw $6f</span><br><span class="line">lretw <span class="comment"># cs=ds ip=6：跳转到标号6处</span></span><br><span class="line"><span class="section">6:</span></span><br><span class="line">cmpl $0x5a5aaa55, setup_sig <span class="comment">#检查setup标记</span></span><br><span class="line">jne setup_bad</span><br><span class="line">movw $__bss_start, %di</span><br><span class="line">movw $_end+3, %cx</span><br><span class="line">xorl %eax, %eax</span><br><span class="line">subw %di, %cx</span><br><span class="line">shrw $2, %cx</span><br><span class="line">rep; stosl <span class="comment">#清空setup程序的bss段</span></span><br><span class="line">calll main <span class="comment">#调用C语言main函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>setup_header结构</strong>
<ul>
<li>硬盘中MBR是由GRUB写入的boot.img,这里的linux/arch/x86/boot/head.S中的bootsector对于硬盘启动无用</li>
<li>GRUB将vmlinux的setup.bin部分读到内存地址0x90000处,然后跳转到0x90200开始执行,恰好跳过了前面512字节的bootsector,从_start开始</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/arch/x86/include/uapi/asm/bootparam.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">setup_header</span> &#123;</span></span><br><span class="line">  __u8 setup_sects; <span class="comment">//setup大小</span></span><br><span class="line">  __u16 root_flags; <span class="comment">//根标志</span></span><br><span class="line">  __u32 syssize; <span class="comment">//系统文件大小</span></span><br><span class="line">  __u16 ram_size; <span class="comment">//内存大小</span></span><br><span class="line">  __u16 vid_mode;</span><br><span class="line">  __u16 root_dev; <span class="comment">//根设备号</span></span><br><span class="line">  __u16 boot_flag; <span class="comment">//引导标志</span></span><br><span class="line">  <span class="comment">//……</span></span><br><span class="line">  __u32 realmode_swtch; <span class="comment">//切换回实模式的函数地址</span></span><br><span class="line">  __u16 start_sys_seg;</span><br><span class="line">  __u16 kernel_version; <span class="comment">//内核版本</span></span><br><span class="line">  __u8 type_of_loader; <span class="comment">//引导器类型 我们这里是GRUB</span></span><br><span class="line">  __u8 loadflags; <span class="comment">//加载内核的标志</span></span><br><span class="line">  __u16 setup_move_size; <span class="comment">//移动setup的大小</span></span><br><span class="line">  __u32 code32_start; <span class="comment">//将要跳转到32位模式下的地址</span></span><br><span class="line">  __u32 ramdisk_image; <span class="comment">//初始化内存盘映像地址,里面有内核驱动模块</span></span><br><span class="line">  __u32 ramdisk_size; <span class="comment">//初始化内存盘映像大小</span></span><br><span class="line">  <span class="comment">//……</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>16位main函数</strong>
<ul>
<li>C编译器编译的代码,是在32位保护模式下的或者64位长模式的,很少编译成16位实模式下,其实setup.bin大部分代码是在16位实模式下</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="comment">// linux/arch/x86/boot/main.c</span></span><br><span class="line"><span class="comment">//定义boot_params变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">boot_params</span> <span class="title">boot_params</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(16)));</span></span><br><span class="line"><span class="type">char</span> *HEAP = _end;</span><br><span class="line"><span class="type">char</span> *heap_end = _end;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//把先前setup_header结构复制到boot_params结构中的hdr变量中,在linux/arch/x86/inc</span></span><br><span class="line">  copy_boot_params();</span><br><span class="line">  <span class="comment">//初始化早期引导所用的console</span></span><br><span class="line">  console_init();</span><br><span class="line">  <span class="comment">//初始化堆</span></span><br><span class="line">  init_heap();</span><br><span class="line">  <span class="comment">//检查CPU是否支持运行Linux</span></span><br><span class="line">  <span class="keyword">if</span> (validate_cpu()) &#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Unable to boot - please use a kernel appropriate &quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">  die();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  //告诉BIOS我们打算在什么CPU模式下运行它</span></span><br><span class="line"><span class="string">  set_bios_mode();</span></span><br><span class="line"><span class="string">  //查看物理内存空间布局</span></span><br><span class="line"><span class="string">  detect_memory();</span></span><br><span class="line"><span class="string">  //初始化键盘</span></span><br><span class="line"><span class="string">  keyboard_init();</span></span><br><span class="line"><span class="string">  //查询Intel的(IST)信息.</span></span><br><span class="line"><span class="string">  query_ist();</span></span><br><span class="line"><span class="string">  /*查询APM BIOS电源管理信息.*/</span></span><br><span class="line"><span class="string">  #if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)</span></span><br><span class="line"><span class="string">  query_apm_bios();</span></span><br><span class="line"><span class="string">  #endif</span></span><br><span class="line"><span class="string">  //查询EDD BIOS扩展数据区域的信息</span></span><br><span class="line"><span class="string">  #if defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)</span></span><br><span class="line"><span class="string">  query_edd();</span></span><br><span class="line"><span class="string">  #endif</span></span><br><span class="line"><span class="string">  //设置显卡的图形模式</span></span><br><span class="line"><span class="string">  set_video();</span></span><br><span class="line"><span class="string">  //进入CPU保护模式,不会返回了</span></span><br><span class="line"><span class="string">  go_to_protected_mode();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//linux/arch/x86/boot/pm.c</span></span><br><span class="line"><span class="string">void go_to_protected_mode(void)&#123;</span></span><br><span class="line"><span class="string">  //安装切换实模式的函数</span></span><br><span class="line"><span class="string">  realmode_switch_hook();</span></span><br><span class="line"><span class="string">  //开启a20地址线,是为了能访问1MB以上的内存空间</span></span><br><span class="line"><span class="string">  if (enable_a20()) &#123;</span></span><br><span class="line"><span class="string">  puts(&quot;</span>A20 gate not responding, unable to boot...\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">  die();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  //重置协处理器,早期x86上的浮点运算单元是以协处理器的方式存在的</span></span><br><span class="line"><span class="string">  reset_coprocessor();</span></span><br><span class="line"><span class="string">  //屏蔽8259所示的中断源</span></span><br><span class="line"><span class="string">  mask_all_interrupts();</span></span><br><span class="line"><span class="string">  //安装中断描述符表和全局描述符表,</span></span><br><span class="line"><span class="string">  setup_idt();</span></span><br><span class="line"><span class="string">  setup_gdt();</span></span><br><span class="line"><span class="string">  //保护模式下长跳转到boot_params.hdr.code32_start</span></span><br><span class="line"><span class="string">  protected_mode_jump(boot_params.hdr.code32_start, (u32)&amp;boo</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// protected_mode_jump是汇编函数,在linux/arch/x86/boot/pmjump.S文件中</span></span><br><span class="line"><span class="string">// 该代码逻辑和保护模式一样,只是多了处理参数的逻辑,即跳转到boot_params.hrd.code32_start中的地址</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 地址在在linux/arch/x86/boot/head.S文件中设为0x100000</span></span><br><span class="line"><span class="string">code32_start:</span></span><br><span class="line"><span class="string">long 0x100000</span></span><br><span class="line"><span class="string">// GRUB会把vmlinuz中的vmlinux.bin部分,放在1MB开始的内存空间中</span></span><br><span class="line"><span class="string">// 通过跳转,正式进入vmlinux.bin中</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>startup_32函数</strong>
<ul>
<li>startup_32中需要重新加载段描述符,之后计算vmlinux.bin文件的编译生成的地址和实际加载地址的偏移,然后重新设置内核栈,检测CPU是否支持长模式,接着再次计算vmlinux.bin加载地址的偏移,来去顶对其中vmlinux.bin.gz解压缩的地址</li>
<li>CPU支持长模式,就设置64位的全局描述表,开启CPU的PAE物理地址扩展特性</li>
<li>设置最初的MMU页表,最后开启分页并进入长模式,跳转到startup_64</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  .code32</span><br><span class="line"><span class="title function_">SYM_FUNC_START</span><span class="params">(startup_32)</span></span><br><span class="line">  cld</span><br><span class="line">  cli</span><br><span class="line">  <span class="title function_">leal</span> <span class="params">(BP_scratch+<span class="number">4</span>)</span><span class="params">(%esi)</span>, %esp</span><br><span class="line">  call 1f</span><br><span class="line">1: popl %ebp</span><br><span class="line">subl $ <span class="title function_">rva</span><span class="params">(<span class="number">1b</span>)</span>, %ebp</span><br><span class="line">  #重新加载全局段描述符表</span><br><span class="line">leal <span class="title function_">rva</span><span class="params">(gdt)</span><span class="params">(%ebp)</span>, %eax</span><br><span class="line">movl %eax, 2<span class="params">(%eax)</span></span><br><span class="line"><span class="title function_">lgdt</span> <span class="params">(%eax)</span></span><br><span class="line">  #……篇幅所限未全部展示代码</span><br><span class="line">  #重新设置栈</span><br><span class="line">leal <span class="title function_">rva</span><span class="params">(boot_stack_end)</span><span class="params">(%ebp)</span>, %esp</span><br><span class="line">  #检测CPU是否支持长模式</span><br><span class="line">call verify_cpu</span><br><span class="line">testl %eax, %eax</span><br><span class="line">jnz .Lno_longmode</span><br><span class="line">  #……计算偏移的代码略过</span><br><span class="line">  #开启PAE</span><br><span class="line">  movl %cr4, %eax</span><br><span class="line">orl $X86_CR4_PAE, %eax</span><br><span class="line">movl %eax, %cr4</span><br><span class="line">  #……建立MMU页表的代码略过</span><br><span class="line">  #开启长模式</span><br><span class="line">  movl $MSR_EFER, %ecx</span><br><span class="line">rdmsr</span><br><span class="line">btsl $_EFER_LME, %eax</span><br><span class="line">  #获取startup_64的地址</span><br><span class="line">  leal <span class="title function_">rva</span><span class="params">(startup_64)</span><span class="params">(%ebp)</span>, %eax</span><br><span class="line">  #……篇幅所限未全部展示代码</span><br><span class="line">  #内核代码段描述符索和startup_64的地址引压入栈</span><br><span class="line">  pushl $__KERNEL_CS</span><br><span class="line">pushl %eax</span><br><span class="line">  #开启分页和保护模式</span><br><span class="line">movl $<span class="params">(X86_CR0_PG | X86_CR0_PE)</span>, %eax</span><br><span class="line">movl %eax, %cr0</span><br><span class="line">    #弹出刚刚栈中压入的内核代码段描述符和startup_64的地址到CS和RIP中,实现跳转,真正进入长</span><br><span class="line">  lret</span><br><span class="line"><span class="title function_">SYM_FUNC_END</span><span class="params">(startup_32）</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>startup_64函数</strong>
<ul>
<li>开启CPU长模式,从startup_64开开真正进入64位的时代</li>
<li>startup_64函数同样也是再linux/arch/x86/boot/compressed/head64.S文件中定义</li>
<li>startup_64函数中,初始化长模式下数据段寄存器,确定最终解压缩地址,然后拷贝压缩vmlinuxbin到该地址,跳转到decompress_kernel地址处,开始解压vmlinux.bin.gz</li>
<li>最后跳转extract_kernel函数就是解压内核的函数</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">.code64</span><br><span class="line">.org <span class="number">0x200</span></span><br><span class="line">SYM_CODE_START(startup_64)</span><br><span class="line">cld</span><br><span class="line">cli</span><br><span class="line">#初始化长模式下数据段寄存器</span><br><span class="line">xorl %eax, %eax</span><br><span class="line">movl %eax, %ds</span><br><span class="line">movl %eax, %es</span><br><span class="line">movl %eax, %ss</span><br><span class="line">movl %eax, %fs</span><br><span class="line">movl %eax, %gs</span><br><span class="line">#……重新确定内核映像加载地址的代码略过</span><br><span class="line">#重新初始化<span class="number">64</span>位长模式下的栈</span><br><span class="line">leaq <span class="title function_">rva</span><span class="params">(boot_stack_end)</span><span class="params">(%rbx)</span>, %rsp</span><br><span class="line">#……建立最新5级MMU页表的代码略过</span><br><span class="line">#确定最终解压缩地址,然后拷贝压缩vmlinux.bin到该地址</span><br><span class="line">pushq %rsi</span><br><span class="line"><span class="title function_">leaq</span> <span class="params">(_bss<span class="number">-8</span>)</span><span class="params">(%rip)</span>, %rsi</span><br><span class="line">leaq <span class="title function_">rva</span><span class="params">(_bss<span class="number">-8</span>)</span><span class="params">(%rbx)</span>, %rdi</span><br><span class="line">movl $<span class="params">(_bss - startup_32)</span>, %ecx</span><br><span class="line">shrl $3, %ecx</span><br><span class="line"><span class="built_in">std</span></span><br><span class="line">rep movsq</span><br><span class="line">cld</span><br><span class="line">popq %rsi</span><br><span class="line">#跳转到重定位的Lrelocated处</span><br><span class="line">leaq <span class="title function_">rva</span><span class="params">(.Lrelocated)</span><span class="params">(%rbx)</span>, %rax</span><br><span class="line">jmp *%rax</span><br><span class="line"><span class="title function_">SYM_CODE_END</span><span class="params">(startup_64)</span></span><br><span class="line">.text</span><br><span class="line"><span class="title function_">SYM_FUNC_START_LOCAL_NOALIGN</span><span class="params">(.Lrelocated)</span></span><br><span class="line">#清理程序文件中需要的BSS段</span><br><span class="line">xorl %eax, %eax</span><br><span class="line">leaq _<span class="title function_">bss</span><span class="params">(%rip)</span>, %rdi</span><br><span class="line">leaq _<span class="title function_">ebss</span><span class="params">(%rip)</span>, %rcx</span><br><span class="line">subq %rdi, %rcx</span><br><span class="line">shrq $3, %rcx</span><br><span class="line">rep stosq</span><br><span class="line">#……省略无关代码</span><br><span class="line">pushq %rsi</span><br><span class="line">movq %rsi, %rdi</span><br><span class="line">leaq <span class="title function_">boot_heap</span><span class="params">(%rip)</span>, %rsi</span><br><span class="line">#准备参数：被解压数据的开始地址</span><br><span class="line">leaq <span class="title function_">input_data</span><span class="params">(%rip)</span>, %rdx</span><br><span class="line">#准备参数：被解压数据的长度</span><br><span class="line">movl <span class="title function_">input_len</span><span class="params">(%rip)</span>, %ecx</span><br><span class="line">#准备参数：解压数据后的开始地址</span><br><span class="line">movq %rbp, %r8</span><br><span class="line">#准备参数：解压数据后的长度</span><br><span class="line">movl <span class="title function_">output_len</span><span class="params">(%rip)</span>, %r9d</span><br><span class="line">#调用解压函数解压vmlinux.bin.gz,返回入口地址</span><br><span class="line">call extract_kernel</span><br><span class="line">popq %rsi</span><br><span class="line">#跳转到内核入口地址</span><br><span class="line">jmp *%rax</span><br><span class="line">SYM FUNC <span class="title function_">END</span><span class="params">(.Lrelocated)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>extract_kernel函数</strong>
<ul>
<li>从startup_32函数到startup_64函数,其间经过了保护模式,长模式,最终到达了extract_kernel函数,extract_kernel函数根据piggy.o中的信息从vmlinux.bin.gz解压出vmlinux</li>
<li>vmlinux正是编译出Linux内核elf格式的文件,只不过它被去掉了符号信息,extract_kernel函数不仅仅是解压,还需要解析elf格式</li>
<li>extract_kernel函数调用__decompress 函数,对vmlinux.bin.gz使用特定的解压算法进行解压</li>
<li>__decompress函数解压出来的是vmlinux文件是elf格式的,所以还要调用parse_elf函数进一步解析elf格式,把vmlinux中的指令段,数据段,BSS 段,根据elf中信息和要求放入特定的内存空间,返回指令段的入口地址</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extract_kernel函数是在linux/arch/x86/boot/compressed/misc.c文件中定义</span></span><br><span class="line">asmlinkage __visible <span class="type">void</span> *<span class="title function_">extract_kernel</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">void</span> *rmode, memptr heap,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">char</span> *input_data,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> input_len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">char</span> *output,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> output_len</span></span><br><span class="line"><span class="params">)</span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> kernel_total_size = VO__end - VO__text;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> virt_addr = LOAD_PHYSICAL_ADDR;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> needed_size;</span><br><span class="line"><span class="comment">//省略了无关性代码</span></span><br><span class="line">debug_putstr(<span class="string">&quot;\nDecompressing Linux... &quot;</span>);</span><br><span class="line"><span class="comment">//调用具体的解压缩算法解压</span></span><br><span class="line">__decompress(input_data, input_len, <span class="literal">NULL</span>, <span class="literal">NULL</span>, output, output_len,</span><br><span class="line"><span class="comment">//解压出的vmlinux是elf格式,所以要解析出里面的指令数据段和常规数据段</span></span><br><span class="line"><span class="comment">//返回vmlinux的入口点即Linux内核程序的开始地址</span></span><br><span class="line">parse_elf(output);</span><br><span class="line">handle_relocations(output, output_len, virt_addr); debug_putstr(<span class="string">&quot;done.\</span></span><br><span class="line"><span class="string">return output;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Linux内核的startup_64</strong>
<ul>
<li>此时的startup_64函数不是之前的startup_64函数,也不参与前面的链接工作</li>
<li>对于SMP系统加电之后,总线仲裁机制会选出多个CPU中的一个CPU,称为BSP,也叫第一个启动的CPU,负责让BSP CPU先启动,其他CPU则等待BSP CPU的唤醒</li>
<li>对于第一个启动的CPU,会跳转secondary_startup_64函数中1标号处,对于其他唤醒的CPU则会直接执行seondary_startup_64函数,在该函数一切准备就绪之后,最后调用x86_64_start_kernel函数</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#linux/arch/x86/kernel/head_64.S</span></span><br><span class="line">.code64</span><br><span class="line">SYM_CODE_START_NOALIGN(startup_64)</span><br><span class="line"><span class="comment">#切换栈</span></span><br><span class="line">leaq (__end_init_task - SIZEOF_PTREGS)(%rip), %rsp</span><br><span class="line"><span class="comment">#跳转到.Lon_kernel_cs:</span></span><br><span class="line">pushq $__KERNEL_CS</span><br><span class="line">leaq .Lon_kernel_cs(%rip), %rax</span><br><span class="line">pushq %rax</span><br><span class="line">lretq</span><br><span class="line"><span class="section">.Lon_kernel_cs:</span></span><br><span class="line"><span class="comment">#对于第一个CPU,则会跳转secondary_startup_64函数中1标号处</span></span><br><span class="line">jmp 1f</span><br><span class="line">SYM_CODE_END(startup_64)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># secondary_startup_64函数</span></span><br><span class="line">SYM_CODE_START(secondary_startup_64)</span><br><span class="line"><span class="comment">#省略了大量无关性代码</span></span><br><span class="line"><span class="section">1:</span></span><br><span class="line">movl <span class="variable">$(X86_CR4_PAE | X86_CR4_PGE)</span>, %ecx</span><br><span class="line"><span class="comment">#ifdef CONFIG_X86_5LEVEL</span></span><br><span class="line">testl $1, __pgtable_l5_enabled(%rip)</span><br><span class="line">jz 1f</span><br><span class="line">orl $X86_CR4_LA57, %ecx</span><br><span class="line"><span class="section">1:</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#省略了大量无关性代码</span></span><br><span class="line"><span class="section">.Ljump_to_C_code:</span></span><br><span class="line">pushq $.Lafter_lret</span><br><span class="line">xorl %ebp, %ebp</span><br><span class="line"><span class="comment">#获取x86_64_start_kernel函数地址赋给rax</span></span><br><span class="line">movq initial_code(%rip), %rax</span><br><span class="line">pushq $__KERNEL_CS</span><br><span class="line"><span class="comment">#将x86_64_start_kernel函数地址压入栈中</span></span><br><span class="line">pushq %rax</span><br><span class="line"><span class="comment">#弹出__KERNEL_CS 和x86_64_start_kernel函数地址到CS：RIP完成调用</span></span><br><span class="line">lretq</span><br><span class="line"><span class="section">.Lafter_lret:</span></span><br><span class="line">SYM_CODE_END(secondary_startup_64)</span><br><span class="line"><span class="comment">#保存了x86_64_start_kernel函数地址</span></span><br><span class="line">SYM_DATA(initial_code, .quad x86_64_start_kernel)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Linux内核的第一个C函数</strong>
<ul>
<li>调用的x86_64_start_kernel函数是使用C编写的,其为Linux内核的第一个C函数</li>
<li>在linux/arch/x86/kernel/head64.c文件中定义</li>
<li>x86_64_start_kernel函数处理了页表(处理Linux内核虚拟地址空间),然后复制引导信息(struct boot_params结构体),最后调用x86_64_start_reservations函数(处理平台固件相关的东西,调用start_kernel函数)</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">x86_64_start_kernel</span><span class="params">(<span class="type">char</span> * real_mode_data)</span>&#123;</span><br><span class="line">  <span class="comment">//重新设置早期页表</span></span><br><span class="line">  reset_early_page_tables();</span><br><span class="line">  <span class="comment">//清理BSS段</span></span><br><span class="line">  clear_bss();</span><br><span class="line">  <span class="comment">//清理之前的顶层页目录</span></span><br><span class="line">  clear_page(init_top_pgt);</span><br><span class="line">  <span class="comment">//复制引导信息</span></span><br><span class="line">  copy_bootdata(__va(real_mode_data));</span><br><span class="line">  <span class="comment">//加载BSP CPU的微码</span></span><br><span class="line">  load_ucode_bsp();</span><br><span class="line">  <span class="comment">//让顶层页目录指向重新设置早期页表</span></span><br><span class="line">  init_top_pgt[<span class="number">511</span>] = early_top_pgt[<span class="number">511</span>];</span><br><span class="line">  x86_64_start_reservations(real_mode_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __init <span class="title function_">x86_64_start_reservations</span><span class="params">(<span class="type">char</span> *real_mode_data)</span>&#123;</span><br><span class="line">  <span class="comment">//略过无关的代码</span></span><br><span class="line">  start_kernel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>start_kernel函数</strong>
<ul>
<li>该函数调用大量的Linux内核功能的初始化函数,定义在/linux/init/main.c文件中</li>
<li>Linux内核所有功能的初始化函数都是在start_kernel函数中调用,一旦函数执行完成,Linux内核就具备向应用程序提供一系列功能服务的能力</li>
<li>关注arch_call_rest_init函数,为<strong>包装函数</strong>,其中直接调用rest_init函数
<ul>
<li>rest_init函数为建立两个Linux内核线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start_kernel定义在/linux/init/main.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="type">char</span> *command_line;</span><br><span class="line">  <span class="type">char</span> *after_dashes;</span><br><span class="line">  <span class="comment">//CPU组早期初始化</span></span><br><span class="line">  cgroup_init_early();</span><br><span class="line">  <span class="comment">//关中断</span></span><br><span class="line">  local_irq_disable();</span><br><span class="line">  <span class="comment">//ARCH层初始化</span></span><br><span class="line">  setup_arch(&amp;command_line);</span><br><span class="line">  <span class="comment">//日志初始化</span></span><br><span class="line">  setup_log_buf(<span class="number">0</span>);</span><br><span class="line">  sort_main_extable();</span><br><span class="line">  <span class="comment">//陷阱门初始化</span></span><br><span class="line">  trap_init();</span><br><span class="line">  <span class="comment">//内存初始化</span></span><br><span class="line">  mm_init();</span><br><span class="line">  ftrace_init();</span><br><span class="line">  <span class="comment">//调度器初始化</span></span><br><span class="line">  sched_init();</span><br><span class="line">  <span class="comment">//工作队列初始化</span></span><br><span class="line">  workqueue_init_early();</span><br><span class="line">  <span class="comment">//RCU锁初始化</span></span><br><span class="line">  rcu_init();</span><br><span class="line">  <span class="comment">//IRQ 中断请求初始化</span></span><br><span class="line">  early_irq_init();</span><br><span class="line">  init_IRQ();</span><br><span class="line">  tick_init();</span><br><span class="line">  rcu_init_nohz();</span><br><span class="line">  <span class="comment">//定时器初始化</span></span><br><span class="line">  init_timers();</span><br><span class="line">  hrtimers_init();</span><br><span class="line">  <span class="comment">//软中断初始化</span></span><br><span class="line">  softirq_init();</span><br><span class="line">  timekeeping_init();</span><br><span class="line">  mem_encrypt_init();</span><br><span class="line">  <span class="comment">//每个cpu页面集初始化</span></span><br><span class="line">  setup_per_cpu_pageset();</span><br><span class="line">  <span class="comment">//fork初始化建立进程的</span></span><br><span class="line">  fork_init();</span><br><span class="line">  proc_caches_init();</span><br><span class="line">  uts_ns_init();</span><br><span class="line">  <span class="comment">//内核缓冲区初始化</span></span><br><span class="line">  buffer_init();</span><br><span class="line">  key_init();</span><br><span class="line">  <span class="comment">//安全相关的初始化</span></span><br><span class="line">  security_init();</span><br><span class="line">  <span class="comment">//VFS数据结构内存池初始化</span></span><br><span class="line">  vfs_caches_init();</span><br><span class="line">  <span class="comment">//页缓存初始化</span></span><br><span class="line">  pagecache_init();</span><br><span class="line">  <span class="comment">//进程信号初始化</span></span><br><span class="line">  signals_init();</span><br><span class="line">  <span class="comment">//运行第一个进程</span></span><br><span class="line">  arch_call_rest_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装函数</span></span><br><span class="line"><span class="type">void</span> __init __weak <span class="title function_">arch_call_rest_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  rest_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精简后的rest_init函数</span></span><br><span class="line">noinline <span class="type">void</span> __ref <span class="title function_">rest_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="comment">//建立kernel_init线程</span></span><br><span class="line">  pid = kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">  <span class="comment">//建立khreadd线程</span></span><br><span class="line">  pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Linux的第一个用户进程</strong>
<ul>
<li>可建立第一个用户进程时,代表Linux内核的初始流程已经基本完成</li>
<li><strong>Linux内核的第一个用户态进程是在kernel_init线程建立的,kernel_init线程执行的就是kernel_init函数</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __ref <span class="title function_">kernel_init</span><span class="params">(<span class="type">void</span> *unused)</span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">    ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,ramdisk_execute_command, r</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">    ret = run_init_process(execute_command);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    panic(<span class="string">&quot;Requested init %s failed (error %d).&quot;</span>, execute_co</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) || !try_to_r</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  panic(<span class="string">&quot;No working init found. Try passing init= option to kernel. &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ramdisk_execute_command和execute_command都是内核启动时传递的参数,可以在GRUB启动选项中设置</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>重点</strong>
<ol>
<li>GRUB加载vmlinuz文件后,会把控制权交给vmlinuz文件的setup.bin的部分中_start,它会设置好栈,清空bss,设置好setup_header结构,调用16位main切换到保护模式,最后跳转到1MB处的vmlinux.bin文件中</li>
<li>从vmlinux.bin文件中startup32、startup64函数开始建立新的全局段描述符表和 MMU页表,切换到长模式下解压vmlinux.bin.gz.释放出vmlinux文件之后,由解析elf格式的函数进行解析,释放vmlinux中的代码段和数据段到指定的内存.然后调用其中的startup_64函数,在这个函数的最后调用Linux内核的第一个C函数</li>
<li>Linux内核第一个C函数重新设置MMU页表,随后便调用了最有名的start_kernel函数,start_kernel函数中调用了大多数Linux内核功能性初始化函数,在最后调用rest_init函数建立了两个内核线程,在其中的kernel_init线程建立了第一个用户态进程</li>
</ol>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-19-12-18-29.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-19-12-18-29.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Linux初始化要点示意图" /></p>
<hr />
<h1 id="6-内存"><a class="markdownIt-Anchor" href="#6-内存"></a> 6 内存</h1>
</div><div class="story post-story"><h2 id="61-如何划分与组织内存"><a class="markdownIt-Anchor" href="#61-如何划分与组织内存"></a> 6.1 如何划分与组织内存</h2>
<ul>
<li>首先解决内存的划分方式与内存页的表示,组织问题,设计好数据结构;然后在内存中建立数据结构对应的实例变量,搞定内存页的初始化问题;最后依赖前面建立的数据结构实现内存页面管理算法</li>
<li><strong>分段还是分页</strong>
<ul>
<li><strong>第一点,从表示方式和状态角度考虑</strong>
<ul>
<li>段的长度大小不一,用什么数据结构表示一个段,如何确定一个段已经分配或空闲</li>
<li>页的大小固定,只需用位图能表示页的分配与释放</li>
</ul>
</li>
<li><strong>第二点,从内存碎片的利用看</strong>
<ul>
<li>段的长度大小不一,容易产生内存碎片</li>
<li>页的大小固定,分配的最小单位是页,可通过修改页表的方式让连续的虚拟页面映射到非连续的物理页面</li>
</ul>
</li>
<li><strong>第三点,从内存和硬盘的数据交换效率考虑</strong>
<ul>
<li>内存不足时,操作系统把内存中的一部分数据写回硬盘来释放内存,涉及到内存和硬盘交换数据</li>
<li>使用页交换数据时,页大小固定,系统性能稳定</li>
</ul>
</li>
<li><strong>段最大的问题是使虚拟内存地址空间难以实施</strong></li>
<li><strong>使用4KB作为页大小(正好对应x86CPU下长模式下MMU4KB的分页方式),选择分页模式管理内存</strong></li>
</ul>
</li>
<li><strong>如何表示一个页</strong>
<ul>
<li>使用分页模型来管理内存,首先把物理内存空间分为4KB大小页,表示从地址x开始到x+0xFFF一段的物理内存空间,x必须是0x1000对其的,这一段x+0xFFF的内存空间称为<strong>内存页</strong></li>
<li>真实的物理内存地址空间不是连续的,中间可能有空洞的,可能是显存或外设的寄存器
<ul>
<li>真正的物理内存空间布局信息来源于<strong>e820msp_t结构数组</strong>,已经转换成phymmarge_t结构数组,由kmachbsp-&gt;mb_e820expadr指向</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-19-12-56-45.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-19-12-56-45.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="物理内存分页结构图" /></p>
<ul>
<li><strong>表示页</strong>
<ul>
<li>用位图或者整型变量数组,用其中一个位代表一个页,位值为0时表示页空闲,值为1时表示页已分配;用整型数组中一个元素表示一个页,用具体数组元素的数值代表页的状态
<ul>
<li>分配,释放内存页的算法:扫描位图或扫描数组</li>
<li><mark>该内存管理器是最简单的,但最低效</mark>
<ul>
<li>仅仅保存了内存页的空闲和已分配的信息</li>
</ul>
</li>
</ul>
</li>
<li>页还需要页的状态,地址,页的分配计数,页的类型,页的链表信息,使用<strong>C语言结构体封装</strong>
<ul>
<li>msadsc_t结构实则很小,表示一个页面,物理内存页有多少就需要多少个msadsc_t结构
<ul>
<li>因为页面地址总是按4kb对齐,所以phyadrflgs_t的低12位可以另作它用</li>
</ul>
</li>
<li>msadsc_t结构里的链表,可以方便它挂入到其他数据结构中</li>
<li>除了分配计数,msadflgs_t结构中的其他部分都是用来描述msadsc_t结构本身信息的</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Cosmos/include/halinc/msadsc_t.h</span></span><br><span class="line"><span class="comment">//内存空间地址描述符标志</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MSADFLGS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">u32_t</span> mf_olkty:<span class="number">2</span>; <span class="comment">//挂入链表的类型</span></span><br><span class="line">  <span class="type">u32_t</span> mf_lstty:<span class="number">1</span>; <span class="comment">//是否挂入链表</span></span><br><span class="line">  <span class="type">u32_t</span> mf_mocty:<span class="number">2</span>; <span class="comment">//分配类型,被谁占用了,内核还是应用或者空闲</span></span><br><span class="line">  <span class="type">u32_t</span> mf_marty:<span class="number">3</span>; <span class="comment">//属于哪个区</span></span><br><span class="line">  <span class="type">u32_t</span> mf_uindx:<span class="number">24</span>; <span class="comment">//分配计数</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">msadflgs_t</span>;</span><br><span class="line"><span class="comment">//物理地址和标志</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_PHYADRFLGS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">u64_t</span> paf_alloc:<span class="number">1</span>; <span class="comment">//分配位</span></span><br><span class="line">  <span class="type">u64_t</span> paf_shared:<span class="number">1</span>; <span class="comment">//共享位</span></span><br><span class="line">  <span class="type">u64_t</span> paf_swap:<span class="number">1</span>; <span class="comment">//交换位</span></span><br><span class="line">  <span class="type">u64_t</span> paf_cache:<span class="number">1</span>; <span class="comment">//缓存位</span></span><br><span class="line">  <span class="type">u64_t</span> paf_kmap:<span class="number">1</span>; <span class="comment">//映射位</span></span><br><span class="line">  <span class="type">u64_t</span> paf_lock:<span class="number">1</span>; <span class="comment">//锁定位</span></span><br><span class="line">  <span class="type">u64_t</span> paf_dirty:<span class="number">1</span>; <span class="comment">//脏位</span></span><br><span class="line">  <span class="type">u64_t</span> paf_busy:<span class="number">1</span>; <span class="comment">//忙位</span></span><br><span class="line">  <span class="type">u64_t</span> paf_rv2:<span class="number">4</span>; <span class="comment">//保留位</span></span><br><span class="line">  <span class="type">u64_t</span> paf_padrs:<span class="number">52</span>; <span class="comment">//页物理地址位</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">phyadrflgs_t</span>;</span><br><span class="line"><span class="comment">//内存空间地址描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MSADSC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> md_list; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">spinlock_t</span> md_lock; <span class="comment">//保护自身的自旋锁</span></span><br><span class="line">  <span class="type">msadflgs_t</span> md_indxflgs; <span class="comment">//内存空间地址描述符标志</span></span><br><span class="line">  <span class="type">phyadrflgs_t</span> md_phyadrs; <span class="comment">//物理地址和标志</span></span><br><span class="line">  <span class="type">void</span>* md_odlink; <span class="comment">//相邻且相同大小msadsc的指针</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">msadsc_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>内存区</strong>
<ul>
<li>将多个页面分成几个内存区,方便对内存更加合理地管理,进一步做精细化的控制</li>
<li>内存区为逻辑上的概念,并不是硬件上必须的;但没有内存也绝对不行</li>
<li>将物理内存分为三个区:硬件区,内核区,应用区
<ul>
<li><strong>硬件区</strong>,占物理内存低端区域0~32MB,虚拟地址主要依赖于CPU中的MMU,但很多外部硬件能直接和内存交换数据,并且只能访问低于24MB的物理内存,只需规定硬件区分配内存页就可分配内存页给硬件设备</li>
<li><strong>内核区</strong>,内核运行在虚拟地址空间需要一段物理内存空间和内核的虚拟地址空间线性映射</li>
<li><strong>应用区</strong>,给应用用户态程序使用,应用程序使用虚拟地址空间按需分配物理内存
<ul>
<li>如果访问到没有与物理内存页建立映射关系的虚拟内存页,CPU产生缺页异常,最终会由操作系统分配一个物理内存页,并建立好映射关系</li>
<li>分配单个页面,把离散的单页,或者内核自身需要建好页表才可以访问的页面,统统收归到用户区</li>
</ul>
</li>
</ul>
</li>
<li>使用结构体表示内存区,但并不能高效的分配内存,因为没有把内存区数据结构和内存页面数据结构关联,分配内存需要遍历扫描msadsc_t结构数组,<strong>需要组织内存页以关联起来提高分配效率</strong></li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-19-15-23-08.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-19-15-23-08.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内存区" /></p>
<ul>
<li><strong>组织内存页</strong>
<ul>
<li>组织内存页就是祖师msadsc_t结构,而msassc_t结构中拥有链表,组织msassc_t结构正是通过另一个数据结构中的链表,将msassc_t结构串联在其中
<ul>
<li>但需要扫描链表,和之前没有区别</li>
</ul>
</li>
<li>定义挂在msadsc_t结构的数据结构,其中需要锁,状态,msadsc_t结构数量,挂载msassc_t结构的链表,和一些统计数据</li>
<li>定义了bafhlst_t数据结构,需要将多个bafhlst_t数据结构组成结构数组,并放在更高的内存分割合并数据结构memdivmer_t中</li>
<li>内存的两个标准操作为什么要用分割和合并:取意于内存分配释放算法,对算法而言分配内存就是分割内存,释放内存就是合并内存</li>
</ul>
</li>
<li>若memdivmer_t结构中dm_mdmlielst数组只是一个数组,没有意义
<ul>
<li>要通过dm_mdmlielst数组,来划分物理内存地址不连续的msadsc_t结构</li>
<li>dm_mdmlielst数组中第0个元素挂载单个msadsc_t结构,其物理内存地址可能对应于0x1000,0x3000,0x5000</li>
<li>dm_mdmlielst数组中第1个元素挂载两个连续的msadsc_t结构,物理内存地址可能对应于0x8000<sub>0x9FFF,0xA000</sub>0xBFFF</li>
<li>dm_mdmlielst数组中第2个元素挂载4个连续的msadsc_t结构,物理内存地址可能对应于0x100000~0x103FFF,0x104000～0x107FFF</li>
<li>依次类推,dm_mdmlielst数组挂载连续msadsc_t结构的数量等于用1左移其数组下标,如数组下标为3,那结果就是8(1&lt;&lt;3)个连续的msadsc_t结构</li>
<li><strong>并不在意其中第一个msadsc_t结构对应的内存物理地址从哪里开始,但是第一个msadsc_t结构与最后一个 msadsc_t结构,它们之间的内存物理地址是连续的</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_BAFHLST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> af_lock; <span class="comment">//保护自身结构的自旋锁</span></span><br><span class="line">  <span class="type">u32_t</span> af_stus; <span class="comment">//状态</span></span><br><span class="line">  <span class="type">uint_t</span> af_oder; <span class="comment">//页面数的位移量</span></span><br><span class="line">  <span class="type">uint_t</span> af_oderpnr; <span class="comment">//oder对应的页面数比如 oder为2那就是1&lt;&lt;2=4</span></span><br><span class="line">  <span class="type">uint_t</span> af_fobjnr; <span class="comment">//多少个空闲msadsc_t结构,即空闲页面</span></span><br><span class="line">  <span class="type">uint_t</span> af_mobjnr; <span class="comment">//此结构的msadsc_t结构总数,即此结构总页面</span></span><br><span class="line">  <span class="type">uint_t</span> af_alcindx; <span class="comment">//此结构的分配计数</span></span><br><span class="line">  <span class="type">uint_t</span> af_freindx; <span class="comment">//此结构的释放计数</span></span><br><span class="line">  <span class="type">list_h_t</span> af_frelst; <span class="comment">//挂载此结构的空闲msadsc_t结构</span></span><br><span class="line">  <span class="type">list_h_t</span> af_alclst; <span class="comment">//挂载此结构已经分配的msadsc_t结构</span></span><br><span class="line">&#125;<span class="type">bafhlst_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MDIVMER_ARR_LMAX 52</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MEMDIVMER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> dm_lock; <span class="comment">//保护自身结构的自旋锁</span></span><br><span class="line">  <span class="type">u32_t</span> dm_stus; <span class="comment">//状态</span></span><br><span class="line">  <span class="type">uint_t</span> dm_divnr; <span class="comment">//内存分配次数</span></span><br><span class="line">  <span class="type">uint_t</span> dm_mernr; <span class="comment">//内存合并次数</span></span><br><span class="line">  <span class="type">bafhlst_t</span> dm_mdmlielst[MDIVMER_ARR_LMAX];<span class="comment">//bafhlst_t结构数组</span></span><br><span class="line">  <span class="type">bafhlst_t</span> dm_onemsalst; <span class="comment">//单个的bafhlst_t结构</span></span><br><span class="line">&#125;<span class="type">memdivmer_t</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-19-16-02-39.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-19-16-02-39.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="页面组织结构示意图" /></p>
<ul>
<li>每个内存区memarea_t结构中包含一个内存分割合并memdivmer_t结构
<ul>
<li>在memdivmer_t结构中又包含dm_mdmlielst数组</li>
<li>在dm_mdmlielst数组中挂载了多个msadsc_t结构</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="62-如何实现内存页的分配与释放"><a class="markdownIt-Anchor" href="#62-如何实现内存页的分配与释放"></a> 6.2 如何实现内存页的分配与释放</h2>
<ul>
<li>内存管理相关的数据结构已定义好了,但没有在内存中建立对应的实例变量,在代码的实际操作中必须建立对应的实例变量</li>
<li><strong>初始化</strong>
<ul>
<li>在hal层初始化中,初始化了从二级引导器中获取的内存布局信息e820map_t数组,并转换成了phymmarge_t结构数组,并对它做了排序
<ul>
<li><strong>但Cosmos物理内存管理器剩下的部分还没有完成初始化</strong></li>
</ul>
</li>
<li>Cosmos的物理内存管理器,依然放在Cosmos的hal层
<ul>
<li>物理内存和硬件平台相关,在cosmos/hal/x86目录下建立memmgrinit.c文件,在文件中写入Cosmos物理内存管理器初始化的init_memmgr函数,并在init_halmm函数中调用</li>
</ul>
</li>
<li><strong>init_memmgr函数需要完成内存页结构msadsc_t和内存区结构memarea_t的初始化</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cosmos/hal/x86/halmm.c中</span></span><br><span class="line"><span class="comment">//hal层的内存初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_halmm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  init_phymmarge();</span><br><span class="line">  init_memmgr();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cosmos物理内存管理器初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_memmgr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化内存页结构msadsc_t</span></span><br><span class="line">  <span class="comment">//初始化内存区结构memarea_t</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>内存页结构初始化</strong>
<ul>
<li>初始化msadsc_t结构对应的变量,一个msadsc_t结构体变量代表一个物理内存页,而物理内存由多个页组成,最终形成msadsc_t结构体数组</li>
<li>只需要找一个内存地址,作为msadsc_t结构体数组,然后扫描phymmarge_t结构体数组中的信息,只要类型是可用内存,就建立一个msadsc_t结构体,并将其中的开始地址作为第一个页面地址</li>
<li>接着要给开始地址加上0x1000,如此循环,直到其结束地址</li>
<li>当phymmarge_t结构体的地址区间,它对所有msadsc_t结构体都建立完成之后,就开始下一个phymmarge_t结构体.依次类推,最后就能建好所有可用物理内存页面对应的msadsc_t结构体</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cosmos/hal.x86/msadsc.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_one_msadsc</span><span class="params">(<span class="type">msadsc_t</span> *msap, <span class="type">u64_t</span> phyadr)</span>&#123;</span><br><span class="line">  <span class="comment">//对msadsc_t结构做基本的初始化,比如链表、锁、标志位</span></span><br><span class="line">  msadsc_t_init(msap);</span><br><span class="line">  <span class="comment">//这是把一个64位的变量地址转换成phyadrflgs_t*类型方便取得其中的地址位段</span></span><br><span class="line">  <span class="type">phyadrflgs_t</span> *tmp = (<span class="type">phyadrflgs_t</span> *)(&amp;phyadr);</span><br><span class="line">  <span class="comment">//把页的物理地址写入到msadsc_t结构中</span></span><br><span class="line">  msap-&gt;md_phyadrs.paf_padrs = tmp-&gt;paf_padrs;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">u64_t</span> <span class="title function_">init_msadsc_core</span><span class="params">(<span class="type">machbstart_t</span> *mbsp, <span class="type">msadsc_t</span> *msavstart, <span class="type">u64_t</span> msanr)</span>&#123;</span><br><span class="line">  <span class="comment">//获取phymmarge_t结构数组开始地址</span></span><br><span class="line">  <span class="type">phymmarge_t</span> *pmagep = (<span class="type">phymmarge_t</span> *)phyadr_to_viradr((<span class="type">adr_t</span>)mbsp-&gt;mb_e820</span><br><span class="line">  <span class="type">u64_t</span> mdindx = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//扫描phymmarge_t结构数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">u64_t</span> i = <span class="number">0</span>; i &lt; mbsp-&gt;mb_e820exnr; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//判断phymmarge_t结构的类型是不是可用内存</span></span><br><span class="line">    <span class="keyword">if</span> (PMR_T_OSAPUSERRAM == pmagep[i].pmr_type)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//遍历phymmarge_t结构的地址区间</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">u64_t</span> start = pmagep[i].pmr_saddr; start &lt; pmagep[i].pmr_end;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//每次加上4KB-1比较是否小于等于phymmarge_t结构的结束地址</span></span><br><span class="line">        <span class="keyword">if</span> ((start + <span class="number">4096</span> - <span class="number">1</span>) &lt;= pmagep[i].pmr_end)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//与当前地址为参数写入第mdindx个msadsc结构</span></span><br><span class="line">          write_one_msadsc(&amp;msavstart[mdindx], start);</span><br><span class="line">          mdindx++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mdindx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> init_msadsc()&#123;</span><br><span class="line">  <span class="type">u64_t</span> coremdnr = <span class="number">0</span>, msadscnr = <span class="number">0</span>;</span><br><span class="line">  <span class="type">msadsc_t</span> *msadscvp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">machbstart_t</span> *mbsp = &amp;kmachbsp;</span><br><span class="line">  <span class="comment">//计算msadsc_t结构数组的开始地址和数组元素个数</span></span><br><span class="line">  <span class="keyword">if</span> (ret_msadsc_vadrandsz(mbsp, &amp;msadscvp, &amp;msadscnr) == FALSE)</span><br><span class="line">  &#123;</span><br><span class="line">    system_error(<span class="string">&quot;init_msadsc ret_msadsc_vadrandsz err\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//开始真正初始化msadsc_t结构数组</span></span><br><span class="line">  coremdnr = init_msadsc_core(mbsp, msadscvp, msadscnr);</span><br><span class="line">  <span class="keyword">if</span> (coremdnr != msadscnr)</span><br><span class="line">  &#123;</span><br><span class="line">    system_error(<span class="string">&quot;init_msadsc init_msadsc_core err\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将msadsc_t结构数组的开始的物理地址写入kmachbsp结构中</span></span><br><span class="line">  mbsp-&gt;mb_memmappadr = viradr_to_phyadr((<span class="type">adr_t</span>)msadscvp);</span><br><span class="line">  <span class="comment">//将msadsc_t结构数组的元素个数写入kmachbsp结构中</span></span><br><span class="line">  mbsp-&gt;mb_memmapnr = coremdnr;</span><br><span class="line">  <span class="comment">//将msadsc_t结构数组的大小写入kmachbsp结构中</span></span><br><span class="line">  mbsp-&gt;mb_memmapsz = coremdnr * <span class="keyword">sizeof</span>(<span class="type">msadsc_t</span>);</span><br><span class="line">  <span class="comment">//计算下一个空闲内存的开始地址</span></span><br><span class="line">  mbsp-&gt;mb_nextwtpadr = PAGE_ALIGN(mbsp-&gt;mb_memmappadr + mbsp-&gt;mb_memmapsz);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ret_msadsc_vadrandsz函数也是遍历phymmarge_t结构数组,计算出有多大的可用内存空间,可以分成多少个页面,需要多少个msadsc_t结构</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>内存区结构初始化</strong>
<ul>
<li>将物理空间在逻辑上分为<strong>硬件区,内核区,用户区</strong>;</li>
<li>要求在内存中建立三个memarea_t结构体的实例变量,需要在内存中找到空闲空间,存放着三个结构体,该结构体是顶层结构,不依赖其他数据结构,只是对其本身进行初始化就好,但其包含了其他数据结构,在初始化时,要对其中的数据结构进行初始化</li>
<li>在init_memarea_core函数的开始,调用memarea_t_init函数,对MEMAREA_MAX个memarea_t结构进行了基本的初始化.然后,在memarea_t_init函数中又调用memdivmer_t_init函数,而在memdivmer_t_init函数中又调用了bafhlst_t_init函数,这保证了那些被包含的数据结构得到了初始化;最后,给三个区分别设置了类型和地址空间</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cosmos/hal/x86/memarea.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bafhlst_t_init</span><span class="params">(<span class="type">bafhlst_t</span> *initp, <span class="type">u32_t</span> stus, <span class="type">uint_t</span> oder, <span class="type">uint_t</span> oderpnr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化bafhlst_t结构体的基本数据</span></span><br><span class="line">  knl_spinlock_init(&amp;initp-&gt;af_lock);</span><br><span class="line">  initp-&gt;af_stus = stus;</span><br><span class="line">  initp-&gt;af_oder = oder;</span><br><span class="line">  initp-&gt;af_oderpnr = oderpnr;</span><br><span class="line">  initp-&gt;af_fobjnr = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;af_mobjnr = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;af_alcindx = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;af_freindx = <span class="number">0</span>;</span><br><span class="line">  list_init(&amp;initp-&gt;af_frelst);</span><br><span class="line">  list_init(&amp;initp-&gt;af_alclst);</span><br><span class="line">  list_init(&amp;initp-&gt;af_ovelst);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">memdivmer_t_init</span><span class="params">(<span class="type">memdivmer_t</span> *initp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化medivmer_t结构体的基本数据</span></span><br><span class="line">  knl_spinlock_init(&amp;initp-&gt;dm_lock);</span><br><span class="line">  initp-&gt;dm_stus = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;dm_divnr = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;dm_mernr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//循环初始化memdivmer_t结构体中dm_mdmlielst数组中的每个bafhlst_t结构的基本数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> li = <span class="number">0</span>; li &lt; MDIVMER_ARR_LMAX; li++)</span><br><span class="line">  &#123;</span><br><span class="line">    bafhlst_t_init(&amp;initp-&gt;dm_mdmlielst[li], BAFH_STUS_DIVM, li, (<span class="number">1UL</span> &lt;&lt; l</span><br><span class="line">  &#125;</span><br><span class="line">  bafhlst_t_init(&amp;initp-&gt;dm_onemsalst, BAFH_STUS_ONEM, <span class="number">0</span>, <span class="number">1UL</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> memarea_t_init(<span class="type">memarea_t</span> *initp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化memarea_t结构体的基本数据</span></span><br><span class="line">  list_init(&amp;initp-&gt;ma_list);</span><br><span class="line">  knl_spinlock_init(&amp;initp-&gt;ma_lock);</span><br><span class="line">  initp-&gt;ma_stus = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ma_flgs = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ma_type = MA_TYPE_INIT;</span><br><span class="line">  initp-&gt;ma_maxpages = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ma_allocpages = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ma_freepages = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ma_resvpages = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ma_horizline = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ma_logicstart = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ma_logicend = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ma_logicsz = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//初始化memarea_t结构体中的memdivmer_t结构体</span></span><br><span class="line">  memdivmer_t_init(&amp;initp-&gt;ma_mdmdata);</span><br><span class="line">  initp-&gt;ma_privp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool_t</span> init_memarea_core(<span class="type">machbstart_t</span> *mbsp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取memarea_t结构开始地址</span></span><br><span class="line">  <span class="type">u64_t</span> phymarea = mbsp-&gt;mb_nextwtpadr;</span><br><span class="line">  <span class="comment">//检查内存空间够不够放下MEMAREA_MAX个memarea_t结构实例变量</span></span><br><span class="line">  <span class="keyword">if</span> (initchkadr_is_ok(mbsp, phymarea, (<span class="keyword">sizeof</span>(<span class="type">memarea_t</span>) * MEMAREA_MAX)) !=</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">memarea_t</span> *virmarea = (<span class="type">memarea_t</span> *)phyadr_to_viradr((<span class="type">adr_t</span>)phymarea);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> mai = <span class="number">0</span>; mai &lt; MEMAREA_MAX; mai++)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">//循环初始化每个memarea_t结构实例变量</span></span><br><span class="line">    memarea_t_init(&amp;virmarea[mai]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置硬件区的类型和空间大小</span></span><br><span class="line">  virmarea[<span class="number">0</span>].ma_type = MA_TYPE_HWAD;</span><br><span class="line">  virmarea[<span class="number">0</span>].ma_logicstart = MA_HWAD_LSTART;</span><br><span class="line">  virmarea[<span class="number">0</span>].ma_logicend = MA_HWAD_LEND;</span><br><span class="line">  virmarea[<span class="number">0</span>].ma_logicsz = MA_HWAD_LSZ;</span><br><span class="line">  <span class="comment">//设置内核区的类型和空间大小</span></span><br><span class="line">  virmarea[<span class="number">1</span>].ma_type = MA_TYPE_KRNL;</span><br><span class="line">  virmarea[<span class="number">1</span>].ma_logicstart = MA_KRNL_LSTART;</span><br><span class="line">  virmarea[<span class="number">1</span>].ma_logicend = MA_KRNL_LEND;</span><br><span class="line">  virmarea[<span class="number">1</span>].ma_logicsz = MA_KRNL_LSZ;</span><br><span class="line">  <span class="comment">//设置应用区的类型和空间大小</span></span><br><span class="line">  virmarea[<span class="number">2</span>].ma_type = MA_TYPE_PROC;</span><br><span class="line">  virmarea[<span class="number">2</span>].ma_logicstart = MA_PROC_LSTART;</span><br><span class="line">  virmarea[<span class="number">2</span>].ma_logicend = MA_PROC_LEND;</span><br><span class="line">  virmarea[<span class="number">2</span>].ma_logicsz = MA_PROC_LSZ;</span><br><span class="line">  <span class="comment">//将memarea_t结构的开始的物理地址写入kmachbsp结构中</span></span><br><span class="line">  mbsp-&gt;mb_memznpadr = phymarea;</span><br><span class="line">  <span class="comment">//将memarea_t结构的个数写入kmachbsp结构中</span></span><br><span class="line">  mbsp-&gt;mb_memznnr = MEMAREA_MAX;</span><br><span class="line">  <span class="comment">//将所有memarea_t结构的大小写入kmachbsp结构中</span></span><br><span class="line">  mbsp-&gt;mb_memznsz = <span class="keyword">sizeof</span>(<span class="type">memarea_t</span>) * MEMAREA_MAX;</span><br><span class="line">  <span class="comment">//计算下一个空闲内存的开始地址</span></span><br><span class="line">  mbsp-&gt;mb_nextwtpadr = PAGE_ALIGN(phymarea + <span class="keyword">sizeof</span>(<span class="type">memarea_t</span>) * MEMAREA_MA</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化内存区</span></span><br><span class="line"><span class="type">void</span> init_memarea()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//真正初始化内存区</span></span><br><span class="line">  <span class="keyword">if</span> (init_memarea_core(&amp;kmachbsp) == FALSE)</span><br><span class="line">  &#123;</span><br><span class="line">    system_error(<span class="string">&quot;init_memarea_core fail&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>处理初始内存占用问题</strong>
<ul>
<li>初始化了内存页和内存区对应的数据结构,已经可以组织好内存页面
<ul>
<li>目前内存中已经有很多数据,有内核本身的执行文件,有字体文件,有MMU页表,有打包的内核映像文件,还有刚建立的内存页和内存区的数据结构;<strong>但建立内存页结构msadsc_t,所有的都是空闲状态,而每一个都表示一个实际的物理内存页</strong></li>
<li>假定在这种情况下,对调用内存分配接口进行内存分配,<strong>按既定的分配算法查找空闲的msadsc_t结构,它一定会找到内核占用的内存页所对应的msadsc_t结构,并把这个内存分配出去,然后得到这个页面的程序对其进行改写,这样内核数据就会被覆盖,(不允许该情况发生)</strong></li>
<li>故将这些已经占用的内存页面所对应的msadsc_t结构标记出来,标记成<strong>已分配</strong>,这样内存分配算法就不会找到它们</li>
</ul>
</li>
<li>解决方法:只要找出被占用内存的起始地址和结束地址,然后从起始地址开始查找对应的msadsc_t结构,再把它标记为已分配,最后直到查找到结束地址为止</li>
<li>实现三个函数:由init_search_krloccupymm函数入口,search_krloccupymsadsc_core函数驱动,由 search_segment_occupymsadsc函数完成实际的工作
<ul>
<li>由于初始化阶段各种数据占用的开始,结束地址和大小,该信息都保存在machbstart_t类型的kmachbsp变量中,所以函数machbstart_t类型的指针为参数</li>
<li>phymmarge_t,msadsc_t,memarea_t这些结构的实例变量和MMU页表所占用的内存空间已经涵盖在了内核自身占用的内存空间</li>
<li><strong>处理初始内存占用问题问题已完美解决,只要在初始化内存呢页结构和内存区结构之后调用init_search_krloccupymm函数即可</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在msadsc.c实现该方案</span></span><br><span class="line"><span class="comment">//搜索一段内存地址空间所对应的msadsc_t结构</span></span><br><span class="line"><span class="type">u64_t</span> <span class="title function_">search_segment_occupymsadsc</span><span class="params">(<span class="type">msadsc_t</span> *msastart, <span class="type">u64_t</span> msanr, <span class="type">u64_t</span> ocpys</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">u64_t</span> mphyadr = <span class="number">0</span>, fsmsnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *fstatmp = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (<span class="type">u64_t</span> mnr = <span class="number">0</span>; mnr &lt; msanr; mnr++)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> ((msastart[mnr].md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE) == ocpystat)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="comment">//找出开始地址对应的第一个msadsc_t结构,就跳转到step1</span></span></span><br><span class="line"><span class="params">      fstatmp = &amp;msastart[mnr];</span></span><br><span class="line"><span class="params">      <span class="keyword">goto</span> step1;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  step1:</span></span><br><span class="line"><span class="params">  fsmsnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == fstatmp)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (<span class="type">u64_t</span> tmpadr = ocpystat; tmpadr &lt; ocpyend; tmpadr += PAGESIZE, fsmsnr</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//从开始地址对应的第一个msadsc_t结构开始设置,直到结束地址对应的最后一个masdsc_t结</span></span></span><br><span class="line"><span class="params">    mphyadr = fstatmp[fsmsnr].md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (mphyadr != tmpadr)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (MF_MOCTY_FREE != fstatmp[fsmsnr].md_indxflgs.mf_mocty ||</span></span><br><span class="line"><span class="params">    <span class="number">0</span> != fstatmp[fsmsnr].md_indxflgs.mf_uindx ||</span></span><br><span class="line"><span class="params">    PAF_NO_ALLOC != fstatmp[fsmsnr].md_phyadrs.paf_alloc)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="comment">//设置msadsc_t结构为已经分配,已经分配给内核</span></span></span><br><span class="line"><span class="params">    fstatmp[fsmsnr].md_indxflgs.mf_mocty = MF_MOCTY_KRNL;</span></span><br><span class="line"><span class="params">    fstatmp[fsmsnr].md_indxflgs.mf_uindx++;</span></span><br><span class="line"><span class="params">    fstatmp[fsmsnr].md_phyadrs.paf_alloc = PAF_ALLOC;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//进行一些数据的正确性检查</span></span></span><br><span class="line"><span class="params">  <span class="type">u64_t</span> ocpysz = ocpyend - ocpystat;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> ((ocpysz &amp; <span class="number">0xfff</span>) != <span class="number">0</span>)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (((ocpysz &gt;&gt; PSHRSIZE) + <span class="number">1</span>) != fsmsnr)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> fsmsnr;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> ((ocpysz &gt;&gt; PSHRSIZE) != fsmsnr)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> fsmsnr;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> search_krloccupymsadsc_core(<span class="type">machbstart_t</span> *mbsp)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">u64_t</span> retschmnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *msadstat = (<span class="type">msadsc_t</span> *)phyadr_to_viradr((<span class="type">adr_t</span>)mbsp-&gt;mb_memmappa</span></span><br><span class="line"><span class="params">  <span class="type">u64_t</span> msanr = mbsp-&gt;mb_memmapnr;</span></span><br><span class="line"><span class="params">  <span class="comment">//搜索BIOS中断表占用的内存页所对应msadsc_t结构</span></span></span><br><span class="line"><span class="params">  retschmnr = search_segment_occupymsadsc(msadstat, msanr, <span class="number">0</span>, <span class="number">0x1000</span>);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="number">0</span> == retschmnr)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//搜索内核栈占用的内存页所对应msadsc_t结构</span></span></span><br><span class="line"><span class="params">  retschmnr = search_segment_occupymsadsc(msadstat, msanr, mbsp-&gt;mb_krlinits</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="number">0</span> == retschmnr)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//搜索内核占用的内存页所对应msadsc_t结构</span></span></span><br><span class="line"><span class="params">  retschmnr = search_segment_occupymsadsc(msadstat, msanr, mbsp-&gt;mb_krlimgpa</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="number">0</span> == retschmnr)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//搜索内核映像文件占用的内存页所对应msadsc_t结构</span></span></span><br><span class="line"><span class="params">  retschmnr = search_segment_occupymsadsc(msadstat, msanr, mbsp-&gt;mb_imgpadr,</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="number">0</span> == retschmnr)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//初始化搜索内核占用的内存页面</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> init_search_krloccupymm(<span class="type">machbstart_t</span> *mbsp)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//实际初始化搜索内核占用的内存页面</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (search_krloccupymsadsc_core(mbsp) == FALSE)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    system_error(<span class="string">&quot;search_krloccupymsadsc_core fail\n&quot;</span>);</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>合并内存页到内存区</strong>
<ul>
<li>让msadsc_t结构挂载到内存区对应的数组中,才能提高内存管理器的分配速度</li>
<li><strong>整体流程分为两步</strong>
<ol>
<li><strong>确定内存页属于哪个区</strong>,即标定一系列msadsc_t结构是属于哪个memarea_t结构的
<ul>
<li>遍历每个memarea_t结构,遍历过程中根据特定的memarea_t结构,然后扫描整个msadsc_t结构数组,最后依次对比msadsc_t的物理地址看msadsc_t是否落在memarea_t结构的地址区间中</li>
<li>如果是,就把memarea_t结构的类型值写入msadsc_t结构中,这样就一个一个打上了标签,遍历memarea_t结构结束之后,每个msadsc_t结构就只归属于某一个memarea_t结构</li>
</ul>
</li>
<li><strong>把特定的内存页合并</strong>,然后挂载到特定的内存区下的memdivmer_t结构中的dm_mdmlielst数组中</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memarea.c文件中写几个函数实现第一步</span></span><br><span class="line"><span class="comment">//给msadsc_t结构打上标签</span></span><br><span class="line"><span class="type">uint_t</span> <span class="title function_">merlove_setallmarflgs_onmemarea</span><span class="params">(<span class="type">memarea_t</span> *mareap, <span class="type">msadsc_t</span> *mstat, uin</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">u32_t</span> muindx = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">msadflgs_t</span> *mdfp = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//获取内存区类型</span></span></span><br><span class="line"><span class="params">  <span class="keyword">switch</span> (mareap-&gt;ma_type)&#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">case</span> MA_TYPE_HWAD:</span></span><br><span class="line"><span class="params">    muindx = MF_MARTY_HWD &lt;&lt; <span class="number">5</span>;<span class="comment">//硬件区标签</span></span></span><br><span class="line"><span class="params">    mdfp = (<span class="type">msadflgs_t</span> *)(&amp;muindx);</span></span><br><span class="line"><span class="params">    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">case</span> MA_TYPE_KRNL:</span></span><br><span class="line"><span class="params">    muindx = MF_MARTY_KRL &lt;&lt; <span class="number">5</span>;<span class="comment">//内核区标签</span></span></span><br><span class="line"><span class="params">    mdfp = (<span class="type">msadflgs_t</span> *)(&amp;muindx);</span></span><br><span class="line"><span class="params">    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">case</span> MA_TYPE_PROC:</span></span><br><span class="line"><span class="params">    muindx = MF_MARTY_PRC &lt;&lt; <span class="number">5</span>;<span class="comment">//应用区标签</span></span></span><br><span class="line"><span class="params">    mdfp = (<span class="type">msadflgs_t</span> *)(&amp;muindx);</span></span><br><span class="line"><span class="params">    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="type">u64_t</span> phyadr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> retnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//扫描所有的msadsc_t结构</span></span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (<span class="type">uint_t</span> mix = <span class="number">0</span>; mix &lt; msanr; mix++)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (MF_MARTY_INIT == mstat[mix].md_indxflgs.mf_marty)</span></span><br><span class="line"><span class="params">    &#123; <span class="comment">//获取msadsc_t结构对应的地址</span></span></span><br><span class="line"><span class="params">       phyadr = mstat[mix].md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;</span></span><br><span class="line"><span class="params">       <span class="comment">//和内存区的地址区间比较</span></span></span><br><span class="line"><span class="params">       <span class="keyword">if</span> (phyadr &gt;= mareap-&gt;ma_logicstart &amp;&amp; ((phyadr + PAGESIZE) - <span class="number">1</span>) &lt;</span></span><br><span class="line"><span class="params">       &#123;</span></span><br><span class="line"><span class="params">        <span class="comment">//设置msadsc_t结构的标签</span></span></span><br><span class="line"><span class="params">        mstat[mix].md_indxflgs.mf_marty = mdfp-&gt;mf_marty;</span></span><br><span class="line"><span class="params">        retnr++;</span></span><br><span class="line"><span class="params">       &#125;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> retnr;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> merlove_mem_core(<span class="type">machbstart_t</span> *mbsp)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//获取msadsc_t结构的首地址</span></span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *mstatp = (<span class="type">msadsc_t</span> *)phyadr_to_viradr((<span class="type">adr_t</span>)mbsp-&gt;mb_memmappadr</span></span><br><span class="line"><span class="params">  <span class="comment">//获取msadsc_t结构的个数</span></span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> msanr = (<span class="type">uint_t</span>)mbsp-&gt;mb_memmapnr, maxp = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//获取memarea_t结构的首地址</span></span></span><br><span class="line"><span class="params">  <span class="type">memarea_t</span> *marea = (<span class="type">memarea_t</span> *)phyadr_to_viradr((<span class="type">adr_t</span>)mbsp-&gt;mb_memznpadr</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> sretf = ~<span class="number">0UL</span>, tretf = ~<span class="number">0UL</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//遍历每个memarea_t结构</span></span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (<span class="type">uint_t</span> mi = <span class="number">0</span>; mi &lt; (<span class="type">uint_t</span>)mbsp-&gt;mb_memznnr; mi++)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//针对其中一个memarea_t结构给msadsc_t结构打上标签</span></span></span><br><span class="line"><span class="params">    sretf = merlove_setallmarflgs_onmemarea(&amp;marea[mi], mstatp, msanr);</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> ((~<span class="number">0UL</span>) == sretf)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//遍历每个memarea_t结构</span></span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (<span class="type">uint_t</span> maidx = <span class="number">0</span>; maidx &lt; (<span class="type">uint_t</span>)mbsp-&gt;mb_memznnr; maidx++)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//针对其中一个memarea_t结构对msadsc_t结构进行合并</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (merlove_mem_onmemarea(&amp;marea[maidx], mstatp, msanr) == FALSE)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    maxp += marea[maidx].ma_maxpages;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//初始化页面合并</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> init_merlove_mem()</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (merlove_mem_core(&amp;kmachbsp) == FALSE)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    system_error(<span class="string">&quot;merlove_mem_core fail\n&quot;</span>);</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码从init_merlove_mem函数开始,其调用的merlove_mem_core函数真正执行工作
<ul>
<li>merlove_mem_core函数有两个遍历内存区,第一次遍历是为了完成第一步,确定内存页属于哪个区</li>
<li>当确定内存页属于哪个区之后,到了第二遍遍历memarea_t结构,合并其中的msadsc_t结构,并把它们挂载到其中的memdivmer_t结构中的dm_mdmlielst数组中
<ul>
<li>该操作较为复杂,第一要保证其中所有的msadsc_t结构挂载到dm_mdmlielst数组中合适的bafhlst_t结构中;第二要保证多个msadsc_t结构有最大的连续性</li>
</ul>
</li>
<li>遍历每个内存区,然后针对其中每一个内存区进行msadsc_t结构的合并操作,<strong>完成这个操作的是 merlove_mem_onmemarea</strong></li>
</ul>
</li>
<li>merlove_mem_onmemarea的整体分为两步
<ul>
<li>第一步,通过merlove_scan_continumsadsc函数,返回最多且地址连续的msadsc_t结构体的开始、结束地址、一共多少个msadsc_t结构体,下一轮开始的msadsc_t结构体的索引号</li>
<li>第二步,根据第一步获取的信息调用merlove_continumsadsc_mareabafh函数,把第一步返回那一组连续的 msadsc_t结构体,挂载到合适的m_mdmlielst数组中的bafhlst_t结构中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现merlove_mem_onmemarea函数</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">continumsadsc_add_bafhlst</span><span class="params">(<span class="type">memarea_t</span> *mareap, <span class="type">bafhlst_t</span> *bafhp, <span class="type">msadsc_t</span></span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  fstat-&gt;md_indxflgs.mf_olkty = MF_OLKTY_ODER;</span></span><br><span class="line"><span class="params">  <span class="comment">//开始的msadsc_t结构指向最后的msadsc_t结构</span></span></span><br><span class="line"><span class="params">  fstat-&gt;md_odlink = fend;</span></span><br><span class="line"><span class="params">  fend-&gt;md_indxflgs.mf_olkty = MF_OLKTY_BAFH;</span></span><br><span class="line"><span class="params">  <span class="comment">//最后的msadsc_t结构指向它属于的bafhlst_t结构</span></span></span><br><span class="line"><span class="params">  fend-&gt;md_odlink = bafhp;</span></span><br><span class="line"><span class="params">  <span class="comment">//把多个地址连续的msadsc_t结构的的开始的那个msadsc_t结构挂载到bafhlst_t结构的af_fre</span></span></span><br><span class="line"><span class="params">  list_add(&amp;fstat-&gt;md_list, &amp;bafhp-&gt;af_frelst);</span></span><br><span class="line"><span class="params">  <span class="comment">//更新bafhlst_t的统计数据</span></span></span><br><span class="line"><span class="params">  bafhp-&gt;af_fobjnr++;</span></span><br><span class="line"><span class="params">  bafhp-&gt;af_mobjnr++;</span></span><br><span class="line"><span class="params">  <span class="comment">//更新内存区的统计数据</span></span></span><br><span class="line"><span class="params">  mareap-&gt;ma_maxpages += fmnr;</span></span><br><span class="line"><span class="params">  mareap-&gt;ma_freepages += fmnr;</span></span><br><span class="line"><span class="params">  mareap-&gt;ma_allmsadscnr += fmnr;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> continumsadsc_mareabafh_core(<span class="type">memarea_t</span> *mareap, <span class="type">msadsc_t</span> **rfstat, msad</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> retval = *rfmnr, tmpmnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *mstat = *rfstat, *mend = *rfend;</span></span><br><span class="line"><span class="params">  <span class="comment">//根据地址连续的msadsc_t结构的数量查找合适bafhlst_t结构</span></span></span><br><span class="line"><span class="params">  <span class="type">bafhlst_t</span> *bafhp = find_continumsa_inbafhlst(mareap, retval);</span></span><br><span class="line"><span class="params">  <span class="comment">//判断bafhlst_t结构状态和类型对不对</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> ((BAFH_STUS_DIVP == bafhp-&gt;af_stus || BAFH_STUS_DIVM == bafhp-&gt;af_stus)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//看地址连续的msadsc_t结构的数量是不是正好是bafhp-&gt;af_oderpnr</span></span></span><br><span class="line"><span class="params">    tmpmnr = retval - bafhp-&gt;af_oderpnr;</span></span><br><span class="line"><span class="params">    <span class="comment">//根据地址连续的msadsc_t结构挂载到bafhlst_t结构中</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (continumsadsc_add_bafhlst(mareap, bafhp, mstat, &amp;mstat[bafhp-&gt;af_o</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="comment">//如果地址连续的msadsc_t结构的数量正好是bafhp-&gt;af_oderpnr则完成,否则返回再次进</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (tmpmnr == <span class="number">0</span>)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      *rfmnr = tmpmnr;</span></span><br><span class="line"><span class="params">      *rfend = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="comment">//挂载bafhp-&gt;af_oderpnr地址连续的msadsc_t结构到bafhlst_t中</span></span></span><br><span class="line"><span class="params">    *rfstat = &amp;mstat[bafhp-&gt;af_oderpnr];</span></span><br><span class="line"><span class="params">    <span class="comment">//还剩多少个地址连续的msadsc_t结构</span></span></span><br><span class="line"><span class="params">    *rfmnr = tmpmnr;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> merlove_continumsadsc_mareabafh(<span class="type">memarea_t</span> *mareap, <span class="type">msadsc_t</span> *mstat, msa</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> mnridx = mnr;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *fstat = mstat, *fend = mend;</span></span><br><span class="line"><span class="params">  <span class="comment">//如果mnridx &gt; 0并且NULL != fend就循环调用continumsadsc_mareabafh_core函数,而m</span></span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (; (mnridx &gt; <span class="number">0</span> &amp;&amp; <span class="literal">NULL</span> != fend);)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//为一段地址连续的msadsc_t结构寻找合适m_mdmlielst数组中的bafhlst_t结构</span></span></span><br><span class="line"><span class="params">    continumsadsc_mareabafh_core(mareap, &amp;fstat, &amp;fend, &amp;mnridx)</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> merlove_scan_continumsadsc(<span class="type">memarea_t</span> *mareap, <span class="type">msadsc_t</span> *fmstat, <span class="type">uint_t</span></span></span><br><span class="line"><span class="params"><span class="type">msadsc_t</span> **retmsastatp, <span class="type">msadsc_t</span> **re</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">u32_t</span> muindx = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">msadflgs_t</span> *mdfp = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *msastat = fmstat;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> retfindmnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">bool_t</span> rets = FALSE;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> tmidx = *fntmsanr;</span></span><br><span class="line"><span class="params">  <span class="comment">//从外层函数的fntmnr变量开始遍历所有msadsc_t结构</span></span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (; tmidx &lt; fmsanr; tmidx++)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//一个msadsc_t结构是否属于这个内存区,是否空闲</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (msastat[tmidx].md_indxflgs.mf_marty == mdfp-&gt;mf_marty &amp;&amp;</span></span><br><span class="line"><span class="params">    <span class="number">0</span> == msastat[tmidx].md_indxflgs.mf_uindx &amp;&amp;</span></span><br><span class="line"><span class="params">    MF_MOCTY_FREE == msastat[tmidx].md_indxflgs.mf_mocty &amp;&amp;</span></span><br><span class="line"><span class="params">    PAF_NO_ALLOC == msastat[tmidx].md_phyadrs.paf_alloc)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="comment">//返回从这个msadsc_t结构开始到下一个非空闲、地址非连续的msadsc_t结构对应的msadsc</span></span></span><br><span class="line"><span class="params">      rets = scan_len_msadsc(&amp;msastat[tmidx], mdfp, fmsanr, &amp;retfindmnr)</span></span><br><span class="line"><span class="params">      <span class="comment">//下一轮开始的msadsc_t结构索引</span></span></span><br><span class="line"><span class="params">      *fntmsanr = tmidx + retfindmnr + <span class="number">1</span>;</span></span><br><span class="line"><span class="params">      <span class="comment">//当前地址连续msadsc_t结构的开始地址</span></span></span><br><span class="line"><span class="params">      *retmsastatp = &amp;msastat[tmidx];</span></span><br><span class="line"><span class="params">      <span class="comment">//当前地址连续msadsc_t结构的结束地址</span></span></span><br><span class="line"><span class="params">      *retmsaendp = &amp;msastat[tmidx + retfindmnr];</span></span><br><span class="line"><span class="params">      <span class="comment">//当前有多少个地址连续msadsc_t结构</span></span></span><br><span class="line"><span class="params">      *retfmnr = retfindmnr + <span class="number">1</span>;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> merlove_mem_onmemarea(<span class="type">memarea_t</span> *mareap, <span class="type">msadsc_t</span> *mstat, <span class="type">uint_t</span> msanr)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *retstatmsap = <span class="literal">NULL</span>, *retendmsap = <span class="literal">NULL</span>, *fntmsap = mstat;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> retfindmnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> fntmnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">bool_t</span> retscan = FALSE;</span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (; fntmnr &lt; msanr;)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//获取最多且地址连续的msadsc_t结构体的开始、结束地址、一共多少个msadsc_t结构体,下</span></span></span><br><span class="line"><span class="params">    retscan = merlove_scan_continumsadsc(mareap, fntmsap, &amp;fntmnr, msanr,</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (<span class="literal">NULL</span> != retstatmsap &amp;&amp; <span class="literal">NULL</span> != retendmsap)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="comment">//把一组连续的msadsc_t结构体挂载到合适的m_mdmlielst数组中的bafhlst_t结构中</span></span></span><br><span class="line"><span class="params">      merlove_continumsadsc_mareabafh(mareap, retstatmsap, retendmsap, retfi</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化汇总</strong>
<ul>
<li>在先前的init_memmgr函数中调用上述函数</li>
<li>init_msadsc、init_memarea函数是可以交换次序的,俩互不影响,但必须最先开始调用,而后面的函数要依赖它们生成的数据结构</li>
<li>但是init_search_krloccupymm函数必须要在init_merlove_mem函数之前被调用,因为init_merlove_mem 函数在合并页面时,必须先知道哪些页面被占用了
<ul>
<li>**init_memmgrob函数:**phymmarge_t结构体的地址和数量、msadsc_t结构体的地址和数据、memarea_t结构体的地址和数量都保存在了kmachbsp变量中,这个变量其实不是用来管理内存的,而且它里面放的是物理地址;<strong>但内核使用的是虚拟地址,需要一个专用的数据结构进行转换用于内存管理</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_memmgr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化内存页结构</span></span><br><span class="line">  init_msadsc();</span><br><span class="line">  <span class="comment">//初始化内存区结构</span></span><br><span class="line">  init_memarea();</span><br><span class="line">  <span class="comment">//处理内存占用</span></span><br><span class="line">  init_search_krloccupymm(&amp;kmachbsp);</span><br><span class="line">  <span class="comment">//合并内存页到内存区中</span></span><br><span class="line">  init_merlove_mem();</span><br><span class="line">  init_memmgrob();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cosmos/include/halinc/halglobal.c</span></span><br><span class="line">HAL_DEFGLOB_VARIABLE(<span class="type">memmgrob_t</span>,memmgrob);</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MEMMGROB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> mo_list;</span><br><span class="line">  <span class="type">spinlock_t</span> mo_lock; <span class="comment">//保护自身自旋锁</span></span><br><span class="line">  <span class="type">uint_t</span> mo_stus; <span class="comment">//状态</span></span><br><span class="line">  <span class="type">uint_t</span> mo_flgs; <span class="comment">//标志</span></span><br><span class="line">  <span class="type">u64_t</span> mo_memsz; <span class="comment">//内存大小</span></span><br><span class="line">  <span class="type">u64_t</span> mo_maxpages; <span class="comment">//内存最大页面数</span></span><br><span class="line">  <span class="type">u64_t</span> mo_freepages; <span class="comment">//内存最大空闲页面数</span></span><br><span class="line">  <span class="type">u64_t</span> mo_alocpages; <span class="comment">//内存最大分配页面数</span></span><br><span class="line">  <span class="type">u64_t</span> mo_resvpages; <span class="comment">//内存保留页面数</span></span><br><span class="line">  <span class="type">u64_t</span> mo_horizline; <span class="comment">//内存分配水位线</span></span><br><span class="line">  <span class="type">phymmarge_t</span>* mo_pmagestat; <span class="comment">//内存空间布局结构指针</span></span><br><span class="line">  <span class="type">u64_t</span> mo_pmagenr;</span><br><span class="line">  <span class="type">msadsc_t</span>* mo_msadscstat; <span class="comment">//内存页面结构指针</span></span><br><span class="line">  <span class="type">u64_t</span> mo_msanr;</span><br><span class="line">  <span class="type">memarea_t</span>* mo_mareastat; <span class="comment">//内存区结构指针</span></span><br><span class="line">  <span class="type">u64_t</span> mo_mareanr;</span><br><span class="line">&#125;<span class="type">memmgrob_t</span>;</span><br><span class="line"><span class="comment">//cosmos/hal/x86/memmgrinit.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memmgrob_t_init</span><span class="params">(<span class="type">memmgrob_t</span> *initp)</span></span><br><span class="line">&#123;</span><br><span class="line">  list_init(&amp;initp-&gt;mo_list);</span><br><span class="line">  knl_spinlock_init(&amp;initp-&gt;mo_lock);</span><br><span class="line">  initp-&gt;mo_stus = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;mo_flgs = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;mo_memsz = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;mo_maxpages = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;mo_freepages = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;mo_alocpages = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;mo_resvpages = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;mo_horizline = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;mo_pmagestat = <span class="literal">NULL</span>;</span><br><span class="line">  initp-&gt;mo_pmagenr = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;mo_msadscstat = <span class="literal">NULL</span>;</span><br><span class="line">  initp-&gt;mo_msanr = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;mo_mareastat = <span class="literal">NULL</span>;</span><br><span class="line">  initp-&gt;mo_mareanr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_memmgrob</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">machbstart_t</span> *mbsp = &amp;kmachbsp;</span><br><span class="line">  <span class="type">memmgrob_t</span> *mobp = &amp;memmgrob;</span><br><span class="line">  memmgrob_t_init(mobp);</span><br><span class="line">  mobp-&gt;mo_pmagestat = (<span class="type">phymmarge_t</span> *)phyadr_to_viradr((<span class="type">adr_t</span>)mbsp-&gt;mb_e820e</span><br><span class="line">  mobp-&gt;mo_pmagenr = mbsp-&gt;mb_e820exnr;</span><br><span class="line">  mobp-&gt;mo_msadscstat = (<span class="type">msadsc_t</span> *)phyadr_to_viradr((<span class="type">adr_t</span>)mbsp-&gt;mb_memmapp</span><br><span class="line">  mobp-&gt;mo_msanr = mbsp-&gt;mb_memmapnr;</span><br><span class="line">  mobp-&gt;mo_mareastat = (<span class="type">memarea_t</span> *)phyadr_to_viradr((<span class="type">adr_t</span>)mbsp-&gt;mb_memznpa</span><br><span class="line">  mobp-&gt;mo_mareanr = mbsp-&gt;mb_memznnr;</span><br><span class="line">  mobp-&gt;mo_memsz = mbsp-&gt;mb_memmapnr &lt;&lt; PSHRSIZE;</span><br><span class="line">  mobp-&gt;mo_maxpages = mbsp-&gt;mb_memmapnr;</span><br><span class="line">  <span class="type">uint_t</span> aidx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> i = <span class="number">0</span>; i &lt; mobp-&gt;mo_msanr; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == mobp-&gt;mo_msadscstat[i].md_indxflgs.mf_uindx &amp;&amp;</span><br><span class="line">    MF_MOCTY_KRNL == mobp-&gt;mo_msadscstat[i].md_indxflgs.mf_mocty &amp;&amp;</span><br><span class="line">    PAF_ALLOC == mobp-&gt;mo_msadscstat[i].md_phyadrs.paf_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">      aidx++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mobp-&gt;mo_alocpages = aidx;</span><br><span class="line">  mobp-&gt;mo_freepages = mobp-&gt;mo_maxpages - mobp-&gt;mo_alocpages;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>本节重点</strong>
<ul>
<li>首先,从初始化msadsc_t结构开始,在内存中建立msadsc_t结构的实例变量,每个物理内存页面一个msadsc_t结构的实例变量</li>
<li>然后初始化memarea_t结构,在msadsc_t结构的实例变量之后,每个内存区一个memarea_t结构实例变量</li>
<li>接着标记哪些msadsc_t结构对应的物理内存被内核占用了,这些被标记msadsc_t结构是不能纳入内存管理结构中去的</li>
<li>最后,把所有的空闲msadsc_t结构按最大地址连续的形式组织起来,挂载到memarea_t结构下的memdivmer_t结构中,对应的dm_mdmlielst数组中</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="63-如何实现内存页的分配与释放"><a class="markdownIt-Anchor" href="#63-如何实现内存页的分配与释放"></a> 6.3 如何实现内存页的分配与释放</h2>
<ul>
<li><strong>内存页的分配</strong>
<ul>
<li>实现一次只分配一个页面:需要写一段循环代码,在其中遍历出一个空闲的msadsc_t结构,然后就可以返回</li>
<li>内存管理器为内核,驱动,还有应用提供服务,对请求内存页面的多少,内存页面是否连续,内存页面所处的物理地址都有要求,问题变得复杂,从<strong>内存分配的接口函数</strong>入手解决问题</li>
<li><strong>内存管理代码的结构</strong>
<ul>
<li>接口函数(返回msadsc_t接口指针)调用框架函数,框架函数调用核心函数</li>
<li><strong>不直接返回物理地址的原因</strong>：物理内存管理器是最底层的内存管理器,上层代码中可能需要页面相关的信息,所以直接返回页面对应msadsc_t结构的指针</li>
<li>还有一个参数用于返回实际分配的页面数(retrealpnr)</li>
</ul>
</li>
</ul>
</li>
<li>在实现接口函数时,onmpgs_retn_bafhlst 函数返回的两个bafhlst_t结构指针
<ul>
<li>若是相等的,在 mm_reldpgsdivmsa_bafhl 函数中只要取出bafhlst_t结构中对应的msadsc_t结构返回</li>
<li>不相等时需要分隔连续的 msadsc_t 结构了,通过 mm_reldpgsdivmsa_bafhl 函数来处理这个问题</li>
</ul>
</li>
<li><strong>算法执行步骤</strong>
<ol>
<li>根据一个页面的请求返回 m_mdmlielst 数组中的第 0 个 bafhlst_t 结构</li>
<li>如果第 0 个 bafhlst_t 结构中有 msadsc_t 结构就直接返回,若没有 msadsc_t 结构,<br />
就会继续查找 m_mdmlielst 数组中的第 1 个 bafhlst_t 结构</li>
<li>如果第 1 个 bafhlst_t 结构中也没有 msadsc_t 结构,就会继续查找 m_mdmlielst 数组<br />
中的第 2 个 bafhlst_t 结构</li>
<li>如果第 2 个 bafhlst_t 结构中有 msadsc_t 结构,记住第 2 个 bafhlst_t 结构中对应是 4<br />
个连续的 msadsc_t 结构.这时让这 4 个连续的 msadsc_t 结构从第 2 个 bafhlst_t 结构<br />
中脱离</li>
<li>把这 4 个连续的 msadsc_t 结构,对半分割成 2 个双 msadsc_t 结构,把其中一个双<br />
msadsc_t 结构挂载到第 1 个 bafhlst_t 结构中</li>
<li>把剩下一个双 msadsc_t 结构,继续对半分割成两个单 msadsc_t 结构,把其中一个单<br />
msadsc_t 结构挂载到第 0 个 bafhlst_t 结构中,剩下一个单 msadsc_t 结构返回给请求<br />
者,完成内存分配</li>
</ol>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-17-41.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-17-41.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内存分配算法示意图" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存分配接口函数</span></span><br><span class="line"><span class="comment">// cosmos/hal/x86/memdivmer.c</span></span><br><span class="line"><span class="comment">//内存分配页面框架函数</span></span><br><span class="line"><span class="type">msadsc_t</span> *<span class="title function_">mm_divpages_fmwk</span><span class="params">(<span class="type">memmgrob_t</span> *mmobjp, <span class="type">uint_t</span> pages, <span class="type">uint_t</span> *retrelpnr</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//返回mrtype对应的内存区结构的指针</span></span></span><br><span class="line"><span class="params">  <span class="type">memarea_t</span> *marea = onmrtype_retn_marea(mmobjp, mrtype);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == marea)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    *retrelpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> retpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//内存分配的核心函数</span></span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *retmsa = mm_divpages_core(marea, pages, &amp;retpnr, flgs);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == retmsa)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    *retrelpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  *retrelpnr = retpnr;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> retmsa;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//内存分配页面接口</span></span></span><br><span class="line"><span class="params"><span class="comment">//mmobjp-&gt;内存管理数据结构指针</span></span></span><br><span class="line"><span class="params"><span class="comment">//pages-&gt;请求分配的内存页面数</span></span></span><br><span class="line"><span class="params"><span class="comment">//retrealpnr-&gt;存放实际分配内存页面数的指针</span></span></span><br><span class="line"><span class="params"><span class="comment">//mrtype-&gt;请求的分配内存页面的内存区类型</span></span></span><br><span class="line"><span class="params"><span class="comment">//flgs-&gt;请求分配的内存页面的标志位</span></span></span><br><span class="line"><span class="params"><span class="type">msadsc_t</span> *mm_division_pages(<span class="type">memmgrob_t</span> *mmobjp, <span class="type">uint_t</span> pages, <span class="type">uint_t</span> *retrealp</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == mmobjp || <span class="literal">NULL</span> == retrealpnr || <span class="number">0</span> == mrtype)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> retpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *retmsa = mm_divpages_fmwk(mmobjp, pages, &amp;retpnr, mrtype, flgs);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == retmsa)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    *retrealpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  *retrealpnr = retpnr;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> retmsa;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 内存分配的核心函数</span></span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> onmpgs_retn_bafhlst(<span class="type">memarea_t</span> *malckp, <span class="type">uint_t</span> pages, <span class="type">bafhlst_t</span> **retrel</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//获取bafhlst_t结构数组的开始地址</span></span></span><br><span class="line"><span class="params">  <span class="type">bafhlst_t</span> *bafhstat = malckp-&gt;ma_mdmdata.dm_mdmlielst;</span></span><br><span class="line"><span class="params">  <span class="comment">//根据分配页面数计算出分配页面在dm_mdmlielst数组中下标</span></span></span><br><span class="line"><span class="params">  <span class="type">sint_t</span> dividx = retn_divoder(pages);</span></span><br><span class="line"><span class="params">  <span class="comment">//从第dividx个数组元素开始搜索</span></span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (<span class="type">sint_t</span> idx = dividx; idx &lt; MDIVMER_ARR_LMAX; idx++)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//如果第idx个数组元素对应的一次可分配连续的页面数大于等于请求的页面数,且其中的可分配对象</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (bafhstat[idx].af_oderpnr &gt;= pages &amp;&amp; <span class="number">0</span> &lt; bafhstat[idx].af_fobjnr)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="comment">//返回请求分配的bafhlst_t结构指针</span></span></span><br><span class="line"><span class="params">      *retrelbafh = &amp;bafhstat[dividx];</span></span><br><span class="line"><span class="params">      <span class="comment">//返回实际分配的bafhlst_t结构指针</span></span></span><br><span class="line"><span class="params">      *retdivbafh = &amp;bafhstat[idx];</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  *retrelbafh = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  *retdivbafh = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">msadsc_t</span> *mm_reldivpages_onmarea(<span class="type">memarea_t</span> *malckp, <span class="type">uint_t</span> pages, <span class="type">uint_t</span> *retr</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">bafhlst_t</span> *retrelbhl = <span class="literal">NULL</span>, *retdivbhl = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//根据页面数在内存区的m_mdmlielst数组中找出其中请求分配页面的bafhlst_t结构（retrelb</span></span></span><br><span class="line"><span class="params">  <span class="type">bool_t</span> rets = onmpgs_retn_bafhlst(malckp, pages, &amp;retrelbhl, &amp;retdivbhl);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (FALSE == rets)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    *retrelpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> retpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//实际在bafhlst_t结构中分配页面</span></span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *retmsa = mm_reldpgsdivmsa_bafhl(malckp, pages, &amp;retpnr, retrelbh</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == retmsa)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    *retrelpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  *retrelpnr = retpnr;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> retmsa;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">msadsc_t</span> *mm_divpages_core(<span class="type">memarea_t</span> *mareap, <span class="type">uint_t</span> pages, <span class="type">uint_t</span> *retrealpnr</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> retpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *retmsa = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="type">cpuflg_t</span> cpuflg;</span></span><br><span class="line"><span class="params">  <span class="comment">//内存区加锁</span></span></span><br><span class="line"><span class="params">  knl_spinlock_cli(&amp;mareap-&gt;ma_lock, &amp;cpuflg);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (DMF_RELDIV == flgs)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//分配内存</span></span></span><br><span class="line"><span class="params">    retmsa = mm_reldivpages_onmarea(mareap, pages, &amp;retpnr);</span></span><br><span class="line"><span class="params">    <span class="keyword">goto</span> ret_step;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  retmsa = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  retpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  ret_step:</span></span><br><span class="line"><span class="params">  <span class="comment">//内存区锁</span></span></span><br><span class="line"><span class="params">  knl_spinunlock_sti(&amp;mareap-&gt;ma_lock, &amp;cpuflg);</span></span><br><span class="line"><span class="params">  *retrealpnr = retpnr;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> retmsa;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// onmpgs_retn_bafhlst 函数返回的两个bafhlst_t结构指针</span></span></span><br><span class="line"><span class="params"><span class="comment">// 若是相等的,在 mm_reldpgsdivmsa_bafhl 函数中只要取出bafhlst_t结构中对应的msadsc_t结构返回就好了</span></span></span><br><span class="line"><span class="params"><span class="comment">// 不相等时需要分隔连续的 msadsc_t 结构了,通过 mm_reldpgsdivmsa_bafhl 函数来处理这个问题</span></span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> mrdmb_add_msa_bafh(<span class="type">bafhlst_t</span> *bafhp, <span class="type">msadsc_t</span> *msastat, <span class="type">msadsc_t</span> *msaen</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//把一段连续的msadsc_t结构加入到它所对应的bafhlst_t结构中</span></span></span><br><span class="line"><span class="params">  msastat-&gt;md_indxflgs.mf_olkty = MF_OLKTY_ODER;</span></span><br><span class="line"><span class="params">  msastat-&gt;md_odlink = msaend;</span></span><br><span class="line"><span class="params">  msaend-&gt;md_indxflgs.mf_olkty = MF_OLKTY_BAFH;</span></span><br><span class="line"><span class="params">  msaend-&gt;md_odlink = bafhp;</span></span><br><span class="line"><span class="params">  list_add(&amp;msastat-&gt;md_list, &amp;bafhp-&gt;af_frelst);</span></span><br><span class="line"><span class="params">  bafhp-&gt;af_mobjnr++;</span></span><br><span class="line"><span class="params">  bafhp-&gt;af_fobjnr++;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">msadsc_t</span> *mm_divpages_opmsadsc(<span class="type">msadsc_t</span> *msastat, <span class="type">uint_t</span> mnr)</span></span><br><span class="line"><span class="params">&#123; <span class="comment">//单个msadsc_t结构的情况</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (mend == msastat)</span></span><br><span class="line"><span class="params">  &#123;<span class="comment">//增加msadsc_t结构中分配计数,分配标志位设置为1</span></span></span><br><span class="line"><span class="params">    msastat-&gt;md_indxflgs.mf_uindx++;</span></span><br><span class="line"><span class="params">    msastat-&gt;md_phyadrs.paf_alloc = PAF_ALLOC;</span></span><br><span class="line"><span class="params">    msastat-&gt;md_indxflgs.mf_olkty = MF_OLKTY_ODER;</span></span><br><span class="line"><span class="params">    msastat-&gt;md_odlink = mend;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> msastat;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  msastat-&gt;md_indxflgs.mf_uindx++;</span></span><br><span class="line"><span class="params">  msastat-&gt;md_phyadrs.paf_alloc = PAF_ALLOC;</span></span><br><span class="line"><span class="params">  <span class="comment">//多个msadsc_t结构的情况下,末端msadsc_t结构也设置已分配状态</span></span></span><br><span class="line"><span class="params">  mend-&gt;md_indxflgs.mf_uindx++;</span></span><br><span class="line"><span class="params">  mend-&gt;md_phyadrs.paf_alloc = PAF_ALLOC;</span></span><br><span class="line"><span class="params">  msastat-&gt;md_indxflgs.mf_olkty = MF_OLKTY_ODER;</span></span><br><span class="line"><span class="params">  msastat-&gt;md_odlink = mend;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> msastat;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> mm_retnmsaob_onbafhlst(<span class="type">bafhlst_t</span> *bafhp, <span class="type">msadsc_t</span> **retmstat, <span class="type">msadsc_t</span></span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//取出一个msadsc_t结构</span></span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *tmp = list_entry(bafhp-&gt;af_frelst.next, <span class="type">msadsc_t</span>, md_list);</span></span><br><span class="line"><span class="params">  <span class="comment">//从链表中删除</span></span></span><br><span class="line"><span class="params">  list_del(&amp;tmp-&gt;md_list);</span></span><br><span class="line"><span class="params">  <span class="comment">//减少bafhlst_t结构中的msadsc_t计数</span></span></span><br><span class="line"><span class="params">  bafhp-&gt;af_mobjnr--;</span></span><br><span class="line"><span class="params">  bafhp-&gt;af_fobjnr--;</span></span><br><span class="line"><span class="params">  <span class="comment">//增加分配计数</span></span></span><br><span class="line"><span class="params">  bafhp-&gt;af_freindx++;</span></span><br><span class="line"><span class="params">  <span class="comment">//返回msadsc_t结构</span></span></span><br><span class="line"><span class="params">  *retmstat = tmp;</span></span><br><span class="line"><span class="params">  <span class="comment">//返回当前msadsc_t结构连续的那个结尾的msadsc_t结构</span></span></span><br><span class="line"><span class="params">  *retmend = (<span class="type">msadsc_t</span> *)tmp-&gt;md_odlink;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (MF_OLKTY_BAFH == tmp-&gt;md_indxflgs.mf_olkty)</span></span><br><span class="line"><span class="params">  &#123;<span class="comment">//如果只单个msadsc_t结构,那就是它本身</span></span></span><br><span class="line"><span class="params">    *retmend = tmp;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">msadsc_t</span> *mm_reldpgsdivmsa_bafhl(<span class="type">memarea_t</span> *malckp, <span class="type">uint_t</span> pages, <span class="type">uint_t</span> *retr</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *retmsa = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="type">bool_t</span> rets = FALSE;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *retmstat = <span class="literal">NULL</span>, *retmend = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//处理相等的情况</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (relbfl == divbfl)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//从bafhlst_t结构中获取msadsc_t结构的开始与结束地址</span></span></span><br><span class="line"><span class="params">    rets = mm_retnmsaob_onbafhlst(relbfl, &amp;retmstat, &amp;retmend);</span></span><br><span class="line"><span class="params">    <span class="comment">//设置msadsc_t结构的相关信息表示已经删除</span></span></span><br><span class="line"><span class="params">    retmsa = mm_divpages_opmsadsc(retmstat, relbfl-&gt;af_oderpnr);</span></span><br><span class="line"><span class="params">    <span class="comment">//返回实际的分配页数</span></span></span><br><span class="line"><span class="params">    *retrelpnr = relbfl-&gt;af_oderpnr;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> retmsa;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//处理不等的情况</span></span></span><br><span class="line"><span class="params">  <span class="comment">//从bafhlst_t结构中获取msadsc_t结构的开始与结束地址</span></span></span><br><span class="line"><span class="params">  rets = mm_retnmsaob_onbafhlst(divbfl, &amp;retmstat, &amp;retmend);</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> divnr = divbfl-&gt;af_oderpnr;</span></span><br><span class="line"><span class="params">  <span class="comment">//从高bafhlst_t数组元素中向下遍历</span></span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (<span class="type">bafhlst_t</span> *tmpbfl = divbfl - <span class="number">1</span>; tmpbfl &gt;= relbfl; tmpbfl--)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//开始分割连续的msadsc_t结构,把剩下的一段连续的msadsc_t结构加入到对应该bafhlst</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (mrdmb_add_msa_bafh(tmpbfl, &amp;retmstat[tmpbfl-&gt;af_oderpnr], (msadsc_</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      system_error(<span class="string">&quot;mrdmb_add_msa_bafh fail\n&quot;</span>);</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    retmstat-&gt;md_odlink = &amp;retmstat[tmpbfl-&gt;af_oderpnr - <span class="number">1</span>];</span></span><br><span class="line"><span class="params">    divnr -= tmpbfl-&gt;af_oderpnr;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  retmsa = mm_divpages_opmsadsc(retmstat, divnr);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == retmsa)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    *retrelpnr = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  *retrelpnr = relbfl-&gt;af_oderpnr;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> retmsa;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>内存页的释放</strong>
<ul>
<li><strong>内存释放页面的代码结构</strong>:接口函数调用框架函数,框架函数调用核心函数,函数返回值为bool类型表示内存页面释放操作成功与否</li>
<li>框架函数中内存区是由msadsc_t结构中获取的,因为之前该结构中保留了所在内存区的类型,故可以查到并返回内存区</li>
<li>在经过 mm_merpages_opmsadsc 函数操作之后并没有将 msadsc_t 结构加入到对应的 bafhlst_t 结构中,利用 mm_merpages_onbafhlst 函数完成</li>
<li><strong>释放算法的核心逻辑</strong>:<strong>最核心的是要对空闲页面进行合并,合并成更大的连续的内存页面</strong></li>
</ul>
</li>
<li><strong>算法演绎</strong>
<ol>
<li>释放一个页面,会返回 m_mdmlielst 数组中的第 0 个 bafhlst_t 结构</li>
<li>设置这个页面对应的 msadsc_t 结构的相关信息,表示已经执行了释放操作<br />
开始查看第 0 个 bafhlst_t 结构中有没有空闲的 msadsc_t,并且它和要释放的<br />
msadsc_t 对应的物理地址是连续的.没有则把这个释放的 msadsc_t 挂载第 0 个<br />
bafhlst_t 结构中,算法结束,否则进入下一步</li>
<li>把第 0 个 bafhlst_t 结构中的 msadsc_t 结构拿出来与释放的 msadsc_t 结构,合并成<br />
2 个连续且更大的 msadsc_t</li>
<li>继续查看第 1 个 bafhlst_t 结构中有没有空闲的 msadsc_t,而且这个空闲 msadsc_t 要<br />
和上一步合并的 2 个 msadsc_t 对应的物理地址是连续的.没有则把这个合并的 2 个<br />
msadsc_t 挂载第 1 个 bafhlst_t 结构中,算法结束,否则进入下一步</li>
<li>把第 1 个 bafhlst_t 结构中的 2 个连续的 msadsc_t 结构,还有合并的 2 个地址连续的<br />
msadsc_t 结构拿出来,合并成 4 个连续且更大的 msadsc_t 结构</li>
<li>继续查看第 2 个 bafhlst_t 结构,有没有空闲的 msadsc_t 结构,并且它要和上一步合<br />
并的 4 个 msadsc_t 结构对应的物理地址是连续的.没有则把这个合并的 4 个<br />
msadsc_t 挂载第 2 个 bafhlst_t 结构中,算法结束</li>
</ol>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-18-32.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-18-32.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内存释放算法" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放内存页面核心</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">mm_merpages_core</span><span class="params">(<span class="type">memarea_t</span> *marea, <span class="type">msadsc_t</span> *freemsa, <span class="type">uint_t</span> freepgs)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool_t</span> rets = FALSE;</span><br><span class="line">  <span class="type">cpuflg_t</span> cpuflg;</span><br><span class="line">  <span class="comment">//内存区加锁</span></span><br><span class="line">  knl_spinlock_cli(&amp;marea-&gt;ma_lock, &amp;cpuflg);</span><br><span class="line">  <span class="comment">//针对一个内存区进行操作</span></span><br><span class="line">  rets = mm_merpages_onmarea(marea, freemsa, freepgs);</span><br><span class="line">  <span class="comment">//内存区解锁</span></span><br><span class="line">  knl_spinunlock_sti(&amp;marea-&gt;ma_lock, &amp;cpuflg);</span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放内存页面框架函数</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">mm_merpages_fmwk</span><span class="params">(<span class="type">memmgrob_t</span> *mmobjp, <span class="type">msadsc_t</span> *freemsa, <span class="type">uint_t</span> freepgs)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取要释放msadsc_t结构所在的内存区</span></span><br><span class="line">  <span class="type">memarea_t</span> *marea = onfrmsa_retn_marea(mmobjp, freemsa, freepgs);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == marea)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//释放内存页面的核心函数</span></span><br><span class="line">  <span class="type">bool_t</span> rets = mm_merpages_core(marea, freemsa, freepgs);</span><br><span class="line">  <span class="keyword">if</span> (FALSE == rets)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放内存页面接口</span></span><br><span class="line"><span class="comment">//mmobjp-&gt;内存管理数据结构指针</span></span><br><span class="line"><span class="comment">//freemsa-&gt;释放内存页面对应的首个msadsc_t结构指针</span></span><br><span class="line"><span class="comment">//freepgs-&gt;请求释放的内存页面数</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">mm_merge_pages</span><span class="params">(<span class="type">memmgrob_t</span> *mmobjp, <span class="type">msadsc_t</span> *freemsa, <span class="type">uint_t</span> freepgs)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == mmobjp || <span class="literal">NULL</span> == freemsa || <span class="number">1</span> &gt; freepgs)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用释放内存页面的框架函数</span></span><br><span class="line">  <span class="type">bool_t</span> rets = mm_merpages_fmwk(mmobjp, freemsa, freepgs);</span><br><span class="line">  <span class="keyword">if</span> (FALSE == rets)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 mm_merpages_core 函数中,调用 mm_merge_pages_onmarea 函数</span></span><br><span class="line"><span class="type">sint_t</span> <span class="title function_">mm_merpages_opmsadsc</span><span class="params">(<span class="type">bafhlst_t</span> *bafh, <span class="type">msadsc_t</span> *freemsa, <span class="type">uint_t</span> freepgs</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *fmend = (<span class="type">msadsc_t</span> *)freemsa-&gt;md_odlink;</span></span><br><span class="line"><span class="params">  <span class="comment">//处理只有一个单页的情况</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (freemsa == fmend)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//页面的分配计数减1</span></span></span><br><span class="line"><span class="params">    freemsa-&gt;md_indxflgs.mf_uindx--;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (<span class="number">0</span> &lt; freemsa-&gt;md_indxflgs.mf_uindx)</span></span><br><span class="line"><span class="params">    &#123;<span class="comment">//如果依然大于0说明它是共享页面 直接返回1指示不需要进行下一步操作</span></span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> <span class="number">1</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="comment">//设置页未分配的标志</span></span></span><br><span class="line"><span class="params">    freemsa-&gt;md_phyadrs.paf_alloc = PAF_NO_ALLOC;</span></span><br><span class="line"><span class="params">    freemsa-&gt;md_indxflgs.mf_olkty = MF_OLKTY_BAFH;</span></span><br><span class="line"><span class="params">    freemsa-&gt;md_odlink = bafh;<span class="comment">//指向所属的bafhlst_t结构</span></span></span><br><span class="line"><span class="params">    <span class="comment">//返回2指示需要进行下一步操作</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="number">2</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//多个页面的超始页面和结束页面都要减一</span></span></span><br><span class="line"><span class="params">  freemsa-&gt;md_indxflgs.mf_uindx--;</span></span><br><span class="line"><span class="params">  fmend-&gt;md_indxflgs.mf_uindx--;</span></span><br><span class="line"><span class="params">  <span class="comment">//如果依然大于0说明它是共享页面 直接返回1指示不需要进行下一步操作</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="number">0</span> &lt; freemsa-&gt;md_indxflgs.mf_uindx)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="number">1</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置起始、结束页页未分配的标志</span></span></span><br><span class="line"><span class="params">  freemsa-&gt;md_phyadrs.paf_alloc = PAF_NO_ALLOC;</span></span><br><span class="line"><span class="params">  fmend-&gt;md_phyadrs.paf_alloc = PAF_NO_ALLOC;</span></span><br><span class="line"><span class="params">  freemsa-&gt;md_indxflgs.mf_olkty = MF_OLKTY_ODER;</span></span><br><span class="line"><span class="params">  <span class="comment">//起始页面指向结束页面</span></span></span><br><span class="line"><span class="params">  freemsa-&gt;md_odlink = fmend;</span></span><br><span class="line"><span class="params">  fmend-&gt;md_indxflgs.mf_olkty = MF_OLKTY_BAFH;</span></span><br><span class="line"><span class="params">  <span class="comment">//结束页面指向所属的bafhlst_t结构</span></span></span><br><span class="line"><span class="params">  fmend-&gt;md_odlink = bafh;</span></span><br><span class="line"><span class="params">  <span class="comment">//返回2指示需要进行下一步操作</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="number">2</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> onfpgs_retn_bafhlst(<span class="type">memarea_t</span> *malckp, <span class="type">uint_t</span> freepgs, <span class="type">bafhlst_t</span> **retr</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//获取bafhlst_t结构数组的开始地址</span></span></span><br><span class="line"><span class="params">  <span class="type">bafhlst_t</span> *bafhstat = malckp-&gt;ma_mdmdata.dm_mdmlielst;</span></span><br><span class="line"><span class="params">  <span class="comment">//根据分配页面数计算出分配页面在dm_mdmlielst数组中下标</span></span></span><br><span class="line"><span class="params">  <span class="type">sint_t</span> dividx = retn_divoder(freepgs);</span></span><br><span class="line"><span class="params">  <span class="comment">//返回请求释放的bafhlst_t结构指针</span></span></span><br><span class="line"><span class="params">  *retrelbf = &amp;bafhstat[dividx];</span></span><br><span class="line"><span class="params">  <span class="comment">//返回最大释放的bafhlst_t结构指针</span></span></span><br><span class="line"><span class="params">  *retmerbf = &amp;bafhstat[MDIVMER_ARR_LMAX - <span class="number">1</span>];</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> mm_merpages_onmarea(<span class="type">memarea_t</span> *malckp, <span class="type">msadsc_t</span> *freemsa, <span class="type">uint_t</span> freepg</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">bafhlst_t</span> *prcbf = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="type">sint_t</span> pocs = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">bafhlst_t</span> *retrelbf = <span class="literal">NULL</span>, *retmerbf = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="type">bool_t</span> rets = FALSE;</span></span><br><span class="line"><span class="params">  <span class="comment">//根据freepgs返回请求释放的和最大释放的bafhlst_t结构指针</span></span></span><br><span class="line"><span class="params">  rets = onfpgs_retn_bafhlst(malckp, freepgs, &amp;retrelbf, &amp;retmerbf);</span></span><br><span class="line"><span class="params">  <span class="comment">//设置msadsc_t结构的信息,完成释放,返回1表示不需要下一步合并操作,返回2表示要进行合并操</span></span></span><br><span class="line"><span class="params">  <span class="type">sint_t</span> mopms = mm_merpages_opmsadsc(retrelbf, freemsa, freepgs);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="number">2</span> == mopms)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//把msadsc_t结构进行合并然后加入对应bafhlst_t结构</span></span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> mm_merpages_onbafhlst(freemsa, freepgs, retrelbf, retmerbf);</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="number">1</span> == mopms)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 在经过 mm_merpages_opmsadsc 函数操作之后并没有将 msadsc_t 结构加入到对应的 bafhlst_t 结构中,利用 mm_merpages_onbafhlst 函数完成</span></span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> mpobf_add_msadsc(<span class="type">bafhlst_t</span> *bafhp, <span class="type">msadsc_t</span> *freemstat, <span class="type">msadsc_t</span> *freem</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  freemstat-&gt;md_indxflgs.mf_olkty = MF_OLKTY_ODER;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置起始页面指向结束页</span></span></span><br><span class="line"><span class="params">  freemstat-&gt;md_odlink = freemend;</span></span><br><span class="line"><span class="params">  freemend-&gt;md_indxflgs.mf_olkty = MF_OLKTY_BAFH;</span></span><br><span class="line"><span class="params">  <span class="comment">//结束页面指向所属的bafhlst_t结构</span></span></span><br><span class="line"><span class="params">  freemend-&gt;md_odlink = bafhp;</span></span><br><span class="line"><span class="params">  <span class="comment">//把起始页面挂载到所属的bafhlst_t结构中</span></span></span><br><span class="line"><span class="params">  list_add(&amp;freemstat-&gt;md_list, &amp;bafhp-&gt;af_frelst);</span></span><br><span class="line"><span class="params">  <span class="comment">//增加bafhlst_t结构的空闲页面对象和总的页面对象的计数</span></span></span><br><span class="line"><span class="params">  bafhp-&gt;af_fobjnr++;</span></span><br><span class="line"><span class="params">  bafhp-&gt;af_mobjnr++;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">bool_t</span> mm_merpages_onbafhlst(<span class="type">msadsc_t</span> *freemsa, <span class="type">uint_t</span> freepgs, <span class="type">bafhlst_t</span> *rel</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">sint_t</span> rets = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="type">msadsc_t</span> *mnxs = freemsa, *mnxe = &amp;freemsa[freepgs - <span class="number">1</span>];</span></span><br><span class="line"><span class="params">  <span class="type">bafhlst_t</span> *tmpbf = relbf;</span></span><br><span class="line"><span class="params">  <span class="comment">//从实际要开始遍历,直到最高的那个bafhlst_t结构</span></span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (; tmpbf &lt; merbf; tmpbf++)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//查看最大地址连续、且空闲msadsc_t结构,如释放的是第0个msadsc_t结构我们就去查找第</span></span></span><br><span class="line"><span class="params">    rets = mm_find_cmsa2blk(tmpbf, &amp;mnxs, &amp;mnxe);</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (<span class="number">1</span> == rets)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">break</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//把合并的msadsc_t结构（从mnxs到mnxe）加入到对应的bafhlst_t结构中</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (mpobf_add_msadsc(tmpbf, mnxs, mnxe) == FALSE)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> FALSE;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> TRUE;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="64-如何管理内存对象"><a class="markdownIt-Anchor" href="#64-如何管理内存对象"></a> 6.4 如何管理内存对象</h2>
<ul>
<li>物理内存页面管理器一次分配至少一个页面,而对内存分页事一个页面4KB,即4096字节
<ul>
<li>对于小于一个页面的内存分配请求无能为力,<strong>故需要实现小于一个页面的内存请求分配</strong></li>
</ul>
</li>
<li><strong>malloc的启发</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一块15字节大小的内存空间</span></span><br><span class="line"><span class="comment">// 然后把字符串复制到分配的内存空间中</span></span><br><span class="line"><span class="comment">// 最后用字符串的形式打印那个块内存,并释放该内存空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *str;</span><br><span class="line">  <span class="comment">// 内存分配 存放15个char字符类型</span></span><br><span class="line">  str = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mem alloc err\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把hello world字符串复制到str开始的内存地址空间中</span></span><br><span class="line">  <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="comment">// 打印hello world字符串和它的地址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;String = %s, Address = %u\n&quot;</span>, str, str);</span><br><span class="line">  <span class="comment">// 释放分配的内存</span></span><br><span class="line">  <span class="built_in">free</span>(str);</span><br><span class="line">  <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对页进行细分</strong></li>
<li>从内存角度看,页最小是以字节为单位的;但从MMU角度看,内存是以页为单位的;故Cosmos的物理内存分配器以页为单位
<ul>
<li><strong>细分页</strong>:从MMU角度页不能细分,但从软件逻辑层面页可以细分
<ul>
<li>结合历史经验和硬件特性,可以把一个页面或连续的多个页面分成32字节,64字节,128字节,256字节,512字节,1024字节,2048字节,4096字节(一个页),该小块内存称为<strong>内存对象</strong></li>
</ul>
</li>
<li><strong>把一个或多个内存页面分配出来,作为一个内存对象的容器,在这个容器中容纳相同的内存对象,即同等大小的内存块</strong></li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-19-36.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-19-36.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内存对象视图" /></p>
<ul>
<li><strong>内存对象容器</strong>
<ul>
<li>内存容器要占用内存页面,需要内存对象计数信息、内存对象大小信息,还要能扩展容量</li>
<li>设计了四个数据结构：kmsob_t 用于表示内存对象容器,kmbext_t 用于表示内存对象容器的扩展内存,msomdc_t 和 msclst_t 用于管理内存对象容器占用的物理内存页面</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-20-01.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-20-01.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内存对象容器关系" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存对象数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_FREOBJH</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> oh_list; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">uint_t</span> oh_stus; <span class="comment">//对象状态</span></span><br><span class="line">  <span class="type">void</span>* oh_stat; <span class="comment">//对象的开始地址</span></span><br><span class="line">&#125;<span class="type">freobjh_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理内存对象容器占用的内存页面所对应的msadsc_t结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MSCLST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint_t</span> ml_msanr; <span class="comment">//多少个msadsc_t</span></span><br><span class="line">  <span class="type">uint_t</span> ml_ompnr; <span class="comment">//一个msadsc_t对应的连续的物理内存页面数</span></span><br><span class="line">  <span class="type">list_h_t</span> ml_list; <span class="comment">//挂载msadsc_t的链表</span></span><br><span class="line">&#125;<span class="type">msclst_t</span>;</span><br><span class="line"><span class="comment">//管理内存对象容器占用的内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MSOMDC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//msclst_t结构数组mc_lst[0]=1个连续页面的msadsc_t</span></span><br><span class="line">  <span class="comment">// mc_lst[1]=2个连续页面的msadsc_t</span></span><br><span class="line">  <span class="comment">// mc_lst[2]=4个连续页面的msadsc_t</span></span><br><span class="line">  <span class="comment">// mc_lst[3]=8个连续页面的msadsc_t</span></span><br><span class="line">  <span class="comment">// mc_lst[4]=16个连续页面的msadsc_t</span></span><br><span class="line">  <span class="type">msclst_t</span> mc_lst[MSCLST_MAX];</span><br><span class="line">  <span class="type">uint_t</span> mc_msanr; <span class="comment">//总共多个msadsc_t结构</span></span><br><span class="line">  <span class="type">list_h_t</span> mc_list;</span><br><span class="line">  <span class="comment">//内存对象容器第一个占用msadsc_t</span></span><br><span class="line">  <span class="type">list_h_t</span> mc_kmobinlst;</span><br><span class="line">  <span class="comment">//内存对象容器第一个占用msadsc_t对应的连续的物理内存页面数</span></span><br><span class="line">  <span class="type">uint_t</span> mc_kmobinpnr;</span><br><span class="line">&#125;<span class="type">msomdc_t</span>;</span><br><span class="line"><span class="comment">//管理内存对象容器扩展容量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_KMBEXT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> mt_list; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">adr_t</span> mt_vstat; <span class="comment">//内存对象容器扩展容量开始地址</span></span><br><span class="line">  <span class="type">adr_t</span> mt_vend; <span class="comment">//内存对象容器扩展容量结束地址</span></span><br><span class="line">  <span class="type">kmsob_t</span>* mt_kmsb; <span class="comment">//指向内存对象容器结构</span></span><br><span class="line">  <span class="type">uint_t</span> mt_mobjnr; <span class="comment">//内存对象容器扩展容量的内存中有多少对象</span></span><br><span class="line">&#125;<span class="type">kmbext_t</span>;</span><br><span class="line"><span class="comment">//内存对象容器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_KMSOB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> so_list; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">spinlock_t</span> so_lock; <span class="comment">//保护结构自身的自旋锁</span></span><br><span class="line">  <span class="type">uint_t</span> so_stus; <span class="comment">//状态与标志</span></span><br><span class="line">  <span class="type">uint_t</span> so_flgs;</span><br><span class="line">  <span class="type">adr_t</span> so_vstat; <span class="comment">//内存对象容器的开始地址</span></span><br><span class="line">  <span class="type">adr_t</span> so_vend; <span class="comment">//内存对象容器的结束地址</span></span><br><span class="line">  <span class="type">size_t</span> so_objsz; <span class="comment">//内存对象大小</span></span><br><span class="line">  <span class="type">size_t</span> so_objrelsz; <span class="comment">//内存对象实际大小</span></span><br><span class="line">  <span class="type">uint_t</span> so_mobjnr; <span class="comment">//内存对象容器中总共的对象个数</span></span><br><span class="line">  <span class="type">uint_t</span> so_fobjnr; <span class="comment">//内存对象容器中空闲的对象个数</span></span><br><span class="line">  <span class="type">list_h_t</span> so_frelst; <span class="comment">//内存对象容器中空闲的对象链表头</span></span><br><span class="line">  <span class="type">list_h_t</span> so_alclst; <span class="comment">//内存对象容器中分配的对象链表头</span></span><br><span class="line">  <span class="type">list_h_t</span> so_mextlst; <span class="comment">//内存对象容器扩展kmbext_t结构链表头</span></span><br><span class="line">  <span class="type">uint_t</span> so_mextnr; <span class="comment">//内存对象容器扩展kmbext_t结构个数</span></span><br><span class="line">  <span class="type">msomdc_t</span> so_mc; <span class="comment">//内存对象容器占用内存页面管理结构</span></span><br><span class="line">  <span class="type">void</span>* so_privp; <span class="comment">//本结构私有数据指针</span></span><br><span class="line">  <span class="type">void</span>* so_extdp; <span class="comment">//本结构扩展数据指针</span></span><br><span class="line">&#125;<span class="type">kmsob_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化</strong>
<ul>
<li>kmsob_t,kmbext_t,freobjh_t结构的实例变量是建立内存对象容器时创建并初始化的,该过程伴随着分配内存对象而进行,故内存对象管理器的初始化很简单</li>
<li>管理 kmsob_t 结构的数据结构,用于挂载不同大小的内存容器
<ul>
<li>init_kmsob函数调用 kmsobmgrhed_t_init 函数,在其中循环初始化 koblst_t 结构体数组</li>
<li>kmsobmgrhed_t 结构的实例变量放在 memmgrob_t结构中</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 cosmos/hal/x86/kmsob.c文件实现kmsob_t数据结构并初始化</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KOBLST_MAX (64)</span></span><br><span class="line"><span class="comment">//挂载kmsob_t结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_KOBLST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> ol_emplst; <span class="comment">//挂载kmsob_t结构的链表</span></span><br><span class="line">  <span class="type">kmsob_t</span>* ol_cahe; <span class="comment">//最近一次查找的kmsob_t结构</span></span><br><span class="line">  <span class="type">uint_t</span> ol_emnr; <span class="comment">//挂载kmsob_t结构的数量</span></span><br><span class="line">  <span class="type">size_t</span> ol_sz; <span class="comment">//kmsob_t结构中内存对象的大小</span></span><br><span class="line">&#125;<span class="type">koblst_t</span>;</span><br><span class="line"><span class="comment">//管理kmsob_t结构的数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_KMSOBMGRHED</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> ks_lock; <span class="comment">//保护自身的自旋锁</span></span><br><span class="line">  <span class="type">list_h_t</span> ks_tclst; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">uint_t</span> ks_tcnr;</span><br><span class="line">  <span class="type">uint_t</span> ks_msobnr; <span class="comment">//总共多少个kmsob_t结构</span></span><br><span class="line">  <span class="type">kmsob_t</span>* ks_msobche; <span class="comment">//最近分配内存对象的kmsob_t结构</span></span><br><span class="line">  <span class="type">koblst_t</span> ks_msoblst[KOBLST_MAX]; <span class="comment">//koblst_t结构数组</span></span><br><span class="line">&#125;<span class="type">kmsobmgrhed_t</span>;</span><br><span class="line"><span class="comment">//初始化koblst_t结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">koblst_t_init</span><span class="params">(<span class="type">koblst_t</span> *initp, <span class="type">size_t</span> koblsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  list_init(&amp;initp-&gt;ol_emplst);</span><br><span class="line">  initp-&gt;ol_cahe = <span class="literal">NULL</span>;</span><br><span class="line">  initp-&gt;ol_emnr = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ol_sz = koblsz;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化kmsobmgrhed_t结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmsobmgrhed_t_init</span><span class="params">(<span class="type">kmsobmgrhed_t</span> *initp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> koblsz = <span class="number">32</span>;</span><br><span class="line">  knl_spinlock_init(&amp;initp-&gt;ks_lock);</span><br><span class="line">  list_init(&amp;initp-&gt;ks_tclst);</span><br><span class="line">  initp-&gt;ks_tcnr = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ks_msobnr = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;ks_msobche = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> i = <span class="number">0</span>; i &lt; KOBLST_MAX; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    koblst_t_init(&amp;initp-&gt;ks_msoblst[i], koblsz);</span><br><span class="line">    koblsz += <span class="number">32</span>;<span class="comment">//这里并不是按照开始的图形分类的而是每次增加32字节,所以是32,64,96</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化kmsob</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_kmsob</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kmsobmgrhed_t_init(&amp;memmgrob.mo_kmsobmgr);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 memmgrob_t</span></span><br><span class="line"><span class="comment">//cosmos/include/halinc/halglobal.c</span></span><br><span class="line">HAL_DEFGLOB_VARIABLE(<span class="type">memmgrob_t</span>,memmgrob);</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MEMMGROB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> mo_list;</span><br><span class="line">  <span class="type">spinlock_t</span> mo_lock;</span><br><span class="line">  <span class="type">uint_t</span> mo_stus;</span><br><span class="line">  <span class="type">uint_t</span> mo_flgs;</span><br><span class="line">  <span class="comment">//略去很多字段</span></span><br><span class="line">  <span class="comment">//管理kmsob_t结构的数据结构</span></span><br><span class="line">  <span class="type">kmsobmgrhed_t</span> mo_kmsobmgr;</span><br><span class="line">  <span class="type">void</span>* mo_privp;</span><br><span class="line">  <span class="type">void</span>* mo_extp;</span><br><span class="line">&#125;<span class="type">memmgrob_t</span>;</span><br><span class="line"><span class="comment">//cosmos/hal/x86/memmgrinit.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_memmgr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化内存页结构</span></span><br><span class="line">  init_msadsc();</span><br><span class="line">  <span class="comment">//初始化内存区结构</span></span><br><span class="line">  init_memarea();</span><br><span class="line">  <span class="comment">//处理内存占用</span></span><br><span class="line">  init_search_krloccupymm(&amp;kmachbsp);</span><br><span class="line">  <span class="comment">//合并内存页到内存区中</span></span><br><span class="line">  init_memmgrob();</span><br><span class="line">  <span class="comment">//初始化kmsob</span></span><br><span class="line">  init_kmsob();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>分配内存对象</strong>
<ul>
<li>初始化了 kmsobmgrhed_t 结构,但没有初始化任何 kmsob_t 结构(存放内存对象的容器)
<ul>
<li>如何查找,建立 kmsob_t结构,然后再 kmsob_t结构中建立 freobjh_t 结构,最后在内存对象容器的容量不足时扩展容器的内存</li>
</ul>
</li>
</ul>
</li>
<li><strong>分配内存对象的接口</strong>
<ul>
<li>只有一个内存对象大小的参数,然后返回内存对象的首地址</li>
<li>该接口函数的实现较为简单:只是对分配内存对象的大小进行检查,然后调用分配内存对象的核心函数,围绕之前的数据结构进行操作</li>
</ul>
</li>
<li><strong>查找内存对象容器</strong>
<ul>
<li>内存对象容器数据结构 kmsob_t 挂载在 kmsobmgrhed_t 数据结构中的 ks_msoblst 数组中,需要遍历 ks_msoblst 数组
<ul>
<li><mark>编写 onmsz_retn_koblst 函数,返回 ks_msoblst 数组元素的指针,表示根据内存对象的大小找到挂载 kmsob_t 结构对应的 koblst_t 结构</mark></li>
<li>通过 onmsz_retn_koblst 函数根据内存对象大小查找并返回 ks_msoblst 数组元素的指针,该数组元素中就挂载着相应的内存对象容器,然后由onkoblst_retn_newkmsob 函数查询其中的内存对象容器并返回</li>
</ul>
</li>
</ul>
</li>
<li><strong>建立内存对象容器</strong>
<ul>
<li>第一次分配内存对象时,调用 onkoblst_retn_newkmsob 函数肯定会返回一个NULL,需要在这时建立一个 kmsob_t结构,即<strong>建立内存对象容器</strong></li>
<li>_create_kmsob 函数根据分配内存对象大小,建立 kmsob_t 结构的内存对象容器,并完成一些初始化工作
<ul>
<li>首先,函数会找物理内存页面管理器申请一块连续内存页面</li>
<li>然后,在其中的开始部分建立 kmsob_t 结构的实例变量,又在 kmsob_t 结构的后面建立 freobjh_t 结构数组,并把每个 freobjh_t 结构挂载到 kmsob_t 结构体中的 so_frelst 中</li>
<li>最后再把 kmsob_t 结构,挂载到 kmsobmgrhed_t 结构对应的 koblst_t 结构中去</li>
</ul>
</li>
</ul>
</li>
<li><strong>扩容内存对象容器</strong>
<ul>
<li>分配另一块连续的内存空间,作为空闲的内存对象,并把这块内存空间加内存对象容器中统一管理</li>
</ul>
</li>
<li><strong>分配内存对象</strong>
<ul>
<li><strong>核心操作是 kmsob_new_opkmsob 函数从空闲内存对象链表头中取出第一个内存对象,返回它的首地址</strong></li>
<li><strong>高效</strong>,无论内存对象容器中的内存对象有多少,kmsob_new_opkmsob 函数的操作始终是固定的,而如此高效的算法<strong>得益于先进的数据结构设计</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在kmsob.c中实现该分配内存对象的接口函数</span></span><br><span class="line"><span class="comment">//分配内存对象的核心函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmsob_new_core</span><span class="params">(<span class="type">size_t</span> msz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取kmsobmgrhed_t结构的地址</span></span><br><span class="line">  <span class="type">kmsobmgrhed_t</span> *kmobmgrp = &amp;memmgrob.mo_kmsobmgr;</span><br><span class="line">  <span class="type">void</span> *retptr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">koblst_t</span> *koblp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">kmsob_t</span> *kmsp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">cpuflg_t</span> cpuflg;</span><br><span class="line">  <span class="comment">//对kmsobmgrhed_t结构加锁</span></span><br><span class="line">  knl_spinlock_cli(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);</span><br><span class="line">  koblp = onmsz_retn_koblst(kmobmgrp, msz);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == koblp)</span><br><span class="line">  &#123;</span><br><span class="line">    retptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">goto</span> ret_step;</span><br><span class="line">  &#125;</span><br><span class="line">  kmsp = onkoblst_retn_newkmsob(koblp, msz);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == kmsp)</span><br><span class="line">  &#123;</span><br><span class="line">    kmsp = _create_kmsob(kmobmgrp, koblp, koblp-&gt;ol_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == kmsp)</span><br><span class="line">    &#123;</span><br><span class="line">      retptr = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">goto</span> ret_step;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  retptr = kmsob_new_onkmsob(kmsp, msz);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == retptr)</span><br><span class="line">  &#123;</span><br><span class="line">    retptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">goto</span> ret_step;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新kmsobmgrhed_t结构的信息</span></span><br><span class="line">  kmsob_updata_cache(kmobmgrp, koblp, kmsp, KUC_NEWFLG);</span><br><span class="line">  ret_step:</span><br><span class="line">  <span class="comment">//解锁kmsobmgrhed_t结构</span></span><br><span class="line">  knl_spinunlock_sti(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);</span><br><span class="line">  <span class="keyword">return</span> retptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内存对象分配接口</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmsob_new</span><span class="params">(<span class="type">size_t</span> msz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//对于小于1 或者 大于2048字节的大小不支持 直接返回NULL表示失败</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &gt; msz || <span class="number">2048</span> &lt; msz)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用核心函数</span></span><br><span class="line">  <span class="keyword">return</span> kmsob_new_core(msz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="comment">// 查找内存对象容器</span></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="comment">//看看内存对象容器是不是合乎要求</span></span><br><span class="line"><span class="type">kmsob_t</span> *<span class="title function_">scan_newkmsob_isok</span><span class="params">(<span class="type">kmsob_t</span> *kmsp, <span class="type">size_t</span> msz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//只要内存对象大小小于等于内存对象容器的对象大小就行</span></span><br><span class="line">  <span class="keyword">if</span> (msz &lt;= kmsp-&gt;so_objsz)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> kmsp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">koblst_t</span> *<span class="title function_">onmsz_retn_koblst</span><span class="params">(<span class="type">kmsobmgrhed_t</span> *kmmgrhlokp, <span class="type">size_t</span> msz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//遍历ks_msoblst数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> kli = <span class="number">0</span>; kli &lt; KOBLST_MAX; kli++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//只要大小合适就返回</span></span><br><span class="line">    <span class="keyword">if</span> (kmmgrhlokp-&gt;ks_msoblst[kli].ol_sz &gt;= msz)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;kmmgrhlokp-&gt;ks_msoblst[kli];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">kmsob_t</span> *<span class="title function_">onkoblst_retn_newkmsob</span><span class="params">(<span class="type">koblst_t</span> *koblp, <span class="type">size_t</span> msz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">kmsob_t</span> *kmsp = <span class="literal">NULL</span>, *tkmsp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">list_h_t</span> *tmplst = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//先看看上次分配所用到的koblst_t是不是正好是这次需要的</span></span><br><span class="line">  kmsp = scan_newkmsob_isok(koblp-&gt;ol_cahe, msz);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> != kmsp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> kmsp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果koblst_t中挂载的kmsob_t大于0</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> &lt; koblp-&gt;ol_emnr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//开始遍历koblst_t中挂载的kmsob_t</span></span><br><span class="line">    list_for_each(tmplst, &amp;koblp-&gt;ol_emplst)</span><br><span class="line">    &#123;</span><br><span class="line">      tkmsp = list_entry(tmplst, <span class="type">kmsob_t</span>, so_list);</span><br><span class="line">      <span class="comment">//检查当前kmsob_t是否合乎要求</span></span><br><span class="line">      kmsp = scan_newkmsob_isok(tkmsp, msz);</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">NULL</span> != kmsp)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> kmsp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">// 建立内存对象容器</span></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">//初始化内存对象数据结构</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freobjh_t_init</span><span class="params">(<span class="type">freobjh_t</span> *initp, <span class="type">uint_t</span> stus, <span class="type">void</span> *stat)</span></span><br><span class="line">&#123;</span><br><span class="line">  list_init(&amp;initp-&gt;oh_list);</span><br><span class="line">  initp-&gt;oh_stus = stus;</span><br><span class="line">  initp-&gt;oh_stat = stat;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化内存对象容器数据结构</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmsob_t_init</span><span class="params">(<span class="type">kmsob_t</span> *initp)</span></span><br><span class="line">&#123;</span><br><span class="line">  list_init(&amp;initp-&gt;so_list);</span><br><span class="line">  knl_spinlock_init(&amp;initp-&gt;so_lock);</span><br><span class="line">  initp-&gt;so_stus = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;so_flgs = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;so_vstat = <span class="literal">NULL</span>;</span><br><span class="line">  initp-&gt;so_vend = <span class="literal">NULL</span>;</span><br><span class="line">  initp-&gt;so_objsz = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;so_objrelsz = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;so_mobjnr = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;so_fobjnr = <span class="number">0</span>;</span><br><span class="line">  list_init(&amp;initp-&gt;so_frelst);</span><br><span class="line">  list_init(&amp;initp-&gt;so_alclst);</span><br><span class="line">  list_init(&amp;initp-&gt;so_mextlst);</span><br><span class="line">  initp-&gt;so_mextnr = <span class="number">0</span>;</span><br><span class="line">  msomdc_t_init(&amp;initp-&gt;so_mc);</span><br><span class="line">  initp-&gt;so_privp = <span class="literal">NULL</span>;</span><br><span class="line">  initp-&gt;so_extdp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把内存对象容器数据结构,挂载到对应的koblst_t结构中去</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">kmsob_add_koblst</span><span class="params">(<span class="type">koblst_t</span> *koblp, <span class="type">kmsob_t</span> *kmsp)</span></span><br><span class="line">&#123;</span><br><span class="line">  list_add(&amp;kmsp-&gt;so_list, &amp;koblp-&gt;ol_emplst);</span><br><span class="line">  koblp-&gt;ol_emnr++;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化内存对象容器</span></span><br><span class="line"><span class="type">kmsob_t</span> *_create_init_kmsob(<span class="type">kmsob_t</span> *kmsp, <span class="type">size_t</span> objsz, <span class="type">adr_t</span> cvadrs, <span class="type">adr_t</span> c</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化kmsob结构体</span></span><br><span class="line">  kmsob_t_init(kmsp);</span><br><span class="line">  <span class="comment">//设置内存对象容器的开始、结束地址,内存对象大小</span></span><br><span class="line">  kmsp-&gt;so_vstat = cvadrs;</span><br><span class="line">  kmsp-&gt;so_vend = cvadre;</span><br><span class="line">  kmsp-&gt;so_objsz = objsz;</span><br><span class="line">  <span class="comment">//把物理内存页面对应的msadsc_t结构加入到kmsob_t中的so_mc.mc_kmobinlst链表上</span></span><br><span class="line">  list_add(&amp;msa-&gt;md_list, &amp;kmsp-&gt;so_mc.mc_kmobinlst);</span><br><span class="line">  kmsp-&gt;so_mc.mc_kmobinpnr = (<span class="type">uint_t</span>)relpnr;</span><br><span class="line">  <span class="comment">//设置内存对象的开始地址为kmsob_t结构之后,结束地址为内存对象容器的结束地址</span></span><br><span class="line">  <span class="type">freobjh_t</span> *fohstat = (<span class="type">freobjh_t</span> *)(kmsp + <span class="number">1</span>), *fohend = (<span class="type">freobjh_t</span> *)cvadr</span><br><span class="line">  <span class="type">uint_t</span> ap = (<span class="type">uint_t</span>)((<span class="type">uint_t</span>)fohstat);</span><br><span class="line">  <span class="type">freobjh_t</span> *tmpfoh = (<span class="type">freobjh_t</span> *)((<span class="type">uint_t</span>)ap);</span><br><span class="line">  <span class="keyword">for</span> (; tmpfoh &lt; fohend;)</span><br><span class="line">  &#123;<span class="comment">//相当在kmsob_t结构体之后建立一个freobjh_t结构体数组</span></span><br><span class="line">    <span class="keyword">if</span> ((ap + (<span class="type">uint_t</span>)kmsp-&gt;so_objsz) &lt;= (<span class="type">uint_t</span>)cvadre)</span><br><span class="line">    &#123;<span class="comment">//初始化每个freobjh_t结构体</span></span><br><span class="line">      freobjh_t_init(tmpfoh, <span class="number">0</span>, (<span class="type">void</span> *)tmpfoh);</span><br><span class="line">      <span class="comment">//把每个freobjh_t结构体加入到kmsob_t结构体中的so_frelst中</span></span><br><span class="line">      list_add(&amp;tmpfoh-&gt;oh_list, &amp;kmsp-&gt;so_frelst);</span><br><span class="line">      kmsp-&gt;so_mobjnr++;</span><br><span class="line">      kmsp-&gt;so_fobjnr++;</span><br><span class="line">    &#125;</span><br><span class="line">    ap += (<span class="type">uint_t</span>)kmsp-&gt;so_objsz;</span><br><span class="line">    tmpfoh = (<span class="type">freobjh_t</span> *)((<span class="type">uint_t</span>)ap);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> kmsp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立一个内存对象容器</span></span><br><span class="line"><span class="type">kmsob_t</span> *_create_kmsob(<span class="type">kmsobmgrhed_t</span> *kmmgrlokp, <span class="type">koblst_t</span> *koblp, <span class="type">size_t</span> objsz</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">kmsob_t</span> *kmsp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">msadsc_t</span> *msa = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">uint_t</span> relpnr = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint_t</span> pages = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">128</span> &lt; objsz)</span><br><span class="line">  &#123;</span><br><span class="line">    pages = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">512</span> &lt; objsz)</span><br><span class="line">  &#123;</span><br><span class="line">    pages = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//为内存对象容器分配物理内存空间,这是我们之前实现的物理内存页面管理器</span></span><br><span class="line">  msa = mm_division_pages(&amp;memmgrob, pages, &amp;relpnr, MA_TYPE_KRNL, DMF_RELDI</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == msa)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">u64_t</span> phyadr = msa-&gt;md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;</span><br><span class="line">  <span class="type">u64_t</span> phyade = phyadr + (relpnr &lt;&lt; PSHRSIZE) - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//计算它们的虚拟地址</span></span><br><span class="line">  <span class="type">adr_t</span> vadrs = phyadr_to_viradr((<span class="type">adr_t</span>)phyadr);</span><br><span class="line">  <span class="type">adr_t</span> vadre = phyadr_to_viradr((<span class="type">adr_t</span>)phyade);</span><br><span class="line">  <span class="comment">//初始化kmsob_t并建立内存对象</span></span><br><span class="line">  kmsp = _create_init_kmsob((<span class="type">kmsob_t</span> *)vadrs, koblp-&gt;ol_sz, vadrs, vadre, ms</span><br><span class="line">  <span class="comment">//把kmsob_t结构,挂载到对应的koblst_t结构中去</span></span><br><span class="line">  <span class="keyword">if</span> (kmsob_add_koblst(koblp, kmsp) == FALSE)</span><br><span class="line">  &#123;</span><br><span class="line">    system_error(<span class="string">&quot; _create_kmsob kmsob_add_koblst FALSE\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//增加计数</span></span><br><span class="line">  kmmgrlokp-&gt;ks_msobnr++;</span><br><span class="line">  <span class="keyword">return</span> kmsp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="comment">// 扩容内存对象容器</span></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="comment">//初始化kmbext_t结构</span></span><br><span class="line"><span class="type">void</span> kmbext_t_init(<span class="type">kmbext_t</span> *initp, <span class="type">adr_t</span> vstat, <span class="type">adr_t</span> vend, <span class="type">kmsob_t</span> *kmsp)</span><br><span class="line">&#123;</span><br><span class="line">  list_init(&amp;initp-&gt;mt_list);</span><br><span class="line">  initp-&gt;mt_vstat = vstat;</span><br><span class="line">  initp-&gt;mt_vend = vend;</span><br><span class="line">  initp-&gt;mt_kmsb = kmsp;</span><br><span class="line">  initp-&gt;mt_mobjnr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展内存页面</span></span><br><span class="line"><span class="type">bool_t</span> kmsob_extn_pages(<span class="type">kmsob_t</span> *kmsp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">msadsc_t</span> *msa = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">uint_t</span> relpnr = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint_t</span> pages = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">128</span> &lt; kmsp-&gt;so_objsz)</span><br><span class="line">  &#123;</span><br><span class="line">    pages = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">512</span> &lt; kmsp-&gt;so_objsz)</span><br><span class="line">  &#123;</span><br><span class="line">    pages = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//找物理内存页面管理器分配2或者4个连续的页面</span></span><br><span class="line">  msa = mm_division_pages(&amp;memmgrob, pages, &amp;relpnr, MA_TYPE_KRNL, DMF_RELDI</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == msa)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">u64_t</span> phyadr = msa-&gt;md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;</span><br><span class="line">  <span class="type">u64_t</span> phyade = phyadr + (relpnr &lt;&lt; PSHRSIZE) - <span class="number">1</span>;</span><br><span class="line">  <span class="type">adr_t</span> vadrs = phyadr_to_viradr((<span class="type">adr_t</span>)phyadr);</span><br><span class="line">  <span class="type">adr_t</span> vadre = phyadr_to_viradr((<span class="type">adr_t</span>)phyade);</span><br><span class="line">  <span class="comment">//求出物理内存页面数对应在kmsob_t的so_mc.mc_lst数组中下标</span></span><br><span class="line">  <span class="type">sint_t</span> mscidx = retn_mscidx(relpnr);</span><br><span class="line">  <span class="comment">//把物理内存页面对应的msadsc_t结构加入到kmsob_t的so_mc.mc_lst数组中</span></span><br><span class="line">  list_add(&amp;msa-&gt;md_list, &amp;kmsp-&gt;so_mc.mc_lst[mscidx].ml_list);</span><br><span class="line">  kmsp-&gt;so_mc.mc_lst[mscidx].ml_msanr++;</span><br><span class="line">  <span class="type">kmbext_t</span> *bextp = (<span class="type">kmbext_t</span> *)vadrs;</span><br><span class="line">  <span class="comment">//初始化kmbext_t数据结构</span></span><br><span class="line">  kmbext_t_init(bextp, vadrs, vadre, kmsp);</span><br><span class="line">  <span class="comment">//设置内存对象的开始地址为kmbext_t结构之后,结束地址为扩展内存页面的结束地址</span></span><br><span class="line">  <span class="type">freobjh_t</span> *fohstat = (<span class="type">freobjh_t</span> *)(bextp + <span class="number">1</span>), *fohend = (<span class="type">freobjh_t</span> *)vadr</span><br><span class="line">  <span class="type">uint_t</span> ap = (<span class="type">uint_t</span>)((<span class="type">uint_t</span>)fohstat);</span><br><span class="line">  <span class="type">freobjh_t</span> *tmpfoh = (<span class="type">freobjh_t</span> *)((<span class="type">uint_t</span>)ap);</span><br><span class="line">  <span class="keyword">for</span> (; tmpfoh &lt; fohend;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ap + (<span class="type">uint_t</span>)kmsp-&gt;so_objsz) &lt;= (<span class="type">uint_t</span>)vadre)</span><br><span class="line">    &#123;<span class="comment">//在扩展的内存空间中建立内存对象</span></span><br><span class="line">      freobjh_t_init(tmpfoh, <span class="number">0</span>, (<span class="type">void</span> *)tmpfoh);</span><br><span class="line">      list_add(&amp;tmpfoh-&gt;oh_list, &amp;kmsp-&gt;so_frelst);</span><br><span class="line">      kmsp-&gt;so_mobjnr++;</span><br><span class="line">      kmsp-&gt;so_fobjnr++;</span><br><span class="line">      bextp-&gt;mt_mobjnr++;</span><br><span class="line">    &#125;</span><br><span class="line">    ap += (<span class="type">uint_t</span>)kmsp-&gt;so_objsz;</span><br><span class="line">    tmpfoh = (<span class="type">freobjh_t</span> *)((<span class="type">uint_t</span>)ap);</span><br><span class="line">  &#125;</span><br><span class="line">  list_add(&amp;bextp-&gt;mt_list, &amp;kmsp-&gt;so_mextlst);</span><br><span class="line">  kmsp-&gt;so_mextnr++;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 分配内存对象</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">//判断内存对象容器中有没有内存对象</span></span><br><span class="line"><span class="type">uint_t</span> scan_kmob_objnr(<span class="type">kmsob_t</span> *kmsp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> &lt; kmsp-&gt;so_fobjnr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> kmsp-&gt;so_fobjnr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际分配内存对象</span></span><br><span class="line"><span class="type">void</span> *kmsob_new_opkmsob(<span class="type">kmsob_t</span> *kmsp, <span class="type">size_t</span> msz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取kmsob_t中的so_frelst链表头的第一个空闲内存对象</span></span><br><span class="line">  <span class="type">freobjh_t</span> *fobh = list_entry(kmsp-&gt;so_frelst.next, <span class="type">freobjh_t</span>, oh_list);</span><br><span class="line">  <span class="comment">//从链表中脱链</span></span><br><span class="line">  list_del(&amp;fobh-&gt;oh_list);</span><br><span class="line">  <span class="comment">//kmsob_t中的空闲对象计数减一</span></span><br><span class="line">  kmsp-&gt;so_fobjnr--;</span><br><span class="line">  <span class="comment">//返回内存对象首地址</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *)(fobh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *kmsob_new_onkmsob(<span class="type">kmsob_t</span> *kmsp, <span class="type">size_t</span> msz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *retptr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">cpuflg_t</span> cpuflg;</span><br><span class="line">  knl_spinlock_cli(&amp;kmsp-&gt;so_lock, &amp;cpuflg);</span><br><span class="line">  <span class="comment">//如果内存对象容器中没有空闲的内存对象了就需要扩展内存对象容器的内存了</span></span><br><span class="line">  <span class="keyword">if</span> (scan_kmsob_objnr(kmsp) &lt; <span class="number">1</span>)</span><br><span class="line">  &#123;<span class="comment">//扩展内存对象容器的内存</span></span><br><span class="line">    <span class="keyword">if</span> (kmsob_extn_pages(kmsp) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">      retptr = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">goto</span> ret_step;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//实际分配内存对象</span></span><br><span class="line">  retptr = kmsob_new_opkmsob(kmsp, msz);</span><br><span class="line">  ret_step:</span><br><span class="line">  knl_spinunlock_sti(&amp;kmsp-&gt;so_lock, &amp;cpuflg);</span><br><span class="line">  <span class="keyword">return</span> retptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>释放内存对象</strong>
<ul>
<li>释放内存对象就是把内存对象归还给它所属的内容对象容器,其逻辑就是释放内存对象的地址和大小,找到对应的内存对象容器,然后把该内存对象假如到对应内存对象容器的空闲链表上,最后看是否要释放内存对象容器占用的物理内存页面</li>
</ul>
</li>
<li><strong>释放内存对象的接口</strong>
<ul>
<li>在 kmsob.c中实现释放内存对象的接口函数</li>
<li>等到 kmsob_delete 函数检查参数通过后,调用释放内存对象的核心函数 kmsob_delete_core
<ul>
<li>kmsob_delete_core 函数中,一开始根据释放内存对象大小,找到挂载其kmsob_t 结构的 koblst_t 结构,接着进行一系列的操作</li>
</ul>
</li>
</ul>
</li>
<li><strong>查找内存对象容器</strong>
<ul>
<li>查找将要释放的内存对象所属的内存对象容器,释放时的查找和分配时的查找不一样,<strong>需要检查释放的内存对象是否属于该内存对象容器</strong></li>
<li>搜索对应 koblst_t 结构中的每个 kmsob_t 结构体,随后进行检查,检查了 kmsob_t 结构的自身内存区域和扩展内存区域.即比较释放内存对象的地址是不是落在它们的内存区间中,其大小是否合乎要求</li>
</ul>
</li>
<li><strong>释放内存对象</strong>
<ul>
<li>找到释放内存对象的 kmsob_t 结构就可以释放内存对象,将这块内存空间还给内存对象容器</li>
<li>kmsob_delete_onkmsob 函数调用kmsob_del_opkmsob 函数,其核心机制就是把要释放内存对象的空间,重新初始化,变成一个freobjh_t结构的实例变量,最后将这个freobjh_t结构加入到 kmsob_t 结构中空闲链表中,就实现了内存对象的释放</li>
</ul>
</li>
<li><strong>销毁内存对象容器</strong>
<ul>
<li>频繁请求不同大小的内存对象,空的内存对象容器会越来越多,会占用大量内存,所以<strong>必须要把空的内存对象容器销毁</strong></li>
<li>首先会检查一下内存对象容器是不是空闲的,如果空闲,就调用销毁内存对象容器的核心函数destroy_kmsob_core</li>
<li>在 _destroy_kmsob_core 函数中
<ul>
<li>首先要释放内存对象容器的扩展空间所占用的物理内存页面</li>
<li>最后才可以释放内存对象容器自身占用物理内存页面</li>
</ul>
</li>
<li><mark>顺序不能颠倒,因为扩展空间的物理内存页面对应的 msadsc_t 结构就挂载在 kmsob_t 结构的 so_mc.mc_lst 数组中</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// 释放内存对象的接口</span></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">kmsob_delete_core</span><span class="params">(<span class="type">void</span> *fadrs, <span class="type">size_t</span> fsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">kmsobmgrhed_t</span> *kmobmgrp = &amp;memmgrob.mo_kmsobmgr;</span><br><span class="line">  <span class="type">bool_t</span> rets = FALSE;</span><br><span class="line">  <span class="type">koblst_t</span> *koblp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">kmsob_t</span> *kmsp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">cpuflg_t</span> cpuflg;</span><br><span class="line">  knl_spinlock_cli(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);</span><br><span class="line">  <span class="comment">//根据释放内存对象的大小在kmsobmgrhed_t中查找并返回koblst_t,在其中挂载着对应的kmsob</span></span><br><span class="line">  koblp = onmsz_retn_koblst(kmobmgrp, fsz);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == koblp)</span><br><span class="line">  &#123;</span><br><span class="line">    rets = FALSE;</span><br><span class="line">    <span class="keyword">goto</span> ret_step;</span><br><span class="line">  &#125;</span><br><span class="line">  kmsp = onkoblst_retn_delkmsob(koblp, fadrs, fsz);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == kmsp)</span><br><span class="line">  &#123;</span><br><span class="line">    rets = FALSE;</span><br><span class="line">    <span class="keyword">goto</span> ret_step;</span><br><span class="line">  &#125;</span><br><span class="line">  rets = kmsob_delete_onkmsob(kmsp, fadrs, fsz);</span><br><span class="line">  <span class="keyword">if</span> (FALSE == rets)</span><br><span class="line">  &#123;</span><br><span class="line">    rets = FALSE;</span><br><span class="line">    <span class="keyword">goto</span> ret_step;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_destroy_kmsob(kmobmgrp, koblp, kmsp) == FALSE)</span><br><span class="line">  &#123;</span><br><span class="line">    rets = FALSE;</span><br><span class="line">    <span class="keyword">goto</span> ret_step;</span><br><span class="line">  &#125;</span><br><span class="line">  rets = TRUE;</span><br><span class="line">  ret_step:</span><br><span class="line">  knl_spinunlock_sti(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);</span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放内存对象接口</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">kmsob_delete</span><span class="params">(<span class="type">void</span> *fadrs, <span class="type">size_t</span> fsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//对参数进行检查,但是多了对内存对象地址的检查</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == fadrs || <span class="number">1</span> &gt; fsz || <span class="number">2048</span> &lt; fsz)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用释放内存对象的核心函数</span></span><br><span class="line">  <span class="keyword">return</span> kmsob_delete_core(fadrs, fsz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">// 查找内存对象容器</span></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">//检查释放的内存对象是不是在kmsob_t结构中</span></span><br><span class="line"><span class="type">kmsob_t</span> *<span class="title function_">scan_delkmsob_isok</span><span class="params">(<span class="type">kmsob_t</span> *kmsp, <span class="type">void</span> *fadrs, <span class="type">size_t</span> fsz)</span></span><br><span class="line">&#123;<span class="comment">//检查释放内存对象的地址是否落在kmsob_t结构的地址区间</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">adr_t</span>)fadrs &gt;= (kmsp-&gt;so_vstat + <span class="keyword">sizeof</span>(<span class="type">kmsob_t</span>)) &amp;&amp; ((<span class="type">adr_t</span>)fadrs +</span><br><span class="line">  &#123; <span class="comment">//检查释放内存对象的大小是否小于等于kmsob_t内存对象容器的对象大小</span></span><br><span class="line">    <span class="keyword">if</span> (fsz &lt;= kmsp-&gt;so_objsz)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> kmsp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &gt; kmsp-&gt;so_mextnr)</span><br><span class="line">  &#123;<span class="comment">//如果kmsob_t结构没有扩展空间,直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">kmbext_t</span> *bexp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">list_h_t</span> *tmplst = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//遍历kmsob_t结构中的每个扩展空间</span></span><br><span class="line">  list_for_each(tmplst, &amp;kmsp-&gt;so_mextlst)</span><br><span class="line">  &#123;</span><br><span class="line">    bexp = list_entry(tmplst, <span class="type">kmbext_t</span>, mt_list);</span><br><span class="line">    <span class="comment">//检查释放内存对象的地址是否落在扩展空间的地址区间</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">adr_t</span>)fadrs &gt;= (bexp-&gt;mt_vstat + <span class="keyword">sizeof</span>(<span class="type">kmbext_t</span>)) &amp;&amp; ((<span class="type">adr_t</span>)fad</span><br><span class="line">    &#123;<span class="comment">//同样的要检查大小</span></span><br><span class="line">      <span class="keyword">if</span> (fsz &lt;= kmsp-&gt;so_objsz)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> kmsp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找释放内存对象所属的kmsob_t结构</span></span><br><span class="line"><span class="type">kmsob_t</span> *onkoblst_retn_delkmsob(<span class="type">koblst_t</span> *koblp, <span class="type">void</span> *fadrs, <span class="type">size_t</span> fsz)</span><br><span class="line">&#123;</span><br><span class="line">  v *kmsp = <span class="literal">NULL</span>, *tkmsp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">list_h_t</span> *tmplst = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//看看上次刚刚操作的kmsob_t结构</span></span><br><span class="line">  kmsp = scan_delkmsob_isok(koblp-&gt;ol_cahe, fadrs, fsz);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> != kmsp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> kmsp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> &lt; koblp-&gt;ol_emnr)</span><br><span class="line">  &#123; <span class="comment">//遍历挂载koblp-&gt;ol_emplst链表上的每个kmsob_t结构</span></span><br><span class="line">    list_for_each(tmplst, &amp;koblp-&gt;ol_emplst)</span><br><span class="line">    &#123;</span><br><span class="line">      tkmsp = list_entry(tmplst, <span class="type">kmsob_t</span>, so_list);</span><br><span class="line">      <span class="comment">//检查释放的内存对象是不是属于这个kmsob_t结构</span></span><br><span class="line">      kmsp = scan_delkmsob_isok(tkmsp, fadrs, fsz);</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">NULL</span> != kmsp)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> kmsp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 释放内存对象</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="type">bool_t</span> kmsob_del_opkmsob(<span class="type">kmsob_t</span> *kmsp, <span class="type">void</span> *fadrs, <span class="type">size_t</span> fsz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((kmsp-&gt;so_fobjnr + <span class="number">1</span>) &gt; kmsp-&gt;so_mobjnr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//让freobjh_t结构重新指向要释放的内存空间</span></span><br><span class="line">  <span class="type">freobjh_t</span> *obhp = (<span class="type">freobjh_t</span> *)fadrs;</span><br><span class="line">  <span class="comment">//重新初始化块内存空间</span></span><br><span class="line">  freobjh_t_init(obhp, <span class="number">0</span>, obhp);</span><br><span class="line">  <span class="comment">//加入kmsob_t结构的空闲链表</span></span><br><span class="line">  list_add(&amp;obhp-&gt;oh_list, &amp;kmsp-&gt;so_frelst);</span><br><span class="line">  <span class="comment">//kmsob_t结构的空闲对象计数加一</span></span><br><span class="line">  kmsp-&gt;so_fobjnr++;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放内存对象</span></span><br><span class="line"><span class="type">bool_t</span> kmsob_delete_onkmsob(<span class="type">kmsob_t</span> *kmsp, <span class="type">void</span> *fadrs, <span class="type">size_t</span> fsz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool_t</span> rets = FALSE;</span><br><span class="line">  <span class="type">cpuflg_t</span> cpuflg;</span><br><span class="line">  <span class="comment">//对kmsob_t结构加锁</span></span><br><span class="line">  knl_spinlock_cli(&amp;kmsp-&gt;so_lock, &amp;cpuflg);</span><br><span class="line">  <span class="comment">//实际完成内存对象释放</span></span><br><span class="line">  <span class="keyword">if</span> (kmsob_del_opkmsob(kmsp, fadrs, fsz) == FALSE)</span><br><span class="line">  &#123;</span><br><span class="line">    rets = FALSE;</span><br><span class="line">    <span class="keyword">goto</span> ret_step;</span><br><span class="line">  &#125;</span><br><span class="line">  rets = TRUE;</span><br><span class="line">  ret_step:</span><br><span class="line">  <span class="comment">//对kmsob_t结构解锁</span></span><br><span class="line">  knl_spinunlock_sti(&amp;kmsp-&gt;so_lock, &amp;cpuflg);</span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">// 销毁内存对象容器</span></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="type">uint_t</span> scan_freekmsob_isok(<span class="type">kmsob_t</span> *kmsp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//当内存对象容器的总对象个数等于空闲对象个数时,说明这内存对象容器空闲</span></span><br><span class="line">  <span class="keyword">if</span> (kmsp-&gt;so_mobjnr == kmsp-&gt;so_fobjnr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool_t</span> _destroy_kmsob_core(<span class="type">kmsobmgrhed_t</span> *kmobmgrp, <span class="type">koblst_t</span> *koblp, <span class="type">kmsob_t</span> *</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">list_h_t</span> *tmplst = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">msadsc_t</span> *msa = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">msclst_t</span> *mscp = kmsp-&gt;so_mc.mc_lst;</span><br><span class="line">  list_del(&amp;kmsp-&gt;so_list);</span><br><span class="line">  koblp-&gt;ol_emnr--;</span><br><span class="line">  kmobmgrp-&gt;ks_msobnr--;</span><br><span class="line">  <span class="comment">//释放内存对象容器扩展空间的物理内存页面</span></span><br><span class="line">  <span class="comment">//遍历kmsob_t结构中的so_mc.mc_lst数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> j = <span class="number">0</span>; j &lt; MSCLST_MAX; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; mscp[j].ml_msanr)</span><br><span class="line">    &#123;<span class="comment">//遍历每个so_mc.mc_lst数组中的msadsc_t结构</span></span><br><span class="line">      list_for_each_head_dell(tmplst, &amp;mscp[j].ml_list)</span><br><span class="line">      &#123;</span><br><span class="line">        msa = list_entry(tmplst, <span class="type">msadsc_t</span>, md_list);</span><br><span class="line">        list_del(&amp;msa-&gt;md_list);</span><br><span class="line">        <span class="comment">//msadsc_t脱链</span></span><br><span class="line">        <span class="comment">//释放msadsc_t对应的物理内存页面</span></span><br><span class="line">        <span class="keyword">if</span> (mm_merge_pages(&amp;memmgrob, msa, (<span class="type">uint_t</span>)mscp[j].ml_ompnr) =</span><br><span class="line">        &#123;</span><br><span class="line">          system_error(<span class="string">&quot;_destroy_kmsob_core mm_merge_pages FALSE2\n&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//释放内存对象容器本身占用的物理内存页面</span></span><br><span class="line">  <span class="comment">//遍历每个so_mc.mc_kmobinlst中的msadsc_t结构.它只会遍历一次</span></span><br><span class="line">  list_for_each_head_dell(tmplst, &amp;kmsp-&gt;so_mc.mc_kmobinlst)</span><br><span class="line">  &#123;</span><br><span class="line">    msa = list_entry(tmplst, <span class="type">msadsc_t</span>, md_list);</span><br><span class="line">    list_del(&amp;msa-&gt;md_list);</span><br><span class="line">    <span class="comment">//msadsc_t脱链</span></span><br><span class="line">    <span class="comment">//释放msadsc_t对应的物理内存页面</span></span><br><span class="line">    <span class="keyword">if</span> (mm_merge_pages(&amp;memmgrob, msa, (<span class="type">uint_t</span>)kmsp-&gt;so_mc.mc_kmobinpnr) =</span><br><span class="line">    &#123;</span><br><span class="line">      system_error(<span class="string">&quot;_destroy_kmsob_core mm_merge_pages FALSE2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">```销毁内存对象容器</span><br><span class="line"><span class="type">bool_t</span> _destroy_kmsob(<span class="type">kmsobmgrhed_t</span> *kmobmgrp, <span class="type">koblst_t</span> *koblp, <span class="type">kmsob_t</span> *kmsp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//看看能不能销毁</span></span><br><span class="line">  <span class="type">uint_t</span> screts = scan_freekmsob_isok(kmsp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">2</span> == screts)</span><br><span class="line">  &#123;<span class="comment">//调用销毁内存对象容器的核心函数</span></span><br><span class="line">    <span class="keyword">return</span> _destroy_kmsob_core(kmobmgrp, koblp, kmsp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="65-如何表示虚拟内存"><a class="markdownIt-Anchor" href="#65-如何表示虚拟内存"></a> 6.5 如何表示虚拟内存</h2>
<ul>
<li><strong>虚拟地址空间的划分</strong>
<ul>
<li>虚拟地址是逻辑上的一个数值,而虚拟地址空间是一堆数值的集合
<ul>
<li>通常情况下,32位的处理器0~0xFFFFFFFF的虚拟地址空间,而64位的虚拟地址空间则更大</li>
<li>64位的虚拟地址空间则为0~0xFFFFFFFFFFFFFFFF</li>
</ul>
</li>
<li>需要一定的安排和设计,比如什么虚拟地址段放应用,什么虚拟地址段放内核等</li>
</ul>
</li>
<li><strong>x86CPU如何划分虚拟地址空间</strong>
<ul>
<li>cosmos工作在x86CPU上,x86CPU是如何划分虚拟地址空间</li>
<li>由于x86CPU支持虚拟地址空间时,要么开启保护模式,要么开启长模式
<ul>
<li>保护模式下是32位的,有0~0xFFFFFFFF个地址,可以使用完整的4GB虚拟地址空间,且没有任何划分</li>
<li>长模式是64位虚拟地址空间有0~0xFFFFFFFFFFFFFFFF个地址,地址空间巨大,将它分为了3段</li>
<li>长模式下,CPU目前只实现了48位地址空间,但寄存器却是64位的,CPU自己用地址数据的第47位的值扩展到最高16位,所以64位地址数据的最高16位,要么全0,要么全1</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-21-28.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-21-28.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="x86虚拟地址划分" /></p>
<ul>
<li><strong>cosmos如何划分虚拟地址空间</strong>
<ul>
<li>cosmos对x86CPU长模式下虚拟地址空间的使用,在长模式下,整个虚拟地址空间只有两段可以用,0xFFFF800000000000<sub>0xFFFFFFFFFFFFFFFF分配给内核(内核空间),0</sub>0x00007FFFFFFFFFFF给应用(应用空间)</li>
<li>应用程序在链接时,会将各个模块的指令和数据分别放在仪器,栈是在最顶端向下增长,堆是在应用程序数据区的后面,向上增长
<ul>
<li>内核空间中有线性映射区0xFFFF800000000000～0xFFFF800400000000为在二级引导器中建立的MMU页表映射</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-21-43.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-21-43.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="内核空间与应用空间" /></p>
<ul>
<li><strong>如何设计数据结构</strong>
<ul>
<li>需要实现一个功能模块,首先要设计出相应的数据结构,虚拟内存模块也需要设计相应的数据结构</li>
</ul>
</li>
<li><strong>虚拟地址空间</strong>
<ul>
<li>由于虚拟地址空间巨大,且虚拟地址空间是以区为单位的,区内部连续,区之间间隔较大空间且每个区扩大时不会建立新的虚拟地址区间数据结构,而是改变其中的指针(节约了内存空间)
<ul>
<li>数据结构最重要的是<strong>虚拟地址的开始与结束字段</strong>,精确描述了一段虚拟地址空间</li>
</ul>
</li>
</ul>
</li>
<li><strong>整个虚拟地址空间如何描述</strong>
<ul>
<li>将许多虚拟地址区间数据结构按顺序连接起来就表示整个虚拟地址空间</li>
</ul>
</li>
<li><strong>进程的内存地址空间</strong>
<ul>
<li>虚拟地址空间作用域应用程序,应用程序在操作系统中用进程表示</li>
<li>进程的完整地址空间:包含虚拟空间信息,进程和虚拟地址到物理地址的映射信息,应用程序文件中的指令区,数据区的开始,结束地址信息</li>
</ul>
</li>
<li><strong>页面盒子</strong>
<ul>
<li>每段虚拟地址空间都会映射到对应的物理页面,每分配一个或一组内存页面都会返回一个 msadsc_t 结构,故还需要设计一个数据结构来挂载 msadsc_t 结构</li>
<li>一般虚拟地址区间和文件对应的数据相关联,常规操作就是把同一个物理内存页面映射到不同的虚拟地址区间,实现一个专用的数据结构,共享操作时就让多个 kmvarsdsc_t 结构指向它</li>
<li>kvmemcbox_t可以独立存在,又和虚拟内存空间有紧密的联系,甚至可以用来管理文件数据占用的物理内存页面</li>
</ul>
</li>
<li><strong>页面盒子的头</strong>
<ul>
<li>kvmemcbox_t独立存在,还需要一个全局的数据结构用于管理所有的 kvmemcbox_t 结构,该结构用于挂载 kvmemcbox_t 结构对其进行计数,还要支持缓存多个空闲的 kvmemcbox_t 结构</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚拟地址空间数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">KMVARSDSC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> kva_lock; <span class="comment">//保护自身自旋锁</span></span><br><span class="line">  <span class="type">u32_t</span> kva_maptype; <span class="comment">//映射类型</span></span><br><span class="line">  <span class="type">list_h_t</span> kva_list; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">u64_t</span> kva_flgs; <span class="comment">//相关标志</span></span><br><span class="line">  <span class="type">u64_t</span> kva_limits;</span><br><span class="line">  <span class="type">void</span>* kva_mcstruct; <span class="comment">//指向它的上层结构</span></span><br><span class="line">  <span class="type">adr_t</span> kva_start; <span class="comment">//虚拟地址的开始</span></span><br><span class="line">  <span class="type">adr_t</span> kva_end; <span class="comment">//虚拟地址的结束</span></span><br><span class="line">  <span class="type">kvmemcbox_t</span>* kva_kvmbox; <span class="comment">//管理这个结构映射的物理页面</span></span><br><span class="line">  <span class="type">void</span>* kva_kvmcobj;</span><br><span class="line">&#125;<span class="type">kmvarsdsc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="comment">// 整个虚拟地址空间的数据结构</span></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_VIRMEMADRS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> vs_lock; <span class="comment">//保护自身的自旋锁</span></span><br><span class="line">  <span class="type">u32_t</span> vs_resalin;</span><br><span class="line">  <span class="type">list_h_t</span> vs_list; <span class="comment">//链表,链接虚拟地址区间</span></span><br><span class="line">  <span class="type">uint_t</span> vs_flgs; <span class="comment">//标志</span></span><br><span class="line">  <span class="type">uint_t</span> vs_kmvdscnr; <span class="comment">//多少个虚拟地址区间</span></span><br><span class="line">  <span class="type">mmadrsdsc_t</span>* vs_mm; <span class="comment">//指向它的上层的数据结构</span></span><br><span class="line">  <span class="type">kmvarsdsc_t</span>* vs_startkmvdsc; <span class="comment">//开始的虚拟地址区间</span></span><br><span class="line">  <span class="type">kmvarsdsc_t</span>* vs_endkmvdsc; <span class="comment">//结束的虚拟地址区间</span></span><br><span class="line">  <span class="type">kmvarsdsc_t</span>* vs_currkmvdsc; <span class="comment">//当前的虚拟地址区间</span></span><br><span class="line">  <span class="type">adr_t</span> vs_isalcstart; <span class="comment">//能分配的开始虚拟地址</span></span><br><span class="line">  <span class="type">adr_t</span> vs_isalcend; <span class="comment">//能分配的结束虚拟地址</span></span><br><span class="line">  <span class="type">void</span>* vs_privte; <span class="comment">//私有数据指针</span></span><br><span class="line">  <span class="type">void</span>* vs_ext; <span class="comment">//扩展数据指针</span></span><br><span class="line">&#125;<span class="type">virmemadrs_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="comment">// 进程的内存地址空间</span></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MMADRSDSC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> msd_lock; <span class="comment">//保护自身的自旋锁</span></span><br><span class="line">  <span class="type">list_h_t</span> msd_list; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">uint_t</span> msd_flag; <span class="comment">//状态和标志</span></span><br><span class="line">  <span class="type">uint_t</span> msd_stus;</span><br><span class="line">  <span class="type">uint_t</span> msd_scount; <span class="comment">//计数,该结构可能被共享</span></span><br><span class="line">  <span class="type">sem_t</span> msd_sem; <span class="comment">//信号量</span></span><br><span class="line">  <span class="type">mmudsc_t</span> msd_mmu; <span class="comment">//MMU相关的信息</span></span><br><span class="line">  <span class="type">virmemadrs_t</span> msd_virmemadrs; <span class="comment">//虚拟地址空间</span></span><br><span class="line">  <span class="type">adr_t</span> msd_stext; <span class="comment">//应用的指令区的开始、结束地址</span></span><br><span class="line">  <span class="type">adr_t</span> msd_etext;</span><br><span class="line">  <span class="type">adr_t</span> msd_sdata; <span class="comment">//应用的数据区的开始、结束地址</span></span><br><span class="line">  <span class="type">adr_t</span> msd_edata;</span><br><span class="line">  <span class="type">adr_t</span> msd_sbss;</span><br><span class="line">  <span class="type">adr_t</span> msd_ebss;</span><br><span class="line">  <span class="type">adr_t</span> msd_sbrk; <span class="comment">//应用的堆区的开始、结束地址</span></span><br><span class="line">  <span class="type">adr_t</span> msd_ebrk;</span><br><span class="line">&#125;<span class="type">mmadrsdsc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 页面盒子</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">KVMEMCBOX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> kmb_list; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">spinlock_t</span> kmb_lock; <span class="comment">//保护自身的自旋锁</span></span><br><span class="line">  <span class="type">refcount_t</span> kmb_cont; <span class="comment">//共享的计数器</span></span><br><span class="line">  <span class="type">u64_t</span> kmb_flgs; <span class="comment">//状态和标志</span></span><br><span class="line">  <span class="type">u64_t</span> kmb_stus;</span><br><span class="line">  <span class="type">u64_t</span> kmb_type; <span class="comment">//类型</span></span><br><span class="line">  <span class="type">uint_t</span> kmb_msanr; <span class="comment">//多少个msadsc_t</span></span><br><span class="line">  <span class="type">list_h_t</span> kmb_msalist; <span class="comment">//挂载msadsc_t结构的链表</span></span><br><span class="line">  <span class="type">kvmemcboxmgr_t</span>* kmb_mgr; <span class="comment">//指向上层结构</span></span><br><span class="line">  <span class="type">void</span>* kmb_filenode; <span class="comment">//指向文件节点描述符</span></span><br><span class="line">  <span class="type">void</span>* kmb_pager; <span class="comment">//指向分页器 暂时不使用</span></span><br><span class="line">  <span class="type">void</span>* kmb_ext; <span class="comment">//自身扩展数据指针</span></span><br><span class="line">&#125;<span class="type">kvmemcbox_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// 页面盒子的头</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">KVMEMCBOXMGR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> kbm_list; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">spinlock_t</span> kbm_lock; <span class="comment">//保护自身的自旋锁</span></span><br><span class="line">  <span class="type">u64_t</span> kbm_flgs; <span class="comment">//标志与状态</span></span><br><span class="line">  <span class="type">u64_t</span> kbm_stus;</span><br><span class="line">  <span class="type">uint_t</span> kbm_kmbnr; <span class="comment">//kvmemcbox_t结构个数</span></span><br><span class="line">  <span class="type">list_h_t</span> kbm_kmbhead; <span class="comment">//挂载kvmemcbox_t结构的链表</span></span><br><span class="line">  <span class="type">uint_t</span> kbm_cachenr; <span class="comment">//缓存空闲kvmemcbox_t结构的个数</span></span><br><span class="line">  <span class="type">uint_t</span> kbm_cachemax; <span class="comment">//最大缓存个数,超过了就要释放</span></span><br><span class="line">  <span class="type">uint_t</span> kbm_cachemin; <span class="comment">//最小缓存个数</span></span><br><span class="line">  <span class="type">list_h_t</span> kbm_cachehead; <span class="comment">//缓存kvmemcbox_t结构的链表</span></span><br><span class="line">  <span class="type">void</span>* kbm_ext; <span class="comment">//扩展数据指针</span></span><br><span class="line">&#125;<span class="type">kvmemcboxmgr_t</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-22-23.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-20-22-22-23.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="虚拟内存数据结构" /></p>
<ul>
<li><strong>理清数据结构之间的关系(从上往下,从左往右)</strong>
<ul>
<li>首先从进程的虚拟地址空间开始,而进程的虚拟地址是由 kmvarsdsc_t 结构表示的,一个 kmvarsdsc_t 结构就表示一个已经分配出去的虚拟地址空间.一个进程所有的 kmvarsdsc_t 结构,要交给进程的 mmadrsdsc_t 结构中的 virmemadrs_t 结构管理</li>
<li>为了管理虚拟地址空间对应的物理内存页面,建立了 kvmembox_t 结构由 kvmemcboxmgr_t 结构统一管理.在 kvmembox_t 结构中,挂载了物理内存页面对应的 msadsc_t 结构</li>
</ul>
</li>
<li><strong>初始化</strong>
<ul>
<li>虚拟地址空间的分配与释放依赖于进程数据结构下的 mmadrsdsc_t 数据结构,需要产生一个 mmadrsdsc_t 数据结构的实例变量,最后初始化它</li>
<li>init_kvirmemadrs 函数首先调用了 mmadrsdsc_t_init,对申明的变量进行初始化.因为这个变量中有链表、自旋锁、信号量这些数据结构,必须要初始化才能使用</li>
<li>最后调用了 kvma_inituserspace_virmemadrs 函数建立一个虚拟地址区间和一个栈区,栈区位于虚拟地址空间的顶端</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cosmos/kernel/krlglobal.c文件中声明 mmadrsdsc_t数据结构的实例变量</span></span><br><span class="line">KRL_DEFGLOB_VARIABLE(<span class="type">mmadrsdsc_t</span>, initmmadrsdsc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化这个变量</span></span><br><span class="line"><span class="comment">// /cosmos/kernel/krlvadrsmem.c</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">kvma_inituserspace_virmemadrs</span><span class="params">(<span class="type">virmemadrs_t</span> *vma)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">kmvarsdsc_t</span> *kmvdc = <span class="literal">NULL</span>, *stackkmvdc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//分配一个kmvarsdsc_t</span></span><br><span class="line">kmvdc = new_kmvarsdsc();</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == kmvdc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分配一个栈区的kmvarsdsc_t</span></span><br><span class="line">stackkmvdc = new_kmvarsdsc();</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == stackkmvdc)</span><br><span class="line">&#123;</span><br><span class="line">del_kmvarsdsc(kmvdc);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚拟区间开始地址0x1000</span></span><br><span class="line">kmvdc-&gt;kva_start = USER_VIRTUAL_ADDRESS_START + <span class="number">0x1000</span>;</span><br><span class="line"><span class="comment">//虚拟区间结束地址0x5000</span></span><br><span class="line">kmvdc-&gt;kva_end = kmvdc-&gt;kva_start + <span class="number">0x4000</span>;</span><br><span class="line">kmvdc-&gt;kva_mcstruct = vma;</span><br><span class="line"><span class="comment">//栈虚拟区间开始地址0x1000USER_VIRTUAL_ADDRESS_END - 0x40000000</span></span><br><span class="line">stackkmvdc-&gt;kva_start = PAGE_ALIGN(USER_VIRTUAL_ADDRESS_END - <span class="number">0x40000000</span>);</span><br><span class="line"><span class="comment">//栈虚拟区间结束地址0x1000USER_VIRTUAL_ADDRESS_END</span></span><br><span class="line">stackkmvdc-&gt;kva_end = USER_VIRTUAL_ADDRESS_END;</span><br><span class="line">stackkmvdc-&gt;kva_mcstruct = vma;</span><br><span class="line">knl_spinlock(&amp;vma-&gt;vs_lock);</span><br><span class="line">vma-&gt;vs_isalcstart = USER_VIRTUAL_ADDRESS_START;</span><br><span class="line">vma-&gt;vs_isalcend = USER_VIRTUAL_ADDRESS_END;</span><br><span class="line"><span class="comment">//设置虚拟地址空间的开始区间为kmvdc</span></span><br><span class="line">vma-&gt;vs_startkmvdsc = kmvdc;</span><br><span class="line"><span class="comment">//设置虚拟地址空间的开始区间为栈区</span></span><br><span class="line">vma-&gt;vs_endkmvdsc = stackkmvdc;</span><br><span class="line"><span class="comment">//加入链表</span></span><br><span class="line">list_add_tail(&amp;kmvdc-&gt;kva_list, &amp;vma-&gt;vs_list);</span><br><span class="line">list_add_tail(&amp;stackkmvdc-&gt;kva_list, &amp;vma-&gt;vs_list);</span><br><span class="line"><span class="comment">//计数加2</span></span><br><span class="line">vma-&gt;vs_kmvdscnr += <span class="number">2</span>;</span><br><span class="line">knl_spinunlock(&amp;vma-&gt;vs_lock);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_kvirmemadrs</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化mmadrsdsc_t结构非常简单</span></span><br><span class="line">mmadrsdsc_t_init(&amp;initmmadrsdsc);</span><br><span class="line"><span class="comment">//初始化进程的用户空间</span></span><br><span class="line">kvma_inituserspace_virmemadrs(&amp;initmmadrsdsc.msd_virmemadrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// krlinit.c中的int_krl函数中调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化内核功能层的内存管理</span></span><br><span class="line">init_krlmm();</span><br><span class="line">die(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krlmm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">init_kvirmemadrs();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>重点梳理
<ul>
<li>首先是虚拟地址空间的划分。由于硬件平台的物理特性，虚拟地址空间被分成了两段，Cosmos 也延续了这种划分的形式，顶端的虚拟地址空间为内核占用，底端为应用占用。内核还建立了 16GB 的线性映射区，而应用的虚拟地址空间分成了指令区，数据区，堆区，栈区</li>
<li>然后为了实现虚拟地址内存，设计了大量的数据结构
<ul>
<li>虚拟地址区间kmvarsdsc_t 结构</li>
<li>管理虚拟地址区间的虚拟地址空间 virmemadrs_t 结构</li>
<li>包含virmemadrs_t 结构和 mmudsc_t 结构的 mmadrsdsc_t 结构</li>
<li>用于挂载 msadsc_t 结构的页面盒子的 kvmemcbox_t 结构</li>
<li>管理所有的 kvmemcbox_t 结构的kvmemcboxmgr_t 结构</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="66-如何分配和释放虚拟内存"><a class="markdownIt-Anchor" href="#66-如何分配和释放虚拟内存"></a> 6.6 如何分配和释放虚拟内存</h2>
<ul>
<li><strong>虚拟地址的空间的分配与释放</strong>
<ul>
<li>分配一个虚拟地址空间就是在整个虚拟地址空间分割出一个区域，释放一块虚拟地址空间就是把这个区域合并到整个虚拟地址空间中去</li>
</ul>
</li>
<li><strong>虚拟地址空间分配接口</strong>
<ul>
<li>分配虚拟地址空间有大小,类型,相关标志，从哪里开始分配等信息,<strong>在krlvadrsmem.c文件中设计好分配虚拟地址空间的接口</strong></li>
<li>接口函数进行参数检查,然后调用核心函数完成的实际工作;核心函数中会调用 vma_find_kmvarsdsc 函数去查找 virmemadrs_t 结构中所有 kmvarsdsc_t 结构，找出合适的虚拟地址区间</li>
</ul>
</li>
<li><strong>分配时查找虚拟地址区间</strong>
<ul>
<li>vma_find_kmvarsdsc 函数根据分配的开始地址和大小,在 virmemadrs_t 结构中查找相应的 kmvarsdsc_t 结构,<strong>分配虚拟地址空间算法的核心</strong></li>
<li>例子:virmemadrs_t 结构中有两个 kmvarsdsc_t 结构，A_kmvarsdsc_t 结构表示 0x1000～0x4000 的虚拟地址空间，B_kmvarsdsc_t 结构表示0x7000～0x9000 的虚拟地址空间;分配 2KB 的虚拟地址空间，vma_find_kmvarsdsc 函数查找发现A_kmvarsdsc_t 结构和 B_kmvarsdsc_t 结构之间正好有 0x4000～0x7000 的空间，刚好放得下 0x2000 大小的空间，于是函数就会返回 A_kmvarsdsc_t 结构，否则就会继续向后查找</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"><span class="comment">// 虚拟地址空间分配接口</span></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"><span class="type">adr_t</span> <span class="title function_">vma_new_vadrs_core</span><span class="params">(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">adr_t</span> start, <span class="type">size_t</span> vassize, <span class="type">u64_t</span> v</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">adr_t</span> retadrs = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="type">kmvarsdsc_t</span> *newkmvd = <span class="literal">NULL</span>, *currkmvd = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="type">virmemadrs_t</span> *vma = &amp;mm-&gt;msd_virmemadrs;</span></span><br><span class="line"><span class="params">  knl_spinlock(&amp;vma-&gt;vs_lock);</span></span><br><span class="line"><span class="params">  <span class="comment">//查找虚拟地址区间</span></span></span><br><span class="line"><span class="params">  currkmvd = vma_find_kmvarsdsc(vma, start, vassize);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == currkmvd)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    retadrs = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">goto</span> out;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//进行虚拟地址区间进行检查看能否复用这个数据结构</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (((<span class="literal">NULL</span> == start) || (start == currkmvd-&gt;kva_end)) &amp;&amp; (vaslimits == cur</span></span><br><span class="line"><span class="params">  &#123;<span class="comment">//能复用的话，当前虚拟地址区间的结束地址返回</span></span></span><br><span class="line"><span class="params">    retadrs = currkmvd-&gt;kva_end;</span></span><br><span class="line"><span class="params">    <span class="comment">//扩展当前虚拟地址区间的结束地址为分配虚拟地址区间的大小</span></span></span><br><span class="line"><span class="params">    currkmvd-&gt;kva_end += vassize;</span></span><br><span class="line"><span class="params">    vma-&gt;vs_currkmvdsc = currkmvd;</span></span><br><span class="line"><span class="params">    <span class="keyword">goto</span> out;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//建立一个新的kmvarsdsc_t虚拟地址区间结构</span></span></span><br><span class="line"><span class="params">  newkmvd = new_kmvarsdsc();</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == newkmvd)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    retadrs = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">goto</span> out;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//如果分配的开始地址为NULL就由系统动态决定</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == start)</span></span><br><span class="line"><span class="params">  &#123;<span class="comment">//当然是接着当前虚拟地址区间之后开始</span></span></span><br><span class="line"><span class="params">    newkmvd-&gt;kva_start = currkmvd-&gt;kva_end;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">else</span></span></span><br><span class="line"><span class="params">  &#123;<span class="comment">//否则这个新的虚拟地址区间的开始就是请求分配的开始地址</span></span></span><br><span class="line"><span class="params">    newkmvd-&gt;kva_start = start;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置新的虚拟地址区间的结束地址</span></span></span><br><span class="line"><span class="params">  newkmvd-&gt;kva_end = newkmvd-&gt;kva_start + vassize;</span></span><br><span class="line"><span class="params">  newkmvd-&gt;kva_limits = vaslimits;</span></span><br><span class="line"><span class="params">  newkmvd-&gt;kva_maptype = vastype;</span></span><br><span class="line"><span class="params">  newkmvd-&gt;kva_mcstruct = vma;</span></span><br><span class="line"><span class="params">  vma-&gt;vs_currkmvdsc = newkmvd;</span></span><br><span class="line"><span class="params">  <span class="comment">//将新的虚拟地址区间加入到virmemadrs_t结构中</span></span></span><br><span class="line"><span class="params">  list_add(&amp;newkmvd-&gt;kva_list, &amp;currkmvd-&gt;kva_list);</span></span><br><span class="line"><span class="params">  <span class="comment">//看看新的虚拟地址区间是否是最后一个</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (list_is_last(&amp;newkmvd-&gt;kva_list, &amp;vma-&gt;vs_list) == TRUE)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    vma-&gt;vs_endkmvdsc = newkmvd;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//返回新的虚拟地址区间的开始地址</span></span></span><br><span class="line"><span class="params">  retadrs = newkmvd-&gt;kva_start;</span></span><br><span class="line"><span class="params">  out:</span></span><br><span class="line"><span class="params">  knl_spinunlock(&amp;vma-&gt;vs_lock);</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> retadrs;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//分配虚拟地址空间的接口</span></span></span><br><span class="line"><span class="params"><span class="type">adr_t</span> vma_new_vadrs(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">adr_t</span> start, <span class="type">size_t</span> vassize, <span class="type">u64_t</span> vaslim</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> == mm || <span class="number">1</span> &gt; vassize)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> != start)</span></span><br><span class="line"><span class="params">  &#123;<span class="comment">//进行参数检查，开始地址要和页面（1KB）对齐，结束地址不能超过整个虚拟地址空间</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (((start &amp; <span class="number">0xfff</span>) != <span class="number">0</span>) || (<span class="number">0x1000</span> &gt; start) || (USER_VIRTUAL_ADDRES</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//调用虚拟地址空间分配的核心函数</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> vma_new_vadrs_core(mm, start, VADSZ_ALIGN(vassize), vaslimits, vast</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// --------------------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 分配时查找虚拟地址区间</span></span></span><br><span class="line"><span class="params"><span class="comment">// --------------------</span></span></span><br><span class="line"><span class="params"><span class="comment">//检查kmvarsdsc_t结构</span></span></span><br><span class="line"><span class="params"><span class="type">kmvarsdsc_t</span> *vma_find_kmvarsdsc_is_ok(<span class="type">virmemadrs_t</span> *vmalocked, <span class="type">kmvarsdsc_t</span> *cu</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">kmvarsdsc_t</span> *nextkmvd = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="type">adr_t</span> newend = start + (<span class="type">adr_t</span>)vassize;</span></span><br><span class="line"><span class="params">  <span class="comment">//如果curr不是最后一个先检查当前kmvarsdsc_t结构</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (list_is_last(&amp;curr-&gt;kva_list, &amp;vmalocked-&gt;vs_list) == FALSE)</span></span><br><span class="line"><span class="params">  &#123;<span class="comment">//就获取curr的下一个kmvarsdsc_t结构</span></span></span><br><span class="line"><span class="params">    nextkmvd = list_next_entry(curr, <span class="type">kmvarsdsc_t</span>, kva_list);</span></span><br><span class="line"><span class="params">    <span class="comment">//由系统动态决定分配虚拟空间的开始地址</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (<span class="literal">NULL</span> == start)</span></span><br><span class="line"><span class="params">    &#123;<span class="comment">//如果curr的结束地址加上分配的大小小于等于下一个kmvarsdsc_t结构的开始地址就返回c</span></span></span><br><span class="line"><span class="params">      <span class="keyword">if</span> ((curr-&gt;kva_end + (<span class="type">adr_t</span>)vassize) &lt;= nextkmvd-&gt;kva_start)</span></span><br><span class="line"><span class="params">      &#123;</span></span><br><span class="line"><span class="params">        <span class="keyword">return</span> curr;</span></span><br><span class="line"><span class="params">      &#125;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">else</span></span></span><br><span class="line"><span class="params">    &#123;<span class="comment">//否则比较应用指定分配的开始、结束地址是不是在curr和下一个kmvarsdsc_t结构之间</span></span></span><br><span class="line"><span class="params">      <span class="keyword">if</span> ((curr-&gt;kva_end &lt;= start) &amp;&amp; (newend &lt;= nextkmvd-&gt;kva_start))</span></span><br><span class="line"><span class="params">      &#123;</span></span><br><span class="line"><span class="params">        <span class="keyword">return</span> curr;</span></span><br><span class="line"><span class="params">      &#125;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">else</span></span></span><br><span class="line"><span class="params">  &#123;<span class="comment">//否则curr为最后一个kmvarsdsc_t结构</span></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (<span class="literal">NULL</span> == start)</span></span><br><span class="line"><span class="params">    &#123;<span class="comment">//curr的结束地址加上分配空间的大小是不是小于整个虚拟地址空间</span></span></span><br><span class="line"><span class="params">      <span class="keyword">if</span> ((curr-&gt;kva_end + (<span class="type">adr_t</span>)vassize) &lt; vmalocked-&gt;vs_isalcend)</span></span><br><span class="line"><span class="params">      &#123;</span></span><br><span class="line"><span class="params">        <span class="keyword">return</span> curr;</span></span><br><span class="line"><span class="params">      &#125;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">else</span></span></span><br><span class="line"><span class="params">    &#123;<span class="comment">//否则比较应用指定分配的开始、结束地址是不是在curr的结束地址和整个虚拟地址空间的结</span></span></span><br><span class="line"><span class="params">      <span class="keyword">if</span> ((curr-&gt;kva_end &lt;= start) &amp;&amp; (newend &lt; vmalocked-&gt;vs_isalcend))</span></span><br><span class="line"><span class="params">      &#123;</span></span><br><span class="line"><span class="params">        <span class="keyword">return</span> curr;</span></span><br><span class="line"><span class="params">      &#125;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//查找kmvarsdsc_t结构</span></span></span><br><span class="line"><span class="params"><span class="type">kmvarsdsc_t</span> *vma_find_kmvarsdsc(<span class="type">virmemadrs_t</span> *vmalocked, <span class="type">adr_t</span> start, <span class="type">size_t</span> v</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">kmvarsdsc_t</span> *kmvdcurrent = <span class="literal">NULL</span>, *curr = vmalocked-&gt;vs_currkmvdsc;</span></span><br><span class="line"><span class="params">  <span class="type">adr_t</span> newend = start + vassize;</span></span><br><span class="line"><span class="params">  <span class="type">list_h_t</span> *listpos = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//分配的虚拟空间大小小于4KB不行</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="number">0x1000</span> &gt; vassize)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//将要分配虚拟地址空间的结束地址大于整个虚拟地址空间 不行</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (newend &gt; vmalocked-&gt;vs_isalcend)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (<span class="literal">NULL</span> != curr)</span></span><br><span class="line"><span class="params">  &#123;<span class="comment">//先检查当前kmvarsdsc_t结构行不行</span></span></span><br><span class="line"><span class="params">    kmvdcurrent = vma_find_kmvarsdsc_is_ok(vmalocked, curr, start, vassize</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (<span class="literal">NULL</span> != kmvdcurrent)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> kmvdcurrent;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//遍历virmemadrs_t中的所有的kmvarsdsc_t结构</span></span></span><br><span class="line"><span class="params">  list_for_each(listpos, &amp;vmalocked-&gt;vs_list)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    curr = list_entry(listpos, <span class="type">kmvarsdsc_t</span>, kva_list);</span></span><br><span class="line"><span class="params">    <span class="comment">//检查每个kmvarsdsc_t结构</span></span></span><br><span class="line"><span class="params">    kmvdcurrent = vma_find_kmvarsdsc_is_ok(vmalocked, curr, start, vassize</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (<span class="literal">NULL</span> != kmvdcurrent)</span></span><br><span class="line"><span class="params">    &#123;<span class="comment">//如果符合要求就返回</span></span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> kmvdcurrent;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>虚拟地址空间释放接口</strong>
<ul>
<li>只需要释放虚拟空间的开始地址和大小</li>
<li>分配虚拟地址空间时,为了节约 kmvarsdsc_t 结构占用的内存空间,规定只要分配的虚拟地址空间上一个虚拟地址空间是连续且类型相同的,就借用上一个 kmvarsdsc_t 结构,而不是重新分配表示新分配的虚拟地址空间(避免物理内存被很快耗尽)</li>
</ul>
</li>
<li><strong>释放时查找虚拟地址区间</strong>
<ul>
<li>释放时仅仅需要保证，释放的虚拟地址空间的开始地址和结束地址落在某一个 kmvarsdsc_t 结构表示的虚拟地址区间</li>
<li>释放时查找虚拟地址空间的函数仅仅检查释放的虚拟地址是否落在查找 kmvarsdsc_t 结构表示的虚拟地址区间中,可能的四种变换形式交给核心释放函数处理</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------------</span></span><br><span class="line"><span class="comment">// 虚拟地址空间释放接口</span></span><br><span class="line"><span class="comment">// -----------------</span></span><br><span class="line"><span class="comment">//释放虚拟地址空间的核心函数</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">vma_del_vadrs_core</span><span class="params">(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">adr_t</span> start, <span class="type">size_t</span> vassize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool_t</span> rets = FALSE;</span><br><span class="line">  <span class="type">kmvarsdsc_t</span> *newkmvd = <span class="literal">NULL</span>, *delkmvd = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">virmemadrs_t</span> *vma = &amp;mm-&gt;msd_virmemadrs;</span><br><span class="line">  knl_spinlock(&amp;vma-&gt;vs_lock);</span><br><span class="line">  <span class="comment">//查找要释放虚拟地址空间的kmvarsdsc_t结构</span></span><br><span class="line">  delkmvd = vma_del_find_kmvarsdsc(vma, start, vassize);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == delkmvd)</span><br><span class="line">  &#123;</span><br><span class="line">    rets = FALSE;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第一种情况要释放的虚拟地址空间正好等于查找的kmvarsdsc_t结构</span></span><br><span class="line">  <span class="keyword">if</span> ((delkmvd-&gt;kva_start == start) &amp;&amp; (delkmvd-&gt;kva_end == (start + (<span class="type">adr_t</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//脱链</span></span><br><span class="line">    list_del(&amp;delkmvd-&gt;kva_list);</span><br><span class="line">    <span class="comment">//删除kmvarsdsc_t结构</span></span><br><span class="line">    del_kmvarsdsc(delkmvd);</span><br><span class="line">    vma-&gt;vs_kmvdscnr--;</span><br><span class="line">    rets = TRUE;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第二种情况要释放的虚拟地址空间是在查找的kmvarsdsc_t结构的上半部分</span></span><br><span class="line">  <span class="keyword">if</span> ((delkmvd-&gt;kva_start == start) &amp;&amp; (delkmvd-&gt;kva_end &gt; (start + (<span class="type">adr_t</span>)v</span><br><span class="line">  &#123; <span class="comment">//所以直接把查找的kmvarsdsc_t结构的开始地址设置为释放虚拟地址空间的结束地址</span></span><br><span class="line">    delkmvd-&gt;kva_start = start + (<span class="type">adr_t</span>)vassize;</span><br><span class="line">    rets = TRUE;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第三种情况要释放的虚拟地址空间是在查找的kmvarsdsc_t结构的下半部分</span></span><br><span class="line">  <span class="keyword">if</span> ((delkmvd-&gt;kva_start &lt; start) &amp;&amp; (delkmvd-&gt;kva_end == (start + (<span class="type">adr_t</span>)v</span><br><span class="line">  &#123;<span class="comment">//所以直接把查找的kmvarsdsc_t结构的结束地址设置为释放虚拟地址空间的开始地址</span></span><br><span class="line">    delkmvd-&gt;kva_end = start;</span><br><span class="line">    rets = TRUE;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//第四种情况要释放的虚拟地址空间是在查找的kmvarsdsc_t结构的中间</span></span><br><span class="line">  <span class="keyword">if</span> ((delkmvd-&gt;kva_start &lt; start) &amp;&amp; (delkmvd-&gt;kva_end &gt; (start + (<span class="type">adr_t</span>)va</span><br><span class="line">  &#123;<span class="comment">//所以要再新建一个kmvarsdsc_t结构来处理释放虚拟地址空间之后的下半虚拟部分地址空间</span></span><br><span class="line">    newkmvd = new_kmvarsdsc();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == newkmvd)</span><br><span class="line">    &#123;</span><br><span class="line">      rets = FALSE;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让新的kmvarsdsc_t结构指向查找的kmvarsdsc_t结构的后半部分虚拟地址空间</span></span><br><span class="line">    newkmvd-&gt;kva_end = delkmvd-&gt;kva_end;</span><br><span class="line">    newkmvd-&gt;kva_start = start + (<span class="type">adr_t</span>)vassize;</span><br><span class="line">    <span class="comment">//和查找到的kmvarsdsc_t结构保持一致</span></span><br><span class="line">    newkmvd-&gt;kva_limits = delkmvd-&gt;kva_limits;</span><br><span class="line">    newkmvd-&gt;kva_maptype = delkmvd-&gt;kva_maptype;</span><br><span class="line">    newkmvd-&gt;kva_mcstruct = vma;</span><br><span class="line">    delkmvd-&gt;kva_end = start;</span><br><span class="line">    <span class="comment">//加入链表</span></span><br><span class="line">    list_add(&amp;newkmvd-&gt;kva_list, &amp;delkmvd-&gt;kva_list);</span><br><span class="line">    vma-&gt;vs_kmvdscnr++;</span><br><span class="line">    <span class="comment">//是否为最后一个kmvarsdsc_t结构</span></span><br><span class="line">    <span class="keyword">if</span> (list_is_last(&amp;newkmvd-&gt;kva_list, &amp;vma-&gt;vs_list) == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      vma-&gt;vs_endkmvdsc = newkmvd;</span><br><span class="line">      vma-&gt;vs_currkmvdsc = newkmvd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      vma-&gt;vs_currkmvdsc = newkmvd;</span><br><span class="line">    &#125;</span><br><span class="line">    rets = TRUE;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  rets = FALSE;</span><br><span class="line">  out:</span><br><span class="line">  knl_spinunlock(&amp;vma-&gt;vs_lock);</span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放虚拟地址空间的接口</span></span><br><span class="line"><span class="type">bool_t</span> vma_del_vadrs(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">adr_t</span> start, <span class="type">size_t</span> vassize)</span><br><span class="line">&#123; <span class="comment">//对参数进行检查</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == mm || <span class="number">1</span> &gt; vassize || <span class="literal">NULL</span> == start)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用核心处理函数</span></span><br><span class="line">  <span class="keyword">return</span> vma_del_vadrs_core(mm, start, VADSZ_ALIGN(vassize));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="comment">// 释放时查找虚拟地址空间</span></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="type">kmvarsdsc_t</span> *vma_del_find_kmvarsdsc(<span class="type">virmemadrs_t</span> *vmalocked, <span class="type">adr_t</span> start, size</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">kmvarsdsc_t</span> *curr = vmalocked-&gt;vs_currkmvdsc;</span><br><span class="line">  <span class="type">adr_t</span> newend = start + (<span class="type">adr_t</span>)vassize;</span><br><span class="line">  <span class="type">list_h_t</span> *listpos = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> != curr)</span><br><span class="line">  &#123;<span class="comment">//释放的虚拟地址空间落在了当前kmvarsdsc_t结构表示的虚拟地址区间</span></span><br><span class="line">    <span class="keyword">if</span> ((curr-&gt;kva_start) &lt;= start &amp;&amp; (newend &lt;= curr-&gt;kva_end))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历所有的kmvarsdsc_t结构</span></span><br><span class="line">  list_for_each(listpos, &amp;vmalocked-&gt;vs_list)</span><br><span class="line">  &#123;</span><br><span class="line">    curr = list_entry(listpos, <span class="type">kmvarsdsc_t</span>, kva_list);</span><br><span class="line">    <span class="comment">//释放的虚拟地址空间是否落在了其中的某个kmvarsdsc_t结构表示的虚拟地址区间</span></span><br><span class="line">    <span class="keyword">if</span> ((start &gt;= curr-&gt;kva_start) &amp;&amp; (newend &lt;= curr-&gt;kva_end))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>测试虚拟空间能正常访问</strong>
<ul>
<li><strong>准备工作</strong>:先分配一个虚拟地址空间,分配一个虚拟地址空间并访问
<ul>
<li>在 init_kvirmemadrs 函数的最后调用的 test_vadr 函数，一旦执行，一定会发生异常。为了显示异常要在异常分发器函数中写点代码</li>
</ul>
</li>
<li><strong>缺页异常</strong>
<ul>
<li>原因:访问一个虚拟地址,该虚拟地址由CPU发送给MMU，而MMU无法将它转换成对应的物理地址，CPU访存指令无法执行，产生缺页异常。CPU 跳转到缺页异常处理的入口地址（kernel.asm 文件中的 exc_page_fault 标号处）开始执行代码，处理这个缺页异常</li>
<li><strong>延迟内存分配技术(最大限度的节约物理内存)</strong>：等到发生缺页异常，才分配物理内存页面，建立对应的MMU页表;只要实际访问到了才分配对应的物理内存页面</li>
</ul>
</li>
<li><strong>开始处理缺页异常</strong>
<ul>
<li>缺页异常是从 kernel.asm 文件中的 exc_page_fault 标号处开始，但它只是保存了 CPU 的上下文，然后调用了内核的通用异常分发器函数，最后由异常分发器函数调用不同的异常处理函数，如果是缺页异常，就要调用缺页异常处理的接口函数，<strong>实现缺页异常处理的接口函数</strong></li>
</ul>
</li>
<li><strong>处理缺页异常的核心</strong>
<ul>
<li>首先，查找缺页地址对应的 kmvarsdsc_t 结构，没找到说明没有分配该虚拟地址空间，那属于非法访问不予处理；然后，查找 kmvarsdsc_t 结构下面的对应 kvmemcbox_t 结构，它是用来挂载物理内存页面的；最后，分配物理内存页面并建立 MMU 页表映射关系</li>
</ul>
</li>
<li><strong>缺页地址是否合法</strong>
<ul>
<li>判断一个缺页地址是否合法要确定它是不是已经分配的虚拟地址，也就是看这个虚拟地址是不是会落在某个 kmvarsdsc_t 结构表示的虚拟地址区间；要去查找相应的 kmvarsdsc_t 结构，如果没有找到则虚拟地址没有分配，即这个缺页地址不合法</li>
<li>核心逻辑就是用虚拟地址和 kmvarsdsc_t 结构中的数据做比较，大于等于 kmvarsdsc_t 结构的开始地址并且小于 kmvarsdsc_t 结构的结束地址就可以</li>
</ul>
</li>
<li><strong>建立 kvmembox_t 结构</strong>
<ul>
<li>kvmemcbox_t 结构可以用来挂载物理内存页面 msadsc_t 结构，而这个 msadsc_t 结构是由虚拟地址区间 kmvarsdsc_t 结构代表的虚拟空间所映射的物理内存页面</li>
<li>一个kmvarsdsc_t 结构，必须要有一个 kvmemcbox_t 结构，才能分配物理内存。除了这个功能，kvmemcbox_t 结构还可以在内存共享的时候使用</li>
</ul>
</li>
<li><strong>映射物理内存页面</strong>
<ul>
<li>给虚拟地址分配对应的物理内存页面，建立对应的 MMU 页表，使虚拟地址到物理地址可以转换成功，数据终于能写入到物理内存之中</li>
<li>vma_map_msa_fault 的实际工作:
<ul>
<li>首先，它会调用vma_new_usermsa 函数，在 vma_new_usermsa 函数内部调用了我们前面学过的页面内存管理接口，分配一个物理内存页面并把对应的 msadsc_t 结构挂载到 kvmemcbox_t 结构上</li>
<li>接着获取 msadsc_t 结构对应内存页面的物理地址</li>
<li>最后是调用 hal_mmu_transform 函数完成虚拟地址到物理地址的映射工作，它主要是建立 MMU 页表</li>
<li>vma_map_phyadrs 函数一旦成功返回，就会随着原有的代码路径层层返回</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_vadr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//分配一个0x1000大小的虚拟地址空间</span></span><br><span class="line"><span class="type">adr_t</span> vadr = vma_new_vadrs(&amp;initmmadrsdsc, <span class="literal">NULL</span>, <span class="number">0x1000</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//返回NULL表示分配失败</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == vadr)</span><br><span class="line">&#123;</span><br><span class="line">kprint(<span class="string">&quot;分配虚拟地址空间失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在刷屏幕上打印分配虚拟地址空间的开始地址</span></span><br><span class="line">kprint(<span class="string">&quot;分配虚拟地址空间地址:%x\n&quot;</span>, vadr);</span><br><span class="line">kprint(<span class="string">&quot;开始写入分配虚拟地址空间\n&quot;</span>);</span><br><span class="line"><span class="comment">//访问虚拟地址空间，把这空间全部设置为0</span></span><br><span class="line">hal_memset((<span class="type">void</span>*)vadr, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">kprint(<span class="string">&quot;结束写入分配虚拟地址空间\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_kvirmemadrs</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="comment">//调用测试函数</span></span><br><span class="line">test_vadr();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// 异常分发器中的函数</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">//cosmos/hal/x86/halintupt.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hal_fault_allocator</span><span class="params">(<span class="type">uint_t</span> faultnumb, <span class="type">void</span> *krnlsframp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印异常号</span></span><br><span class="line">kprint(<span class="string">&quot;faultnumb is :%d\n&quot;</span>, faultnumb);</span><br><span class="line"><span class="comment">//如果异常号等于14则是内存缺页异常</span></span><br><span class="line"><span class="keyword">if</span> (faultnumb == <span class="number">14</span>)</span><br><span class="line">&#123;<span class="comment">//打印缺页地址，这地址保存在CPU的CR2寄存器中</span></span><br><span class="line">kprint(<span class="string">&quot;异常地址:%x,此地址禁止访问\n&quot;</span>, read_cr2());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//死机，不让这个函数返回了</span></span><br><span class="line">die(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">//缺页异常处理接口</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="type">sint_t</span> <span class="title function_">vma_map_fairvadrs</span><span class="params">(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">adr_t</span> vadrs)</span></span><br><span class="line">&#123;<span class="comment">//对参数进行检查</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="number">0x1000</span> &gt; vadrs) || (USER_VIRTUAL_ADDRESS_END &lt; vadrs) || (<span class="literal">NULL</span> == mm)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> -EPARAM;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//进行缺页异常的核心处理</span></span><br><span class="line">  <span class="keyword">return</span> vma_map_fairvadrs_core(mm, vadrs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由异常分发器调用的接口</span></span><br><span class="line"><span class="type">sint_t</span> krluserspace_accessfailed(<span class="type">adr_t</span> fairvadrs)</span><br><span class="line">&#123;<span class="comment">//这里应该获取当前进程的mm，但是现在我们没有进程，才initmmadrsdsc代替</span></span><br><span class="line">  <span class="type">mmadrsdsc_t</span>* mm = &amp;initmmadrsdsc;</span><br><span class="line">  <span class="comment">//应用程序的虚拟地址不可能大于USER_VIRTUAL_ADDRESS_END</span></span><br><span class="line">  <span class="keyword">if</span>(USER_VIRTUAL_ADDRESS_END &lt; fairvadrs)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> -EACCES;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vma_map_fairvadrs(mm, fairvadrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 在 cosmos/hal/x86/halintupt.c 文件的异常分发器函数中调用它</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> hal_fault_allocator(<span class="type">uint_t</span> faultnumb, <span class="type">void</span> *krnlsframp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">adr_t</span> fairvadrs;</span><br><span class="line">  kprint(<span class="string">&quot;faultnumb is :%d\n&quot;</span>, faultnumb);</span><br><span class="line">  <span class="keyword">if</span> (faultnumb == <span class="number">14</span>)</span><br><span class="line">  &#123; <span class="comment">//获取缺页的地址</span></span><br><span class="line">    fairvadrs = (<span class="type">adr_t</span>)read_cr2();</span><br><span class="line">    kprint(<span class="string">&quot;异常地址:%x,此地址禁止访问\n&quot;</span>, fairvadrs);</span><br><span class="line">    <span class="keyword">if</span> (krluserspace_accessfailed(fairvadrs) != <span class="number">0</span>)</span><br><span class="line">    &#123;<span class="comment">//处理缺页失败就死机</span></span><br><span class="line">      system_error(<span class="string">&quot;缺页处理失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功就返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  die(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">// 处理缺页异常的核心</span></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="type">sint_t</span> vma_map_fairvadrs_core(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">adr_t</span> vadrs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">sint_t</span> rets = FALSE;</span><br><span class="line">  <span class="type">adr_t</span> phyadrs = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">virmemadrs_t</span> *vma = &amp;mm-&gt;msd_virmemadrs;</span><br><span class="line">  <span class="type">kmvarsdsc_t</span> *kmvd = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">kvmemcbox_t</span> *kmbox = <span class="literal">NULL</span>;</span><br><span class="line">  knl_spinlock(&amp;vma-&gt;vs_lock);</span><br><span class="line">  <span class="comment">//查找对应的kmvarsdsc_t结构</span></span><br><span class="line">  kmvd = vma_map_find_kmvarsdsc(vma, vadrs);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == kmvd)</span><br><span class="line">  &#123;</span><br><span class="line">    rets = -EFAULT;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回kmvarsdsc_t结构下对应kvmemcbox_t结构</span></span><br><span class="line">  kmbox = vma_map_retn_kvmemcbox(kmvd);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == kmbox)</span><br><span class="line">  &#123;</span><br><span class="line">    rets = -ENOMEM;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//分配物理内存页面并建立MMU页表</span></span><br><span class="line">  phyadrs = vma_map_phyadrs(mm, kmvd, vadrs, (<span class="number">0</span> | PML4E_US | PML4E_RW | PML4</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == phyadrs)</span><br><span class="line">  &#123;</span><br><span class="line">    rets = -ENOMEM;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  rets = EOK;</span><br><span class="line">  out:</span><br><span class="line">  knl_spinunlock(&amp;vma-&gt;vs_lock);</span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">// 缺页地址是否合法</span></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="type">kmvarsdsc_t</span> *vma_map_find_kmvarsdsc(<span class="type">virmemadrs_t</span> *vmalocked, <span class="type">adr_t</span> vadrs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">list_h_t</span> *pos = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">kmvarsdsc_t</span> *curr = vmalocked-&gt;vs_currkmvdsc;</span><br><span class="line">  <span class="comment">//看看上一次刚刚被操作的kmvarsdsc_t结构</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> != curr)</span><br><span class="line">  &#123;<span class="comment">//虚拟地址是否落在kmvarsdsc_t结构表示的虚拟地址区间</span></span><br><span class="line">    <span class="keyword">if</span> ((vadrs &gt;= curr-&gt;kva_start) &amp;&amp; (vadrs &lt; curr-&gt;kva_end))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历每个kmvarsdsc_t结构</span></span><br><span class="line">  list_for_each(pos, &amp;vmalocked-&gt;vs_list)</span><br><span class="line">  &#123;</span><br><span class="line">    curr = list_entry(pos, <span class="type">kmvarsdsc_t</span>, kva_list);</span><br><span class="line">    <span class="comment">//虚拟地址是否落在kmvarsdsc_t结构表示的虚拟地址区间</span></span><br><span class="line">    <span class="keyword">if</span> ((vadrs &gt;= curr-&gt;kva_start) &amp;&amp; (vadrs &lt; curr-&gt;kva_end))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="comment">// 建立 kvmemcbox_t结构</span></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="type">kvmemcbox_t</span> *vma_map_retn_kvmemcbox(<span class="type">kmvarsdsc_t</span> *kmvd)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">kvmemcbox_t</span> *kmbox = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//如果kmvarsdsc_t结构中已经存在了kvmemcbox_t结构，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> != kmvd-&gt;kva_kvmbox)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> kmvd-&gt;kva_kvmbox;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//新建一个kvmemcbox_t结构</span></span><br><span class="line">  kmbox = knl_get_kvmemcbox();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == kmbox)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//指向这个新建的kvmemcbox_t结构</span></span><br><span class="line">  kmvd-&gt;kva_kvmbox = kmbox;</span><br><span class="line">  <span class="keyword">return</span> kmvd-&gt;kva_kvmbox;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"><span class="comment">// 映射物理内存页面</span></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"><span class="type">adr_t</span> vma_map_msa_fault(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">kvmemcbox_t</span> *kmbox, <span class="type">adr_t</span> vadrs, u64_</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">msadsc_t</span> *usermsa;</span><br><span class="line">  <span class="type">adr_t</span> phyadrs = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//分配一个物理内存页面，挂载到kvmemcbox_t中，并返回对应的msadsc_t结构</span></span><br><span class="line">  usermsa = vma_new_usermsa(mm, kmbox);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == usermsa)</span><br><span class="line">  &#123;<span class="comment">//没有物理内存页面返回NULL表示失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取msadsc_t对应的内存页面的物理地址</span></span><br><span class="line">  phyadrs = msadsc_ret_addr(usermsa);</span><br><span class="line">  <span class="comment">//建立MMU页表完成虚拟地址到物理地址的映射</span></span><br><span class="line">  <span class="keyword">if</span> (hal_mmu_transform(&amp;mm-&gt;msd_mmu, vadrs, phyadrs, flags) == TRUE)</span><br><span class="line">  &#123;<span class="comment">//映射成功则返回物理地址</span></span><br><span class="line">    <span class="keyword">return</span> phyadrs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//映射失败就要先释放分配的物理内存页面</span></span><br><span class="line">  vma_del_usermsa(mm, kmbox, usermsa, phyadrs);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口函数</span></span><br><span class="line"><span class="type">adr_t</span> vma_map_phyadrs(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">kmvarsdsc_t</span> *kmvd, <span class="type">adr_t</span> vadrs, <span class="type">u64_t</span> f</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">kvmemcbox_t</span> *kmbox = kmvd-&gt;kva_kvmbox;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == kmbox)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用核心函数，flags表示页表条目中的相关权限、存在、类型等位段</span></span><br><span class="line">  <span class="keyword">return</span> vma_map_msa_fault(mm, kmbox, vadrs, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="67-瞧一瞧linux伙伴系统如何分配内存"><a class="markdownIt-Anchor" href="#67-瞧一瞧linux伙伴系统如何分配内存"></a> 6.7 瞧一瞧Linux:伙伴系统如何分配内存</h2>
<ul>
<li>Linux系统中用来管理物理内存页面的<strong>伙伴系统</strong>,以及负责分配比页更小的内存对象的SLAB分配器</li>
<li><strong>伙伴系统</strong>：源于Sun公司的Solaris操作系统</li>
<li><strong>怎样表示一个页</strong>
<ul>
<li>Linux使用分页机制管理物理内存,即将物理内存分成4KB大小的页面进行管理</li>
<li>早期的Linux使用位图,后来使用字节数组,如今<strong>使用Page结构体</strong></li>
<li>page结构体巨大,信息量很多,但占用的内存很少，大量使用C语言union联合体定义结构字段</li>
<li>使用page结构通过flags表示状态,<strong>Linux内核中，一个page结构表示一个物理内存页面</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">  <span class="comment">// page结构体的标志，它决定页面是什么状态</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="comment">//挂载上级结构的链表</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">      <span class="comment">//用于文件系统，address_space结构描述上文件占用了哪些内存页面</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">      <span class="type">pgoff_t</span> index;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//DMA设备的地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="type">dma_addr_t</span> dma_addr;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//当页面用于内存对象时指向相关的数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line">          <span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="type">int</span> pages;</span><br><span class="line">            <span class="type">int</span> pobjects;</span><br><span class="line">          <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="type">short</span> <span class="type">int</span> pages;</span><br><span class="line">            <span class="type">short</span> <span class="type">int</span> pobjects;</span><br><span class="line">          <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">//指向管理SLAB的结构kmem_cache</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line">      <span class="comment">//指向SLAB的第一个对象</span></span><br><span class="line">      <span class="type">void</span> *freelist;</span><br><span class="line">      <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *s_mem;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">          <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">          <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">          <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//用于页表映射相关的字段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> _pt_pad_1;</span><br><span class="line">      <span class="type">pgtable_t</span> pmd_huge_pte;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> _pt_pad_2;</span><br><span class="line">      <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span></span><br><span class="line">        <span class="type">atomic_t</span> pt_frag_refcount;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">//自旋锁</span></span><br><span class="line">      <span class="meta">#<span class="keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="type">spinlock_t</span> *ptl;</span><br><span class="line">      <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">spinlock_t</span> ptl;</span><br><span class="line">      <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//用于设备映射</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">      <span class="type">void</span> *zone_device_data;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//页面引用计数</span></span><br><span class="line">  <span class="type">atomic_t</span> _refcount;</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">    <span class="type">int</span> _last_cpupid;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="class"><span class="keyword">struct</span> <span class="title">page_alignment</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>怎样表示一个区</strong>
<ul>
<li>因为硬件限制,linux内核不能对所有物理内存页统一对待，把属性相同物理内存页面归结到一个区
<ul>
<li>在32位的x86平台,一些使用DMA设备只能访问0<sub>16MB物理空间，因此将0</sub>16MB划分为DMA区</li>
<li>高内存区适用于要访问物理地址空间大于虚拟地址空间,linux内核不能建立直接映射的情况
<ul>
<li>64位的x86平台没有高内存区</li>
</ul>
</li>
<li>除了这两个区,物理内存中剩余页面被划分到常规内存区</li>
</ul>
</li>
<li>在linux查看机器的内存区:cat /proc/zoneinfo | grep Node</li>
<li>linux内核用zone数据结构表示一个区
<ul>
<li>_watermark表示内存页面总量的水位线有min,low,high三种状态,可以作为启动内存页面回收的判断标准</li>
<li>spanned_pages是该内存区总的页面数</li>
<li>present_pages表示页面真正存在,一些内存区中存在内存空洞,空洞对应的page结构不能用</li>
<li><strong>在zone中需要关注的是 free_area 结构的数组</strong>,用于实现伙伴系统,其中 MAX_ORDER 的值默认为11，分别表示挂载地址连续的page结构数目为1,2,4,8,…1024
<ul>
<li>free_area结构是一个 list_head 链表数组,该数组将具有相同迁移类型的page结构尽可能地分组，同一类型的所有相同 order 的 page 结构构成一组 page 结构体</li>
<li>分配时会先按请求的 migratetype 从对应的 page 结构块中寻找,若不成功才会从其他 migratetype 的page结构块中分配,<mark>为了让内存页迁移更加高效，可以有效降低内存碎片</mark></li>
</ul>
</li>
<li><strong>指向 pglist_data 的指针(重要结构)</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zone数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">  MIGRATE_UNMOVABLE, <span class="comment">//不能移动的</span></span><br><span class="line">  MIGRATE_MOVABLE, <span class="comment">//可移动和</span></span><br><span class="line">  MIGRATE_RECLAIMABLE,</span><br><span class="line">  MIGRATE_PCPTYPES, <span class="comment">//属于pcp list的</span></span><br><span class="line">  MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">    MIGRATE_CMA, <span class="comment">//属于CMA区的</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    MIGRATE_ISOLATE,</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//页面空闲链表头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nr_free;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> _watermark[NR_WMARK];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> watermark_boost;</span><br><span class="line">  <span class="comment">//预留的内存页面数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nr_reserved_highatomic;</span><br><span class="line">  <span class="comment">//内存区属于哪个内存节点</span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="type">int</span> node;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">  <span class="comment">//内存区开始的page结构数组的开始下标</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> zone_start_pfn;</span><br><span class="line">  <span class="type">atomic_long_t</span> managed_pages;</span><br><span class="line">  <span class="comment">//内存区总的页面数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> spanned_pages;</span><br><span class="line">  <span class="comment">//内存区存在的页面数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> present_pages;</span><br><span class="line">  <span class="comment">//内存区名字</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="comment">//挂载页面page结构的链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">  <span class="comment">//内存区的标志</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">  <span class="comment">/*保护free_area的自旋锁*/</span></span><br><span class="line">  <span class="type">spinlock_t</span> lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>怎样表示一个节点</strong>
<ul>
<li>NUMA体系结构:在很多服务器和大型计算机上,如果物理内存时分布式的,有多个计算节点组成,那么每个CPU核都会有自己的本地内存,CPU在访问本地内存时较快,访问其他CPU核内存较慢
<ul>
<li>Linux对NUMA进行抽象可以将一整块连续物理内存划分成几个内存节点,也可以将不连续的物理内存当成真正的NUMA</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-15-56-49.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-15-56-49.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="NUMA架构" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  ZONELIST_FALLBACK,</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    ZONELIST_NOFALLBACK,</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  MAX_ZONELISTS</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span><span class="comment">//内存区指针</span></span><br><span class="line">  <span class="type">int</span> zone_idx; <span class="comment">//内存区对应的索引</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//zone枚举类型 从0开始</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">  ZONE_DMA,</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">  ZONE_DMA32,</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ZONE_NORMAL,</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">  ZONE_HIGHMEM,</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ZONE_MOVABLE,</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DEVICE</span></span><br><span class="line">  ZONE_DEVICE,</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  __MAX_NR_ZONES</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义MAX_NR_ZONES为__MAX_NR_ZONES 最大为6</span></span><br><span class="line">DEFINE(MAX_NR_ZONES, __MAX_NR_ZONES);</span><br><span class="line"><span class="comment">//内存节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line"><span class="comment">//定一个内存区数组，最大为6个zone元素</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">  <span class="comment">//两个zonelist，一个是指向本节点的的内存区，另一个指向由本节点分配不到内存时可选的备用内存区</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">  <span class="comment">//本节点有多少个内存区</span></span><br><span class="line">  <span class="type">int</span> nr_zones;</span><br><span class="line">  <span class="comment">//本节点开始的page索引号</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">  <span class="comment">//本节点有多少个可用的页面</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> node_present_pages;</span><br><span class="line">  <span class="comment">//本节点有多少个可用的页面包含内存空洞</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages;</span><br><span class="line">  <span class="comment">//节点id</span></span><br><span class="line">  <span class="type">int</span> node_id;</span><br><span class="line">  <span class="comment">//交换内存页面相关的字段</span></span><br><span class="line">  <span class="type">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">  <span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span></span><br><span class="line">  <span class="comment">//本节点保留的内存页面</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> totalreserve_pages;</span><br><span class="line">  <span class="comment">//自旋锁</span></span><br><span class="line">  <span class="type">spinlock_t</span> lru_lock;</span><br><span class="line">&#125; pg_data t;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数据结构之间的关系</strong>
<ul>
<li>pglist_data,zonelist,zone,page 数据结构的核心内容</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-16-01-33.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-16-01-33.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Linux内存数据结构关系" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-16-02-46.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-16-02-46.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="伙伴系统示意图" /></p>
<ul>
<li><strong>何为伙伴</strong>
<ul>
<li>Linux物理内存页面管理中,连续且相同大小的pages可表示为伙伴</li>
</ul>
</li>
<li><strong>分配页面</strong>
<ul>
<li>首先要找到内存节点,接着找到内存区,然后合适的空闲链表,最后在其中找到页的page结构完成物理内存页面的分配</li>
</ul>
</li>
<li><strong>通过接口找到内存节点</strong>
<ul>
<li>虚线框中为接口函数，所有接口函数都会调用 alloc_pages 函数,该函数会调用 __alloc_pages_nodemask 函数完成内存页面的分配</li>
<li>alloc_pages_current函数最终调用__alloc_pages_nodemask 函数，参数order表示请求分配2的order次方个页面,<strong>gfp_t类型的gfp_mask参数为重点</strong>
<ul>
<li>gfp_t 是 int 类型，用其中位的状态表示请求分配不同的内存区的内存页面，以及分配内存页面的不同方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-16-17-29.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-16-17-29.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="分配内存页面的接口" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alloc_pages 函数的形式</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_pages_current</span><span class="params">(<span class="type">gfp_t</span> gfp, <span class="type">unsigned</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">pol</span> =</span> &amp;default_policy;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (!in_interrupt() &amp;&amp; !(gfp &amp; __GFP_THISNODE))</span><br><span class="line">  pol = get_task_policy(current);</span><br><span class="line">  <span class="keyword">if</span> (pol-&gt;mode == MPOL_INTERLEAVE)</span><br><span class="line">  page = alloc_page_interleave(gfp, order, interleave_nodes(pol));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  page = __alloc_pages_nodemask(gfp, order,</span><br><span class="line">  policy_node(gfp, pol, numa_node_id()),</span><br><span class="line">  policy_nodemask(gfp, pol));</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page * <span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> alloc_pages_current(gfp_mask, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gfp_mask 的类型和取值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> __bitwise <span class="type">gfp_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DMA 0x01u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HIGHMEM 0x02u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DMA32 0x04u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_MOVABLE 0x08u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_RECLAIMABLE 0x10u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HIGH 0x20u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_IO 0x40u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_FS 0x80u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ZERO 0x100u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ATOMIC 0x200u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_DIRECT_RECLAIM 0x400u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_KSWAPD_RECLAIM 0x800u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_WRITE 0x1000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOWARN 0x2000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_RETRY_MAYFAIL 0x4000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOFAIL 0x8000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NORETRY 0x10000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_MEMALLOC 0x20000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_COMP 0x40000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_NOMEMALLOC 0x80000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_HARDWALL 0x100000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_THISNODE 0x200000u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___GFP_ACCOUNT 0x400000u</span></span><br><span class="line"><span class="comment">//需要原子分配内存不得让请求者进入睡眠</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_ATOMIC (__GFP_HIGH|__GFP_ATOMIC|__GFP_KSWAPD_RECLAIM)</span></span><br><span class="line"><span class="comment">//分配用于内核自己使用的内存，可以有IO和文件系统相关的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_KERNEL (__GFP_RECLAIM | __GFP_IO | __GFP_FS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_KERNEL_ACCOUNT (GFP_KERNEL | __GFP_ACCOUNT)</span></span><br><span class="line"><span class="comment">//分配内存不能睡眠，不能有I/O和文件系统相关的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_NOWAIT (__GFP_KSWAPD_RECLAIM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_NOIO (__GFP_RECLAIM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_NOFS (__GFP_RECLAIM | __GFP_IO)</span></span><br><span class="line"><span class="comment">//分配用于用户进程的内存</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_USER (__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)</span></span><br><span class="line"><span class="comment">//用于DMA设备的内存</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_DMA __GFP_DMA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_DMA32 __GFP_DMA32</span></span><br><span class="line"><span class="comment">//把高端内存区的内存分配给用户进程</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_HIGHUSER (GFP_USER | __GFP_HIGHMEM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_HIGHUSER_MOVABLE (GFP_HIGHUSER | __GFP_MOVABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP_TRANSHUGE_LIGHT ((GFP_HIGHUSER_MOVABLE | __GFP_COMP | \__GFP_NOMEM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GFP TRANSHUGE (GFP TRANSHUGE LIGHT | GFP DIRECT RECLAIM)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>开始分配</strong>
<ul>
<li>分配内存页面的函数__alloc_pages_nodemask 函数完成3件事:
<ol>
<li>准备分配页面的参数</li>
<li>进入快速分配路径</li>
<li>若快速分配路径没有分配页面，进入慢速分配路径</li>
</ol>
</li>
</ul>
</li>
<li><strong>准备分配页面的参数</strong>
<ul>
<li>在 __alloc_pages_nodemask 函数中,具有一个变量ac时 alloc_context 类型的,<strong>分配参数就保存在ac变量中</strong></li>
<li>prepare_alloc_pages 函数根据传递进来的参数对ac变量进一步处理</li>
<li>prepare_alloc_pages 函数根据传递进入的参数，就能找出要分配内存区、候选内存区以及内存区中空闲链表的 migratetype 类型，把这些全部收集到 ac 结构中返回 true 说明分配内存页面的参数已准备好</li>
</ul>
</li>
<li><strong>Plan A:快速分配路径</strong>
<ul>
<li>快速分配路径不会处理内存页面合并和回收</li>
<li>遍历所有的候选内存区,然后针对每个内存区检查水位线,是否执行内存回收机制,当一切检查通过之后欧就开始调用 rmqueue 函数执行内存页面分配</li>
</ul>
</li>
<li><strong>Plan B:慢速分配路径</strong>
<ul>
<li>当快速分配路径没有分配到页时,进入慢速分配路径,慢速分配路径<strong>会执行页面回收,回收页面之后会进行多次重复分配,直到最后分配到内存页面或分配失败</strong></li>
<li>__alloc_pages_slowpath 函数一开始会唤醒所有用于内存交换回收的线程 get_page_from_freelist 函数分配失败了就会进行内存回收，内存回收主要是释放一些文件占用的内存页面。如果内存回收不行，就会就进入到<strong>内存压缩环节</strong>
<ul>
<li><strong>内存压缩是指移动内存页面进行内存碎片整理,腾出更大的连续的内存空间</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>如何分配内存页面</strong>
<ul>
<li>最终执行内存页面分配动作的始终是 get_page_from_freelist 函数,<strong>准确是实际完成分配任务的是 rmqueue 函数</strong></li>
<li>需要重点关注 rmqueue_pcplist 和 __rmqueue_smallest 函数
<ul>
<li>rmqueue_pcplist 函数，在请求分配一个页面时，用它从 pcplist 中分配页面的;主要是优化了请求分配单个内存页面的性能,遇到多个内存页面的分配请求会调用 __rmqueue_smallest 函数，从 free_area 数组中分配
<ul>
<li>pcp 是指，每个 CPU 都有一个内存页面高速缓冲，由数据结构per_cpu_pageset 描述，包含在内存区中</li>
<li>针对每个 CPU，都建立出预先分配了单个内存页面的链表，用于满足本地 CPU 发出的单一内存请求提升系统的性能</li>
</ul>
</li>
<li>__rmqueue_smallest 函数
<ul>
<li>首先要取得 current_order 对应的free_area 区中 page，若没有，就继续增加 current_order，直到最大的 MAX_ORDER；要是得到一组连续 page 的首地址，就对其脱链，然后调用 expand 函数分割伙伴</li>
</ul>
</li>
<li><mark>expand 函数是完成伙伴算法的核心</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,  <span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">  <span class="type">gfp_t</span> alloc_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line">  <span class="comment">//分配页面的order大于等于最大的order直接返回NULL</span></span><br><span class="line">  <span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line">    WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">  alloc_mask = gfp_mask;</span><br><span class="line">  <span class="comment">//准备分配页面的参数放在ac变量中</span></span><br><span class="line">  <span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line">  <span class="comment">//进入快速分配路径</span></span><br><span class="line">  page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">  <span class="keyword">if</span> (likely(page))</span><br><span class="line">  <span class="keyword">goto</span> out;</span><br><span class="line">  alloc_mask = current_gfp_context(gfp_mask);</span><br><span class="line">  ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line">  ac.nodemask = nodemask;</span><br><span class="line">  <span class="comment">//进入慢速分配路径</span></span><br><span class="line">  page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line">  out:</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 准备分配页面的参数</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line"><span class="type">nodemask_t</span> *nodemask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line"><span class="type">int</span> migratetype;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">highest_zoneidx</span>;</span></span><br><span class="line"><span class="type">bool</span> spread_dirty_pages;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">prepare_alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params"><span class="type">int</span> preferred_nid, <span class="type">nodemask_t</span> *nodemask,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> alloc_context *ac, <span class="type">gfp_t</span> *alloc_mask,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> *alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从哪个内存区分配内存</span></span><br><span class="line">ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line"><span class="comment">//根据节点id计算出zone的指针</span></span><br><span class="line">ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask);</span><br><span class="line">ac-&gt;nodemask = nodemask;</span><br><span class="line"><span class="comment">//计算出free_area中的migratetype值，比如如分配的掩码为GFP_KERNEL，那么其类型为MIGR</span></span><br><span class="line">ac-&gt;migratetype = gfp_migratetype(gfp_mask);</span><br><span class="line"><span class="comment">//处理CMA相关的分配选项</span></span><br><span class="line">*alloc_flags = current_alloc_flags(gfp_mask, *alloc_flags);</span><br><span class="line">ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line"><span class="comment">//搜索nodemask表示的节点中可用的zone保存在preferred_zoneref</span></span><br><span class="line">ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 快速分配路径</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">bool</span> no_fallback;</span><br><span class="line">retry:</span><br><span class="line">no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">z = ac-&gt;preferred_zoneref;</span><br><span class="line"><span class="comment">//遍历ac-&gt;preferred_zoneref中每个内存区</span></span><br><span class="line">for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">ac-&gt;nodemask) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mark;</span><br><span class="line"><span class="comment">//查看内存水位线</span></span><br><span class="line">mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line"><span class="comment">//检查内存区中空闲内存是否在水印之上</span></span><br><span class="line"><span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">gfp_mask)) &#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">//当前内存区的内存结点需要做内存回收吗</span></span><br><span class="line">ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="comment">//快速分配路径不处理页面回收的问题</span></span><br><span class="line"><span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//根据分配的order数量判断内存区的水位线是否满足要求</span></span><br><span class="line"><span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line"><span class="comment">//如果可以可就从这个内存区开始分配</span></span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">try_this_zone:</span><br><span class="line"><span class="comment">//真正分配内存页面</span></span><br><span class="line">page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line"><span class="keyword">if</span> (page) &#123;</span><br><span class="line"><span class="comment">//清除一些标志或者设置联合页等等</span></span><br><span class="line">prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// 慢速分配路径</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_slowpath</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> alloc_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> did_some_progress;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">compact_priority</span> <span class="title">compact_priority</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">compact_result</span>;</span></span><br><span class="line"><span class="type">int</span> compaction_retries;</span><br><span class="line"><span class="type">int</span> no_progress_loops;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cpuset_mems_cookie;</span><br><span class="line"><span class="type">int</span> reserve_flags;</span><br><span class="line">retry:</span><br><span class="line"><span class="comment">//唤醒所有交换内存的线程</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"><span class="comment">//依然调用快速分配路径入口函数尝试分配内存页面</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"><span class="comment">//尝试直接回收内存并且再分配内存页面</span></span><br><span class="line">page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">&amp;did_some_progress);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"><span class="comment">//尝试直接压缩内存并且再分配内存页面</span></span><br><span class="line">page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">compact_priority, &amp;compact_result);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"><span class="comment">//检查对于给定的分配请求，重试回收是否有意义</span></span><br><span class="line"><span class="keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,</span><br><span class="line">did_some_progress &gt; <span class="number">0</span>, &amp;no_progress_loops))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"><span class="comment">//检查对于给定的分配请求，重试压缩是否有意义</span></span><br><span class="line"><span class="keyword">if</span> (did_some_progress &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">should_compact_retry(ac, order, alloc_flags,</span><br><span class="line">compact_result, &amp;compact_priority,&amp;compaction_retries))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"><span class="comment">//回收、压缩内存已经失败了，开始尝试杀死进程，回收内存页面</span></span><br><span class="line">page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line">got_pg:</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// 如何分配内存页面</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params"><span class="type">gfp_t</span> gfp_flags, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params"><span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||</span><br><span class="line">migratetype != MIGRATE_MOVABLE) &#123;</span><br><span class="line"><span class="comment">//如果order等于0,就说明是分配一个页面，说就从pcplist中分配</span></span><br><span class="line">page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,</span><br><span class="line">migratetype, alloc_flags);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加锁并关中断</span></span><br><span class="line">spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">page = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (order &gt; <span class="number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;</span><br><span class="line"><span class="comment">//从free_area中分配</span></span><br><span class="line">page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="comment">//它最后也是调用__rmqueue_smallest函数</span></span><br><span class="line">page = __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line">&#125; <span class="keyword">while</span> (page &amp;&amp; check_new_pages(page, order));</span><br><span class="line">spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line">zone_statistics(preferred_zone, zone);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// rmqueue_pcplist函数</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> &#123;</span></span><br><span class="line"><span class="type">int</span> count; <span class="comment">//列表中的页面数</span></span><br><span class="line"><span class="type">int</span> high; <span class="comment">//页面数高于水位线，需要清空</span></span><br><span class="line"><span class="type">int</span> batch; <span class="comment">//从伙伴系统增加/删除的块数</span></span><br><span class="line"><span class="comment">//页面列表，每个迁移类型一个。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lists</span>[<span class="title">MIGRATE_PCPTYPES</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> <span class="title">pcp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">s8 expire;</span><br><span class="line">u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">s8 stat_threshold;</span><br><span class="line">s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_pcplist</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">int</span> <span class="title">migratetype</span>,<span class="title">unsig</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line"><span class="comment">//如果list为空，就从这个内存区中分配一部分页面到pcp中来</span></span><br><span class="line">pcp-&gt;count += rmqueue_bulk(zone, <span class="number">0</span>,</span><br><span class="line">pcp-&gt;batch, <span class="built_in">list</span>,</span><br><span class="line">migratetype, alloc_flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取list上第一个page结构</span></span><br><span class="line">page = list_first_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> page, lru);</span><br><span class="line"><span class="comment">//脱链</span></span><br><span class="line">list_del(&amp;page-&gt;lru);</span><br><span class="line"><span class="comment">//减少pcp页面计数</span></span><br><span class="line">pcp-&gt;count--;</span><br><span class="line">&#125; <span class="keyword">while</span> (check_new_pcp(page));</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">rmqueue_pcplist</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> zone *zone, <span class="type">gfp_t</span> gfp_flags,<span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> a</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> per_cpu_pages *pcp;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> list_head *<span class="built_in">list</span>;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> page *page;</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> flags;</span></span><br><span class="line"><span class="params"><span class="comment">//关中断</span></span></span><br><span class="line"><span class="params">local_irq_save(flags);</span></span><br><span class="line"><span class="params"><span class="comment">//获取当前CPU下的pcp</span></span></span><br><span class="line"><span class="params">pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span></span><br><span class="line"><span class="params"><span class="comment">//获取pcp下迁移的list链表</span></span></span><br><span class="line"><span class="params"><span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</span></span><br><span class="line"><span class="params"><span class="comment">//摘取list上的page结构</span></span></span><br><span class="line"><span class="params">page = __rmqueue_pcplist(zone, migratetype, alloc_flags, pcp, <span class="built_in">list</span>);</span></span><br><span class="line"><span class="params"><span class="comment">//开中断</span></span></span><br><span class="line"><span class="params">local_irq_restore(flags);</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> page;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// ----------------</span></span></span><br><span class="line"><span class="params"><span class="comment">// _rmqueue_smallest</span></span></span><br><span class="line"><span class="params"><span class="comment">// ----------------</span></span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *get_page_from_free_area(<span class="keyword">struct</span> free_area *area,<span class="type">int</span></span></span><br><span class="line"><span class="params">&#123;<span class="comment">//返回free_list[migratetype]中的第一个page若没有就返回NULL</span></span></span><br><span class="line"><span class="params"><span class="keyword">return</span> list_first_entry_or_null(&amp;area-&gt;free_list[migratetype],</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> page, lru);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> del_page_from_free_list(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> zone *zon</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (page_reported(page))</span></span><br><span class="line"><span class="params">__ClearPageReported(page);</span></span><br><span class="line"><span class="params"><span class="comment">//脱链</span></span></span><br><span class="line"><span class="params">list_del(&amp;page-&gt;lru);</span></span><br><span class="line"><span class="params"><span class="comment">//清除page中伙伴系统的标志</span></span></span><br><span class="line"><span class="params">__ClearPageBuddy(page);</span></span><br><span class="line"><span class="params">set_page_private(page, <span class="number">0</span>);</span></span><br><span class="line"><span class="params"><span class="comment">//减少free_area中页面计数</span></span></span><br><span class="line"><span class="params">zone-&gt;free_area[order].nr_free--;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> add_to_free_list(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> zone *zone,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> migratetype)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> free_area *area = &amp;zone-&gt;free_area[order];</span></span><br><span class="line"><span class="params"><span class="comment">//把一组page的首个page加入对应的free_area中</span></span></span><br><span class="line"><span class="params">list_add(&amp;page-&gt;lru, &amp;area-&gt;free_list[migratetype]);</span></span><br><span class="line"><span class="params">area-&gt;nr_free++;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//分割一组页</span></span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> expand(<span class="keyword">struct</span> zone *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params"><span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> migratetype)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="comment">//最高order下连续的page数 比如high = 3 size=8</span></span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">1</span> &lt;&lt; high;</span></span><br><span class="line"><span class="params"><span class="keyword">while</span> (high &gt; low) &#123;</span></span><br><span class="line"><span class="params">high--;</span></span><br><span class="line"><span class="params">size &gt;&gt;= <span class="number">1</span>;<span class="comment">//每次循环左移一位 4,2,1</span></span></span><br><span class="line"><span class="params"><span class="comment">//标记为保护页，当其伙伴被释放时，允许合并</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))</span></span><br><span class="line"><span class="params"><span class="keyword">continue</span>;</span></span><br><span class="line"><span class="params"><span class="comment">//把另一半pages加入对应的free_area中</span></span></span><br><span class="line"><span class="params">add_to_free_list(&amp;page[size], zone, high, migratetype);</span></span><br><span class="line"><span class="params"><span class="comment">//设置伙伴</span></span></span><br><span class="line"><span class="params">set_buddy_order(&amp;page[size], high);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> __always_inline <span class="keyword">struct</span> page *__rmqueue_smallest(<span class="keyword">struct</span> zone *zone, unsi</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> current_order;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> free_area *area;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> page *page;</span></span><br><span class="line"><span class="params"><span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span></span><br><span class="line"><span class="params"><span class="comment">//获取current_order对应的free_area</span></span></span><br><span class="line"><span class="params">area = &amp;(zone-&gt;free_area[current_order]);</span></span><br><span class="line"><span class="params"><span class="comment">//获取free_area中对应migratetype为下标的free_list中的page</span></span></span><br><span class="line"><span class="params">page = get_page_from_free_area(area, migratetype);</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (!page)</span></span><br><span class="line"><span class="params"><span class="keyword">continue</span>;</span></span><br><span class="line"><span class="params"><span class="comment">//脱链page</span></span></span><br><span class="line"><span class="params">del_page_from_free_list(page, zone, current_order);</span></span><br><span class="line"><span class="params"><span class="comment">//分割伙伴</span></span></span><br><span class="line"><span class="params">expand(zone, page, order, current_order, migratetype);</span></span><br><span class="line"><span class="params">set_pcppage_migratetype(page, migratetype);</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> page;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="68-瞧一瞧linuxslab如何分配内存"><a class="markdownIt-Anchor" href="#68-瞧一瞧linuxslab如何分配内存"></a> 6.8 瞧一瞧Linux:SLAB如何分配内存</h2>
<ul>
<li><strong>SLAB</strong>
<ul>
<li>与cosmos物理内存页面管理器一样,linux中的伙伴系统是以页面为最小单位分配的,现实中需要根据内核对象的实例变量大小来申请和释放内存空间，<strong>使用slab分配器实现内核中更小粒度的内存分配</strong></li>
</ul>
</li>
<li><strong>SLAB对象</strong>
<ul>
<li>在slab分配器中,把一个内存页面或一组连续的内存页面划分成大小相同的块,其中一个小的内存块就是slab对象,但这一组连续的内存页面中不只是slab对象，还有slab管理头和着色区
<ul>
<li>着色区为一块动态的内存块,建立slab时设置大小，目的时为了错开不同slab中的对象地址,降低硬件cache行中的地址争用，以免导致cache抖动效应，降低系统性能</li>
<li>slab头是一种数据结构，不一定存放在保存对象内存页面的开始;通常会有一个保存slab管理头的slab,在linux中slab管理头用 kmem_cache 结构表示</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-19-21-51.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-19-21-51.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="slab对象示意图" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-19-27-15.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-19-27-15.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="kmem_cache结构图解" /></p>
<ul>
<li>有多少个CPU就会有多少个 array_cache 类型的变量
<ul>
<li>为每个CPU构造一个变量副本的同步机制为<strong>每CPU变量</strong></li>
<li>array_cache结构中entry[]表示一个遵循LIFO顺序的数组,avail和limit分别指向了当前可用独享的数目和允许容纳对象的最大数目</li>
</ul>
</li>
<li><strong>第一个kmem_cache</strong>：静态定义在代码中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// slab对象</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> avail;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line">  <span class="type">void</span> *entry[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">  <span class="comment">//是每个CPU一个array_cache类型的变量，cpu_cache是用于管理空闲对象的</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> __<span class="title">percpu</span> *<span class="title">cpu_cache</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">//cache大小</span></span><br><span class="line">  <span class="type">slab_flags_t</span> flags;<span class="comment">//slab标志</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> num;<span class="comment">//对象个数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> gfporder;<span class="comment">//分配内存页面的order</span></span><br><span class="line">  <span class="type">gfp_t</span> allocflags;</span><br><span class="line">  <span class="type">size_t</span> colour;<span class="comment">//着色区大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> colour_off;<span class="comment">//着色区的开始偏移</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//本SLAB的名字</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">//所有的SLAB都要链接起来</span></span><br><span class="line">  <span class="type">int</span> refcount;<span class="comment">//引用计数</span></span><br><span class="line">  <span class="type">int</span> object_size;<span class="comment">//对象大小</span></span><br><span class="line">  <span class="type">int</span> align;<span class="comment">//对齐大小</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span><span class="comment">//指向管理kmemcache的上层结构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">// 第一个kmem_cache</span></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> <span class="title">kmem_cache_boot</span> =</span> &#123;</span><br><span class="line">  .batchcount = <span class="number">1</span>,</span><br><span class="line">  .limit = BOOT_CPUCACHE_ENTRIES,</span><br><span class="line">  .shared = <span class="number">1</span>,</span><br><span class="line">  .size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache),</span><br><span class="line">  .name = <span class="string">&quot;kmem_cache&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> __init <span class="title function_">kmem_cache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// 指向静态定义的kmem_cache_boot</span></span><br><span class="line">  kmem_cache = &amp;kmem_cache_boot;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_INIT_LISTS; i++)</span><br><span class="line">  kmem_cache_node_init(&amp;init_kmem_cache_node[i]);</span><br><span class="line">  <span class="comment">//建立保存kmem_cache结构的kmem_cache</span></span><br><span class="line">  create_boot_cache(kmem_cache, <span class="string">&quot;kmem_cache&quot;</span>,</span><br><span class="line">  offsetof(<span class="keyword">struct</span> kmem_cache, node) +</span><br><span class="line">  nr_node_ids * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_node *),</span><br><span class="line">  SLAB_HWCACHE_ALIGN, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//加入全局slab_caches链表中</span></span><br><span class="line">  list_add(&amp;kmem_cache-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> nid;</span><br><span class="line">  for_each_online_node(nid) &#123;</span><br><span class="line">  init_list(kmem_cache, &amp;init_kmem_cache_node[CACHE_CACHE + nid], ni</span><br><span class="line">  init_list(kmalloc_caches[KMALLOC_NORMAL][INDEX_NODE],</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//建立kmalloc函数使用的的kmem_cache</span></span><br><span class="line">  create_kmalloc_caches(ARCH_KMALLOC_FLAGS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>管理 kmem_cache</strong>
<ul>
<li>kmem_cache_node 结构是每个内存节点中对应一个用来管理 kmem_cache 结构,开始是静态定义的</li>
<li><strong>初始化时建立了第一个 kmem_cache 结构之后，init_list 函数负责一个个分配内存空间</strong></li>
<li>第一次分配对象时,没有对应的内存页面存放对象,<strong>slab模块会调用 cache_grow_begin 函数获取内存页面,然后用获取的页面存放对象</strong>
<ul>
<li>cache_grow_begin 函数会为 kmem_cache 结构分配用来存放对象的页面，随后调用与之对应的 cache_grow_end 函数，把这页面挂载到kmem_cache_node 结构的链表中，并让页面指向 kmem_cache 结构</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-19-36-50.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-19-36-50.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="slab全局结构图" /></p>
<ul>
<li>全局结构
<ul>
<li>page 可能是一组连续的 pages，但是只会把第一个 page 挂载到kmem_cache_node 中，同时，在 slab_map_pages 函数中又让 page 指向了kmem_cache</li>
<li><strong>kmem_cache_node 中的三个链表</strong>
<ul>
<li>分别挂载的 pages，有一部分是空闲对象的 page、还有对象全部都已经分配的 page，以及全部都为空闲对象的page(为了提高分配时查找 kmem_cache 的性能)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// 管理keme_cache</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_INIT_LISTS (2 * MAX_NUMNODES)</span></span><br><span class="line"><span class="comment">//定义的kmem_cache_node结构数组</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> __<span class="title">initdata</span> <span class="title">init_kmem_cache_node</span>[<span class="title">NUM_INIT_LISTS</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> list_lock;<span class="comment">//自旋锁</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span><span class="comment">//有一部分空闲对象的kmem_cache结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span><span class="comment">//没有空闲对象的kmem_cache结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span><span class="comment">//对象全部空闲kmem_cache结构</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> total_slabs; <span class="comment">//一共多少kmem_cache结构</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> free_slabs; <span class="comment">//空闲的kmem_cache结构</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> free_objects;<span class="comment">//空闲的对象</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">init_list</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="keyword">struct</span> kmem_cache_node</span></span><br><span class="line"><span class="params"><span class="type">int</span> nodeid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">ptr</span>;</span></span><br><span class="line">  <span class="comment">//分配新的 kmem_cache_node 结构的空间</span></span><br><span class="line">  ptr = kmalloc_node(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_node), GFP_NOWAIT, nodeid);</span><br><span class="line">  BUG_ON(!ptr);</span><br><span class="line">  <span class="comment">//复制初始时的静态kmem_cache_node结构</span></span><br><span class="line">  <span class="built_in">memcpy</span>(ptr, <span class="built_in">list</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_node));</span><br><span class="line">  spin_lock_init(&amp;ptr-&gt;list_lock);</span><br><span class="line">  MAKE_ALL_LISTS(cachep, ptr, nodeid);</span><br><span class="line">  <span class="comment">//设置kmem_cache_node的地址</span></span><br><span class="line">  cachep-&gt;node[nodeid] = ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次分配对象时,没有对应的内存页面存放对象,slab模块会调用 cache_grow_begin 函数获取内存页面,然后用获取的页面存放对象</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">slab_map_pages</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cache, <span class="keyword">struct</span> page *page,<span class="type">void</span> *f</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//页面结构指向kmem_cache结构</span></span></span><br><span class="line"><span class="params">  page-&gt;slab_cache = cache;</span></span><br><span class="line"><span class="params">  <span class="comment">//指向空闲对象的链表</span></span></span><br><span class="line"><span class="params">  page-&gt;freelist = freelist;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">struct</span> page *cache_grow_begin(<span class="keyword">struct</span> kmem_cache *cachep,</span></span><br><span class="line"><span class="params"><span class="type">gfp_t</span> flags, <span class="type">int</span> nodeid)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *freelist;</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> offset;</span></span><br><span class="line"><span class="params">  <span class="type">gfp_t</span> local_flags;</span></span><br><span class="line"><span class="params">  <span class="type">int</span> page_node;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> kmem_cache_node *n;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> page *page;</span></span><br><span class="line"><span class="params">  WARN_ON_ONCE(cachep-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));</span></span><br><span class="line"><span class="params">  local_flags = flags &amp; (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);</span></span><br><span class="line"><span class="params">  <span class="comment">//获取页面</span></span></span><br><span class="line"><span class="params">  page = kmem_getpages(cachep, local_flags, nodeid);</span></span><br><span class="line"><span class="params">  <span class="comment">//获取页面所在的内存节点号</span></span></span><br><span class="line"><span class="params">  page_node = page_to_nid(page);</span></span><br><span class="line"><span class="params">  <span class="comment">//根据内存节点获取对应kmem_cache_node结构</span></span></span><br><span class="line"><span class="params">  n = get_node(cachep, page_node);</span></span><br><span class="line"><span class="params">  <span class="comment">//分配管理空闲对象的数据结构</span></span></span><br><span class="line"><span class="params">  freelist = alloc_slabmgmt(cachep, page, offset,</span></span><br><span class="line"><span class="params">  local_flags &amp; ~GFP_CONSTRAINT_MASK, page_node);</span></span><br><span class="line"><span class="params">  <span class="comment">//让页面中相关的字段指向kmem_cache和空闲对象</span></span></span><br><span class="line"><span class="params">  slab_map_pages(cachep, page, freelist);</span></span><br><span class="line"><span class="params">  <span class="comment">//初始化空闲对象管理数据</span></span></span><br><span class="line"><span class="params">  cache_init_objs(cachep, page);</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> page;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="type">void</span> cache_grow_end(<span class="keyword">struct</span> kmem_cache *cachep, <span class="keyword">struct</span> page *page)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> kmem_cache_node *n;</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (!page)</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//初始化结page构的slab_list链表</span></span></span><br><span class="line"><span class="params">  INIT_LIST_HEAD(&amp;page-&gt;slab_list);</span></span><br><span class="line"><span class="params">  <span class="comment">//根据内存节点获取对应kmem_cache_node结构.</span></span></span><br><span class="line"><span class="params">  n = get_node(cachep, page_to_nid(page));</span></span><br><span class="line"><span class="params">  spin_lock(&amp;n-&gt;list_lock);</span></span><br><span class="line"><span class="params">  <span class="comment">//slab计数增加</span></span></span><br><span class="line"><span class="params">  n-&gt;total_slabs++;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (!page-&gt;active) &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//把这个page结构加入到kmem_cache_node结构的空闲链表中</span></span></span><br><span class="line"><span class="params">    list_add_tail(&amp;page-&gt;slab_list, &amp;n-&gt;slabs_free);</span></span><br><span class="line"><span class="params">    n-&gt;free_slabs++;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  spin_unlock(&amp;n-&gt;list_lock);</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-19-40-03.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-19-40-03.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="slab分配对象的过程图解" /></p>
<ul>
<li><strong>SLAB分配对象的过程</strong>
<ul>
<li>根据请求分配对象的大小,查找对应的 kmem_cache 结构,接着从结构中获取 array_cache 结构,然后分配对象</li>
<li>如果没有空闲对象了，就需要在 kmem_cache 对应的 kmem_cache_node 结构中查找有空闲对象的 kmem_cache</li>
<li>如果还是没找到，就要分配内存页面新增 kmem_cache结构</li>
</ul>
</li>
<li><strong>slab分配接口</strong>
<ul>
<li>在linux中用的最多的是 kmalloc 函数,经常用于分配小的缓存区,或者数据结构分配实例空间为slab分配接口,用来分配一小块内存空间</li>
<li>在__do_kmalloc 函数中，查找出分配大小对应的kmem_cache 结构，然后调用 slab_alloc 函数进行分配
<ul>
<li>slab_alloc 函数才是SLAB 的接口函数，但是参数中必须要有 kmem_cache 结构</li>
</ul>
</li>
</ul>
</li>
<li><strong>如何查找 kmem_cache 结构</strong>
<ul>
<li>调用 kmalloc_slab 函数</li>
<li>kmalloc_caches 就是个全局的二维数组，kmalloc_slab 函数只是根据分配大小和分配标志计算出了数组下标，最后取出其中 kmem_cache 结构指针</li>
<li>__do_kmalloc 函数中根据分配对象大小查找的所有 kmem_cache 结构，kmem_cache 结构就建立好了，保存在 kmalloc_caches 数组中</li>
</ul>
</li>
<li><strong>分配对象</strong>
<ul>
<li>从 slab_alloc 函数开始探索对象的分配过程,第一个参数就是 kmem_cache 结构的指针,表示从该 kmem_cache 结构中分配对象</li>
<li>真正做事的函数是 ____cache_alloc 函数，首先获取了当前 kmem_cache 结构中指向 array_cache 结构的指针，找到它里面空闲对象的地址，然后在 array_cache 结构中取出一个空闲对象地址返回，这样就分配成功了</li>
<li>速度是很快的，如果 array_cache 结构中没有空闲对象了，就会调用cache_alloc_refill 函数</li>
</ul>
</li>
<li><strong>调用 cache_alloc_refill 函数的过程的主要的工作</strong>
<ul>
<li>获取 cachep 所属的 kmem_cache_node</li>
<li>然后调用 get_first_slab，获取 kmem_cache_node 结构还有没有包含空闲对象的kmem_cache
<ul>
<li>但是请注意，这里返回的是 page，因为 page 会指向 kmem_cache 结构，page 所代表的物理内存页面，也保存着 kmem_cache 结构中的对象</li>
</ul>
</li>
<li>最后，如果 kmem_cache_node 结构没有包含空闲对象的 kmem_cache 了，就必须调用cache_grow_begin 函数，找伙伴系统分配新的内存页面，而且还要找第一个kmem_cache 分配新的对象，来存放 kmem_cache 结构的实例变量，并进行必要的初始化</li>
<li>这些步骤完成之后，再调用 cache_grow_end 函数，把刚刚分配的 page 挂载到kmem_cache_node 结构的 slabs_list 链表上</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// slab分配接口</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *__do_kmalloc(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags,<span class="type">unsigned</span> <span class="type">long</span> caller)&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cachep</span>;</span></span><br><span class="line">  <span class="type">void</span> *ret;</span><br><span class="line">  <span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//查找size对应的kmem_cache</span></span><br><span class="line">  cachep = kmalloc_slab(size, flags);</span><br><span class="line">  <span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(cachep)))</span><br><span class="line">  <span class="keyword">return</span> cachep;</span><br><span class="line">  <span class="comment">//分配对象</span></span><br><span class="line">  ret = slab_alloc(cachep, flags, caller);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *__kmalloc(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __do_kmalloc(size, flags, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="comment">// 如何查找 kmem_cache 结构</span></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">kmalloc_cache_type</span> &#123;</span></span><br><span class="line">  KMALLOC_NORMAL = <span class="number">0</span>,</span><br><span class="line">  KMALLOC_RECLAIM,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">  KMALLOC_DMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  NR_KMALLOC_TYPES</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">kmalloc_caches</span>[<span class="title">NR_KMALLOC_TYPES</span>][<span class="title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="title">ro_after_init</span>()&#123;</span></span><br><span class="line">  <span class="number">3</span>, <span class="comment">/* 8 */</span></span><br><span class="line">  <span class="number">4</span>, <span class="comment">/* 16 */</span></span><br><span class="line">  <span class="number">5</span>, <span class="comment">/* 24 */</span></span><br><span class="line">  <span class="number">5</span>, <span class="comment">/* 32 */</span></span><br><span class="line">  <span class="number">6</span>, <span class="comment">/* 40 */</span></span><br><span class="line">  <span class="number">6</span>, <span class="comment">/* 48 */</span></span><br><span class="line">  <span class="number">6</span>, <span class="comment">/* 56 */</span></span><br><span class="line">  <span class="number">6</span>, <span class="comment">/* 64 */</span></span><br><span class="line">  <span class="number">1</span>, <span class="comment">/* 72 */</span></span><br><span class="line">  <span class="number">1</span>, <span class="comment">/* 80 */</span></span><br><span class="line">  <span class="number">1</span>, <span class="comment">/* 88 */</span></span><br><span class="line">  <span class="number">1</span>, <span class="comment">/* 96 */</span></span><br><span class="line">  <span class="number">7</span>, <span class="comment">/* 104 */</span></span><br><span class="line">  <span class="number">7</span>, <span class="comment">/* 112 */</span></span><br><span class="line">  <span class="number">7</span>, <span class="comment">/* 120 */</span></span><br><span class="line">  <span class="number">7</span>, <span class="comment">/* 128 */</span></span><br><span class="line">  <span class="number">2</span>, <span class="comment">/* 136 */</span></span><br><span class="line">  <span class="number">2</span>, <span class="comment">/* 144 */</span></span><br><span class="line">  <span class="number">2</span>, <span class="comment">/* 152 */</span></span><br><span class="line">  <span class="number">2</span>, <span class="comment">/* 160 */</span></span><br><span class="line">  <span class="number">2</span>, <span class="comment">/* 168 */</span></span><br><span class="line">  <span class="number">2</span>, <span class="comment">/* 176 */</span></span><br><span class="line">  <span class="number">2</span>, <span class="comment">/* 184 */</span></span><br><span class="line">  <span class="number">2</span> <span class="comment">/* 192 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//根据分配标志返回枚举类型，其实是0、1、2其中之一</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">enum</span> kmalloc_cache_type <span class="title function_">kmalloc_type</span><span class="params">(<span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">    <span class="keyword">if</span> (likely((flags &amp; (__GFP_DMA | __GFP_RECLAIMABLE)) == <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> KMALLOC_NORMAL;</span><br><span class="line">      <span class="keyword">return</span> flags &amp; __GFP_DMA ? KMALLOC_DMA : KMALLOC_RECLAIM;</span><br><span class="line">  <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> flags &amp; __GFP_RECLAIMABLE ? KMALLOC_RECLAIM : KMALLOC_NORMAL;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">kmalloc_slab</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line">  <span class="comment">//计算出index</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">192</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">      <span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line">      index = size_index[size_index_elem(size)];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    index = fls(size - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> kmalloc_caches[kmalloc_type(flags)][index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------</span></span><br><span class="line"><span class="comment">// 建立 kmalloc_caches 中的 kmem_cache</span></span><br><span class="line"><span class="comment">// ---------------------------------</span></span><br><span class="line"><span class="keyword">struct</span> kmem_cache *__init <span class="title function_">create_kmalloc_cache</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//从第一个kmem_cache中分配一个对象放kmem_cache</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);</span><br><span class="line">  <span class="keyword">if</span> (!s)</span><br><span class="line">  panic(<span class="string">&quot;Out of memory when creating slab %s\n&quot;</span>, name);</span><br><span class="line">  <span class="comment">//设置s的对齐参数，处理s的freelist就是arr_cache</span></span><br><span class="line">  create_boot_cache(s, name, size, flags, useroffset, usersize);</span><br><span class="line">  list_add(&amp;s-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">  s-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建一个kmem_cache</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">new_kmalloc_cache</span><span class="params">(<span class="type">int</span> idx, <span class="keyword">enum</span> kmalloc_cache_type type, sl</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (type == KMALLOC_RECLAIM)</span></span><br><span class="line"><span class="params">  flags |= SLAB_RECLAIM_ACCOUNT;</span></span><br><span class="line"><span class="params">  <span class="comment">//根据kmalloc_info中信息建立一个kmem_cache</span></span></span><br><span class="line"><span class="params">  kmalloc_caches[type][idx] = create_kmalloc_cache(</span></span><br><span class="line"><span class="params">  kmalloc_info[idx].name[type],</span></span><br><span class="line"><span class="params">  kmalloc_info[idx].size, flags, <span class="number">0</span>,</span></span><br><span class="line"><span class="params">  kmalloc_info[idx].size);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//建立所有的kmalloc_caches中的kmem_cache</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> __init create_kmalloc_caches(<span class="type">slab_flags_t</span> flags)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="type">int</span> i;</span></span><br><span class="line"><span class="params"><span class="keyword">enum</span> kmalloc_cache_type type;</span></span><br><span class="line"><span class="params"><span class="keyword">for</span> (type = KMALLOC_NORMAL; type &lt;= KMALLOC_RECLAIM; type++) &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">for</span> (i = KMALLOC_SHIFT_LOW; i &lt;= KMALLOC_SHIFT_HIGH; i++) &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (!kmalloc_caches[type][i])</span></span><br><span class="line"><span class="params">      <span class="comment">//建立一个新的kmem_cache</span></span></span><br><span class="line"><span class="params">      new_kmalloc_cache(i, type, flags);</span></span><br><span class="line"><span class="params">      <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; i == <span class="number">6</span> &amp;&amp;</span></span><br><span class="line"><span class="params">      !kmalloc_caches[type][<span class="number">1</span>])</span></span><br><span class="line"><span class="params">      new_kmalloc_cache(<span class="number">1</span>, type, flags);</span></span><br><span class="line"><span class="params">      <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; i == <span class="number">7</span> &amp;&amp;</span></span><br><span class="line"><span class="params">      !kmalloc_caches[type][<span class="number">2</span>])</span></span><br><span class="line"><span class="params">      new_kmalloc_cache(<span class="number">2</span>, type, flags);</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// -------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 分配对象</span></span></span><br><span class="line"><span class="params"><span class="comment">// -------</span></span></span><br><span class="line"><span class="params"><span class="type">static</span> __always_inline <span class="type">void</span> *slab_alloc(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> save_flags;</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *objp;</span></span><br><span class="line"><span class="params">  <span class="comment">//关中断</span></span></span><br><span class="line"><span class="params">  local_irq_save(save_flags);</span></span><br><span class="line"><span class="params">  <span class="comment">//分配对象</span></span></span><br><span class="line"><span class="params">  objp = __do_cache_alloc(cachep, flags);</span></span><br><span class="line"><span class="params">  <span class="comment">//恢复中断</span></span></span><br><span class="line"><span class="params">  local_irq_restore(save_flags);</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> objp;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 真正干活的 \__do_cache_alloc函数</span></span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *____cache_alloc(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *objp;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> array_cache *ac;</span></span><br><span class="line"><span class="params">  <span class="comment">//获取当前cpu在cachep结构中的array_cache结构的指针</span></span></span><br><span class="line"><span class="params">  ac = cpu_cache_get(cachep);</span></span><br><span class="line"><span class="params">  <span class="comment">//如果ac中的avail不为0,说明当前kmem_cache结构中freelist是有空闲对象</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (likely(ac-&gt;avail)) &#123;</span></span><br><span class="line"><span class="params">    ac-&gt;touched = <span class="number">1</span>;</span></span><br><span class="line"><span class="params">    <span class="comment">//空间对象的地址保存在ac-&gt;entry</span></span></span><br><span class="line"><span class="params">    objp = ac-&gt;entry[--ac-&gt;avail];</span></span><br><span class="line"><span class="params">    <span class="keyword">goto</span> out;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  objp = cache_alloc_refill(cachep, flags);</span></span><br><span class="line"><span class="params">  out:</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> objp;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> __always_inline <span class="type">void</span> *__do_cache_alloc(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span></span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> ____cache_alloc(cachep, flags);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// cache_alloc_refill函数</span></span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">struct</span> page *get_first_slab(<span class="keyword">struct</span> kmem_cache_node *n, <span class="type">bool</span> pfmemalloc)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> page *page;</span></span><br><span class="line"><span class="params">  assert_spin_locked(&amp;n-&gt;list_lock);</span></span><br><span class="line"><span class="params">  <span class="comment">//首先从kmem_cache_node结构中的slabs_partial链表上查看有没有page</span></span></span><br><span class="line"><span class="params">  page = list_first_entry_or_null(&amp;n-&gt;slabs_partial, <span class="keyword">struct</span> page,slab_list);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (!page) &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//如果没有</span></span></span><br><span class="line"><span class="params">    n-&gt;free_touched = <span class="number">1</span>;</span></span><br><span class="line"><span class="params">    <span class="comment">//从kmem_cache_node结构中的slabs_free链表上查看有没有page</span></span></span><br><span class="line"><span class="params">    page = list_first_entry_or_null(&amp;n-&gt;slabs_free, <span class="keyword">struct</span> page,slab_list)</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (page)</span></span><br><span class="line"><span class="params">    n-&gt;free_slabs--; <span class="comment">//空闲slab计数减一</span></span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//返回page</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> page;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="type">void</span> *cache_alloc_refill(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">int</span> batchcount;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> kmem_cache_node *n;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> array_cache *ac, *shared;</span></span><br><span class="line"><span class="params">  <span class="type">int</span> node;</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> page *page;</span></span><br><span class="line"><span class="params">  <span class="comment">//获取内存节点</span></span></span><br><span class="line"><span class="params">  node = numa_mem_id();</span></span><br><span class="line"><span class="params">  ac = cpu_cache_get(cachep);</span></span><br><span class="line"><span class="params">  batchcount = ac-&gt;batchcount;</span></span><br><span class="line"><span class="params">  <span class="comment">//获取cachep所属的kmem_cache_node</span></span></span><br><span class="line"><span class="params">  n = get_node(cachep, node);</span></span><br><span class="line"><span class="params">  shared = READ_ONCE(n-&gt;shared);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (!n-&gt;free_objects &amp;&amp; (!shared || !shared-&gt;avail))</span></span><br><span class="line"><span class="params">  <span class="keyword">goto</span> direct_grow;</span></span><br><span class="line"><span class="params">  <span class="keyword">while</span> (batchcount &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//获取kmem_cache_node结构中其它kmem_cache,返回的是page，而page会指向kmem_cac</span></span></span><br><span class="line"><span class="params">    page = get_first_slab(n, <span class="literal">false</span>);</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (!page)</span></span><br><span class="line"><span class="params">      <span class="keyword">goto</span> must_grow;</span></span><br><span class="line"><span class="params">    batchcount = alloc_block(cachep, ac, page, batchcount);</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  must_grow:</span></span><br><span class="line"><span class="params">  n-&gt;free_objects -= ac-&gt;avail;</span></span><br><span class="line"><span class="params">  direct_grow:</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (unlikely(!ac-&gt;avail)) &#123;</span></span><br><span class="line"><span class="params">    <span class="comment">//分配新的kmem_cache并初始化</span></span></span><br><span class="line"><span class="params">    page = cache_grow_begin(cachep, gfp_exact_node(flags), node);</span></span><br><span class="line"><span class="params">    ac = cpu_cache_get(cachep);</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (!ac-&gt;avail &amp;&amp; page)</span></span><br><span class="line"><span class="params">    alloc_block(cachep, ac, page, batchcount);</span></span><br><span class="line"><span class="params">    <span class="comment">//让page挂载到kmem_cache_node结构的slabs_list链表上</span></span></span><br><span class="line"><span class="params">    cache_grow_end(cachep, page);</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (!ac-&gt;avail)</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  ac-&gt;touched = <span class="number">1</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//重新分配</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> ac-&gt;entry[--ac-&gt;avail];</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<hr />
<h1 id="7-进程"><a class="markdownIt-Anchor" href="#7-进程"></a> 7 进程</h1>
</div><div class="story post-story"><h2 id="71-到底什么是进程"><a class="markdownIt-Anchor" href="#71-到底什么是进程"></a> 7.1 到底什么是进程</h2>
<ul>
<li><strong>在linux下使用ps命令,可以看出系统有多少个进程</strong>
<ul>
<li>展示的只是具体进程的数据(如创建进程和用户,进程ID,使用CPU的百分比,进程运行状态,进程的建立时间,进程的运行时间,进程名等综合起来代表一个进程)</li>
</ul>
</li>
<li><strong>什么是进程</strong>
<ul>
<li>进程是一个应用程序运行时的实例(从进程的结构);进程是应用程序运行时所需资源的容器(进程的功能);甚至进程是一堆数据结构(从操作系统对进程实现的角度)</li>
</ul>
</li>
<li><strong>进程的结构</strong>
<ul>
<li>进程是一个应用程序运行时刻的实例,目的是操作系统用于管理和运行多个应用程序;其次从实现的内存管理组件角度看,操作系统是给应用程序提供服务的</li>
<li>进程必须要有一个地址空间,地址空间至少包括两部分内容:一部分是内核,一部分是用户的应用程序</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-21-41-59.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-21-41-59.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="进程结构示意图" /></p>
<ul>
<li><strong>整体结构</strong>
<ul>
<li>上图中8个进程,每个进程拥有x86 CPU的整个虚拟地址空间，虚拟地址空间被分成两部分,上半部分是所有进程都共享的内核部分,里面放着一份内核代码和数据,下半部分是应用程序,分别独立,互不干扰</li>
<li>CPU在R0特权级运行时,就运行在上半部分内核的地址空间中</li>
<li>CPU在R3特权级时,就运行在下半部分的应用程序地址空间中</li>
<li>各进程的虚拟地址空间相同,之间的物理地址不同,由MMU页进行隔离,<mark>所以每个进程的应用程序不能随意访问内核代码和数据</mark></li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-21-42-33.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-21-21-42-33.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="进程结构细化示意图" /></p>
<ul>
<li><strong>细节结构</strong>
<ul>
<li>从应用程序和内核的关系看,应用程序需要提供资源,内核需要控制应用程序的运行,<strong>内核必须能命令应用程序让它随时中断(进入内核地址空间)或恢复执行</strong>，因此需要保存应用程序的机器上下文和运行时刻的栈</li>
<li><strong>内核提供服务的机制</strong>:通过停止应用程序代码执行,进入内核地址空间运行内核代码,然后返回结果
<ul>
<li>使用<strong>资源描述符</strong>,表示打开某个文件或访问某个设备的记录表</li>
</ul>
</li>
<li>进程细化结构中,带*号的是每个进程都独立一份的,根据该细化结构可以实现多个进程并发运行</li>
</ul>
</li>
<li><strong>如何表示一个进程</strong>
<ul>
<li>一个进程有状态,id,运行时间,优先级,应用程序栈,内核栈您机器上下文,资源描述符,地址空间等信息</li>
<li>使用 thread_t 结构的一个实例变量代表一个进程,进程的内核栈和进程的应用程序栈是两块内存空间,进程的权限表示一个进程是用户进程还是系统进程(权限不同完成功能不同)
<ul>
<li>进程有64个优先级,<strong>td_priority 数值越小，优先级越高</strong></li>
<li>td_handtbl 只是一个 objnode_t 结构的指针类型数组</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的地址空间</strong>
<ul>
<li>在 thread_t 结构中有 mmadrsdsc_t 结构的指针，在结构中有虚拟地址区间结构和 MMU 相关信息</li>
<li>mmadrsdsc_t 结构描述了一个进程的完整地址空间;
<ul>
<li>常规情况下,新建进程就要建立一个 mmadrsdsc_t 结构,让 thread_t 结构的 td_mmdsc 的指针变量指向它</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程的机器上下文</strong>
<ul>
<li>一部分是CPU寄存器,一部分是内核函数调用路径
<ul>
<li>CPU的通用寄存器,是中断发生进入内核时,压入内核栈中的,从中断入口处开始调用的函数,都是属于内核的函数</li>
<li>函数的调用路径存在内核栈中,进程调度器函数会调用进程切换函数,完成切换进程操作后,在进程切换函数中保存栈寄存器的值</li>
</ul>
</li>
<li>context_t 结构中的 x64tss_t 结构的指针是CPU要求的一个结构,结构本身的地址放在一个 GDT 表项中
<ul>
<li>由CPU的tr寄存器指向,tr寄存器中的值是 GDT 中x64tss_t结构项对应的索引</li>
</ul>
</li>
<li>CPU 发生中断时，会根据中断门描述里的目标段选择子，进行必要的特权级切换，特权级的切换就必须要切换栈，CPU 硬件会自己把当前 rsp 寄存器保存到内部的临时寄存器tmprsp；然后从 x64tss_t 结构体中找出对应的栈地址，装入 rsp 寄存器中；接着，再把当前的 ss、tmprsp、rflags、cs、rip，依次压入当前 rsp 指向的栈中</li>
</ul>
</li>
<li><strong>建立进程</strong>
<ul>
<li>建立进程不是建立 thread_t 结构的实例变量,还需要建立进程的应用程序栈和进程的内核栈，进程地址空间等</li>
</ul>
</li>
<li><strong>建立进程接口</strong>
<ul>
<li>接口函数在 cosmos/kernel/krlthread.c</li>
<li>krlnew_thread 函数对参数进行合理检查,参数为应用程序启动运行的地址,创建标志,进程权限和进程优先级,进程的应用程序栈和内核栈大小</li>
<li>进程对栈的大小有要求,小于默认8kb就使用默认的栈大小,最后根据创建标志确认是建立内核态进程还是建立普通进程</li>
</ul>
</li>
<li><strong>建立内核进程</strong>
<ul>
<li>内核进程是用进程的方式运行一段内核代码,那么这段代码就可以随时暂停或继续运行,又或者和其他代码段并发运行,只有这种进程永远不会回到进程应用程序地址空间中去,只会在内核地址空间中运行</li>
<li><strong>代码逻辑</strong>:首先分配一个内核栈的内存空间,接着创建 thread_t 结构的实例变量,然后对 thread_t 结构体的字段进行设置,最后初始化进程内核栈把这个新进程加入到进程的调度系统中</li>
</ul>
</li>
<li><strong>创建 thread_t 结构</strong>
<ul>
<li>创建 thread_t 结构其实就是分配一块内存用于存放 thread_t 结构的实例变量</li>
<li>首先以 thread_t 结构地地址作为进程的ID(具有唯一性);
<ul>
<li>其次目前没有为一个进程分配 mmadrsdsc_t 结构体,而是指向了默认的地址空间结构 initmmadrsdsc;</li>
<li>最后,hal_retn_cpuid 函数在目前情况下永远为0(因为使用了一个CPU)</li>
</ul>
</li>
</ul>
</li>
<li><strong>初始化内核栈</strong>
<ul>
<li>初始化内核栈是为了在进程的内核栈中放置一份CPU的寄存器数据(一个进程机器上下文的一部分)</li>
<li>当一个进程开始运行时,将会pop指令从进程的内核栈弹出到CPU中,CPU开始运行进程,CPU的一些寄存器有位置关系需要一个结构体来操作</li>
<li>intstkregs_t 结构中,每个字段都是8字节64位的,x86CPU在长模式下rsp栈指针寄存器始终8字节对齐
<ul>
<li>栈是向下伸长(从高地址向低地址),结构是反向定义</li>
</ul>
</li>
</ul>
</li>
<li><strong>建立普通进程</strong>
<ul>
<li>在建立进程的接口函数 krlnew_thread 进程中,会根据参数 flg 的值选择调用不同的函数来建立不同类型的进程</li>
<li>和建立内核进程相比，建立普通进程有两点不同
<ul>
<li>第一，多分配了一个应用程序栈。因为内核进程不会返回到进程的应用程序空间，所以不需要应用程序栈，而普通进程则需要；</li>
<li>第二，在最后调用的是 krlthread_userstack_init 函数，该函数初始化返回进程应用程序空间的内核栈</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-22-16-19-33.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-22-16-19-33.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="进程建立流程图" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 进程结构</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// cosmos/include/knlinc/krlthread_t.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_THREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> td_lock; <span class="comment">//进程的自旋锁</span></span><br><span class="line">  <span class="type">list_h_t</span> td_list; <span class="comment">//进程链表</span></span><br><span class="line">  <span class="type">uint_t</span> td_flgs; <span class="comment">//进程的标志</span></span><br><span class="line">  <span class="type">uint_t</span> td_stus; <span class="comment">//进程的状态</span></span><br><span class="line">  <span class="type">uint_t</span> td_cpuid; <span class="comment">//进程所在的CPU的id</span></span><br><span class="line">  <span class="type">uint_t</span> td_id; <span class="comment">//进程的id</span></span><br><span class="line">  <span class="type">uint_t</span> td_tick; <span class="comment">//进程运行了多少tick</span></span><br><span class="line">  <span class="type">uint_t</span> td_privilege; <span class="comment">//进程的权限</span></span><br><span class="line">  <span class="type">uint_t</span> td_priority; <span class="comment">//进程的优先级</span></span><br><span class="line">  <span class="type">uint_t</span> td_runmode; <span class="comment">//进程的运行模式</span></span><br><span class="line">  <span class="type">adr_t</span> td_krlstktop; <span class="comment">//应用程序内核栈顶地址</span></span><br><span class="line">  <span class="type">adr_t</span> td_krlstkstart; <span class="comment">//应用程序内核栈开始地址</span></span><br><span class="line">  <span class="type">adr_t</span> td_usrstktop; <span class="comment">//应用程序栈顶地址</span></span><br><span class="line">  <span class="type">adr_t</span> td_usrstkstart; <span class="comment">//应用程序栈开始地址</span></span><br><span class="line">  <span class="type">mmadrsdsc_t</span>* td_mmdsc; <span class="comment">//地址空间结构</span></span><br><span class="line">  <span class="type">context_t</span> td_context; <span class="comment">//机器上下文件结构</span></span><br><span class="line">  <span class="type">objnode_t</span>* td_handtbl[TD_HAND_MAX];<span class="comment">//打开的对象数组</span></span><br><span class="line">&#125;<span class="type">thread_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 进程的地址空间</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MMADRSDSC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> msd_lock; <span class="comment">//保护自身的自旋锁</span></span><br><span class="line">  <span class="type">list_h_t</span> msd_list; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">uint_t</span> msd_flag; <span class="comment">//状态和标志</span></span><br><span class="line">  <span class="type">uint_t</span> msd_stus;</span><br><span class="line">  <span class="type">uint_t</span> msd_scount; <span class="comment">//计数，该结构可能被共享</span></span><br><span class="line">  <span class="type">sem_t</span> msd_sem; <span class="comment">//信号量</span></span><br><span class="line">  <span class="type">mmudsc_t</span> msd_mmu; <span class="comment">//MMU页表相关的信息</span></span><br><span class="line">  <span class="type">virmemadrs_t</span> msd_virmemadrs; <span class="comment">//虚拟地址空间结构</span></span><br><span class="line">  <span class="type">adr_t</span> msd_stext; <span class="comment">//应用的指令区的开始、结束地址</span></span><br><span class="line">  <span class="type">adr_t</span> msd_etext;</span><br><span class="line">  <span class="type">adr_t</span> msd_sdata; <span class="comment">//应用的数据区的开始、结束地址</span></span><br><span class="line">  <span class="type">adr_t</span> msd_edata;</span><br><span class="line">  <span class="type">adr_t</span> msd_sbss; <span class="comment">//应用初始化为0的区域开始、结束地址</span></span><br><span class="line">  <span class="type">adr_t</span> msd_ebss;</span><br><span class="line">  <span class="type">adr_t</span> msd_sbrk; <span class="comment">//应用的堆区的开始、结束地址</span></span><br><span class="line">  <span class="type">adr_t</span> msd_ebrk;</span><br><span class="line">&#125;<span class="type">mmadrsdsc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 进程的机器上下文</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_CONTEXT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint_t</span> ctx_nextrip; <span class="comment">//保存下一次运行的地址</span></span><br><span class="line">  <span class="type">uint_t</span> ctx_nextrsp; <span class="comment">//保存下一次运行时内核栈的地址</span></span><br><span class="line">  <span class="type">x64tss_t</span>* ctx_nexttss; <span class="comment">//指向tss结构</span></span><br><span class="line">&#125;<span class="type">context_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cosmos/hal/x86/halglobal.c</span></span><br><span class="line"><span class="comment">// 每个CPU核心一个tss</span></span><br><span class="line">HAL_DEFGLOB_VARIABLE(<span class="type">x64tss_t</span>,x64tss)[CPUCORE_MAX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_X64TSS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">u32_t</span> reserv0; <span class="comment">//保留</span></span><br><span class="line"><span class="type">u64_t</span> rsp0; <span class="comment">//R0特权级的栈地址</span></span><br><span class="line"><span class="type">u64_t</span> rsp1; <span class="comment">//R1特权级的栈地址，我们未使用</span></span><br><span class="line"><span class="type">u64_t</span> rsp2; <span class="comment">//R2特权级的栈地址，我们未使用</span></span><br><span class="line"><span class="type">u64_t</span> reserv28;<span class="comment">//保留</span></span><br><span class="line"><span class="type">u64_t</span> ist[<span class="number">7</span>]; <span class="comment">//我们未使用</span></span><br><span class="line"><span class="type">u64_t</span> reserv92;<span class="comment">//保留</span></span><br><span class="line"><span class="type">u16_t</span> reserv100;<span class="comment">//保留</span></span><br><span class="line"><span class="type">u16_t</span> iobase; <span class="comment">//我们未使用</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">x64tss_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">// 建立进程接口</span></span><br><span class="line"><span class="comment">// cosmos/kernel/krlthread.c</span></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="type">thread_t</span> *<span class="title function_">krlnew_thread</span><span class="params">(<span class="type">void</span> *filerun, <span class="type">uint_t</span> flg, <span class="type">uint_t</span> prilg, <span class="type">uint_t</span> prity,</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> tustksz = usrstksz, tkstksz = krlstksz;</span></span><br><span class="line"><span class="params">  <span class="comment">//对参数进行检查，不合乎要求就返回NULL表示创建失败</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (filerun == <span class="literal">NULL</span> || usrstksz &gt; DAFT_TDUSRSTKSZ || krlstksz &gt; DAFT_TDKRL</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> ((prilg != PRILG_USR &amp;&amp; prilg != PRILG_SYS) || (prity &gt;= PRITY_MAX))</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//进程应用程序栈大小检查，大于默认大小则使用默认大小</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (usrstksz &lt; DAFT_TDUSRSTKSZ)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">  tustksz = DAFT_TDUSRSTKSZ;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//进程内核栈大小检查，大于默认大小则使用默认大小</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (krlstksz &lt; DAFT_TDKRLSTKSZ)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">  tkstksz = DAFT_TDKRLSTKSZ;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//是否建立内核进程</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (KERNTHREAD_FLG == flg)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> krlnew_kern_thread_core(filerun, flg, prilg, prity, tustksz, tk</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//是否建立普通进程</span></span></span><br><span class="line"><span class="params">  <span class="keyword">else</span> <span class="keyword">if</span> (USERTHREAD_FLG == flg)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> krlnew_user_thread_core(filerun, flg, prilg, prity, tustksz, tk</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// ------------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 建立内核态进程</span></span></span><br><span class="line"><span class="params"><span class="comment">// ------------</span></span></span><br><span class="line"><span class="params"><span class="type">thread_t</span> *krlnew_kern_thread_core(<span class="type">void</span> *filerun, <span class="type">uint_t</span> flg, <span class="type">uint_t</span> prilg, uin</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">thread_t</span> *ret_td = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="type">bool_t</span> acs = FALSE;</span></span><br><span class="line"><span class="params">  <span class="type">adr_t</span> krlstkadr = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//分配内核栈空间</span></span></span><br><span class="line"><span class="params">  krlstkadr = krlnew(krlstksz);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (krlstkadr == <span class="literal">NULL</span>)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//建立thread_t结构体的实例变量</span></span></span><br><span class="line"><span class="params">  ret_td = krlnew_thread_dsc();</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (ret_td == <span class="literal">NULL</span>)</span></span><br><span class="line"><span class="params">  &#123;<span class="comment">//创建失败必须要释放之前的栈空间</span></span></span><br><span class="line"><span class="params">  acs = krldelete(krlstkadr, krlstksz);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (acs == FALSE)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程权限</span></span></span><br><span class="line"><span class="params">  ret_td-&gt;td_privilege = prilg;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程优先级</span></span></span><br><span class="line"><span class="params">  ret_td-&gt;td_priority = prity;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程的内核栈顶和内核栈开始地址</span></span></span><br><span class="line"><span class="params">  ret_td-&gt;td_krlstktop = krlstkadr + (<span class="type">adr_t</span>)(krlstksz - <span class="number">1</span>);</span></span><br><span class="line"><span class="params">  ret_td-&gt;td_krlstkstart = krlstkadr;</span></span><br><span class="line"><span class="params">  <span class="comment">//初始化进程的内核栈</span></span></span><br><span class="line"><span class="params">  krlthread_kernstack_init(ret_td, filerun, KMOD_EFLAGS);</span></span><br><span class="line"><span class="params">  <span class="comment">//加入进程调度系统</span></span></span><br><span class="line"><span class="params">  krlschdclass_add_thread(ret_td);</span></span><br><span class="line"><span class="params">  <span class="comment">//返回进程指针</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> ret_td;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// -----------------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 创建 thread_t 结构</span></span></span><br><span class="line"><span class="params"><span class="comment">// -----------------</span></span></span><br><span class="line"><span class="params"><span class="comment">//初始化context_t结构</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> context_t_init(<span class="type">context_t</span> *initp)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">initp-&gt;ctx_nextrip = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">initp-&gt;ctx_nextrsp = <span class="number">0</span>;</span></span><br><span class="line"><span class="params"><span class="comment">//指向当前CPU的tss</span></span></span><br><span class="line"><span class="params">initp-&gt;ctx_nexttss = &amp;x64tss[hal_retn_cpuid()];</span></span><br><span class="line"><span class="params"><span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//返回进程id其实就thread_t结构的地址</span></span></span><br><span class="line"><span class="params"><span class="type">uint_t</span> krlretn_thread_id(<span class="type">thread_t</span> *tdp)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> (<span class="type">uint_t</span>)tdp;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//初始化thread_t结构</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> thread_t_init(<span class="type">thread_t</span> *initp)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">krlspinlock_init(&amp;initp-&gt;td_lock);</span></span><br><span class="line"><span class="params">list_init(&amp;initp-&gt;td_list);</span></span><br><span class="line"><span class="params">initp-&gt;td_flgs = TDFLAG_FREE;</span></span><br><span class="line"><span class="params">initp-&gt;td_stus = TDSTUS_NEW;<span class="comment">//进程状态为新建</span></span></span><br><span class="line"><span class="params">initp-&gt;td_cpuid = hal_retn_cpuid();</span></span><br><span class="line"><span class="params">initp-&gt;td_id = krlretn_thread_id(initp);</span></span><br><span class="line"><span class="params">initp-&gt;td_tick = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">initp-&gt;td_privilege = PRILG_USR;<span class="comment">//普通进程权限</span></span></span><br><span class="line"><span class="params">initp-&gt;td_priority = PRITY_MIN;<span class="comment">//最高优先级</span></span></span><br><span class="line"><span class="params">initp-&gt;td_runmode = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">initp-&gt;td_krlstktop = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">initp-&gt;td_krlstkstart = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">initp-&gt;td_usrstktop = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">initp-&gt;td_usrstkstart = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">initp-&gt;td_mmdsc = &amp;initmmadrsdsc;<span class="comment">//指向默认的地址空间结构</span></span></span><br><span class="line"><span class="params">context_t_init(&amp;initp-&gt;td_context);</span></span><br><span class="line"><span class="params"><span class="comment">//初始化td_handtbl数组</span></span></span><br><span class="line"><span class="params"><span class="keyword">for</span> (<span class="type">uint_t</span> hand = <span class="number">0</span>; hand &lt; TD_HAND_MAX; hand++)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">initp-&gt;td_handtbl[hand] = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//创建thread_t结构</span></span></span><br><span class="line"><span class="params"><span class="type">thread_t</span> *krlnew_thread_dsc()</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="comment">//分配thread_t结构大小的内存空间</span></span></span><br><span class="line"><span class="params"><span class="type">thread_t</span> *rettdp = (<span class="type">thread_t</span> *)(krlnew((<span class="type">size_t</span>)(<span class="keyword">sizeof</span>(<span class="type">thread_t</span>))));</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (rettdp == <span class="literal">NULL</span>)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//初始化刚刚分配的thread_t结构</span></span></span><br><span class="line"><span class="params">thread_t_init(rettdp);</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> rettdp;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// -------------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 初始化内核栈</span></span></span><br><span class="line"><span class="params"><span class="comment">// -------------</span></span></span><br><span class="line"><span class="params"><span class="keyword">typedef</span> <span class="keyword">struct</span> s_INTSTKREGS</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_gs;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_fs;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_es;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_ds; <span class="comment">//段寄存器</span></span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_r15;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_r14;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_r13;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_r12;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_r11;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_r10;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_r9;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_r8;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_rdi;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_rsi;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_rbp;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_rdx; <span class="comment">//通用寄存器</span></span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_rcx;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_rbx;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_rax;</span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_rip_old;<span class="comment">//程序的指针寄存器</span></span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_cs_old;<span class="comment">//代码段寄存器</span></span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_rflgs; <span class="comment">//rflags标志寄存</span></span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_rsp_old;<span class="comment">//栈指针寄存器</span></span></span><br><span class="line"><span class="params">  <span class="type">uint_t</span> r_ss_old; <span class="comment">//栈段寄存器</span></span></span><br><span class="line"><span class="params">&#125;<span class="type">intstkregs_t</span>;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 初始化内核栈</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> krlthread_kernstack_init(<span class="type">thread_t</span> *thdp, <span class="type">void</span> *runadr, <span class="type">uint_t</span> cpuflags)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//处理栈顶16字节对齐</span></span></span><br><span class="line"><span class="params">  thdp-&gt;td_krlstktop &amp;= (~<span class="number">0xf</span>);</span></span><br><span class="line"><span class="params">  thdp-&gt;td_usrstktop &amp;= (~<span class="number">0xf</span>);</span></span><br><span class="line"><span class="params">  <span class="comment">//内核栈顶减去intstkregs_t结构的大小</span></span></span><br><span class="line"><span class="params">  <span class="type">intstkregs_t</span> *arp = (<span class="type">intstkregs_t</span> *)(thdp-&gt;td_krlstktop - <span class="keyword">sizeof</span>(intstkreg</span></span><br><span class="line"><span class="params">  <span class="comment">//把intstkregs_t结构的空间初始化为0</span></span></span><br><span class="line"><span class="params">  hal_memset((<span class="type">void</span>*)arp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">intstkregs_t</span>));</span></span><br><span class="line"><span class="params">  <span class="comment">//rip寄存器的值设为程序运行首地址</span></span></span><br><span class="line"><span class="params">  arp-&gt;r_rip_old = (<span class="type">uint_t</span>)runadr;</span></span><br><span class="line"><span class="params">  <span class="comment">//cs寄存器的值设为内核代码段选择子</span></span></span><br><span class="line"><span class="params">  arp-&gt;r_cs_old = K_CS_IDX;</span></span><br><span class="line"><span class="params">  arp-&gt;r_rflgs = cpuflags;</span></span><br><span class="line"><span class="params">  <span class="comment">//返回进程的内核栈</span></span></span><br><span class="line"><span class="params">  arp-&gt;r_rsp_old = thdp-&gt;td_krlstktop;</span></span><br><span class="line"><span class="params">  arp-&gt;r_ss_old = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//其它段寄存器的值设为内核数据段选择子</span></span></span><br><span class="line"><span class="params">  arp-&gt;r_ds = K_DS_IDX;</span></span><br><span class="line"><span class="params">  arp-&gt;r_es = K_DS_IDX;</span></span><br><span class="line"><span class="params">  arp-&gt;r_fs = K_DS_IDX;</span></span><br><span class="line"><span class="params">  arp-&gt;r_gs = K_DS_IDX;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程下一次运行的地址为runadr</span></span></span><br><span class="line"><span class="params">  thdp-&gt;td_context.ctx_nextrip = (<span class="type">uint_t</span>)runadr;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程下一次运行的栈地址为arp</span></span></span><br><span class="line"><span class="params">  thdp-&gt;td_context.ctx_nextrsp = (<span class="type">uint_t</span>)arp;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 初始化返回进程应用程序空间的内核栈</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> krlthread_userstack_init(<span class="type">thread_t</span> *thdp, <span class="type">void</span> *runadr, <span class="type">uint_t</span> cpuflags)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//处理栈顶16字节对齐</span></span></span><br><span class="line"><span class="params">  thdp-&gt;td_krlstktop &amp;= (~<span class="number">0xf</span>);</span></span><br><span class="line"><span class="params">  thdp-&gt;td_usrstktop &amp;= (~<span class="number">0xf</span>);</span></span><br><span class="line"><span class="params">  <span class="comment">//内核栈顶减去intstkregs_t结构的大小</span></span></span><br><span class="line"><span class="params">  <span class="type">intstkregs_t</span> *arp = (<span class="type">intstkregs_t</span> *)(thdp-&gt;td_krlstktop - <span class="keyword">sizeof</span>(<span class="type">intstkregs_t</span>));</span></span><br><span class="line"><span class="params">  <span class="comment">//把intstkregs_t结构的空间初始化为0</span></span></span><br><span class="line"><span class="params">  hal_memset((<span class="type">void</span>*)arp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">intstkregs_t</span>));</span></span><br><span class="line"><span class="params">  <span class="comment">//rip寄存器的值设为程序运行首地址</span></span></span><br><span class="line"><span class="params">  arp-&gt;r_rip_old = (<span class="type">uint_t</span>)runadr;</span></span><br><span class="line"><span class="params">  <span class="comment">//cs寄存器的值设为应用程序代码段选择子</span></span></span><br><span class="line"><span class="params">  arp-&gt;r_cs_old = U_CS_IDX;</span></span><br><span class="line"><span class="params">  arp-&gt;r_rflgs = cpuflags;</span></span><br><span class="line"><span class="params">  <span class="comment">//返回进程应用程序空间的栈</span></span></span><br><span class="line"><span class="params">  arp-&gt;r_rsp_old = thdp-&gt;td_usrstktop;</span></span><br><span class="line"><span class="params">  <span class="comment">//其它段寄存器的值设为应用程序数据段选择子</span></span></span><br><span class="line"><span class="params">  arp-&gt;r_ss_old = U_DS_IDX;</span></span><br><span class="line"><span class="params">  arp-&gt;r_ds = U_DS_IDX;</span></span><br><span class="line"><span class="params">  arp-&gt;r_es = U_DS_IDX;</span></span><br><span class="line"><span class="params">  arp-&gt;r_fs = U_DS_IDX;</span></span><br><span class="line"><span class="params">  arp-&gt;r_gs = U_DS_IDX;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程下一次运行的地址为runadr</span></span></span><br><span class="line"><span class="params">  thdp-&gt;td_context.ctx_nextrip = (<span class="type">uint_t</span>)runadr;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程下一次运行的栈地址为arp</span></span></span><br><span class="line"><span class="params">  thdp-&gt;td_context.ctx_nextrsp = (<span class="type">uint_t</span>)arp;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">// 初始化进程的内核栈所使用的段选择子指向的是应用程序的代码段和数据段，这个代码段和数据段它们特权级为 R3，CPU 正是根据这个代码段、数据段选择子来切换 CPU 工作特权级的</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// -----------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 建立普通进程</span></span></span><br><span class="line"><span class="params"><span class="comment">// -----------</span></span></span><br><span class="line"><span class="params"><span class="type">thread_t</span> *krlnew_user_thread_core(<span class="type">void</span> *filerun, <span class="type">uint_t</span> flg, <span class="type">uint_t</span> prilg, uin</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">thread_t</span> *ret_td = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="type">bool_t</span> acs = FALSE;</span></span><br><span class="line"><span class="params">  <span class="type">adr_t</span> usrstkadr = <span class="literal">NULL</span>, krlstkadr = <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="comment">//分配应用程序栈空间</span></span></span><br><span class="line"><span class="params">  usrstkadr = krlnew(usrstksz);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (usrstkadr == <span class="literal">NULL</span>)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//分配内核栈空间</span></span></span><br><span class="line"><span class="params">  krlstkadr = krlnew(krlstksz);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (krlstkadr == <span class="literal">NULL</span>)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (krldelete(usrstkadr, usrstksz) == FALSE)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//建立thread_t结构体的实例变量</span></span></span><br><span class="line"><span class="params">  ret_td = krlnew_thread_dsc();</span></span><br><span class="line"><span class="params">  <span class="comment">//创建失败必须要释放之前的栈空间</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (ret_td == <span class="literal">NULL</span>)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">    acs = krldelete(usrstkadr, usrstksz);</span></span><br><span class="line"><span class="params">    acs = krldelete(krlstkadr, krlstksz);</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (acs == FALSE)</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程权限</span></span></span><br><span class="line"><span class="params">  ret_td-&gt;td_privilege = prilg;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程优先级</span></span></span><br><span class="line"><span class="params">  ret_td-&gt;td_priority = prity;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程的内核栈顶和内核栈开始地址</span></span></span><br><span class="line"><span class="params">  ret_td-&gt;td_krlstktop = krlstkadr + (<span class="type">adr_t</span>)(krlstksz - <span class="number">1</span>);</span></span><br><span class="line"><span class="params">  ret_td-&gt;td_krlstkstart = krlstkadr;</span></span><br><span class="line"><span class="params">  <span class="comment">//设置进程的应用程序栈顶和内核应用程序栈开始地址</span></span></span><br><span class="line"><span class="params">  ret_td-&gt;td_usrstktop = usrstkadr + (<span class="type">adr_t</span>)(usrstksz - <span class="number">1</span>);</span></span><br><span class="line"><span class="params">  ret_td-&gt;td_usrstkstart = usrstkadr;</span></span><br><span class="line"><span class="params">  <span class="comment">//初始化返回进程应用程序空间的内核栈</span></span></span><br><span class="line"><span class="params">  krlthread_userstack_init(ret_td, filerun, UMOD_EFLAGS);</span></span><br><span class="line"><span class="params">  <span class="comment">//加入调度器系统</span></span></span><br><span class="line"><span class="params">  krlschdclass_add_thread(ret_td);</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> ret_td;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="72-多进程如何调度"><a class="markdownIt-Anchor" href="#72-多进程如何调度"></a> 7.2 多进程如何调度</h2>
<ul>
<li><strong>为什么需要多进程调度</strong>
<ul>
<li>第一,CPU同一时刻只能运行一个进程,而CPU个数总是比进程个数少,需要让多进程共用一个CPU,每个进程在这个CPU上运行一段时间</li>
<li>第二,当一个进程不能获取某种资源,导致不能继续运行时就应该让出CPU;<strong>进程拿不到资源就要让出CPU</strong></li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-22-16-39-34.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-22-16-39-34.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="多线程调度示意图" /></p>
<ul>
<li><strong>进程的生命周期</strong>
<ul>
<li>进程的生命周期,通常用进程的状态表示</li>
<li>只用宏来定义进程的状态
<ul>
<li>进程僵尸状态,表示进程将要系统不再进行调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TDSTUS_RUN 0 <span class="comment">//进程运行状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TDSTUS_SLEEP 3 <span class="comment">//进程睡眠状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TDSTUS_WAIT 4 <span class="comment">//进程等待状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TDSTUS_NEW 5 <span class="comment">//进程新建状态</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TDSTUS_ZOMB 6 <span class="comment">//进程僵死状态</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-22-16-47-04.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-22-16-47-04.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="进程状态切换示意图" /></p>
<ul>
<li><strong>如何组织进程</strong>
<ul>
<li>系统中会随时分配或删除 thread_t 结构</li>
<li>最简单的处理办法就是使用<strong>链表数据结构</strong>,但进程有优先级,可以设计成<strong>每一个优先级对应一个链表头</strong></li>
<li>schedclass_t 是一个全局数据结构,包含一个 schdata_t结构数组,数组大小根据CPU的数量决定,每个 schdata_t 结构中,又包含一个进程优先级大小的 thrdlst_t 结构数组</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-22-17-01-25.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-22-17-01-25.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="组织进程示意图" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于是调度器模块,故需要建立 krlsched.h 和 krlsched.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_THRDLST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">list_h_t</span> tdl_lsth; <span class="comment">//挂载进程的链表头</span></span><br><span class="line"><span class="type">thread_t</span>* tdl_curruntd; <span class="comment">//该链表上正在运行的进程</span></span><br><span class="line"><span class="type">uint_t</span> tdl_nr; <span class="comment">//该链表上进程个数</span></span><br><span class="line">&#125;<span class="type">thrdlst_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_SCHDATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> sda_lock; <span class="comment">//自旋锁</span></span><br><span class="line"><span class="type">uint_t</span> sda_cpuid; <span class="comment">//当前CPU id</span></span><br><span class="line"><span class="type">uint_t</span> sda_schdflgs; <span class="comment">//标志</span></span><br><span class="line"><span class="type">uint_t</span> sda_premptidx; <span class="comment">//进程抢占计数</span></span><br><span class="line"><span class="type">uint_t</span> sda_threadnr; <span class="comment">//进程数</span></span><br><span class="line"><span class="type">uint_t</span> sda_prityidx; <span class="comment">//当前优先级</span></span><br><span class="line"><span class="type">thread_t</span>* sda_cpuidle; <span class="comment">//当前CPU的空转进程</span></span><br><span class="line"><span class="type">thread_t</span>* sda_currtd; <span class="comment">//当前正在运行的进程</span></span><br><span class="line"><span class="type">thrdlst_t</span> sda_thdlst[PRITY_MAX]; <span class="comment">//进程链表数组</span></span><br><span class="line">&#125;<span class="type">schdata_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_SCHEDCALSS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> scls_lock; <span class="comment">//自旋锁</span></span><br><span class="line"><span class="type">uint_t</span> scls_cpunr; <span class="comment">//CPU个数</span></span><br><span class="line"><span class="type">uint_t</span> scls_threadnr; <span class="comment">//系统中所有的进程数</span></span><br><span class="line"><span class="type">uint_t</span> scls_threadid_inc; <span class="comment">//分配进程id所用</span></span><br><span class="line"><span class="type">schdata_t</span> scls_schda[CPUCORE_MAX]; <span class="comment">//每个CPU调度数据结构</span></span><br><span class="line">&#125;<span class="type">schedclass_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>管理进程的初始化</strong>
<ul>
<li>就是对 schdata_t 结构的变量的初始化
<ul>
<li>schdata_t 结构的变量应该是全局变量,所以在 cosmos/kernel/krlglobal.c文件中定义 schedclass_t 结构的全局变量</li>
</ul>
</li>
<li>在 cosmos/kernel/krlsched.c文件中写初始化 osschedcls 变量的代码
<ul>
<li>由 init_krlsched 函数调用 schedclass_t_init 函数,对 osschedcls 变量进行初始化工作</li>
</ul>
</li>
<li>init_krlsched 函数由 cosmos/kernel/krlinit.c文件中的<strong>init_krl 函数</strong>中调用</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">KRL_DEFGLOB_VARIABLE(<span class="type">schedclass_t</span>,osschedcls);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thrdlst_t_init</span><span class="params">(<span class="type">thrdlst_t</span> *initp)</span></span><br><span class="line">&#123;</span><br><span class="line">list_init(&amp;initp-&gt;tdl_lsth); <span class="comment">//初始化挂载进程的链表</span></span><br><span class="line">initp-&gt;tdl_curruntd = <span class="literal">NULL</span>; <span class="comment">//开始没有运行进程</span></span><br><span class="line">initp-&gt;tdl_nr = <span class="number">0</span>; <span class="comment">//开始没有进程</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">schdata_t_init</span><span class="params">(<span class="type">schdata_t</span> *initp)</span></span><br><span class="line">&#123;</span><br><span class="line">krlspinlock_init(&amp;initp-&gt;sda_lock);</span><br><span class="line">initp-&gt;sda_cpuid = hal_retn_cpuid(); <span class="comment">//获取CPU id</span></span><br><span class="line">initp-&gt;sda_schdflgs = NOTS_SCHED_FLGS;</span><br><span class="line">initp-&gt;sda_premptidx = <span class="number">0</span>;</span><br><span class="line">initp-&gt;sda_threadnr = <span class="number">0</span>;</span><br><span class="line">initp-&gt;sda_prityidx = <span class="number">0</span>;</span><br><span class="line">initp-&gt;sda_cpuidle = <span class="literal">NULL</span>; <span class="comment">//开始没有空转进程和运行的进程</span></span><br><span class="line">initp-&gt;sda_currtd = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint_t</span> ti = <span class="number">0</span>; ti &lt; PRITY_MAX; ti++)</span><br><span class="line">&#123;<span class="comment">//初始化schdata_t结构中的每个thrdlst_t结构</span></span><br><span class="line">thrdlst_t_init(&amp;initp-&gt;sda_thdlst[ti]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">schedclass_t_init</span><span class="params">(<span class="type">schedclass_t</span> *initp)</span></span><br><span class="line">&#123;</span><br><span class="line">krlspinlock_init(&amp;initp-&gt;scls_lock);</span><br><span class="line">initp-&gt;scls_cpunr = CPUCORE_MAX; <span class="comment">//CPU最大个数</span></span><br><span class="line">initp-&gt;scls_threadnr = <span class="number">0</span>; <span class="comment">//开始没有进程</span></span><br><span class="line">initp-&gt;scls_threadid_inc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint_t</span> si = <span class="number">0</span>; si &lt; CPUCORE_MAX; si++)</span><br><span class="line">&#123;<span class="comment">//初始化osschedcls变量中的每个schdata_t</span></span><br><span class="line">schdata_t_init(&amp;initp-&gt;scls_schda[si]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krlsched</span><span class="params">()</span></span><br><span class="line">&#123; <span class="comment">//初始化osschedcls变量</span></span><br><span class="line">schedclass_t_init(&amp;osschedcls);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  init_krl 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">init_krlsched();</span><br><span class="line">die(<span class="number">0</span>);<span class="comment">//控制不让init_krl函数返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>设计实现进程调度器</strong>
<ul>
<li>进程调度器是为了在合适的时间点,合适的代码执行路径上进行进程调度(从当前运行进程切换到另一个进程上裕兴,让当前进程停止运行,由CPU开始执行另一个进程的代码)</li>
</ul>
</li>
<li><strong>进程调度器入口</strong>
<ul>
<li>进程调度器为函数:确定当前正在运行的进程,然后选择下一个将要运行的进程,最后从当前运行的进程,切换到下一个将要运行的进程</li>
</ul>
</li>
<li><strong>如何获取当前运行的进程</strong>
<ul>
<li>目的:为了保存当前进程的运行上下文,确保在下一次调度到当前运行的进程时能恢复运行</li>
<li>每次切换到下一个进程运行时会将下一个运行的进程设置为当前运行的进程</li>
<li>schdata_t 结构中的 <strong>sda_currtd 字段</strong>正是保存当前正在运行进程的过程,返回这个字段的值就能取得当前正在运行的进程</li>
</ul>
</li>
<li><strong>选择下一个进程</strong>
<ul>
<li>根据调度器入口函数的设计,取得了当前正在运行的进程之后,下一步就是选择下个将要投入运行的进程</li>
<li><strong>进程调度算法的核心</strong>:关乎到进程的吞吐量,能否及时响应请求,CPU的利用率,各个进程之间运行获取资源的公平性,影响整个操作系统的性能,可靠性</li>
<li><strong>实现简单的优先级调度算法</strong>:始终选择优先级最高的进程作为下一个运行的进程
<ul>
<li>首先，从高到低扫描优先级进程链表，然后若当前优先级进程链表不为空，就取出该链表上的第一个进程，放入 thrdlst_t 结构中的 tdl_curruntd 字段中，并把之前 thrdlst_t 结构的 tdl_curruntd 字段中的进程挂入该链表的尾部，并返回</li>
<li>最后，当扫描到最低优先级时也没有找到进程，就返回默认的空转进程</li>
</ul>
</li>
</ul>
</li>
<li><strong>获取空转进程</strong>
<ul>
<li>在选择下一个进程的函数中,若没有找到合适的进程返回默认的空转进程</li>
<li>调度器的功能必须完成从一个进程到下一个进程的切换,若没有下一个进程,而上一个进程又不能运行，调度器将无路可去，整个系统将停止，故<strong>需要为系统留下一个空转进程</strong></li>
</ul>
</li>
<li><strong>进程切换</strong>
<ul>
<li>函数调用路径是通过栈来保存的,对于运行在内核空间中的进程就是保存在对应的内核栈中</li>
<li>进程切换函数:
<ul>
<li>首先，把当前进程的通用寄存器保存到当前进程的内核栈中</li>
<li>然后，保存 CPU 的 RSP寄存器到当前进程的机器上下文结构中，并且读取保存在下一个进程机器上下文结构中的RSP 的值，把它存到 CPU 的 RSP 寄存器中</li>
<li>接着，调用一个函数切换 MMU 页表</li>
<li>最后，从下一个进程的内核栈中恢复下一个进程的通用寄存器</li>
</ul>
</li>
<li><strong>save_to_new_context 进程切换函数:通过切换进程的内核栈导致切换进程</strong>
<ul>
<li>因为进程的函数调用路径就保存在对应的内核栈中，只要调用 krlschedul 函数，最后的函数调用路径一定会停在 save_to_new_context 函数中，当 save_to_new_context 函数一返回，就会导致回到调用save_to_new_context 函数的 krlschedul 函数中，最后层层返回</li>
</ul>
</li>
<li><mark>切换机制能正常运行必须保证下一个进程被正常调用过,即调用过 krlschedul 函数</mark>
<ul>
<li>在 _to_new_context 函数中完成该特殊操作</li>
<li>__to_new_context 负责设置当前运行的进程，处理 CPU 发生中断时需要切换栈的问题，又切换了一个进程的 MMU 页表（即使用新进程的地址空间），最后如果是新建进程第一次运行，就调用  retnfrom_first_sched 函数进行处理
<ul>
<li>retnfrom_first_sched 函数不会返回到调用它的 __to_new_context 函数中，而是直接运行新建进程的相关代码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程调度器的入口函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">krlschedul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">thread_t</span> *prev = krlsched_retn_currthread(),<span class="comment">//返回当前运行进程</span></span><br><span class="line">  *next = krlsched_select_thread();<span class="comment">//选择下一个运行的进程</span></span><br><span class="line">  save_to_new_context(next, prev);<span class="comment">//从当前进程切换到下一个进程</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前运行进程函数</span></span><br><span class="line"><span class="type">thread_t</span> *<span class="title function_">krlsched_retn_currthread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint_t</span> cpuid = hal_retn_cpuid();</span><br><span class="line">  <span class="comment">//通过cpuid获取当前cpu的调度数据结构</span></span><br><span class="line">  <span class="type">schdata_t</span> *schdap = &amp;osschedcls.scls_schda[cpuid];</span><br><span class="line">  <span class="keyword">if</span> (schdap-&gt;sda_currtd == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;<span class="comment">//若调度数据结构中当前运行进程的指针为空，就出错死机</span></span><br><span class="line">  hal_sysdie(<span class="string">&quot;schdap-&gt;sda_currtd NULL&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> schdap-&gt;sda_currtd;<span class="comment">//返回当前运行的进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的优先级调度算法</span></span><br><span class="line"><span class="type">thread_t</span> *<span class="title function_">krlsched_select_thread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">thread_t</span> *retthd, *tdtmp;</span><br><span class="line"><span class="type">cpuflg_t</span> cufg;</span><br><span class="line"><span class="type">uint_t</span> cpuid = hal_retn_cpuid();</span><br><span class="line"><span class="type">schdata_t</span> *schdap = &amp;osschedcls.scls_schda[cpuid];</span><br><span class="line">krlspinlock_cli(&amp;schdap-&gt;sda_lock, &amp;cufg);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint_t</span> pity = <span class="number">0</span>; pity &lt; PRITY_MAX; pity++)</span><br><span class="line">&#123;<span class="comment">//从最高优先级开始扫描</span></span><br><span class="line"><span class="keyword">if</span> (schdap-&gt;sda_thdlst[pity].tdl_nr &gt; <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//若当前优先级的进程链表不为空</span></span><br><span class="line"><span class="keyword">if</span> (list_is_empty_careful(&amp;(schdap-&gt;sda_thdlst[pity].tdl_lsth)) ==</span><br><span class="line">&#123;<span class="comment">//取出当前优先级进程链表下的第一个进程</span></span><br><span class="line">tdtmp = list_entry(schdap-&gt;sda_thdlst[pity].tdl_lsth.next, thr</span><br><span class="line">list_del(&amp;tdtmp-&gt;td_list);<span class="comment">//脱链</span></span><br><span class="line"><span class="keyword">if</span> (schdap-&gt;sda_thdlst[pity].tdl_curruntd != <span class="literal">NULL</span>)</span><br><span class="line">&#123;<span class="comment">//将这sda_thdlst[pity].tdl_curruntd的进程挂入链表尾</span></span><br><span class="line">list_add_tail(&amp;(schdap-&gt;sda_thdlst[pity].tdl_curruntd-&gt;td_</span><br><span class="line">&#125;</span><br><span class="line">schdap-&gt;sda_thdlst[pity].tdl_curruntd = tdtmp;</span><br><span class="line">retthd = tdtmp;<span class="comment">//将选择的进程放入sda_thdlst[pity].tdl_curruntd中，</span></span><br><span class="line"><span class="keyword">goto</span> return_step;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (schdap-&gt;sda_thdlst[pity].tdl_curruntd != <span class="literal">NULL</span>)</span><br><span class="line">&#123;<span class="comment">//若sda_thdlst[pity].tdl_curruntd不为空就直接返回它</span></span><br><span class="line">retthd = schdap-&gt;sda_thdlst[pity].tdl_curruntd;</span><br><span class="line"><span class="keyword">goto</span> return_step;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果最后也没有找到进程就返回默认的空转进程</span></span><br><span class="line">schdap-&gt;sda_prityidx = PRITY_MIN;</span><br><span class="line">retthd = krlsched_retn_idlethread();</span><br><span class="line">return_step:</span><br><span class="line"><span class="comment">//解锁并返回进程</span></span><br><span class="line">krlspinunlock_sti(&amp;schdap-&gt;sda_lock, &amp;cufg);</span><br><span class="line"><span class="keyword">return</span> retthd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取空转进程的函数</span></span><br><span class="line"><span class="type">thread_t</span> *krlsched_retn_idlethread()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint_t</span> cpuid = hal_retn_cpuid();</span><br><span class="line"><span class="comment">//通过cpuid获取当前cpu的调度数据结构</span></span><br><span class="line"><span class="type">schdata_t</span> *schdap = &amp;osschedcls.scls_schda[cpuid];</span><br><span class="line"><span class="keyword">if</span> (schdap-&gt;sda_cpuidle == <span class="literal">NULL</span>)</span><br><span class="line">&#123;<span class="comment">//若调度数据结构中空转进程的指针为空，就出错死机</span></span><br><span class="line">hal_sysdie(<span class="string">&quot;schdap-&gt;sda_cpuidle NULL&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> schdap-&gt;sda_cpuidle;<span class="comment">//返回空转进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程切换函数</span></span><br><span class="line"><span class="type">void</span> save_to_new_context(<span class="type">thread_t</span> *next, <span class="type">thread_t</span> *prev)</span><br><span class="line">&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">  <span class="string">&quot;pushfq \n\t&quot;</span><span class="comment">//保存当前进程的标志寄存器</span></span><br><span class="line">  <span class="string">&quot;cli \n\t&quot;</span> <span class="comment">//关中断</span></span><br><span class="line">  <span class="comment">//保存当前进程的通用寄存器</span></span><br><span class="line">  <span class="string">&quot;pushq %%rax\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%rbx\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%rcx\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%rdx\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%rbp\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%rsi\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%rdi\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%r8\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%r9\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%r10\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%r11\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%r12\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%r13\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%r14\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;pushq %%r15\n\t&quot;</span></span><br><span class="line">  <span class="comment">//保存CPU的RSP寄存器到当前进程的机器上下文结构中</span></span><br><span class="line">  <span class="string">&quot;movq %%rsp,%[PREV_RSP] \n\t&quot;</span></span><br><span class="line">  <span class="comment">//把下一个进程的机器上下文结构中的RSP的值，写入CPU的RSP寄存器中</span></span><br><span class="line">  <span class="string">&quot;movq %[NEXT_RSP],%%rsp \n\t&quot;</span><span class="comment">//事实上这里已经切换到下一个进程了，因为切换进程的</span></span><br><span class="line">  <span class="comment">//调用__to_new_context函数切换MMU页表</span></span><br><span class="line">  <span class="string">&quot;callq __to_new_context\n\t&quot;</span></span><br><span class="line">  <span class="comment">//恢复下一个进程的通用寄存器</span></span><br><span class="line">  <span class="string">&quot;popq %%r15\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r14\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r13\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r12\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r11\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r10\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r9\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r8\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rdi\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rsi\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rbp\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rdx\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rcx\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rbx\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rax\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popfq \n\t&quot;</span> <span class="comment">//恢复下一个进程的标志寄存器</span></span><br><span class="line">  <span class="comment">//输出当前进程的内核栈地址</span></span><br><span class="line">  : [ PREV_RSP ] <span class="string">&quot;=m&quot;</span>(prev-&gt;td_context.ctx_nextrsp)</span><br><span class="line">  <span class="comment">//读取下一个进程的内核栈地址</span></span><br><span class="line">  : [ NEXT_RSP ] <span class="string">&quot;m&quot;</span>(next-&gt;td_context.ctx_nextrsp), <span class="string">&quot;D&quot;</span>(next), <span class="string">&quot;S&quot;</span>(prev)</span><br><span class="line">  : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成特殊处理</span></span><br><span class="line"><span class="type">void</span> __to_new_context(<span class="type">thread_t</span> *next, <span class="type">thread_t</span> *prev)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint_t</span> cpuid = hal_retn_cpuid();</span><br><span class="line"><span class="type">schdata_t</span> *schdap = &amp;osschedcls.scls_schda[cpuid];</span><br><span class="line"><span class="comment">//设置当前运行进程为下一个运行的进程</span></span><br><span class="line">schdap-&gt;sda_currtd = next;</span><br><span class="line"><span class="comment">//设置下一个运行进程的tss为当前CPU的tss</span></span><br><span class="line">next-&gt;td_context.ctx_nexttss = &amp;x64tss[cpuid];</span><br><span class="line"><span class="comment">//设置当前CPU的tss中的R0栈为下一个运行进程的内核栈</span></span><br><span class="line">next-&gt;td_context.ctx_nexttss-&gt;rsp0 = next-&gt;td_krlstktop;</span><br><span class="line"><span class="comment">//装载下一个运行进程的MMU页表</span></span><br><span class="line">hal_mmu_load(&amp;next-&gt;td_mmdsc-&gt;msd_mmu);</span><br><span class="line"><span class="keyword">if</span> (next-&gt;td_stus == TDSTUS_NEW)</span><br><span class="line">&#123; <span class="comment">//如果是新建进程第一次运行就要进行处理</span></span><br><span class="line">next-&gt;td_stus = TDSTUS_RUN;</span><br><span class="line">retnfrom_first_sched(next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建进程第一次运行时调用 retnfrom_first_sched 函数进行处理</span></span><br><span class="line"><span class="type">void</span> retnfrom_first_sched(<span class="type">thread_t</span> *thrdp)</span><br><span class="line">&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">  <span class="string">&quot;movq %[NEXT_RSP],%%rsp\n\t&quot;</span> <span class="comment">//设置CPU的RSP寄存器为该进程机器上下文结构中的</span></span><br><span class="line">  <span class="comment">//恢复进程保存在内核栈中的段寄存器</span></span><br><span class="line">  <span class="string">&quot;popq %%r14\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;movw %%r14w,%%gs\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r14\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;movw %%r14w,%%fs\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r14\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;movw %%r14w,%%es\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r14\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;movw %%r14w,%%ds\n\t&quot;</span></span><br><span class="line">  <span class="comment">//恢复进程保存在内核栈中的通用寄存器</span></span><br><span class="line">  <span class="string">&quot;popq %%r15\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r14\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r13\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r12\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r11\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r10\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r9\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%r8\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rdi\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rsi\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rbp\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rdx\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rcx\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rbx\n\t&quot;</span></span><br><span class="line">  <span class="string">&quot;popq %%rax\n\t&quot;</span></span><br><span class="line">  <span class="comment">//恢复进程保存在内核栈中的RIP、CS、RFLAGS，（有可能需要恢复进程应用程序的RSP、SS</span></span><br><span class="line">  <span class="string">&quot;iretq\n\t&quot;</span></span><br><span class="line">  :</span><br><span class="line">  : [ NEXT_RSP ] <span class="string">&quot;m&quot;</span>(thrdp-&gt;td_context.ctx_nextrsp)</span><br><span class="line">  : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="73-如何实现进程的等待与唤醒机制"><a class="markdownIt-Anchor" href="#73-如何实现进程的等待与唤醒机制"></a> 7.3 如何实现进程的等待与唤醒机制</h2>
<ul>
<li><strong>进程的等待与唤醒</strong>
<ul>
<li>进程得不到所需的资源时就会进入等待状态,直到资源可用时才会被唤醒</li>
</ul>
</li>
<li><strong>进程等待结构</strong>
<ul>
<li>需要一种数据结构用于挂载等待的进程,在唤醒时才可以找到等待的进程</li>
</ul>
</li>
<li><strong>进程等待</strong>
<ul>
<li>让进程进入等待状态的机制是一个函数:会设置进程状态为等待状态,让进程从调度系统数据结构中脱落,最后让进程加入到 kwlst_t 等待结构中</li>
<li>函数使进程进入等待状态,而进程是当前正在运行的进程,而当前正在运行的进程正式调用这个函数的进程,故一个进程想要进入等待状态,只需要调用 krlsched_wait 函数即可</li>
</ul>
</li>
<li><strong>进程唤醒</strong>
<ul>
<li>从等待数据结构中获取进程,然后设置进程的状态为运行状态,最后将进程加入到进程调度系统数据结构中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// 进程等待结构</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_KWLST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> wl_lock; <span class="comment">//自旋锁</span></span><br><span class="line">  <span class="type">uint_t</span> wl_tdnr; <span class="comment">//等待进程的个数</span></span><br><span class="line">  <span class="type">list_h_t</span> wl_list; <span class="comment">//挂载等待进程的链表头</span></span><br><span class="line">&#125;<span class="type">kwlst_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 进程等待</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">krlsched_wait</span><span class="params">(<span class="type">kwlst_t</span> *wlst)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">cpuflg_t</span> cufg, tcufg;</span><br><span class="line">  <span class="type">uint_t</span> cpuid = hal_retn_cpuid();</span><br><span class="line">  <span class="type">schdata_t</span> *schdap = &amp;osschedcls.scls_schda[cpuid];</span><br><span class="line">  <span class="comment">//获取当前正在运行的进程</span></span><br><span class="line">  <span class="type">thread_t</span> *tdp = krlsched_retn_currthread();</span><br><span class="line">  <span class="type">uint_t</span> pity = tdp-&gt;td_priority;</span><br><span class="line">  krlspinlock_cli(&amp;schdap-&gt;sda_lock, &amp;cufg);</span><br><span class="line">  krlspinlock_cli(&amp;tdp-&gt;td_lock, &amp;tcufg);</span><br><span class="line">  tdp-&gt;td_stus = TDSTUS_WAIT;<span class="comment">//设置进程状态为等待状态</span></span><br><span class="line">  list_del(&amp;tdp-&gt;td_list);<span class="comment">//脱链</span></span><br><span class="line">  krlspinunlock_sti(&amp;tdp-&gt;td_lock, &amp;tcufg);</span><br><span class="line">  <span class="keyword">if</span> (schdap-&gt;sda_thdlst[pity].tdl_curruntd == tdp)</span><br><span class="line">  &#123;</span><br><span class="line">    schdap-&gt;sda_thdlst[pity].tdl_curruntd = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  schdap-&gt;sda_thdlst[pity].tdl_nr--;</span><br><span class="line">  krlspinunlock_sti(&amp;schdap-&gt;sda_lock, &amp;cufg);</span><br><span class="line">  krlwlst_add_thread(wlst, tdp);<span class="comment">//将进程加入等待结构中</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// 进程唤醒</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">krlsched_up</span><span class="params">(<span class="type">kwlst_t</span> *wlst)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">cpuflg_t</span> cufg, tcufg;</span><br><span class="line">  <span class="type">uint_t</span> cpuid = hal_retn_cpuid();</span><br><span class="line">  <span class="type">schdata_t</span> *schdap = &amp;osschedcls.scls_schda[cpuid];</span><br><span class="line">  <span class="type">thread_t</span> *tdp;</span><br><span class="line">  <span class="type">uint_t</span> pity;</span><br><span class="line">  <span class="comment">//取出等待数据结构第一个进程并从等待数据结构中删除</span></span><br><span class="line">  tdp = krlwlst_del_thread(wlst);</span><br><span class="line">  pity = tdp-&gt;td_priority;<span class="comment">//获取进程的优先级</span></span><br><span class="line">  krlspinlock_cli(&amp;schdap-&gt;sda_lock, &amp;cufg);</span><br><span class="line">  krlspinlock_cli(&amp;tdp-&gt;td_lock, &amp;tcufg);</span><br><span class="line">  tdp-&gt;td_stus = TDSTUS_RUN;<span class="comment">//设置进程的状态为运行状态</span></span><br><span class="line">  krlspinunlock_sti(&amp;tdp-&gt;td_lock, &amp;tcufg);</span><br><span class="line">  list_add_tail(&amp;tdp-&gt;td_list, &amp;(schdap-&gt;sda_thdlst[pity].tdl_lsth));<span class="comment">//加入进</span></span><br><span class="line">  schdap-&gt;sda_thdlst[pity].tdl_nr++;</span><br><span class="line">  krlspinunlock_sti(&amp;schdap-&gt;sda_lock, &amp;cufg);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>空转进程</strong>
<ul>
<li>空转进程是操作系统在没有任何进程可以调度运行时进程调度器最后的选择</li>
</ul>
</li>
<li><strong>建立空转进程</strong>
<ul>
<li>空转进程是内核进程,<strong>但不加入调度系统,而是用专用的指针指向</strong></li>
<li>建立空转进程由 new_cpuidle 函数调用 new_cpuidle_thread 函数完成
<ul>
<li>new_cpuidle_thread 函数的操作与建立内核进程差不多,但在函数最后，让调度系统数据结构的空转进程和当前进程的指针，指向刚刚建立的过程</li>
<li>在调用初始内核栈函数时，将 krlcpuidle_main 函数(<strong>空转进程的主函数</strong>)传了进去
<ul>
<li>空转进程的主函数本质就是个死循环，在死循环中打印一行信息，然后进行进程调度，这个函数就是永无休止地执行这两个步骤</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>空转进程运行</strong>
<ul>
<li>由于空转进程是第一进程故没法用调度器调度,需要手动开启</li>
<li>首先取出空转进程，设置机器上下文结构和运行状态,最后调用 retnfrom_first_sched 函数,恢复进程内核栈中的内容,让进程启动运行</li>
<li><strong>还应该将建立空转和启动空转进程运行函数封装在一个初始化空转进程的函数中,并在内核层初始化init_kel函数的最后调用</strong></li>
</ul>
</li>
<li><strong>多进程运行</strong>
<ul>
<li>在空转进程中调用了调度器函数，然后进程调度器会发现系统中没有进程，又不得不调度空转进程
<ul>
<li>所以最后结果就是：空转进程调用进程调度器，而调度器又选择了空转进程，导致形成了一个闭环</li>
</ul>
</li>
<li>建立多个进程验证进程调度器正常工作</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// 建立空转进程</span></span><br><span class="line"><span class="comment">// cosmos/kernel/krlcpuidle.c</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="type">thread_t</span> *<span class="title function_">new_cpuidle_thread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">thread_t</span> *ret_td = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">bool_t</span> acs = FALSE;</span><br><span class="line"><span class="type">adr_t</span> krlstkadr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">uint_t</span> cpuid = hal_retn_cpuid();</span><br><span class="line"><span class="type">schdata_t</span> *schdap = &amp;osschedcls.scls_schda[cpuid];</span><br><span class="line">krlstkadr = krlnew(DAFT_TDKRLSTKSZ);<span class="comment">//分配进程的内核栈</span></span><br><span class="line"><span class="keyword">if</span> (krlstkadr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分配thread_t结构体变量</span></span><br><span class="line">ret_td = krlnew_thread_dsc();</span><br><span class="line"><span class="keyword">if</span> (ret_td == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">acs = krldelete(krlstkadr, DAFT_TDKRLSTKSZ);</span><br><span class="line"><span class="keyword">if</span> (acs == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置进程具有系统权限</span></span><br><span class="line">ret_td-&gt;td_privilege = PRILG_SYS;</span><br><span class="line">ret_td-&gt;td_priority = PRITY_MIN;</span><br><span class="line"><span class="comment">//设置进程的内核栈顶和内核栈开始地址</span></span><br><span class="line">ret_td-&gt;td_krlstktop = krlstkadr + (<span class="type">adr_t</span>)(DAFT_TDKRLSTKSZ - <span class="number">1</span>);</span><br><span class="line">ret_td-&gt;td_krlstkstart = krlstkadr;</span><br><span class="line"><span class="comment">//初始化进程的内核栈</span></span><br><span class="line">krlthread_kernstack_init(ret_td, (<span class="type">void</span> *)krlcpuidle_main, KMOD_EFLAGS);</span><br><span class="line"><span class="comment">//设置调度系统数据结构的空转进程和当前进程为ret_td</span></span><br><span class="line">schdap-&gt;sda_cpuidle = ret_td;</span><br><span class="line">schdap-&gt;sda_currtd = ret_td;</span><br><span class="line"><span class="keyword">return</span> ret_td;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建空转进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">new_cpuidle</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">thread_t</span> *thp = new_cpuidle_thread();<span class="comment">//建立空转进程</span></span><br><span class="line"><span class="keyword">if</span> (thp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;<span class="comment">//失败则主动死机</span></span><br><span class="line">hal_sysdie(<span class="string">&quot;newcpuilde err&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">kprint(<span class="string">&quot;CPUIDLETASK: %x\n&quot;</span>, (<span class="type">uint_t</span>)thp);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空转进程的主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">krlcpuidle_main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  kprint(<span class="string">&quot;空转进程运行:%x\n&quot;</span>, i);<span class="comment">//打印</span></span><br><span class="line">  krlschedul();<span class="comment">//调度进程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 空转进程运行</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">krlcpuidle_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint_t</span> cpuid = hal_retn_cpuid();</span><br><span class="line">  <span class="type">schdata_t</span> *schdap = &amp;osschedcls.scls_schda[cpuid];</span><br><span class="line">  <span class="comment">//取得空转进程</span></span><br><span class="line">  <span class="type">thread_t</span> *tdp = schdap-&gt;sda_cpuidle;</span><br><span class="line">  <span class="comment">//设置空转进程的tss和R0特权级的栈</span></span><br><span class="line">  tdp-&gt;td_context.ctx_nexttss = &amp;x64tss[cpuid];</span><br><span class="line">  tdp-&gt;td_context.ctx_nexttss-&gt;rsp0 = tdp-&gt;td_krlstktop;</span><br><span class="line">  <span class="comment">//设置空转进程的状态为运行状态</span></span><br><span class="line">  tdp-&gt;td_stus = TDSTUS_RUN;</span><br><span class="line">  <span class="comment">//启动进程运行</span></span><br><span class="line">  retnfrom_first_sched(tdp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init_kel函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  init_krlsched();<span class="comment">//初始化进程调度器</span></span><br><span class="line">  init_krlcpuidle();<span class="comment">//初始化空转进程</span></span><br><span class="line">  die(<span class="number">0</span>);<span class="comment">//防止init_krl函数返回</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化空转进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krlcpuidle</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  new_cpuidle();<span class="comment">//建立空转进程</span></span><br><span class="line">  krlcpuidle_start();<span class="comment">//启动空转进程运行</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 多进程运行</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_a_main</span><span class="params">()</span><span class="comment">//进程A主函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;; i++) &#123;</span><br><span class="line">    kprint(<span class="string">&quot;进程A运行:%x\n&quot;</span>, i);</span><br><span class="line">    krlschedul();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_b_main</span><span class="params">()</span><span class="comment">//进程B主函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;; i++) &#123;</span><br><span class="line">    kprint(<span class="string">&quot;进程B运行:%x\n&quot;</span>, i);</span><br><span class="line">    krlschedul();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_ab_thread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  krlnew_thread((<span class="type">void</span>*)thread_a_main, KERNTHREAD_FLG,</span><br><span class="line">  PRILG_SYS, PRITY_MIN, DAFT_TDUSRSTKSZ, DAFT_TDKRLSTKSZ);</span><br><span class="line">  krlnew_thread((<span class="type">void</span>*)thread_b_main, KERNTHREAD_FLG,</span><br><span class="line">  PRILG_SYS, PRITY_MIN, DAFT_TDUSRSTKSZ, DAFT_TDKRLSTKSZ);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krlcpuidle</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  new_cpuidle();<span class="comment">//建立空转进程</span></span><br><span class="line">  init_ab_thread();<span class="comment">//初始化建立A、B进程</span></span><br><span class="line">  krlcpuidle_start();<span class="comment">//开始运行空转进程</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="74-linux如何实现进程与进程调度"><a class="markdownIt-Anchor" href="#74-linux如何实现进程与进程调度"></a> 7.4 Linux如何实现进程与进程调度</h2>
<ul>
<li><strong>Linux进程的数据结构</strong>
<ul>
<li>Linux把运行中的应用程序抽象成 task_struct，应用程序所需要的各种资源,内存,文件等都包含在其中</li>
<li>一个 task_struct 结构体的实例变量代表一个 Linux 进程</li>
</ul>
</li>
<li><strong>创建 task_struct 结构</strong>
<ul>
<li>Linux早期创建 task_struct 结构体的实例变量:找伙伴内存管理系统,分配两个连续的页面(8KB),作为进程的内核栈,再把 task_struct 结构体的实例变量,放在这8KB内存空间的开始地址处,内核栈是从上向下伸长的,task_struct数据结构是从下向上伸长的</li>
<li>Linux把 task_struct 结构和内核栈放在一起,只要把 RSP 寄存器的值读取出来,然后将其低13位清零,就得到了当前 task_struct 结构体的地址,由于内核栈比较大且会向下伸长,覆盖掉 task_struct 结构体的概率较小</li>
<li><mark>最新版本,task_struct 和内核栈是分开的</mark></li>
</ul>
</li>
<li><strong>Linux进程地址空间</strong>
<ul>
<li><strong>Linux支持虚拟内存的操作系统内核</strong>，Linux用于描述一个进程的地址空间的数据结构,就是 mm_struct 结构</li>
<li>mm_struct 结构中 vm_area_struct 结构，相当于之前 Cosmos 的 kmvarsdsc_t 结构，是用来描述一段虚拟地址空间的</li>
<li>mm_struct 结构中也包含了 MMU 页表相关的信息</li>
<li><strong>建立 mm_struct 结构的实例变量</strong>
<ul>
<li>copy_mm 函数在 copy_process 函数中被调用的, copy_mm 函数调用 dup_mm 函数，把当前进程的 mm_struct 结构复制到 allocate_mm 宏分配的一个 mm_struct 结构中</li>
</ul>
</li>
</ul>
</li>
<li><strong>Linux进程文件表</strong>
<ul>
<li>一个文件进行读写操作之前,必须先打开文件,这个文件就记录在进程的文件表中,它由 task_struct 结构中的 files 字段指向 files_struct 结构</li>
<li><mark>Linux建立新进程时,复制当前进程的 files_struct 结构以建立一个 files_struct 结构</mark>
<ul>
<li>copy_files 函数由 copy_process 函数调用，copy_files 最终会复制当前进程的files_struct 结构到一个新的 files_struct 结构实例变量中，并让新进程的 files 指针指向这个新的 files_struct 结构实例变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-10-20-10.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-10-20-10.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="进程内核栈" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------------</span></span><br><span class="line"><span class="comment">// Linux进程的数据结构</span></span><br><span class="line"><span class="comment">// -----------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span><span class="comment">//处理器特有数据</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">long</span> state; <span class="comment">//进程状态</span></span><br><span class="line">  <span class="type">void</span> *<span class="built_in">stack</span>; <span class="comment">//进程内核栈地址</span></span><br><span class="line">  <span class="type">refcount_t</span> usage; <span class="comment">//进程使用计数</span></span><br><span class="line">  <span class="type">int</span> on_rq; <span class="comment">//进程是否在运行队列上</span></span><br><span class="line">  <span class="type">int</span> prio; <span class="comment">//动态优先级</span></span><br><span class="line">  <span class="type">int</span> static_prio; <span class="comment">//静态优先级</span></span><br><span class="line">  <span class="type">int</span> normal_prio; <span class="comment">//取决于静态优先级和调度策略</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> rt_priority; <span class="comment">//实时优先级</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span><span class="comment">//指向其所在的调度类</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span><span class="comment">//普通进程的调度实体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span><span class="comment">//实时进程的调度实体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span> <span class="title">dl</span>;</span><span class="comment">//采用EDF算法调度实时进程的调度实体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span> <span class="title">sched_info</span>;</span><span class="comment">//用于调度器统计进程的运行信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span><span class="comment">//所有进程的链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">//指向进程内存结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span></span><br><span class="line">  <span class="type">pid_t</span> pid; <span class="comment">//进程id</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span><span class="comment">//指向其父进程</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span> <span class="comment">//链表中的所有元素都是它的子进程</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span> <span class="comment">//用于把当前进程插入到兄弟链表中</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span><span class="comment">//指向其所在进程组的领头进程</span></span><br><span class="line">  u64 utime; <span class="comment">//用于记录进程在用户态下所经过的节拍数</span></span><br><span class="line">  u64 stime; <span class="comment">//用于记录进程在内核态下所经过的节拍数</span></span><br><span class="line">  u64 gtime; <span class="comment">//用于记录作为虚拟机进程所经过的节拍数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> min_flt;<span class="comment">//缺页统计</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> maj_flt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> <span class="comment">//进程相关的文件系统信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span><span class="comment">//进程打开的所有文件</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">stack_vm_area</span>;</span><span class="comment">//内核栈的内存区</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="comment">// 创建 task_struct 结构</span></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> *<span class="title function_">alloc_thread_stack_node</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="type">int</span> nod</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> page *page = alloc_pages_node(node, THREADINFO_GFP,</span></span><br><span class="line"><span class="params">  THREAD_SIZE_ORDER);<span class="comment">//分配两个页面</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (likely(page)) &#123;</span></span><br><span class="line"><span class="params">    tsk-&gt;<span class="built_in">stack</span> = kasan_reset_tag(page_address(page));</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> tsk-&gt;<span class="built_in">stack</span>;<span class="comment">//让task_struct结构的stack字段指向page的地址</span></span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *alloc_task_struct_node(<span class="type">int</span> node)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);<span class="comment">//在tas</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">struct</span> task_struct *dup_task_struct(<span class="keyword">struct</span> task_struct *orig, <span class="type">int</span> node)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> task_struct *tsk; <span class="type">unsigned</span> <span class="type">long</span> *<span class="built_in">stack</span>;</span></span><br><span class="line"><span class="params">  tsk = alloc_task_struct_node(node);<span class="comment">//分配task_struct结构体</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (!tsk)</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">  <span class="built_in">stack</span> = alloc_thread_stack_node(tsk, node);<span class="comment">//分配内核栈</span></span></span><br><span class="line"><span class="params">  tsk-&gt;<span class="built_in">stack</span> = <span class="built_in">stack</span>;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> tsk;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> __latent_entropy <span class="keyword">struct</span> task_struct *copy_process(</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> pid *pid, <span class="type">int</span> trace, <span class="type">int</span> node,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> kernel_clone_args *args)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">int</span> pidfd = <span class="number">-1</span>, retval;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> task_struct *p;</span></span><br><span class="line"><span class="params">  <span class="comment">//……</span></span></span><br><span class="line"><span class="params">  retval = -ENOMEM;</span></span><br><span class="line"><span class="params">  p = dup_task_struct(current, node);<span class="comment">//分配task_struct和内核栈</span></span></span><br><span class="line"><span class="params">  <span class="comment">//……</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> ERR_PTR(retval);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">pid_t</span> kernel_clone(<span class="keyword">struct</span> kernel_clone_args *args)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  u64 clone_flags = args-&gt;flags;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> task_struct *p;</span></span><br><span class="line"><span class="params">  <span class="type">pid_t</span> nr;</span></span><br><span class="line"><span class="params">  <span class="comment">//……</span></span></span><br><span class="line"><span class="params">  <span class="comment">//复制进程</span></span></span><br><span class="line"><span class="params">  p = copy_process(<span class="literal">NULL</span>, trace, NUMA_NO_NODE, args);</span></span><br><span class="line"><span class="params">  <span class="comment">//……</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> nr;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//建立进程接口</span></span></span><br><span class="line"><span class="params">SYSCALL_DEFINE0(fork)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> kernel_clone_args args = &#123;</span></span><br><span class="line"><span class="params">  .exit_signal = SIGCHLD,</span></span><br><span class="line"><span class="params">  &#125;;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> kernel_clone(&amp;args);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// ----------------</span></span></span><br><span class="line"><span class="params"><span class="comment">// Linux进程地址空间</span></span></span><br><span class="line"><span class="params"><span class="comment">// ----------------</span></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> mm_struct &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> vm_area_struct *mmap; <span class="comment">//虚拟地址区间链表VMAs</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> rb_root mm_rb; <span class="comment">//组织vm_area_struct结构的红黑树的根</span></span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> task_size; <span class="comment">//进程虚拟地址空间大小</span></span></span><br><span class="line"><span class="params">  <span class="type">pgd_t</span> * pgd; <span class="comment">//指向MMU页表</span></span></span><br><span class="line"><span class="params">  <span class="type">atomic_t</span> mm_users; <span class="comment">//多个进程共享这个mm_struct</span></span></span><br><span class="line"><span class="params">  <span class="type">atomic_t</span> mm_count; <span class="comment">//mm_struct结构本身计数</span></span></span><br><span class="line"><span class="params">  <span class="type">atomic_long_t</span> pgtables_bytes;<span class="comment">//页表占用了多个页</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> map_count; <span class="comment">//多少个VMA</span></span></span><br><span class="line"><span class="params">  <span class="type">spinlock_t</span> page_table_lock; <span class="comment">//保护页表的自旋锁</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> list_head mmlist; <span class="comment">//挂入mm_struct结构的链表</span></span></span><br><span class="line"><span class="params">  <span class="comment">//进程应用程序代码开始、结束地址，应用程序数据的开始、结束地址</span></span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span></span><br><span class="line"><span class="params">  <span class="comment">//进程应用程序堆区的开始、当前地址、栈开始地址</span></span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span></span><br><span class="line"><span class="params">  <span class="comment">//进程应用程序参数区开始、结束地址</span></span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span></span><br><span class="line"><span class="params">&#125;;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// mm_struct 结构建立对应的实例变量</span></span></span><br><span class="line"><span class="params"><span class="comment">//在mm_cachep内存对象中分配一个mm_struct结构休对象</span></span></span><br><span class="line"><span class="params">#define allocate_mm() (kmem_cache_alloc(mm_cachep, GFP_KERNEL))</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">struct</span> mm_struct *dup_mm(<span class="keyword">struct</span> task_struct *tsk,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> mm_struct *oldmm)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> mm_struct *mm;</span></span><br><span class="line"><span class="params">  <span class="comment">//分配mm_struct结构</span></span></span><br><span class="line"><span class="params">  mm = allocate_mm();</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (!mm)</span></span><br><span class="line"><span class="params">  <span class="keyword">goto</span> fail_nomem;</span></span><br><span class="line"><span class="params">  <span class="comment">//复制mm_struct结构</span></span></span><br><span class="line"><span class="params">  <span class="built_in">memcpy</span>(mm, oldmm, <span class="keyword">sizeof</span>(*mm));</span></span><br><span class="line"><span class="params">  <span class="comment">//……</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> mm;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="type">int</span> copy_mm(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> mm_struct *mm, *oldmm;</span></span><br><span class="line"><span class="params">  <span class="type">int</span> retval;</span></span><br><span class="line"><span class="params">  tsk-&gt;min_flt = tsk-&gt;maj_flt = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  tsk-&gt;nvcsw = tsk-&gt;nivcsw = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  retval = -ENOMEM;</span></span><br><span class="line"><span class="params">  mm = dup_mm(tsk, current-&gt;mm);<span class="comment">//分配mm_struct结构的实例变量</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (!mm)</span></span><br><span class="line"><span class="params">  <span class="keyword">goto</span> fail_nomem;</span></span><br><span class="line"><span class="params">  good_mm:</span></span><br><span class="line"><span class="params">  tsk-&gt;mm = mm;</span></span><br><span class="line"><span class="params">  tsk-&gt;active_mm = mm;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params">  fail_nomem:</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> retval;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// --------------</span></span></span><br><span class="line"><span class="params"><span class="comment">// Linux进程文件表</span></span></span><br><span class="line"><span class="params"><span class="comment">// --------------</span></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> files_struct &#123;</span></span><br><span class="line"><span class="params">  <span class="type">atomic_t</span> count;<span class="comment">//自动计数</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> fdtable __rcu *fdt;</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> fdtable fdtab;</span></span><br><span class="line"><span class="params">  <span class="type">spinlock_t</span> file_lock; <span class="comment">//自旋锁</span></span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">int</span> next_fd;<span class="comment">//下一个文件句柄</span></span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> close_on_exec_init[<span class="number">1</span>];<span class="comment">//执行exec()时要关闭的文件句柄</span></span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> open_fds_init[<span class="number">1</span>];</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">long</span> full_fds_bits_init[<span class="number">1</span>];</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> file __rcu * fd_array[NR_OPEN_DEFAULT];<span class="comment">//默认情况下打开文件的指针数组</span></span></span><br><span class="line"><span class="params">&#125;;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="type">int</span> copy_files(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> files_struct *oldf, *newf;</span></span><br><span class="line"><span class="params"><span class="type">int</span> error = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">oldf = current-&gt;files;<span class="comment">//获取当前进程的files_struct的指针</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (!oldf)</span></span><br><span class="line"><span class="params"><span class="keyword">goto</span> out;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (clone_flags &amp; CLONE_FILES) &#123;</span></span><br><span class="line"><span class="params"><span class="type">atomic_inc</span>(&amp;oldf-&gt;count);</span></span><br><span class="line"><span class="params"><span class="keyword">goto</span> out;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//分配新files_struct结构的实例变量，并复制当前的files_struct结构</span></span></span><br><span class="line"><span class="params">newf = dup_fd(oldf, NR_OPEN_MAX, &amp;error);</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (!newf)</span></span><br><span class="line"><span class="params"><span class="keyword">goto</span> out;</span></span><br><span class="line"><span class="params">tsk-&gt;files = newf;<span class="comment">//新进程的files_struct结构指针指向新的files_struct结构</span></span></span><br><span class="line"><span class="params">error = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">out:</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> error;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Linux进程调度</strong>
<ul>
<li>Linux有多重调度算法,支持调度算法,具有给予优先级的调度算法,实时调度算法,完全公平调度算法(CFQ)</li>
</ul>
</li>
<li><strong>进程调度实体</strong>
<ul>
<li>进程调度实体是Linux进程调度系统的一部分,被嵌入到Linux进程数据结构中,与调度器进行关联,能间接地访问进程
<ul>
<li><strong>高内聚低耦合的方式保证进程数据结构和调度数据结构相关独立</strong></li>
</ul>
</li>
<li>task_struct 结构中包含至少一个 sched_entity 结构的变量</li>
<li>使用 sched_entity 访问 task_struct 结构:只要通过 sched_entity 结构变量的地址，减去它在 task_struct 结构中的偏移(由编译器自动计算)，就能获取到 task_struct 结构的地址</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-12-05-04.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-12-05-04.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="调度实体在进程结构中的位置" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 进程调度实体</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span><span class="comment">//表示当前调度实体的权重</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">run_node</span>;</span><span class="comment">//红黑树的数据节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">group_node</span>;</span><span class="comment">// 链表节点，被链接到 percpu 的 rq-&gt;cfs_tasks</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> on_rq; <span class="comment">//当前调度实体是否在就绪队列上</span></span><br><span class="line">  u64 exec_start;<span class="comment">//当前实体上次被调度执行的时间</span></span><br><span class="line">  u64 sum_exec_runtime;<span class="comment">//当前实体总执行时间</span></span><br><span class="line">  u64 prev_sum_exec_runtime;<span class="comment">//截止到上次统计，进程执行的时间</span></span><br><span class="line">  u64 vruntime;<span class="comment">//当前实体的虚拟时间</span></span><br><span class="line">  u64 nr_migrations;<span class="comment">//实体执行迁移的次数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_statistics</span> <span class="title">statistics</span>;</span><span class="comment">//统计信息包含进程的睡眠统计、等待延迟统计、CP</span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="type">int</span> depth;<span class="comment">// 表示当前实体处于调度组中的深度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">parent</span>;</span><span class="comment">//指向父级调度实体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span><span class="comment">//当前调度实体属于的 cfs_rq.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">my_q</span>;</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span> <span class="title">avg</span> ;</span><span class="comment">// 记录当前实体对于CPU的负载</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>进程运行队列</strong>
<ul>
<li>首先Linux定义了一个进程运行队列结构,每个CPU分配进程运行队列结构实例变量
<ul>
<li>rq结构中, 通过cfs_rq，rt_rq,dl_rq来关联调度实体,task_struct结构指针是为了快速访问特殊进程</li>
</ul>
</li>
<li>cfs_rq，rt_rq,dl_rq作用于三种不同的调度算法,重点关注cfs_rq
<ul>
<li>其中 load、exec_clock、min_vruntime、tasks_timeline 字段是 CFS 调度算法得以实现的关键</li>
<li>cfs_rq结构中的 tasks_timeline 字段：调度实体是通过红黑树组织起来的</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程运行队列结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">  <span class="type">raw_spinlock_t</span> lock;<span class="comment">//自旋锁</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nr_running;<span class="comment">//多个就绪运行进程</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> <span class="title">cfs</span>;</span> <span class="comment">//作用于完全公平调度算法的运行队列</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> <span class="title">rt</span>;</span><span class="comment">//作用于实时调度算法的运行队列</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dl_rq</span> <span class="title">dl</span>;</span><span class="comment">//作用于EDF调度算法的运行队列</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">curr</span>;</span><span class="comment">//这个运行队列当前正在运行的进程</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">idle</span>;</span><span class="comment">//这个运行队列的空转进程</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">stop</span>;</span><span class="comment">//这个运行队列的停止进程</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">prev_mm</span>;</span><span class="comment">//这个运行队列上一次运行进程的mm_struct</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> clock_update_flags;<span class="comment">//时钟更新标志</span></span><br><span class="line">  u64 clock; <span class="comment">//运行队列的时间</span></span><br><span class="line">  <span class="comment">//后面的代码省略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rb_root</span>;</span> <span class="comment">//红黑树的根</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_leftmost</span>;</span><span class="comment">//红黑树最左子节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span><span class="comment">//cfs_rq上所有调度实体的负载总和</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nr_running;<span class="comment">//cfs_rq上所有的调度实体不含调度组中的调度实体</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> h_nr_running;<span class="comment">//cfs_rq上所有的调度实体包含调度组中所有调度实体</span></span><br><span class="line">  u64 exec_clock;<span class="comment">//当前 cfs_rq 上执行的时间</span></span><br><span class="line">  u64 min_vruntime;<span class="comment">//最小虚拟运行时间</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> <span class="title">tasks_timeline</span>;</span><span class="comment">//所有调度实体的根</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span>;</span><span class="comment">//当前调度实体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">next</span>;</span><span class="comment">//下一个调度实体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">last</span>;</span><span class="comment">//上次执行过的调度实体</span></span><br><span class="line">  <span class="comment">//省略不关注的代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>调度实体和运行队列的关系</strong>
<ul>
<li>task_struct 结构中包含了 sched_entity 结构</li>
<li>sched_entity 结构是通过红黑树组织,红黑树的根在 cfs_rq 结构中,cfs_rq 结构被包含在 rq 结构,每个CPU对应一个 rq 结构</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-12-39-46.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-12-39-46.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="运行队列框架示意图" /></p>
<ul>
<li><strong>调度器类</strong>
<ul>
<li>为了支持不同的调度器,Linux定义调度器类数据结构,定义了调度器需要实现的函数
<ul>
<li>sched_class 结构定义了一组函数指针</li>
<li>Linux 系统一共定义了五个 sched_class 结构的实例变量，五个 sched_class 结构紧靠在一起，形成了 sched_class 结构数组</li>
<li>类的优先级:stop_sched_class &gt; dl_sched_class &gt; rt_sched_class &gt; fair_sched_class &gt; idle_sched_class</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 调度器类</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">  <span class="comment">//向运行队列中添加一个进程，入队</span></span><br><span class="line">  <span class="type">void</span> (*enqueue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">  <span class="comment">//向运行队列中删除一个进程，出队</span></span><br><span class="line">  <span class="type">void</span> (*dequeue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">  <span class="comment">//检查当前进程是否可抢占</span></span><br><span class="line">  <span class="type">void</span> (*check_preempt_curr)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags</span><br><span class="line">  <span class="comment">//从运行队列中返回可以投入运行的一个进程</span></span><br><span class="line">  <span class="keyword">struct</span> task_struct *(*pick_next_task)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义在链接脚本文件中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> sched_class __begin_sched_classes[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> sched_class __end_sched_classes[];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sched_class_highest (__end_sched_classes - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sched_class_lowest (__begin_sched_classes - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_class_range(class, _from, _to) \</span></span><br><span class="line"><span class="meta">for (class = (_from); class != (_to); class--)</span></span><br><span class="line"><span class="comment">//遍历每个调度类</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_class(class) \</span></span><br><span class="line"><span class="meta">for_class_range(class, sched_class_highest, sched_class_lowest)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> sched_class stop_sched_class;<span class="comment">//停止调度类</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> sched_class dl_sched_class;<span class="comment">//Deadline调度类</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> sched_class rt_sched_class;<span class="comment">//实时调度类</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> sched_class fair_sched_class;<span class="comment">//CFS调度类</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">struct</span> sched_class idle_sched_class;<span class="comment">//空转调度类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cfs调度器需要的 fair_sched_class</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> sched_class fair_sched_class</span><br><span class="line">__section(<span class="string">&quot;__fair_sched_class&quot;</span>) = &#123;</span><br><span class="line">  .enqueue_task = enqueue_task_fair,</span><br><span class="line">  .dequeue_task = dequeue_task_fair,</span><br><span class="line">  .check_preempt_curr = check_preempt_wakeup,</span><br><span class="line">  .pick_next_task = __pick_next_task_fair,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Linux的CFS调度器</strong></li>
<li><strong>普通进程的权重</strong>
<ul>
<li>cfs调度器与其他进程调度器的不同之处在于没有时间片的概念,是分配CPU使用时间的比例</li>
<li>cfs调度器具有<strong>权重</strong>,权重表示进程的优先级,各个进程按权重的比例分配CPU时间</li>
<li>分配给进程的时间计算公式:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>进程的时间</mtext><mo>=</mo><mi>C</mi><mi>P</mi><mi>U</mi><mtext>总时间</mtext><mo>∗</mo><mtext>进程的权重</mtext><mi mathvariant="normal">/</mi><mtext>就绪队列所有进程权重之和</mtext></mrow><annotation encoding="application/x-tex">进程的时间= CPU总时间*进程的权重/就绪队列所有进程权重之和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">权</span><span class="mord cjk_fallback">重</span><span class="mord">/</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">绪</span><span class="mord cjk_fallback">队</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">权</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">和</span></span></span></span>
<ul>
<li>进程对外的编程接口使用的是<strong>nice值</strong>,大小为-20~19，数值越小优先级越大,意味着权重值越大
<ul>
<li>nice值和权重之间可进行转换，每降低一个nice值就能获得多10%的CPU时间</li>
<li>1024 权重对应 nice 值为0，被称为 NICE_0_LOAD。默认情况下，大多数进程的权重都是 NICE_0_LOAD</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>进程调度延迟</strong>
<ul>
<li><strong>调度延迟为了保证每一个可运行的进程都至少运行一次的时间间隔</strong></li>
<li>随着进程的增加,每个进程分配的时间在减少,进程调度次数增加,调度器占用的时间就会增加,因此<strong>cfs调度器的调度延迟时间的设定并不固定</strong>
<ul>
<li>当进程小于8时,调度延迟是固定的6ms</li>
<li>超过8时,就要保证每个进程至少运行一段时间(最小调度粒度时间)才会被调度
<ul>
<li>CFS默认设置中,最小调度粒度时间为0.75ms,用变量sysctl_sched_min_granularity 记录，由 __sched_period 函数负责计算</li>
</ul>
</li>
</ul>
</li>
<li>参数 nr_running 是 Linux 系统中可运行的进程数量，当超过sched_nr_latency 时无法保证调度延迟，因此转为保证最小调度粒度</li>
</ul>
</li>
<li><strong>虚拟时间</strong>
<ul>
<li>vruntime 表示虚拟时间,CFS调度器记录每个进程的执行时间,为保证每个进程运行时间的公平,进程运行时间最少的进程先运行</li>
<li>进程的实际执行时间不等,但CFS引入虚拟时间,将实际执行时间转换为相同的虚拟时间,即保证每个进程运行的虚拟时间相等
<ul>
<li>转换公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>r</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>=</mo><mi>w</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>N</mi><mi>I</mi><mi>C</mi><mi>E</mi><mi mathvariant="normal">_</mi><mn>0</mn><mi mathvariant="normal">_</mi><mi>L</mi><mi>O</mi><mi>A</mi><mi>D</mi><mi mathvariant="normal">/</mi><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">vruntime = wtime*( NICE\_0\_LOAD/weight)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord">0</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>CFS 调度主要保证每个进程运行的虚拟时间一致即可。在选择下一个即将运行的进程时，只需要找到虚拟时间最小的进程就行了,计算过程由 calc_delta_fair 函数完成
<ul>
<li>调用 __calc_delta 函数的时候，传递的 weight 参数是NICE_0_LOAD，lw 参数正是调度实体中的 load_weight 结构体</li>
</ul>
</li>
<li>在运行队列中用红黑树结构组织进程的调度实体，进程虚拟时间正是红黑树的 key
<ul>
<li>红黑树的最左子节点，就是虚拟时间最小的进程，随着时间的推移进程会从红黑树的左边跑到右，然后从右边跑到左边</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 普通进程的权重</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sched_prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line">  <span class="comment">/* -20 */</span> <span class="number">88761</span>, <span class="number">71755</span>, <span class="number">56483</span>, <span class="number">46273</span>, <span class="number">36291</span>,</span><br><span class="line">  <span class="comment">/* -15 */</span> <span class="number">29154</span>, <span class="number">23254</span>, <span class="number">18705</span>, <span class="number">14949</span>, <span class="number">11916</span>,</span><br><span class="line">  <span class="comment">/* -10 */</span> <span class="number">9548</span>, <span class="number">7620</span>, <span class="number">6100</span>, <span class="number">4904</span>, <span class="number">3906</span>,</span><br><span class="line">  <span class="comment">/* -5 */</span> <span class="number">3121</span>, <span class="number">2501</span>, <span class="number">1991</span>, <span class="number">1586</span>, <span class="number">1277</span>,</span><br><span class="line">  <span class="comment">/* 0 */</span> <span class="number">1024</span>, <span class="number">820</span>, <span class="number">655</span>, <span class="number">526</span>, <span class="number">423</span>,</span><br><span class="line">  <span class="comment">/* 5 */</span> <span class="number">335</span>, <span class="number">272</span>, <span class="number">215</span>, <span class="number">172</span>, <span class="number">137</span>,</span><br><span class="line">  <span class="comment">/* 10 */</span> <span class="number">110</span>, <span class="number">87</span>, <span class="number">70</span>, <span class="number">56</span>, <span class="number">45</span>,</span><br><span class="line">  <span class="comment">/* 15 */</span> <span class="number">36</span>, <span class="number">29</span>, <span class="number">23</span>, <span class="number">18</span>, <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 进程调度延迟</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sysctl_sched_min_granularity = <span class="number">750000ULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> normalized_sysctl_sched_min_granularity = <span class="number">750000ULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> sched_nr_latency = <span class="number">8</span>;</span><br><span class="line"><span class="type">static</span> u64 __sched_period(<span class="type">unsigned</span> <span class="type">long</span> nr_running)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (unlikely(nr_running &gt; sched_nr_latency))</span><br><span class="line">  <span class="keyword">return</span> nr_running * sysctl_sched_min_granularity;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> sysctl_sched_latency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 虚拟时间</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="type">static</span> u64 __calc_delta(u64 delta_exec, <span class="type">unsigned</span> <span class="type">long</span> weight, <span class="keyword">struct</span> load_weig</span><br><span class="line">&#123;</span><br><span class="line">u64 fact = scale_load_down(weight);</span><br><span class="line"><span class="type">int</span> shift = WMULT_SHIFT;</span><br><span class="line">__update_inv_weight(lw);</span><br><span class="line"><span class="keyword">if</span> (unlikely(fact &gt;&gt; <span class="number">32</span>)) &#123;</span><br><span class="line"><span class="keyword">while</span> (fact &gt;&gt; <span class="number">32</span>) &#123;</span><br><span class="line">fact &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">shift--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了避免使用浮点计算</span></span><br><span class="line">fact = mul_u32_u32(fact, lw-&gt;inv_weight);</span><br><span class="line"><span class="keyword">while</span> (fact &gt;&gt; <span class="number">32</span>) &#123;</span><br><span class="line">fact &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">shift--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mul_u64_u32_shr(delta_exec, fact, shift);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u64 calc_delta_fair(u64 delta, <span class="keyword">struct</span> sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(se-&gt;load.weight != NICE_0_LOAD))</span><br><span class="line">delta = __calc_delta(delta, NICE_0_LOAD, &amp;se-&gt;load);</span><br><span class="line"><span class="keyword">return</span> delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>CFS调度进程</strong>
<ul>
<li>CFS 调度器就是要维持各个可运行进程的虚拟时间相等，不相等就需要被调度运行。如果一个进程比其它进程的虚拟时间小，它就应该运行达到和其它进程的虚拟时间持平，直到它的虚拟时间超过其它进程，这时就要停下来，这样其它进程才能被调度运行</li>
</ul>
</li>
<li><strong>定时周期调度</strong>
<ul>
<li>虚拟时间为一个数据,但需要更新机制,以免导致一个进程永远运行下去(虚拟时间永远最小)</li>
<li>Linux启动会启动定时器,每1/1000,1/250,1/100秒产生一个时钟中断,在中断处理函数中调用 scheduler_tick 函数
<ul>
<li>scheduler_tick 函数会调用进程调度类的 task_tick 函数，对于 CFS 调度器就是 task_tick_fair 函数</li>
<li>真正做事的是 entity_tick 函数，其调用了update_curr 函数更新当前进程虚拟时间并更新了运行队列的相关数据</li>
<li>entity_tick 函数的最后调用了 check_preempt_tick 函数,检查是否可以抢占调度
<ul>
<li>如果需要抢占就会调用 resched_curr 函数设置进程的抢占标志，但是这个函数本身不会调用进程调度器函数，而是在进程从中断或者系统调用返回到用户态空间时，检查当前进程的调度标志，然后根据需要调用进程调度器函数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>调度器入口</strong>
<ul>
<li>需要进行进程抢占调度,Linux就会在适当的时机进行进程调度(就是调用进程调度器入口函数,该函数会选择一个最合适投入运行的进程,然后切换到该进程上运行)</li>
<li>在循环中调用 _schedule 函数执行真正的进程调度，因为在执行调度的过程中有更高优先级的进程进入可运行状态需要抢占当前进程
<ul>
<li>__schedule 函数中会更新一些统计数据，然后调用 pick_next_task 函数挑选出下一个进程投入运行</li>
<li>最后，如果当前进程和下一个要运行的进程不同，就要进行进程机器上下文切换，其中会切换地址空间和 CPU 寄存器</li>
</ul>
</li>
</ul>
</li>
<li><strong>挑选下一个进程</strong>
<ul>
<li>挑选下一个进程过程是在 pick_next_task 函数(框架函数)中完成，会依照优先级调用具体调度器类的函数完成工作，对于 CFS 则会调用 pick_next_task_fair 函数
<ul>
<li>pick_next_task_fair 调用 pick_next_entity 函数选择虚拟时间最小的调度实体，然后调用set_next_entity 函数，对选择的调度实体进行一些必要的处理，主要是将这调度实体从运行队列中拿出来</li>
<li>pick_next_entity 调用了相关函数，从运行队列上的红黑树中查找虚拟时间最少的调度实体，然后处理要跳过调度的情况，最后决定挑选的调度实体是否可以抢占并返回它</li>
<li>代码的调用路径最终会返回到 __schedule 函数中，这个函数中就是上一个运行的进程和将要投入运行的下一个进程，最后调用 context_switch 函数，完成两个进程的地址空间和机器上下文的切换，一次进程调度工作结束(机制和 Cosmos 的save_to_new_context 函数类似)</li>
</ul>
</li>
<li><mark>核心就是让虚拟时间最小的进程最先运行， 一旦进程运行虚拟时间就会增加，最后尽量保证所有进程的虚拟时间相等，谁小了就要多运行，谁大了就要暂停运行</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 定时周期调度</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_curr</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> =</span> cfs_rq-&gt;curr;</span><br><span class="line">u64 now = rq_clock_task(rq_of(cfs_rq));<span class="comment">//获取当前时间</span></span><br><span class="line">u64 delta_exec;</span><br><span class="line">delta_exec = now - curr-&gt;exec_start;<span class="comment">//间隔时间</span></span><br><span class="line">curr-&gt;exec_start = now;</span><br><span class="line">curr-&gt;sum_exec_runtime += delta_exec;<span class="comment">//累计运行时间</span></span><br><span class="line">curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);<span class="comment">//计算进程的虚拟时间</span></span><br><span class="line">update_min_vruntime(cfs_rq);<span class="comment">//更新运行队列中的最小虚拟时间，这是新建进程的虚拟时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">entity_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr, <span class="type">int</span> queued)</span></span><br><span class="line">&#123;</span><br><span class="line">update_curr(cfs_rq);<span class="comment">//更新当前运行进程和运行队列相关的时间</span></span><br><span class="line"><span class="keyword">if</span> (cfs_rq-&gt;nr_running &gt; <span class="number">1</span>)<span class="comment">//当运行进程数量大于1就检查是否可抢占</span></span><br><span class="line">check_preempt_tick(cfs_rq, curr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_sched_entity(se) \</span></span><br><span class="line"><span class="meta">for (; se; se = NULL)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_tick_fair</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *curr, <span class="type">int</span> queued)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;curr-&gt;se;<span class="comment">//获取当前进程的调度实体</span></span><br><span class="line">for_each_sched_entity(se) &#123;<span class="comment">//仅对当前进程的调度实体</span></span><br><span class="line">cfs_rq = cfs_rq_of(se);<span class="comment">//获取当前进程的调度实体对应运行队列</span></span><br><span class="line">entity_tick(cfs_rq, se, queued);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">scheduler_tick</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(cpu);<span class="comment">//获取运行CPU运行进程队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> rq-&gt;curr;<span class="comment">//获取当进程</span></span><br><span class="line">update_rq_clock(rq);<span class="comment">//更新运行队列的时间等数据</span></span><br><span class="line">curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="number">0</span>);<span class="comment">//更新当前时间的虚拟时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check_preempt_tick 函数,检查是否抢占调度</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_preempt_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *cur</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> ideal_runtime, delta_exec;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sched_entity *se;</span></span><br><span class="line"><span class="params">s64 delta;</span></span><br><span class="line"><span class="params"><span class="comment">//计算当前进程在本次调度中分配的运行时间</span></span></span><br><span class="line"><span class="params">ideal_runtime = sched_slice(cfs_rq, curr);</span></span><br><span class="line"><span class="params"><span class="comment">//当前进程已经运行的实际时间</span></span></span><br><span class="line"><span class="params">delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;</span></span><br><span class="line"><span class="params"><span class="comment">//如果实际运行时间已经超过分配给进程的运行时间，就需要抢占当前进程。设置进程的TIF_NEED_</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (delta_exec &gt; ideal_runtime) &#123;</span></span><br><span class="line"><span class="params">resched_curr(rq_of(cfs_rq));</span></span><br><span class="line"><span class="params"><span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//因此如果进程运行时间小于最小调度粒度时间，不应该抢占</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (delta_exec &lt; sysctl_sched_min_granularity)</span></span><br><span class="line"><span class="params"><span class="keyword">return</span>;</span></span><br><span class="line"><span class="params"><span class="comment">//从红黑树中找到虚拟时间最小的调度实体</span></span></span><br><span class="line"><span class="params">se = __pick_first_entity(cfs_rq);</span></span><br><span class="line"><span class="params">delta = curr-&gt;vruntime - se-&gt;vruntime;</span></span><br><span class="line"><span class="params"><span class="comment">//如果当前进程的虚拟时间仍然比红黑树中最左边调度实体虚拟时间小，也不应该发生调度</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span></span><br><span class="line"><span class="params"><span class="keyword">return</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// ---------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 调度器入口</span></span></span><br><span class="line"><span class="params"><span class="comment">// ---------</span></span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="type">void</span> __sched notrace __schedule(<span class="type">bool</span> preempt)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> task_struct *prev, *next;</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> *switch_count;</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> prev_state;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> rq_flags rf;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> rq *rq;</span></span><br><span class="line"><span class="params"><span class="type">int</span> cpu;</span></span><br><span class="line"><span class="params">cpu = smp_processor_id();</span></span><br><span class="line"><span class="params">rq = cpu_rq(cpu);<span class="comment">//获取当前CPU的运行队列</span></span></span><br><span class="line"><span class="params">prev = rq-&gt;curr; <span class="comment">//获取当前进程</span></span></span><br><span class="line"><span class="params">rq_lock(rq, &amp;rf);<span class="comment">//运行队列加锁</span></span></span><br><span class="line"><span class="params">update_rq_clock(rq);<span class="comment">//更新运行队列时钟</span></span></span><br><span class="line"><span class="params">switch_count = &amp;prev-&gt;nivcsw;</span></span><br><span class="line"><span class="params">next = pick_next_task(rq, prev, &amp;rf);<span class="comment">//获取下一个投入运行的进程</span></span></span><br><span class="line"><span class="params">clear_tsk_need_resched(prev); <span class="comment">//清除抢占标志</span></span></span><br><span class="line"><span class="params">clear_preempt_need_resched();</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (likely(prev != next)) &#123;<span class="comment">//当前运行进程和下一个运行进程不同，就要进程切换</span></span></span><br><span class="line"><span class="params">rq-&gt;nr_switches++; <span class="comment">//切换计数统计</span></span></span><br><span class="line"><span class="params">++*switch_count;</span></span><br><span class="line"><span class="params">rq = context_switch(rq, prev, next, &amp;rf);<span class="comment">//进程机器上下文切换</span></span></span><br><span class="line"><span class="params">&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="params">rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span></span><br><span class="line"><span class="params">rq_unlock_irq(rq, &amp;rf);<span class="comment">//解锁运行队列</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">void</span> schedule(<span class="type">void</span>)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> task_struct *tsk = current;<span class="comment">//获取当前进程</span></span></span><br><span class="line"><span class="params"><span class="keyword">do</span> &#123;</span></span><br><span class="line"><span class="params">preempt_disable();<span class="comment">//关闭内核抢占</span></span></span><br><span class="line"><span class="params">__schedule(<span class="literal">false</span>);<span class="comment">//进程调用</span></span></span><br><span class="line"><span class="params">sched_preempt_enable_no_resched();<span class="comment">//开启内核抢占</span></span></span><br><span class="line"><span class="params">&#125; <span class="keyword">while</span> (need_resched());<span class="comment">//是否需要再次重新调用</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// -------------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 挑选下一个进程</span></span></span><br><span class="line"><span class="params"><span class="comment">// -------------</span></span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *pick_next_task(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> sched_class *class;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> task_struct *p;</span></span><br><span class="line"><span class="params"><span class="comment">//这是对CFS的一种优化处理，因为大部分进程属于CFS管理</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (likely(prev-&gt;sched_class &lt;= &amp;fair_sched_class &amp;&amp;</span></span><br><span class="line"><span class="params">rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;</span></span><br><span class="line"><span class="params">p = pick_next_task_fair(rq, prev, rf);<span class="comment">//调用CFS的对应的函数</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span></span><br><span class="line"><span class="params"><span class="keyword">goto</span> restart;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (!p) &#123;<span class="comment">//如果没有获取到运行进程</span></span></span><br><span class="line"><span class="params">put_prev_task(rq, prev);<span class="comment">//将上一个进程放回运行队列中</span></span></span><br><span class="line"><span class="params">p = pick_next_task_idle(rq);<span class="comment">//获取空转进程</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> p;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">restart:</span></span><br><span class="line"><span class="params">for_each_class(class) &#123;<span class="comment">//依次从最高优先级的调度类开始遍历</span></span></span><br><span class="line"><span class="params">p = class-&gt;pick_next_task(rq);</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (p)<span class="comment">//如果在一个调度类所管理的运行队列中挑选到一个进程，立即返回</span></span></span><br><span class="line"><span class="params"><span class="keyword">return</span> p;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">BUG();<span class="comment">//出错</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> task_struct *pick_next_task_fair(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> cfs_rq *cfs_rq = &amp;rq-&gt;cfs;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sched_entity *se;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> task_struct *p;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (prev)</span></span><br><span class="line"><span class="params">put_prev_task(rq, prev);<span class="comment">//把上一个进程放回运行队列</span></span></span><br><span class="line"><span class="params"><span class="keyword">do</span> &#123;</span></span><br><span class="line"><span class="params">se = pick_next_entity(cfs_rq, <span class="literal">NULL</span>);<span class="comment">//选择最适合运行的调度实体</span></span></span><br><span class="line"><span class="params">set_next_entity(cfs_rq, se);<span class="comment">//对选择的调度实体进行一些处理</span></span></span><br><span class="line"><span class="params">cfs_rq = group_cfs_rq(se);</span></span><br><span class="line"><span class="params">&#125; <span class="keyword">while</span> (cfs_rq);<span class="comment">//在没有调度组的情况下，循环一次就结束了</span></span></span><br><span class="line"><span class="params">p = task_of(se);<span class="comment">//通过se获取包含se的进程task_struct</span></span></span><br><span class="line"><span class="params"><span class="keyword">return</span> p;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sched_entity *__pick_first_entity(<span class="keyword">struct</span> cfs_rq *cfs_rq)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> rb_node *left = rb_first_cached(&amp;cfs_rq-&gt;tasks_timeline);<span class="comment">//先读取在ta</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (!left)</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//如果为空直接返回NULL</span></span></span><br><span class="line"><span class="params"><span class="comment">//通过红黑树结点指针取得包含它的调度实体结构地址</span></span></span><br><span class="line"><span class="params"><span class="keyword">return</span> rb_entry(left, <span class="keyword">struct</span> sched_entity, run_node);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">struct</span> sched_entity *__pick_next_entity(<span class="keyword">struct</span> sched_entity *se)</span></span><br><span class="line"><span class="params">&#123; <span class="comment">//获取当前红黑树节点的下一个结点</span></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> rb_node *next = rb_next(&amp;se-&gt;run_node);</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (!next)</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//如果为空直接返回NULL</span></span></span><br><span class="line"><span class="params"><span class="keyword">return</span> rb_entry(next, <span class="keyword">struct</span> sched_entity, run_node);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">static</span> <span class="keyword">struct</span> sched_entity *pick_next_entity(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sch</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="comment">//获取Cfs_rq中的红黑树上最左节点上调度实体，虚拟时间最小</span></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sched_entity *left = __pick_first_entity(cfs_rq);</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sched_entity *se;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (!left || (curr &amp;&amp; entity_before(curr, left)))</span></span><br><span class="line"><span class="params">left = curr;<span class="comment">//可能当前进程主动放弃CPU，它的虚拟时间比红黑树上的还小，所以left指向</span></span></span><br><span class="line"><span class="params">se = left;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (cfs_rq-&gt;skip == se) &#123; <span class="comment">//如果选择的调度实体是要跳过的调度实体</span></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sched_entity *second;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (se == curr) &#123;<span class="comment">//如果是当前调度实体</span></span></span><br><span class="line"><span class="params">second = __pick_first_entity(cfs_rq);<span class="comment">//选择运行队列中虚拟时间最小的调度实</span></span></span><br><span class="line"><span class="params">&#125; <span class="keyword">else</span> &#123;<span class="comment">//否则选择红黑树上第二左的进程节点</span></span></span><br><span class="line"><span class="params">second = __pick_next_entity(se);</span></span><br><span class="line"><span class="params"><span class="comment">//如果次优的调度实体的虚拟时间，还是比当前的调度实体的虚拟时间大</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (!second || (curr &amp;&amp; entity_before(curr, second)))</span></span><br><span class="line"><span class="params">second = curr;<span class="comment">//让次优的调度实体也指向当前调度实体</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//判断left和second的虚拟时间的差距是否小于sysctl_sched_wakeup_granularity</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (second &amp;&amp; wakeup_preempt_entity(second, left) &lt; <span class="number">1</span>)</span></span><br><span class="line"><span class="params">se = second;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (cfs_rq-&gt;next &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;next, left) &lt; <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="params">se = cfs_rq-&gt;next;</span></span><br><span class="line"><span class="params">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cfs_rq-&gt;last &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;last, left) &lt; <span class="number">1</span>)</span></span><br><span class="line"><span class="params">se = cfs_rq-&gt;last;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">clear_buddies(cfs_rq, se);<span class="comment">//需要清除掉last、next、skip指针</span></span></span><br><span class="line"><span class="params"><span class="keyword">return</span> se;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-15-30-57.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-15-30-57.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Linux进程与进程调度" /></p>
<hr />
<h1 id="8-设备io"><a class="markdownIt-Anchor" href="#8-设备io"></a> 8 设备IO</h1>
</div><div class="story post-story"><h2 id="81-如何表示设备类型与设备驱动"><a class="markdownIt-Anchor" href="#81-如何表示设备类型与设备驱动"></a> 8.1 如何表示设备类型与设备驱动</h2>
<ul>
<li><strong>计算机的结构</strong>
<ul>
<li>各种硬件以总线为基础连接在一起，各自完成工作，互相配合实现用户要求的功能</li>
<li>总线有层级关系,各种设备通过总线连接</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-15-49-26.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-15-49-26.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="计算机结构示意图" /></p>
<ul>
<li><strong>分权而治</strong>
<ul>
<li>操作系统要控制各个设备,就是要包含每个设备的控制代码,但如果操作系统内核被设计为通用可移植的内核,内核代码庞大,危险性高；且操作系统内核开发人员并不能写一套为所有设备写一套控制代码;设备厂商不愿意公开设备代码细节;更新设备需要重写控制代码,重新编译</li>
<li>操作系统内核不包含或仅包含基本的通用的设备控制代码,控制设备时加载相应设备的独立的设备控制代码(<strong>灵活性提高</strong>)</li>
</ul>
</li>
<li><strong>设备分类</strong>
<ul>
<li>操作系统内核定义的设备可称为内核设备或逻辑设备(对物理计算平台中几种类型设备的抽象)</li>
<li>在 cosmos/include/knlinc/krldevice.h文件中对设备进行分类</li>
</ul>
</li>
<li><strong>设备驱动</strong>
<ul>
<li>操作系统内核如何表示多个设备与驱动的存在,如何组织多个设备和多个驱动程序,驱动程序提供哪些服务</li>
</ul>
</li>
<li><strong>设备</strong>
<ul>
<li>在操作系统内核建立<strong>设备数据结构</strong>的实例变量就表示操作系统内核中存在一个逻辑设备</li>
<li>设备信息中，<strong>设备ID结构十分重要</strong>，表示设备的类型,设备号，子设备号，指向设备驱动程序的指针
<ul>
<li>子设备号为了解决多个相同设备,指针用于访问设备时调用设备驱动程序</li>
</ul>
</li>
</ul>
</li>
<li><strong>驱动</strong>
<ul>
<li>需要定义数据结构表示驱动程序,数据结构中应包含驱动程序名,驱动程序ID，驱动程序所管理的设备,<strong>最重要的是完成功能设备相关功能的函数</strong></li>
<li>cosmos内核每加载一个驱动程序模块,就会自动分配一个驱动程序数据结构并将其初始化,在首次启动驱动程序时会调用驱动程序的入口点函数,分配设备数据结构,并用相关的信息将其实例化</li>
<li><strong>握手动作</strong>:cosmos内核负责建立驱动数据结构,驱动程序负责建立设备数据结构</li>
</ul>
</li>
<li><strong>设备驱动的组织</strong>:利用<strong>设备表</strong>的数据结构组织驱动程序数据结构和设备数据结构
<ul>
<li>devtable_t 是每个设备类型一个,表示一类设备,在 devtlst_t 中,具有设备技术和设备链表</li>
<li>在 cosmos 中需要定义 devtable_t 结构的全局变量</li>
<li>首先 devtable_t 结构中能找到所有的设备和驱动，然后从设备能找到对应的驱动，从驱动也能找到其管理的所有设备 ，最后就能实现一个驱动管理多个设备</li>
</ul>
</li>
<li><strong>驱动程序功能</strong>
<ul>
<li>每个驱动程序提供的操作定义成函数由驱动程序实现,<strong>函数的形式不能改变(操作系统内核与驱动程序沟通的桥梁)</strong></li>
<li>利用 driver_t 结构中的函数指针数组使驱动程序的功能函数与操作系统内核关联起来, driver_t 中 drv_dipfun 函数指针数组存放上述驱动程序函数的指针</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-16-19-58.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-16-19-58.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="设备表结构示意图" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 设备分类</span></span><br><span class="line"><span class="comment">// 在 cosmos/include/knlinc/krldevice.h文件中对设备进行分类</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOT_DEVICE 0 <span class="comment">//不表示任何设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BRIDGE_DEVICE 4 <span class="comment">//总线桥接器设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPUCORE_DEVICE 5 <span class="comment">//CPU设备，CPU也是设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAMCONTER_DEVICE 6 <span class="comment">//内存控制器设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_DEVICE 7 <span class="comment">//内存设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USBHOSTCONTER_DEVICE 8 <span class="comment">//USB主控制设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTUPTCONTER_DEVICE 9 <span class="comment">//中断控制器设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA_DEVICE 10 <span class="comment">//DMA设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCKPOWER_DEVICE 11 <span class="comment">//时钟电源设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDCONTER_DEVICE 12 <span class="comment">//LCD控制器设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NANDFLASH_DEVICE 13 <span class="comment">//nandflash设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_DEVICE 14 <span class="comment">//摄像头设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_DEVICE 15 <span class="comment">//串口设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_DEVICE 16 <span class="comment">//定时器设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USB_DEVICE 17 <span class="comment">//USB设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WATCHDOG_DEVICE 18 <span class="comment">//看门狗设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_DEVICE 22 <span class="comment">//实时时钟设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SD_DEVICE 25 <span class="comment">//SD卡设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUDIO_DEVICE 26 <span class="comment">//音频设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_DEVICE 27 <span class="comment">//触控设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETWORK_DEVICE 28 <span class="comment">//网络设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIR_DEVICE 29 <span class="comment">//虚拟设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILESYS_DEVICE 30 <span class="comment">//文件系统设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTICK_DEVICE 31 <span class="comment">//系统TICK设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNKNOWN_DEVICE 32 <span class="comment">//未知设备，也是设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HD_DEVICE 33 <span class="comment">//硬盘设备</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// 设备</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_DEVID</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint_t</span> dev_mtype;<span class="comment">//设备类型号</span></span><br><span class="line">  <span class="type">uint_t</span> dev_stype; <span class="comment">//设备子类型号</span></span><br><span class="line">  <span class="type">uint_t</span> dev_nr; <span class="comment">//设备序号</span></span><br><span class="line">&#125;<span class="type">devid_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_DEVICE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> dev_list;<span class="comment">//设备链表</span></span><br><span class="line">  <span class="type">list_h_t</span> dev_indrvlst; <span class="comment">//设备在驱动程序数据结构中对应的挂载链表</span></span><br><span class="line">  <span class="type">list_h_t</span> dev_intbllst; <span class="comment">//设备在设备表数据结构中对应的挂载链表</span></span><br><span class="line">  <span class="type">spinlock_t</span> dev_lock; <span class="comment">//设备自旋锁</span></span><br><span class="line">  <span class="type">uint_t</span> dev_count; <span class="comment">//设备计数</span></span><br><span class="line">  <span class="type">sem_t</span> dev_sem; <span class="comment">//设备信号量</span></span><br><span class="line">  <span class="type">uint_t</span> dev_stus; <span class="comment">//设备状态</span></span><br><span class="line">  <span class="type">uint_t</span> dev_flgs; <span class="comment">//设备标志</span></span><br><span class="line">  <span class="type">devid_t</span> dev_id; <span class="comment">//设备ID</span></span><br><span class="line">  <span class="type">uint_t</span> dev_intlnenr; <span class="comment">//设备中断服务例程的个数</span></span><br><span class="line">  <span class="type">list_h_t</span> dev_intserlst; <span class="comment">//设备中断服务例程的链表</span></span><br><span class="line">  <span class="type">list_h_t</span> dev_rqlist; <span class="comment">//对设备的请求服务链表</span></span><br><span class="line">  <span class="type">uint_t</span> dev_rqlnr; <span class="comment">//对设备的请求服务个数</span></span><br><span class="line">  <span class="type">sem_t</span> dev_waitints; <span class="comment">//用于等待设备的信号量</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">s_DRIVER</span>* <span class="title">dev_drv</span>;</span> <span class="comment">//设备对应的驱动程序数据结构的指针</span></span><br><span class="line">  <span class="type">void</span>* dev_attrb; <span class="comment">//设备属性指针</span></span><br><span class="line">  <span class="type">void</span>* dev_privdata; <span class="comment">//设备私有数据指针</span></span><br><span class="line">  <span class="type">void</span>* dev_userdata;<span class="comment">//将来扩展所用</span></span><br><span class="line">  <span class="type">void</span>* dev_extdata;<span class="comment">//将来扩展所用</span></span><br><span class="line">  <span class="type">char_t</span>* dev_name; <span class="comment">//设备名</span></span><br><span class="line">&#125;<span class="type">device_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// 驱动</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_DRIVER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> drv_lock; <span class="comment">//保护驱动程序数据结构的自旋锁</span></span><br><span class="line">  <span class="type">list_h_t</span> drv_list;<span class="comment">//挂载驱动程序数据结构的链表</span></span><br><span class="line">  <span class="type">uint_t</span> drv_stuts; <span class="comment">//驱动程序的相关状态</span></span><br><span class="line">  <span class="type">uint_t</span> drv_flg; <span class="comment">//驱动程序的相关标志</span></span><br><span class="line">  <span class="type">uint_t</span> drv_id; <span class="comment">//驱动程序ID</span></span><br><span class="line">  <span class="type">uint_t</span> drv_count; <span class="comment">//驱动程序的计数器</span></span><br><span class="line">  <span class="type">sem_t</span> drv_sem; <span class="comment">//驱动程序的信号量</span></span><br><span class="line">  <span class="type">void</span>* drv_safedsc; <span class="comment">//驱动程序的安全体</span></span><br><span class="line">  <span class="type">void</span>* drv_attrb; <span class="comment">//LMOSEM内核要求的驱动程序属性体</span></span><br><span class="line">  <span class="type">void</span>* drv_privdata; <span class="comment">//驱动程序私有数据的指针</span></span><br><span class="line">  <span class="type">drivcallfun_t</span> drv_dipfun[IOIF_CODE_MAX]; <span class="comment">//驱动程序功能派发函数指针数组</span></span><br><span class="line">  <span class="type">list_h_t</span> drv_alldevlist; <span class="comment">//挂载驱动程序所管理的所有设备的链表</span></span><br><span class="line">  <span class="type">drventyexit_t</span> drv_entry; <span class="comment">//驱动程序的入口函数指针</span></span><br><span class="line">  <span class="type">drventyexit_t</span> drv_exit; <span class="comment">//驱动程序的退出函数指针</span></span><br><span class="line">  <span class="type">void</span>* drv_userdata;<span class="comment">//用于将来扩展</span></span><br><span class="line">  <span class="type">void</span>* drv_extdata; <span class="comment">//用于将来扩展</span></span><br><span class="line">  <span class="type">char_t</span>* drv_name; <span class="comment">//驱动程序的名字</span></span><br><span class="line">&#125;<span class="type">driver_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// 设备驱动的组织</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_MAX 34</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_DEVTLST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint_t</span> dtl_type;<span class="comment">//设备类型</span></span><br><span class="line">  <span class="type">uint_t</span> dtl_nr;<span class="comment">//设备计数</span></span><br><span class="line">  <span class="type">list_h_t</span> dtl_list;<span class="comment">//挂载设备device_t结构的链表</span></span><br><span class="line">&#125;<span class="type">devtlst_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_DEVTABLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">list_h_t</span> devt_list; <span class="comment">//设备表自身的链表</span></span><br><span class="line">  <span class="type">spinlock_t</span> devt_lock; <span class="comment">//设备表自旋锁</span></span><br><span class="line">  <span class="type">list_h_t</span> devt_devlist; <span class="comment">//全局设备链表</span></span><br><span class="line">  <span class="type">list_h_t</span> devt_drvlist; <span class="comment">//全局驱动程序链表，驱动程序不需要分类，一个链表就行</span></span><br><span class="line">  <span class="type">uint_t</span> devt_devnr; <span class="comment">//全局设备计数</span></span><br><span class="line">  <span class="type">uint_t</span> devt_drvnr; <span class="comment">//全局驱动程序计数</span></span><br><span class="line">  <span class="type">devtlst_t</span> devt_devclsl[DEVICE_MAX]; <span class="comment">//分类存放设备数据结构的devtlst_t结构数组</span></span><br><span class="line">&#125;<span class="type">devtable_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 devtable_t 结构的全局变量</span></span><br><span class="line"><span class="comment">//在 cosmos/kernel/krlglobal.c文件中</span></span><br><span class="line">KRL_DEFGLOB_VARIABLE(<span class="type">devtable_t</span>,osdevtable);</span><br><span class="line"><span class="comment">//在 cosmos/kernel/krldevice.c文件中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">devtlst_t_init</span><span class="params">(<span class="type">devtlst_t</span> *initp, <span class="type">uint_t</span> dtype)</span></span><br><span class="line">&#123;</span><br><span class="line">  initp-&gt;dtl_type = dtype;<span class="comment">//设置设备类型 initp-&gt;dtl_nr = 0;</span></span><br><span class="line">  list_init(&amp;initp-&gt;dtl_list);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">devtable_t_init</span><span class="params">(<span class="type">devtable_t</span> *initp)</span></span><br><span class="line">&#123;</span><br><span class="line">  list_init(&amp;initp-&gt;devt_list);</span><br><span class="line">  krlspinlock_init(&amp;initp-&gt;devt_lock);</span><br><span class="line">  list_init(&amp;initp-&gt;devt_devlist);</span><br><span class="line">  list_init(&amp;initp-&gt;devt_drvlist);</span><br><span class="line">  initp-&gt;devt_devnr = <span class="number">0</span>;</span><br><span class="line">  initp-&gt;devt_drvnr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> t = <span class="number">0</span>; t &lt; DEVICE_MAX; t++)</span><br><span class="line">  &#123;<span class="comment">//初始化设备链表</span></span><br><span class="line">    devtlst_t_init(&amp;initp-&gt;devt_devclsl[t], t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krldevice</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  devtable_t_init(&amp;osdevtable);<span class="comment">//初始化系统全局设备表</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在 cosmos/kernel/krlinit.c文件中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  init_krlmm();</span><br><span class="line">  init_krldevice();</span><br><span class="line">  <span class="comment">//记住一定要在初始化调度器之前，初始化设备表</span></span><br><span class="line">  init_krlsched();</span><br><span class="line">  init_krlcpuidle();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// 驱动程序功能</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// 驱动程序的几种主要函数</span></span><br><span class="line"><span class="comment">//驱动程序入口和退出函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_entry</span><span class="params">(<span class="type">driver_t</span>* drvp,<span class="type">uint_t</span> val,<span class="type">void</span>* p)</span>;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_exit</span><span class="params">(<span class="type">driver_t</span>* drvp,<span class="type">uint_t</span> val,<span class="type">void</span>* p)</span>;</span><br><span class="line"><span class="comment">//设备中断处理函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_handle</span><span class="params">(<span class="type">uint_t</span> ift_nr,<span class="type">void</span>* devp,<span class="type">void</span>* sframe)</span>;</span><br><span class="line"><span class="comment">//打开、关闭设备函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_open</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_close</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="comment">//读、写设备数据函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_read</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_write</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="comment">//调整读写设备数据位置函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_lseek</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="comment">//控制设备函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_ioctrl</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="comment">//开启、停止设备函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_dev_start</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_dev_stop</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="comment">//设置设备电源函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_set_powerstus</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="comment">//枚举设备函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_enum_dev</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="comment">//刷新设备缓存函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_flush</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"><span class="comment">//设备关机函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">device_shutdown</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能函数与系统内核关联</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_OPEN 0 <span class="comment">//对应于open操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_CLOSE 1 <span class="comment">//对应于close操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_READ 2 <span class="comment">//对应于read操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_WRITE 3 <span class="comment">//对应于write操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_LSEEK 4 <span class="comment">//对应于lseek操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_IOCTRL 5 <span class="comment">//对应于ioctrl操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_DEV_START 6 <span class="comment">//对应于start操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_DEV_STOP 7 <span class="comment">//对应于stop操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_SET_POWERSTUS 8 <span class="comment">//对应于powerstus操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_ENUM_DEV 9 <span class="comment">//对应于enum操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_FLUSH 10 <span class="comment">//对应于flush操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_SHUTDOWN 11 <span class="comment">//对应于shutdown操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOIF_CODE_MAX 12 <span class="comment">//最大功能码</span></span></span><br><span class="line"><span class="comment">//驱动程序分派函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">drvstus_t</span> <span class="params">(*<span class="type">drivcallfun_t</span>)</span><span class="params">(<span class="type">device_t</span>*,<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="comment">//驱动程序入口、退出函数指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">drvstus_t</span> <span class="params">(*<span class="type">drventyexit_t</span>)</span><span class="params">(<span class="keyword">struct</span> s_DRIVER*,<span class="type">uint_t</span>,<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_DRIVER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="type">drivcallfun_t</span> drv_dipfun[IOIF_CODE_MAX];<span class="comment">//驱动程序分派函数指针数组。</span></span><br><span class="line"><span class="type">list_h_t</span> drv_alldevlist;<span class="comment">//驱动所管理的所有设备。</span></span><br><span class="line"><span class="type">drventyexit_t</span> drv_entry;</span><br><span class="line"><span class="type">drventyexit_t</span> drv_exit;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">&#125;driver t;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="82-如何在内核中注册设备"><a class="markdownIt-Anchor" href="#82-如何在内核中注册设备"></a> 8.2 如何在内核中注册设备</h2>
<ul>
<li><strong>设备的注册流程(以USB鼠标为例)</strong>
<ul>
<li>操作系统收到中断</li>
<li>USB总线驱动的中断处理程序会执行</li>
<li>调用操作系统内核相关服务，查找USB鼠标对应的驱动程序</li>
<li>操作系统加载驱动程序</li>
<li>驱动程序开始执行，向操作系统内核注册一个鼠标设备
<ul>
<li>对于安装在主板上的设备，操作系统会枚举设备信息，然后加载驱动程序，让驱动程序创建并注册相应的设备</li>
</ul>
</li>
<li><strong>简单实现</strong>:不支持设备热拔插功能,cosmos自动加载驱动,在驱动中向cosmos注册相应的设备,大大降低复杂性
<ul>
<li>cosmos在初始化驱动时会扫描整个驱动表,然后加载表中每个驱动,分别调用各个驱动的入口函数,最后在驱动中建立设备并向内核注册</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-17-04-24.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-17-04-24.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="自动加载驱动的整个流程" /></p>
<ul>
<li><strong>驱动程序表</strong>
<ul>
<li>把驱动程序和内核链接在一起，省略加载驱动程序的过程，因为加载驱动程序不仅仅是把驱动程序放在内存中,还要进行程序链接相关操作
<ul>
<li>将内核和驱动程序链接在一起,需要用<strong>驱动程序表</strong>让内核知道驱动程序的存在</li>
</ul>
</li>
<li>drventyexit_t类型,为函数指针类型,存放的是驱动程序的入口函数,内核需要扫描这个函数指针数组就可以调用每个驱动程序</li>
<li>init_krldriver 函数的主要工作:<strong>遍历驱动程序表中的每个驱动程序入口,将它作为参数传递给 krlrun_driverentry 函数</strong>
<ul>
<li>init_krldevice 函数需要在 init_krl 函数中调用</li>
<li><mark>一定要先初始化设备表，然后才能初始化驱动程序，否则在驱动程序中建立的设备和驱动无处安放</mark></li>
</ul>
</li>
</ul>
</li>
<li><strong>运行驱动程序</strong>:使用驱动程序表省略加载驱动程序的步骤,但驱动程序必须要运行才能工作</li>
<li><strong>调用驱动程序入口函数</strong>
<ul>
<li>使用**驱动描述符指针(drvp)**调用驱动程序入口函数
<ul>
<li>先调用 new_driver_dsc 函数建立一个 driver_t 结构实例变量</li>
<li>然后调用传递的函数指针,并将drvp作为参数传送进去</li>
<li>接着再进入驱动程序中运行</li>
<li>最后当驱动程序入口函数返回时将驱动程序加入cosmos系统中</li>
</ul>
</li>
</ul>
</li>
<li><strong>一个驱动程序入口函数的例子</strong>
<ul>
<li>一个驱动程序被操作系统调用,产生实际作用,这个驱动程序入口函数，就至少有一套标准流程要走，否则只需要返回DFCOKSTUS(宏,表成功)</li>
<li>标准流程:首先要建立一个设备描述符,接着把驱动程序的功能函数设置到 driver_t 结构中的 drv_dipfun 数组中，并将设备挂载到驱动上,然后要向内核注册设备,最后驱动程序初始化自己的物理设备,安装中断回调函数</li>
</ul>
</li>
<li><strong>设备与驱动的联系</strong>
<ul>
<li>第一个接口函数是将设备挂载到驱动上,将设备和驱动产生联系,确保驱动能找到设备,设备能找到驱动</li>
<li>代码中,遍历驱动设备链表中的所有设备,看是否有设备ID冲突,没有冲突就将设备载入驱动,并把设备中的相关字段指向管理自己的驱动,<mark>设备和驱动就联系在一起</mark></li>
</ul>
</li>
<li><strong>向内核注册设备</strong>
<ul>
<li>向内核注册设备，注册过程由内核实现并提供接口</li>
<li>在注册设备过程中,内核通过设备的类型和ID，把用来表示设备的 device_t 结构挂载到设备表中</li>
<li>krlnew_device 函数检查在设备表中有没有设备 ID 冲突，如果没有的话就加入设备类型链表和全局设备链表中，最后对其计数器变量加一
<ul>
<li>完成了这些操作之后，在操作设备时，通过设备 ID 就可以找到对应的设备了</li>
</ul>
</li>
</ul>
</li>
<li><strong>安装中断回调函数</strong>
<ul>
<li>设备很多时候必须和CPU进行通信,<strong>通过中断的形式进行</strong></li>
<li>中断回调函数是驱动程序提供的,内核必须提供相应的接口用于安装中断回调函数</li>
<li>krlnew_devhandle 函数有三个参数，分别是安装中断回调函数的设备，驱动程序提供的中断回调函数，还有一个是设备在中断控制器中断线的号码</li>
<li>krlnew_devhandle 函数中一开始就会调用内核层的中断框架接口，在 cosmos/kernel/krlintupt.c 文件中实现
<ul>
<li>krladd_irqhandle 函数的主要工作是创建了一个 intserdsc_t 结构，用来保存设备和其驱动程序提供的中断回调函数</li>
<li><mark>通过 intserdsc_t 结构也让中断处理框架和设备驱动联系起来</mark></li>
</ul>
</li>
<li>中断来了之后,，中断处理框架既能找到对应的 intserdsc_t 结构，又能从 intserdsc_t 结构中得到中断回调函数和对应的设备描述符，从而调用中断回调函数，进行具体设备的中断处理</li>
</ul>
</li>
<li><strong>驱动加入内核</strong>
<ul>
<li>当操作系统内核调用了驱动程序入口函数，驱动程序入口函数就会进行一系列操作，包括建立设备，安装中断回调函数等等，再之后就会返回到操作系统内核</li>
<li>接下来，操作系统内核会根据返回状态，决定是否将该驱动程序加入到操作系统内核中，即将 river_t 结构的实例变量挂载到设备表中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 驱动程序表</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">//cosmos/kernel/krlglobal.c</span></span><br><span class="line">KRL_DEFGLOB_VARIABLE(<span class="type">drventyexit_t</span>,osdrvetytabl)[]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krldriver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//遍历驱动程序表中的每个驱动程序入口函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> ei = <span class="number">0</span>; osdrvetytabl[ei] != <span class="literal">NULL</span>; ei++)</span><br><span class="line">  &#123; <span class="comment">//运行一个驱动程序入口</span></span><br><span class="line">    <span class="keyword">if</span> (krlrun_driverentry(osdrvetytabl[ei]) == DFCERRSTUS)</span><br><span class="line">    &#123;</span><br><span class="line">      hal_sysdie(<span class="string">&quot;init driver err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_krl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  init_krlmm();</span><br><span class="line">  init_krldevice();</span><br><span class="line">  init_krldriver();</span><br><span class="line">  <span class="comment">//……</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"><span class="comment">// 调用驱动程序入口函数</span></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">krlrun_driverentry</span><span class="params">(<span class="type">drventyexit_t</span> drventry)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">driver_t</span> *drvp = new_driver_dsc();<span class="comment">//建立driver_t实例变量</span></span><br><span class="line">  <span class="keyword">if</span> (drvp == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (drventry(drvp, <span class="number">0</span>, <span class="literal">NULL</span>) == DFCERRSTUS)<span class="comment">//运行驱动程序入口函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (krldriver_add_system(drvp) == DFCERRSTUS)<span class="comment">//把驱动程序加入系统</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="comment">// 一个驱动程序入口函数的例子(不可运行)</span></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">systick_entry</span><span class="params">(<span class="type">driver_t</span>* drvp,<span class="type">uint_t</span> val,<span class="type">void</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(drvp==<span class="literal">NULL</span>) <span class="comment">//drvp是内核传递进来的参数，不能为NULL</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">device_t</span>* devp=new_device_dsc();<span class="comment">//建立设备描述符结构的变量实例</span></span><br><span class="line"><span class="keyword">if</span>(devp==<span class="literal">NULL</span>)<span class="comment">//不能失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line">systick_set_device(devp,drvp);<span class="comment">//驱动程序的功能函数设置到driver_t结构中的drv_dip</span></span><br><span class="line"><span class="keyword">if</span>(krldev_add_driver(devp,drvp)==DFCERRSTUS)<span class="comment">//将设备挂载到驱动中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(del_device_dsc(devp)==DFCERRSTUS)<span class="comment">//注意释放资源</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(krlnew_device(devp)==DFCERRSTUS)<span class="comment">//向内核注册设备</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(del_device_dsc(devp)==DFCERRSTUS)<span class="comment">//注意释放资源</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//安装中断回调函数systick_handle</span></span><br><span class="line"><span class="keyword">if</span>(krlnew_devhandle(devp,systick_handle,<span class="number">20</span>)==DFCERRSTUS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS; <span class="comment">//注意释放资源</span></span><br><span class="line">&#125;</span><br><span class="line">init_8254();<span class="comment">//初始化物理设备</span></span><br><span class="line"><span class="keyword">if</span>(krlenable_intline(<span class="number">20</span>)==DFCERRSTUS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="comment">// 设备与驱动的联系</span></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">krldev_add_driver</span><span class="params">(<span class="type">device_t</span> *devp, <span class="type">driver_t</span> *drvp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">list_h_t</span> *lst;</span><br><span class="line">  <span class="type">device_t</span> *fdevp;</span><br><span class="line">  <span class="comment">//遍历这个驱动上所有设备</span></span><br><span class="line">  list_for_each(lst, &amp;drvp-&gt;drv_alldevlist)</span><br><span class="line">  &#123;</span><br><span class="line">    fdevp = list_entry(lst, <span class="type">device_t</span>, dev_indrvlst);</span><br><span class="line">    <span class="comment">//比较设备ID有相同的则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (krlcmp_devid(&amp;devp-&gt;dev_id, &amp;fdevp-&gt;dev_id) == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将设备挂载到驱动上</span></span><br><span class="line">  list_add(&amp;devp-&gt;dev_indrvlst, &amp;drvp-&gt;drv_alldevlist);</span><br><span class="line">  devp-&gt;dev_drv = drvp;<span class="comment">//让设备中dev_drv字段指向管理自己的驱动</span></span><br><span class="line">  <span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 向内核注册设备</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">krlnew_device</span><span class="params">(<span class="type">device_t</span> *devp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">device_t</span> *findevp;</span><br><span class="line">  <span class="type">drvstus_t</span> rets = DFCERRSTUS;</span><br><span class="line">  <span class="type">cpuflg_t</span> cpufg;</span><br><span class="line">  <span class="type">list_h_t</span> *lstp;</span><br><span class="line">  <span class="type">devtable_t</span> *dtbp = &amp;osdevtable;</span><br><span class="line">  <span class="type">uint_t</span> devmty = devp-&gt;dev_id.dev_mtype;</span><br><span class="line">  <span class="keyword">if</span> (devp-&gt;dev_drv == <span class="literal">NULL</span>)<span class="comment">//没有驱动的设备不行</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  krlspinlock_cli(&amp;dtbp-&gt;devt_lock, &amp;cpufg);<span class="comment">//加锁</span></span><br><span class="line">  <span class="comment">//遍历设备类型链表上的所有设备</span></span><br><span class="line">  list_for_each(lstp, &amp;dtbp-&gt;devt_devclsl[devmty].dtl_list)</span><br><span class="line">  &#123;</span><br><span class="line">    findevp = list_entry(lstp, <span class="type">device_t</span>, dev_intbllst);</span><br><span class="line">    <span class="comment">//不能有设备ID相同的设备，如果有则出错</span></span><br><span class="line">    <span class="keyword">if</span> (krlcmp_devid(&amp;devp-&gt;dev_id, &amp;findevp-&gt;dev_id) == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      rets = DFCERRSTUS;</span><br><span class="line">      <span class="keyword">goto</span> return_step;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//先把设备加入设备表的全局设备链表</span></span><br><span class="line">  list_add(&amp;devp-&gt;dev_intbllst, &amp;dtbp-&gt;devt_devclsl[devmty].dtl_list)</span><br><span class="line">  <span class="comment">//将设备加入对应设备类型的链表中</span></span><br><span class="line">  list_add(&amp;devp-&gt;dev_list, &amp;dtbp-&gt;devt_devlist);</span><br><span class="line">  dtbp-&gt;devt_devclsl[devmty].dtl_nr++;<span class="comment">//设备计数加一</span></span><br><span class="line">  dtbp-&gt;devt_devnr++;<span class="comment">//总的设备数加一</span></span><br><span class="line">  rets = DFCOKSTUS;</span><br><span class="line">  return_step:</span><br><span class="line">  krlspinunlock_sti(&amp;dtbp-&gt;devt_lock, &amp;cpufg);<span class="comment">//解锁</span></span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">// 安装中断回调函数</span></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">//中断回调函数类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">drvstus_t</span> <span class="params">(*<span class="type">intflthandle_t</span>)</span><span class="params">(<span class="type">uint_t</span> ift_nr,<span class="type">void</span>* device,<span class="type">void</span>* sframe)</span>;</span><br><span class="line"><span class="comment">//安装中断回调函数接口</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">krlnew_devhandle</span><span class="params">(<span class="type">device_t</span> *devp, <span class="type">intflthandle_t</span> handle, <span class="type">uint_t</span> phyil</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//调用内核层中断框架接口函数</span></span></span><br><span class="line"><span class="params">  <span class="type">intserdsc_t</span> *sdp = krladd_irqhandle(devp, handle, phyiline);</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (sdp == <span class="literal">NULL</span>)</span></span><br><span class="line"><span class="params">  &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> DFCERRSTUS;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="type">cpuflg_t</span> cpufg;</span></span><br><span class="line"><span class="params">  krlspinlock_cli(&amp;devp-&gt;dev_lock, &amp;cpufg);</span></span><br><span class="line"><span class="params">  <span class="comment">//将中断服务描述符结构挂入这个设备结构中</span></span></span><br><span class="line"><span class="params">  list_add(&amp;sdp-&gt;s_indevlst, &amp;devp-&gt;dev_intserlst);</span></span><br><span class="line"><span class="params">  devp-&gt;dev_intlnenr++;</span></span><br><span class="line"><span class="params">  krlspinunlock_sti(&amp;devp-&gt;dev_lock, &amp;cpufg);</span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> DFCOKSTUS;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 内核层的中断框架接口</span></span></span><br><span class="line"><span class="params"><span class="keyword">typedef</span> <span class="keyword">struct</span> s_INTSERDSC&#123;</span></span><br><span class="line"><span class="params"><span class="type">list_h_t</span> s_list; <span class="comment">//在中断异常描述符中的链表</span></span></span><br><span class="line"><span class="params"><span class="type">list_h_t</span> s_indevlst; <span class="comment">//在设备描述描述符中的链表</span></span></span><br><span class="line"><span class="params"><span class="type">u32_t</span> s_flg; <span class="comment">//标志</span></span></span><br><span class="line"><span class="params"><span class="type">intfltdsc_t</span>* s_intfltp; <span class="comment">//指向中断异常描述符</span></span></span><br><span class="line"><span class="params"><span class="type">void</span>* s_device; <span class="comment">//指向设备描述符</span></span></span><br><span class="line"><span class="params"><span class="type">uint_t</span> s_indx; <span class="comment">//中断回调函数运行计数</span></span></span><br><span class="line"><span class="params"><span class="type">intflthandle_t</span> s_handle; <span class="comment">//中断处理的回调函数指针</span></span></span><br><span class="line"><span class="params">&#125;<span class="type">intserdsc_t</span>;</span></span><br><span class="line"><span class="params"><span class="type">intserdsc_t</span> *krladd_irqhandle(<span class="type">void</span> *device, <span class="type">intflthandle_t</span> handle, <span class="type">uint_t</span> phyi</span></span><br><span class="line"><span class="params">&#123; <span class="comment">//根据设备中断线返回对应中断异常描述符</span></span></span><br><span class="line"><span class="params"><span class="type">intfltdsc_t</span> *intp = hal_retn_intfltdsc(phyiline);</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (intp == <span class="literal">NULL</span>)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="type">intserdsc_t</span> *serdscp = (<span class="type">intserdsc_t</span> *)krlnew(<span class="keyword">sizeof</span>(<span class="type">intserdsc_t</span>));<span class="comment">//建立一个</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (serdscp == <span class="literal">NULL</span>)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">//初始化intserdsc_t结构体实例变量，并把设备指针和回调函数放入其中</span></span></span><br><span class="line"><span class="params">intserdsc_t_init(serdscp, <span class="number">0</span>, intp, device, handle);</span></span><br><span class="line"><span class="params"><span class="comment">//把intserdsc_t结构体实例变量挂载到中断异常描述符结构中</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (hal_add_ihandle(intp, serdscp) == FALSE)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (krldelete((<span class="type">adr_t</span>)serdscp, <span class="keyword">sizeof</span>(<span class="type">intserdsc_t</span>)) == FALSE)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">hal_sysdie(<span class="string">&quot;krladd_irqhandle ERR&quot;</span>);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> serdscp;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// ----------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 驱动加入内核</span></span></span><br><span class="line"><span class="params"><span class="comment">// ----------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 实现挂载功能的函数</span></span></span><br><span class="line"><span class="params"><span class="type">drvstus_t</span> krldriver_add_system(<span class="type">driver_t</span> *drvp)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="type">cpuflg_t</span> cpufg;</span></span><br><span class="line"><span class="params">  <span class="type">devtable_t</span> *dtbp = &amp;osdevtable;<span class="comment">//设备表</span></span></span><br><span class="line"><span class="params">  krlspinlock_cli(&amp;dtbp-&gt;devt_lock, &amp;cpufg);<span class="comment">//加锁</span></span></span><br><span class="line"><span class="params">  list_add(&amp;drvp-&gt;drv_list, &amp;dtbp-&gt;devt_drvlist);<span class="comment">//挂载</span></span></span><br><span class="line"><span class="params">  dtbp-&gt;devt_drvnr++;<span class="comment">//增加驱动程序计数</span></span></span><br><span class="line"><span class="params">  krlspinunlock_sti(&amp;dtbp-&gt;devt_lock, &amp;cpufg);<span class="comment">//解锁</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> DFCOKSTUS;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="83-设备如何处理内核io包"><a class="markdownIt-Anchor" href="#83-设备如何处理内核io包"></a> 8.3 设备如何处理内核IO包</h2>
<ul>
<li><strong>什么是IO包</strong>
<ul>
<li>内核要求设备完成任务,无非是调用设备的驱动程序函数,把完成任务的细节用参数的形式传递给设备的驱动程序</li>
<li><strong>IO包</strong>：使用更高效的管理方法,需要把操作所需的各种参数封装在一个数据结构中，统一驱动程序功能函数的形式
<ul>
<li>**objnode_t 的数据结构(当做IO包看)**中包括各个驱动程序功能函数的所有参数,不单是完成了IO包传递参数的功能,在整个IO生命周期中,都起着重要的作用</li>
</ul>
</li>
</ul>
</li>
<li><strong>创建和删除IO包</strong>
<ul>
<li>创建IO包是在内存中建立 objnode_t 结构的实例变量并初始化它</li>
<li>在 cosmos/kernel/建立 krlobjnode.c 文件
<ul>
<li>krlnew_objnode,krldel_objnode 完成了建立,删除 objnode_t 结构,分配和释放 objnode_t 结构的内存空间</li>
<li>内存管理组件在操作系统内核中的重要性, objnode_t_init 函数会初始化 objnode_t 结构中的字段</li>
</ul>
</li>
</ul>
</li>
<li><strong>向设备发送IO包</strong>
<ul>
<li>向设备发送IO包标志着一个设备驱动程序开始运行,之后内核就实际的控制权交给驱动程序,由驱动程序代表内核操控设备</li>
<li>函数属于驱动模型函数,在 krldevice.c 文件中实现函数
<ul>
<li>krldev_io 函数，只接受一个参数，也就是 objnode_t 结构的指针。它会首先检查 objnode_t 结构中的 IO 操作码是不是合乎要求的，还要检查被操作的对象即设备是不是为空，然后调用 krldev_call_driver 函数</li>
<li>krldev_call_driver 函数会再次确认传递进来的设备和 IO 操作码，然后重点检查设备有没有驱动程序。这一切检查通过之后，就用 IO 操作码为索引调用驱动程序功能分派函数数组中的函数，并把设备和 objnode_t 结构传递进去</li>
</ul>
</li>
</ul>
</li>
<li><strong>驱动程序实例</strong>
<ul>
<li>systick 设备驱动是系统的心跳，主要功能和作用是每隔 1ms 产生一个中断</li>
<li>8254是一个古老且常用的定时器，对它进行编程设定，可以周期的产生定时器中断</li>
<li>以8254定时器为基础,实现系统的systick设备，先从systick设备驱动程序的整体框架入手，然后建立systick设备，最后一步一步实现systick设备驱动程序</li>
</ul>
</li>
<li><strong>systick设备驱动程序的整体框架</strong>
<ul>
<li>cosmos/drivers/下建立 drctick.c文件实现整体框架</li>
<li>在各个函数可以返回一个错误状态,而不做任何实际工作,但必须要有这个函数以给予适当的响应</li>
</ul>
</li>
<li><strong>systick设备驱动程序的入口</strong>:建立设备,向内核注册设备，安装中断回调函数等操作
<ul>
<li>函数最后的 krlenable_intline 函数的主要功能是开启一个中断源上的中断;而 init_8254 函数则是为了初始化8254</li>
<li>将驱动程序入口函数 systick_entry 函数放入驱动表中
<ul>
<li>之后系统启动时就会执行初始驱动初始化 init_krldriver 函数，接着这个函数就会启动运行 systick 设备驱动程序入口函数，建立 systick 设备, 不断的产生时钟中断</li>
</ul>
</li>
</ul>
</li>
<li><strong>配置设备和驱动</strong>
<ul>
<li>在驱动程序入口函数中，除了那些标准的流程之外还要对设备和驱动进行适当的配置，就是设置一些标志、状态、名称、驱动功能派发函数等等。有了这些信息，设备才能加入到驱动程序中，然后注册到内核，才能被内核所识别</li>
<li>实现设置驱动程序的函数,主要设置设备驱动程序的名称,功能派发函数</li>
<li>systick_set_driver 函数，无非就是将12个驱动功能函数的地址，分别设置到 driver_t 结构的 drv_dipfun 数组中。其中，驱动功能函数在该数组中的元素位置，正好与 IO 操作码一一对应，当内核用 IO 操作码调用驱动时，就是调用了这个数据中的函数。最后将驱动程序的名称设置为systick0drv</li>
<li>新建的设备需要配置相关的信息才能工作,设备类型非常重要,内核通过类型类区分各种设备
<ul>
<li>systick_set_device 函数需要两个参数，但是第二个参数暂时没起作用，而第一个参数其实是一个 device_t 结构的指针，在 systick_entry 函数中调用 new_device_dsc 函数的时候，就会返回这个指针。后面我们会把设备加载到内核中，那时这个指针指向的设备才会被注册</li>
</ul>
</li>
</ul>
</li>
<li><strong>打开与关闭设备</strong>
<ul>
<li>实现打开与关闭设备功能:只是简单地增加与减少设备的引用计数，然后返回成功完成的状态。而增加与减少设备的引用计数，是为了统计有多少个进程打开了这个设备，当设备引用计数为 0 时，就说明没有进程使用该设备.</li>
</ul>
</li>
<li><strong>systick设备中断回调函数</strong>
<ul>
<li>systick 设备产生的中断，以及在中断回调函数中执行的操作，即周期性的执行系统中的某些动作</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// IO包数据结构</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_OBJNODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> on_lock; <span class="comment">//自旋锁</span></span><br><span class="line">  <span class="type">list_h_t</span> on_list; <span class="comment">//链表</span></span><br><span class="line">  <span class="type">sem_t</span> on_complesem; <span class="comment">//完成信号量</span></span><br><span class="line">  <span class="type">uint_t</span> on_flgs; <span class="comment">//标志</span></span><br><span class="line">  <span class="type">uint_t</span> on_stus; <span class="comment">//状态</span></span><br><span class="line">  <span class="type">sint_t</span> on_opercode; <span class="comment">//操作码</span></span><br><span class="line">  <span class="type">uint_t</span> on_objtype; <span class="comment">//对象类型</span></span><br><span class="line">  <span class="type">void</span>* on_objadr; <span class="comment">//对象地址</span></span><br><span class="line">  <span class="type">uint_t</span> on_acsflgs; <span class="comment">//访问设备、文件标志</span></span><br><span class="line">  <span class="type">uint_t</span> on_acsstus; <span class="comment">//访问设备、文件状态</span></span><br><span class="line">  <span class="type">uint_t</span> on_currops; <span class="comment">//对应于读写数据的当前位置</span></span><br><span class="line">  <span class="type">uint_t</span> on_len; <span class="comment">//对应于读写数据的长度</span></span><br><span class="line">  <span class="type">uint_t</span> on_ioctrd; <span class="comment">//IO控制码</span></span><br><span class="line">  <span class="type">buf_t</span> on_buf; <span class="comment">//对应于读写数据的缓冲区</span></span><br><span class="line">  <span class="type">uint_t</span> on_bufcurops; <span class="comment">//对应于读写数据的缓冲区的当前位置</span></span><br><span class="line">  <span class="type">size_t</span> on_bufsz; <span class="comment">//对应于读写数据的缓冲区的大小</span></span><br><span class="line">  <span class="type">uint_t</span> on_count; <span class="comment">//对应于对象节点的计数</span></span><br><span class="line">  <span class="type">void</span>* on_safedsc; <span class="comment">//对应于对象节点的安全描述符</span></span><br><span class="line">  <span class="type">void</span>* on_fname; <span class="comment">//对应于访问数据文件的名称</span></span><br><span class="line">  <span class="type">void</span>* on_finode; <span class="comment">//对应于访问数据文件的结点</span></span><br><span class="line">  <span class="type">void</span>* on_extp; <span class="comment">//用于扩展</span></span><br><span class="line">&#125;<span class="type">objnode_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// 创建和删除IO包</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">//建立objnode_t结构</span></span><br><span class="line"><span class="type">objnode_t</span> *<span class="title function_">krlnew_objnode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">objnode_t</span> *ondp = (<span class="type">objnode_t</span> *)krlnew((<span class="type">size_t</span>)<span class="keyword">sizeof</span>(<span class="type">objnode_t</span>));<span class="comment">//分配objn</span></span><br><span class="line">  <span class="keyword">if</span> (ondp == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  objnode_t_init(ondp);<span class="comment">//初始化objnode_t结构</span></span><br><span class="line">  <span class="keyword">return</span> ondp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除objnode_t结构</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">krldel_objnode</span><span class="params">(<span class="type">objnode_t</span> *onodep)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (krldelete((<span class="type">adr_t</span>)onodep, (<span class="type">size_t</span>)<span class="keyword">sizeof</span>(<span class="type">objnode_t</span>)) == FALSE)<span class="comment">//删除objn</span></span><br><span class="line">  &#123;</span><br><span class="line">    hal_sysdie(<span class="string">&quot;krldel_objnode err&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// 向设备发送IO包</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">//发送设备IO</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">krldev_io</span><span class="params">(<span class="type">objnode_t</span> *nodep)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取设备对象</span></span><br><span class="line">  <span class="type">device_t</span> *devp = (<span class="type">device_t</span> *)(nodep-&gt;on_objadr);</span><br><span class="line">  <span class="keyword">if</span> ((nodep-&gt;on_objtype != OBJN_TY_DEV &amp;&amp; nodep-&gt;on_objtype != OBJN_TY_FIL)</span><br><span class="line">  &#123;<span class="comment">//检查操作对象类型是不是文件或者设备，对象地址是不是为空</span></span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nodep-&gt;on_opercode &lt; <span class="number">0</span> || nodep-&gt;on_opercode &gt;= IOIF_CODE_MAX)</span><br><span class="line">  &#123;<span class="comment">//检查IO操作码是不是合乎要求</span></span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> krldev_call_driver(devp, nodep-&gt;on_opercode, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, nodep);<span class="comment">//调</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用设备驱动</span></span><br><span class="line"><span class="type">drvstus_t</span> krldev_call_driver(<span class="type">device_t</span> *devp, <span class="type">uint_t</span> iocode, <span class="type">uint_t</span> val1, uint_</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">driver_t</span> *drvp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (devp == <span class="literal">NULL</span> || iocode &gt;= IOIF_CODE_MAX)</span><br><span class="line">  &#123;<span class="comment">//检查设备和IO操作码</span></span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  drvp = devp-&gt;dev_drv;</span><br><span class="line">  <span class="keyword">if</span> (drvp == <span class="literal">NULL</span>)<span class="comment">//检查设备是否有驱动程序</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用IO操作码为索引调用驱动程序功能分派函数数组中的函数</span></span><br><span class="line">  <span class="keyword">return</span> drvp-&gt;drv_dipfun[iocode](devp, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------</span></span><br><span class="line"><span class="comment">// systick设备驱动程序的整体框架</span></span><br><span class="line"><span class="comment">// ---------------------------</span></span><br><span class="line"><span class="comment">//驱动程序入口和退出函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_entry(<span class="type">driver_t</span> *drvp, <span class="type">uint_t</span> val, <span class="type">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">drvstus_t</span> systick_exit(<span class="type">driver_t</span> *drvp, <span class="type">uint_t</span> val, <span class="type">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设备中断处理函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_handle(<span class="type">uint_t</span> ift_nr, <span class="type">void</span> *devp, <span class="type">void</span> *sframe)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCEERSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开、关闭设备函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_open(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">drvstus_t</span> systick_close(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读、写设备数据函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_read(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">drvstus_t</span> systick_write(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调整读写设备数据位置函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_lseek(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制设备函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_ioctrl(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开启、停止设备函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_dev_start(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">drvstus_t</span> systick_dev_stop(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置设备电源函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_set_powerstus(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//枚举设备函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_enum_dev(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//刷新设备缓存函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_flush(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设备关机函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_shutdown(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="comment">// systick设备驱动程序的入口</span></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_entry(<span class="type">driver_t</span>* drvp,<span class="type">uint_t</span> val,<span class="type">void</span>* p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(drvp==<span class="literal">NULL</span>) <span class="comment">//drvp是内核传递进来的参数，不能为NULL</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">device_t</span>* devp=new_device_dsc();<span class="comment">//建立设备描述符结构的变量实例</span></span><br><span class="line">  <span class="keyword">if</span>(devp==<span class="literal">NULL</span>)<span class="comment">//不能失败</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  systick_set_driver(drvp);</span><br><span class="line">  systick_set_device(devp,drvp);<span class="comment">//驱动程序的功能函数设置到driver_t结构中的 drv_dipfun</span></span><br><span class="line">  <span class="keyword">if</span>(krldev_add_driver(devp,drvp)==DFCERRSTUS)<span class="comment">//将设备挂载到驱动中</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(del_device_dsc(devp)==DFCERRSTUS)<span class="comment">//注意释放资源。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(krlnew_device(devp)==DFCERRSTUS)<span class="comment">//向内核注册设备</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(del_device_dsc(devp)==DFCERRSTUS)<span class="comment">//注意释放资源</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//安装中断回调函数systick_handle</span></span><br><span class="line">  <span class="keyword">if</span>(krlnew_devhandle(devp,systick_handle,<span class="number">20</span>)==DFCERRSTUS)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS; <span class="comment">//注意释放资源。</span></span><br><span class="line">  &#125;</span><br><span class="line">  init_8254();<span class="comment">//初始化物理设备</span></span><br><span class="line">  <span class="keyword">if</span>(krlenable_intline(<span class="number">0x20</span>)==DFCERRSTUS)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 systick_entry 函数放在驱动表里</span></span><br><span class="line"><span class="comment">//cosmos/kernel/krlglobal.c</span></span><br><span class="line">KRL_DEFGLOB_VARIABLE(<span class="type">drventyexit_t</span>,osdrvetytabl)[]=&#123;systick_entry,<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// 配置设备和驱动</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="type">void</span> systick_set_driver(<span class="type">driver_t</span> *drvp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//设置驱动程序功能派发函数</span></span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_OPEN] = systick_open;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_CLOSE] = systick_close;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_READ] = systick_read;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_WRITE] = systick_write;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_LSEEK] = systick_lseek;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_IOCTRL] = systick_ioctrl;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_DEV_START] = systick_dev_start;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_DEV_STOP] = systick_dev_stop;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_SET_POWERSTUS] = systick_set_powerstus;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_ENUM_DEV] = systick_enum_dev;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_FLUSH] = systick_flush;</span><br><span class="line">  drvp-&gt;drv_dipfun[IOIF_CODE_SHUTDOWN] = systick_shutdown;</span><br><span class="line">  drvp-&gt;drv_name = <span class="string">&quot;systick0drv&quot;</span>;<span class="comment">//设置驱动程序名称</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 打开与关闭设备</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">//打开设备</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_open(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line">  krldev_inc_devcount(devp);<span class="comment">//增加设备计数</span></span><br><span class="line">  <span class="keyword">return</span> DFCOKSTUS;<span class="comment">//返回成功完成的状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭设备</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_close(<span class="type">device_t</span> *devp, <span class="type">void</span> *iopack)</span><br><span class="line">&#123;</span><br><span class="line">  krldev_dec_devcount(devp);<span class="comment">//减少设备计数</span></span><br><span class="line">  <span class="keyword">return</span> DFCOKSTUS;<span class="comment">//返回成功完成的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------</span></span><br><span class="line"><span class="comment">// systick 设备中断回调函数</span></span><br><span class="line"><span class="comment">// ----------------------</span></span><br><span class="line"><span class="comment">// 中断函数</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_handle(<span class="type">uint_t</span> ift_nr, <span class="type">void</span> *devp, <span class="type">void</span> *sframe)</span><br><span class="line">&#123;</span><br><span class="line">  kprint(<span class="string">&quot;systick_handle run devname:%s intptnr:%d\n&quot;</span>, ((<span class="type">device_t</span> *)devp)-&gt;d</span><br><span class="line">  <span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改内核初始化函数</span></span><br><span class="line"><span class="type">void</span> init_krl()</span><br><span class="line">&#123;</span><br><span class="line">  init_krlmm();</span><br><span class="line">  init_krldevice();<span class="comment">//初始化设备</span></span><br><span class="line">  init_krldriver();<span class="comment">//初始化驱动程序</span></span><br><span class="line">  init_krlsched();</span><br><span class="line">  <span class="comment">//init_krlcpuidle();禁止进程运行</span></span><br><span class="line">  STI();<span class="comment">//打开CPU响应中断的能力</span></span><br><span class="line">  die(<span class="number">0</span>);<span class="comment">//进入死循环</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个进程中都要主动调用进程调度器函数，否则进程就会永远霸占 CPU，永远运行下去</span></span><br><span class="line"><span class="comment">// 需要使用定时器周期性的检查进程运行多少时间,若进程运行时间超过了,就应该强制调度,让别的进程开始运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新进程运行时间的代码,在中断回调函数中调用即可</span></span><br><span class="line"><span class="type">drvstus_t</span> systick_handle(<span class="type">uint_t</span> ift_nr, <span class="type">void</span> *devp, <span class="type">void</span> *sframe)</span><br><span class="line">&#123;</span><br><span class="line">  krlthd_inc_tick(krlsched_retn_currthread());<span class="comment">//更新当前进程的tick</span></span><br><span class="line">  <span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// krlthd_inc_tick 函数需要一个进程指针的参数，而 krlsched_retn_currthread 函数是返回当前正在运行进程的指针。在 krlthd_inc_tick 函数中对进程的 tick 值加 1，如果大于 20（也就是 20 毫秒）就重新置 0，并进行调度</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="84-瞧一瞧linux如何获取所有设备信息"><a class="markdownIt-Anchor" href="#84-瞧一瞧linux如何获取所有设备信息"></a> 8.4 瞧一瞧Linux:如何获取所有设备信息</h2>
<ul>
<li><strong>感受Linux的设备信息</strong>
<ul>
<li>linux设备文件在sys/bus目录下</li>
<li>linux用bus总线组织设备和驱动,在sys/bus目录下输入tree命令就可以看到所有总线下的所有设备
<ul>
<li>总线目录下有设备目录,设备目录下是设备文件</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据结构</strong>
<ul>
<li>Linux的驱动模型至少有三个核心数据结构,分别是总线,设备和驱动，还需要 kobject 和 kset</li>
</ul>
</li>
<li><strong>kobject 与 kset</strong>
<ul>
<li>kobject 和 kset 是构成 /sys 目录下的目录节点和文件节点的核心,也是层次化组织总线,设备,驱动的核心数据结构, kobject，kset数据结构都能表示一个目录或文件节点
<ul>
<li>每一个 kobject，都对应着 /sys 目录下的一个目录或者文件，目录或者文件的名字就是 kobject 结构中的 name</li>
<li>kset 结构中包含一个 kobject 结构,既是 kobject 的容器,同时本身还是一个 kobject
<ul>
<li>kset不仅是个kobject，还能挂载多个kobject，是kobject的集合容器</li>
<li>在Linux内核中,至少有两个顶层kset</li>
</ul>
</li>
</ul>
</li>
<li>kset与kobject只是基础数据结构,肯定是嵌入到更高级的数据结构之中使用</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-21-00-54.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-21-00-54.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="kset与kobject" /></p>
<ul>
<li><strong>文件操作函数</strong>
<ul>
<li>在Linux系统中,提供更高级的封装,Linux设备将设备分为几类:字符设备,块设备,网络设备以及杂项设备</li>
<li>设备的数据结构都会直接或间接包含基础的 device 结构</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-21-20-23.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-23-21-20-23.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="设备类型一览表" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="comment">// kobject 与 kset</span></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">//名称，反映在sysfs中</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">//挂入kset结构的链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">parent</span>;</span> <span class="comment">//指向父结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">kset</span>;</span> <span class="comment">//指向所属的kset</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> *<span class="title">ktype</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span> *<span class="title">sd</span>;</span> <span class="comment">//指向sysfs文件系统目录项</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span> <span class="comment">//引用计数器结构</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> state_initialized:<span class="number">1</span>;<span class="comment">//初始化状态</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> state_in_sysfs:<span class="number">1</span>; <span class="comment">//是否在sysfs中</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">//挂载kobject结构的链表</span></span><br><span class="line">  <span class="type">spinlock_t</span> list_lock; <span class="comment">//自旋锁</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span><span class="comment">//自身包含一个kobject结构</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span><span class="comment">//暂时不关注</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span><span class="comment">//管理所有设备</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">bus_kset</span>;</span><span class="comment">//管理所有总线</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">system_kset</span>;</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">devices_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, &amp;device_uevent_ops, <span class="literal">NULL</span>);<span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __init <span class="title function_">buses_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">bus_kset = kset_create_and_add(<span class="string">&quot;bus&quot;</span>, &amp;bus_uevent_ops, <span class="literal">NULL</span>);<span class="comment">//建立总线kset</span></span><br><span class="line"><span class="keyword">if</span> (!bus_kset)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">system_kset = kset_create_and_add(<span class="string">&quot;system&quot;</span>, <span class="literal">NULL</span>, &amp;devices_kset-&gt;kobj);<span class="comment">//在</span></span><br><span class="line"><span class="keyword">if</span> (!system_kset)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>总线</strong>
<ul>
<li>总线可以表示CPU与设备的连接,抽象为bus_type结构</li>
<li>bus_type结构包括总线名字,总线属性,还有操作该总线下所有设备通用操作函数的指针</li>
<li>总线不仅仅是组织设备和驱动的容器,还是同类设备的共有功能的抽象
<ul>
<li>subsys_private 是总线的驱动核心的私有数据</li>
<li>通过 bus_kset 可以找到所有的 kset，通过 kset 又能找到 subsys_private，再通过 subsys_private 就可以找到总线了，也可以找到该总线上所有的设备与驱动</li>
</ul>
</li>
</ul>
</li>
<li><strong>设备</strong>
<ul>
<li>Linux抽象出总线结构,但是还需要一个设备,设备也是一个数据结构,里面包含一个设备的所有信息</li>
<li>device 结构很大，结构中同样包含了 kobject 结构，使得设备可以加入 kset 和 kobject 组建的层次结构中</li>
<li>device 结构中有总线和驱动指针，能帮助设备找到自己的驱动程序和总线</li>
</ul>
</li>
<li><strong>驱动</strong>
<ul>
<li>驱动需要数据结构,其中包含了驱动程序的相关信息,在device结构中就是device_driver结构</li>
<li>在 device_driver 结构中，包含了驱动程序的名字、驱动程序所在模块、设备探查和电源相关的回调函数的指针</li>
<li>在 driver_private 结构中同样包含了 kobject 结构，用于组织所有的驱动，还指向了驱动本身</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// 总线</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//总线名称</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *dev_name;<span class="comment">//用于列举设备，如（&quot;foo%u&quot;, dev-&gt;id）</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev_root</span>;</span><span class="comment">//父设备</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span><span class="comment">//总线的默认属性</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span><span class="comment">//总线上设备的默认属性</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span><span class="comment">//总线上驱动的默认属性</span></span><br><span class="line">  <span class="comment">//每当有新的设备或驱动程序被添加到这个总线上时调用</span></span><br><span class="line">  <span class="type">int</span> (*match)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv);</span><br><span class="line">  <span class="comment">//当一个设备被添加、移除或其他一些事情时被调用产生uevent来添加环境变量。</span></span><br><span class="line">  <span class="type">int</span> (*uevent)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> kobj_uevent_env *env);</span><br><span class="line">  <span class="comment">//当一个新的设备或驱动程序添加到这个总线时被调用，并回调特定驱动程序探查函数，以初始化匹配</span></span><br><span class="line">  <span class="type">int</span> (*probe)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//将设备状态同步到软件状态时调用</span></span><br><span class="line">  <span class="type">void</span> (*sync_state)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//当一个设备从这个总线上删除时被调用</span></span><br><span class="line">  <span class="type">int</span> (*remove)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//当系统关闭时被调用</span></span><br><span class="line">  <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//调用以使设备重新上线（在下线后）</span></span><br><span class="line">  <span class="type">int</span> (*online)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//调用以使设备离线，以便热移除。可能会失败。</span></span><br><span class="line">  <span class="type">int</span> (*offline)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//当这个总线上的设备想进入睡眠模式时调用</span></span><br><span class="line">  <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state);</span><br><span class="line">  <span class="comment">//调用以使该总线上的一个设备脱离睡眠模式</span></span><br><span class="line">  <span class="type">int</span> (*resume)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//调用以找出该总线上的一个设备支持多少个虚拟设备功能</span></span><br><span class="line">  <span class="type">int</span> (*num_vf)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//调用以在该总线上的设备配置DMA</span></span><br><span class="line">  <span class="type">int</span> (*dma_configure)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//该总线的电源管理操作，回调特定的设备驱动的pm-ops</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">  <span class="comment">//此总线的IOMMU具体操作，用于将IOMMU驱动程序实现到总线上</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line">  <span class="comment">//驱动核心的私有数据，只有驱动核心能够接触这个</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line">  <span class="comment">//当探测或移除该总线上的一个设备时，设备驱动核心应该锁定该设备</span></span><br><span class="line">  <span class="type">bool</span> need_parent_lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过kobject找到对应的subsys_private</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_subsys_private(obj) container_of(obj, struct subsys_private, subsys</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">subsys</span>;</span><span class="comment">//定义这个子系统结构的kset</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">devices_kset</span>;</span><span class="comment">//该总线的&quot;设备&quot;目录，包含所有的设备</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">interfaces</span>;</span><span class="comment">//总线相关接口的列表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span><span class="comment">//保护设备，和接口列表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">drivers_kset</span>;</span><span class="comment">//该总线的&quot;驱动&quot;目录，包含所有的驱动</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span><span class="comment">//挂载总线上所有设备的可迭代链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_drivers</span>;</span><span class="comment">//挂载总线上所有驱动的可迭代链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">bus_notifier</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> drivers_autoprobe:<span class="number">1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> <span class="comment">//指向所属总线</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kset</span> <span class="title">glue_dirs</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">//指向这个结构所关联类结构的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// 设备</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span><span class="comment">//指向父设备</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_private</span> *<span class="title">p</span>;</span><span class="comment">//设备的私有数据</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *init_name; <span class="comment">//设备初始化名字</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span><span class="comment">//设备类型</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span> <span class="comment">//指向设备所属总线</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span><span class="comment">//指向设备的驱动</span></span><br><span class="line">  <span class="type">void</span> *platform_data;<span class="comment">//设备平台数据</span></span><br><span class="line">  <span class="type">void</span> *driver_data;<span class="comment">//设备驱动的私有数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dev_links_info</span> <span class="title">links</span>;</span><span class="comment">//设备供应商链接</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span> <span class="title">power</span>;</span><span class="comment">//用于设备的电源管理</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_domain</span> *<span class="title">pm_domain</span>;</span><span class="comment">//提供在系统暂停时执行调用</span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">msi_list</span>;</span><span class="comment">//主机的MSI描述符链表</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span> <span class="comment">//用访问设备树节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span> <span class="comment">//设备固件节点</span></span><br><span class="line">  <span class="type">dev_t</span> devt; <span class="comment">//用于创建sysfs &quot;dev&quot;</span></span><br><span class="line">  u32 id; <span class="comment">//设备实例id</span></span><br><span class="line">  <span class="type">spinlock_t</span> devres_lock;<span class="comment">//设备资源链表锁</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">devres_head</span>;</span><span class="comment">//设备资源链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">//设备的类</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span> <span class="comment">//可选的属性组</span></span><br><span class="line">  <span class="type">void</span> (*release)(<span class="keyword">struct</span> device *dev);<span class="comment">//在所有引用结束后释放设备</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iommu_group</span> *<span class="title">iommu_group</span>;</span><span class="comment">//该设备属于的IOMMU组</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dev_iommu</span> *<span class="title">iommu</span>;</span><span class="comment">//每个设备的通用IOMMU运行时数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// 驱动</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//驱动名称</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span><span class="comment">//指向总线</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">//模块持有者</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *mod_name;<span class="comment">//用于内置模块</span></span><br><span class="line">  <span class="type">bool</span> suppress_bind_attrs;<span class="comment">//禁用通过sysfs的绑定/解绑</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span> <span class="title">probe_type</span>;</span><span class="comment">//要使用的探查类型（同步或异步）</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_match_table</span>;</span><span class="comment">//开放固件表</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span> *<span class="title">acpi_match_table</span>;</span><span class="comment">//ACPI匹配表</span></span><br><span class="line">  <span class="comment">//被调用来查询一个特定设备的存在</span></span><br><span class="line">  <span class="type">int</span> (*probe) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//将设备状态同步到软件状态时调用</span></span><br><span class="line">  <span class="type">void</span> (*sync_state)(<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//当设备被从系统中移除时被调用，以便解除设备与该驱动的绑定</span></span><br><span class="line">  <span class="type">int</span> (*remove) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//关机时调用，使设备停止</span></span><br><span class="line">  <span class="type">void</span> (*shutdown) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//调用以使设备进入睡眠模式，通常是进入一个低功率状态</span></span><br><span class="line">  <span class="type">int</span> (*suspend) (<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state);</span><br><span class="line">  <span class="comment">//调用以使设备从睡眠模式中恢复</span></span><br><span class="line">  <span class="type">int</span> (*resume) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//默认属性</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">  <span class="comment">//绑定设备的属性</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">  <span class="comment">//设备电源操作</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">  <span class="comment">//当sysfs目录被写入时被调用</span></span><br><span class="line">  <span class="type">void</span> (*coredump) (<span class="keyword">struct</span> device *dev);</span><br><span class="line">  <span class="comment">//驱动程序私有数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">klist</span> <span class="title">klist_devices</span>;</span><span class="comment">//驱动管理的所有设备的链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">klist_node</span> <span class="title">knode_bus</span>;</span><span class="comment">//加入bus链表的节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module_kobject</span> *<span class="title">mkobj</span>;</span><span class="comment">//指向用kobject管理模块节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span><span class="comment">//指向驱动本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 文件操作函数</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 用miscdevice结构表示杂项设备，this_device指针指向下层，属于这个杂项设备的device结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> minor;<span class="comment">//设备号</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//设备名称</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span><span class="comment">//文件操作函数结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">//链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span><span class="comment">//指向父设备的device结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span><span class="comment">//指向本设备的device结构</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *nodename;<span class="comment">//节点名字</span></span><br><span class="line">  <span class="type">umode_t</span> mode;<span class="comment">//访问权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点是 file_operations 结构，设备一经注册，就会在 sys 相关的目录下建立设备对应的文件结点，对这个文件结点打开、读写等操作，最终会调用到驱动程序对应的函数，而对应的函数指针就保存在 file_operations 结构中</span></span><br><span class="line"><span class="comment">// file_operations 结构中的函数指针有 31 个</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">//所在的模块</span></span><br><span class="line">  <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);<span class="comment">//调整读写偏移</span></span><br><span class="line">  <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);<span class="comment">//读</span></span><br><span class="line">  <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);<span class="comment">//</span></span><br><span class="line">  <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);<span class="comment">//映射</span></span><br><span class="line">  <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);<span class="comment">//打开</span></span><br><span class="line">  <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);<span class="comment">//刷新</span></span><br><span class="line">  <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);<span class="comment">//关闭</span></span><br><span class="line">&#125; randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux 的打开系统调用接口会调用 filp_open 函数,其调用路径</span></span><br><span class="line"><span class="comment">// filp_open</span></span><br><span class="line"><span class="comment">// file_open_name</span></span><br><span class="line"><span class="comment">// do_filp_open</span></span><br><span class="line"><span class="comment">// path_openat</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_o_path</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">unsigned</span> flags, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">  <span class="type">int</span> error = path_lookupat(nd, flags, &amp;path);<span class="comment">//解析文件路径得到文件inode节点</span></span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    audit_inode(nd-&gt;name, path.dentry, <span class="number">0</span>);</span><br><span class="line">    error = vfs_open(&amp;path, file);<span class="comment">//vfs层打开文件接口</span></span><br><span class="line">    path_put(&amp;path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_open</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">  file-&gt;f_path = *path;</span><br><span class="line">  <span class="keyword">return</span> do_dentry_open(file, d_backing_inode(path-&gt;dentry), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_dentry_open</span><span class="params">(<span class="keyword">struct</span> file *f, <span class="keyword">struct</span> inode *inode,<span class="type">int</span> (*open)(stru</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">  <span class="comment">//略过我们不想看的代码</span></span></span><br><span class="line"><span class="params">  f-&gt;f_op = fops_get(inode-&gt;i_fop);<span class="comment">//获取文件节点的file_operations</span></span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (!open)<span class="comment">//如果open为空则调用file_operations结构中的open函数</span></span></span><br><span class="line"><span class="params">  open = f-&gt;f_op-&gt;open;</span></span><br><span class="line"><span class="params">  <span class="keyword">if</span> (open) &#123;</span></span><br><span class="line"><span class="params">  error = open(inode, f);</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">  <span class="comment">//略过我们不想看的代码</span></span></span><br><span class="line"><span class="params">  <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">// file_operations 结构的地址存在一个文件的inode结构中</span></span></span><br><span class="line"><span class="params"><span class="comment">// 在Linux 系统中，都是用inode结构表示一个文件，不管它是数据文件还是设备文件</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>驱动程序实例</strong>
<ul>
<li>该驱动程序的主要工作就是获取所有总线和其下所有设备的名字;需要先了解驱动程序的整体框架,接着建立总线和设备,然后实现驱动程序的打开,关闭，读写操作函数,最后写个应用程序测试驱动程序</li>
</ul>
</li>
<li><strong>驱动程序框架</strong>
<ul>
<li>Linux内核的驱动程序是在一个可加载的内核模块中实现，可加载的内核模块只需要两个函数和模块信息</li>
<li>要在模块中实现总线和设备驱动,需要更多的函数和数据结构</li>
<li>模块一旦加载就会执行 miscdrv_init 函数，卸载时就会执行 miscdrv_exit 函数</li>
</ul>
</li>
<li><strong>建立设备</strong>
<ul>
<li>先建立总线，然后在总线下建立一个设备</li>
<li>Linux系统提供 bus_register 函数向内核注册一个总线，相当于建立一个总线,需要在 miscdrv_init 函数中调用</li>
<li>bus_register 函数会在系统中注册一个总线,所需参数就是总线结构的地址(&amp;deviceinfo_bus)，返回非0表示注册失败</li>
<li>建立 misc 杂项设备:misc杂项设备需要定一个数据结构,然后调用 misc 杂项设备注册接口函数</li>
<li>misc_register 函数只是负责分配设备号，以及把 miscdev 加入链表，真正的核心工作由device_create_with_groups 函数来完成</li>
<li>执行make命令，产生 miscdvrv.ko内核模块文件,把该文件加载到 Linux系统中即可</li>
<li>终端中使用 sudo cat /proc/kmsg指令读取/proc/kmsg文件,内核prink函数输出信息</li>
<li>在 /dev 目录看到一个 devicesinfo 文件，同时在 /sys/bus/ 目录下也可以看到一个 devicesinfobus 文件(建立的设备和总线的文件节点的名称)</li>
</ul>
</li>
<li><strong>打开,关系,读写函数</strong>
<ul>
<li>正常情况下不能获取 bus_kset 地址的，它是所有总线的根，包含了所有总线的kobject，Linux 为了保护 bus_kset，并没有在 bus_type 结构中直接包含 kobject，而是让总线指向一个 subsys_private 结构，在其中包含了 kobject 结构</li>
<li>要注册一个总线得到 bus_kset，根据它又能找到所有 subsys_private 结构中的 kobject，接着找到 subsys_private 结构，反向查询到bus_type 结构的地址</li>
<li>然后调用 Linux 提供的 bus_for_each_dev 函数，就可以遍历一个总线上的所有设备，它每遍历到一个设备，就调用一个函数，这个函数是用参数的方式传给它的，在代码中就是 misc_find_match 函数</li>
<li>在调用 misc_find_match 函数时，会把一个设备结构的地址和另一个指针作为参数传递进来。最后就能打印每个设备的名称了</li>
</ul>
</li>
<li><strong>测试驱动</strong>
<ul>
<li>加载驱动之后会自动建立设备文件，但驱动程序不会主动工作，需要写应用程序对设备文件进行读写才能测试驱动</li>
<li>切换到代码目录 make 一下，然后加载 miscdrv.ko 模块，最后在终端中执行 sudo ./app，就能在另一个已经执行了 sudo cat /proc/kmsg 的终端中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_NAME <span class="string">&quot;devicesinfo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUS_DEV_NAME <span class="string">&quot;devicesinfobus&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">misc_find_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;device name is:%s\n&quot;</span>, dev-&gt;kobj.name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应于设备文件的读操作函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">misc_read</span> <span class="params">(<span class="keyword">struct</span> file *pfile, <span class="type">char</span> __user *buff, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;line:%d,%s is call\n&quot;</span>,__LINE__,__FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应于设备文件的写操作函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">misc_write</span><span class="params">(<span class="keyword">struct</span> file *pfile, <span class="type">const</span> <span class="type">char</span> __user *buff, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;line:%d,%s is call\n&quot;</span>,__LINE__,__FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应于设备文件的打开操作函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">misc_open</span><span class="params">(<span class="keyword">struct</span> inode *pinode, <span class="keyword">struct</span> file *pfile)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;line:%d,%s is call\n&quot;</span>,__LINE__,__FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应于设备文件的关闭操作函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">misc_release</span><span class="params">(<span class="keyword">struct</span> inode *pinode, <span class="keyword">struct</span> file *pfile)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;line:%d,%s is call\n&quot;</span>,__LINE__,__FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">devicesinfo_bus_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">strncmp</span>(dev-&gt;kobj.name, driver-&gt;name, <span class="built_in">strlen</span>(driver-&gt;name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应于设备文件的操作函数结构</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">misc_fops</span> =</span> &#123;</span><br><span class="line">.read = misc_read,</span><br><span class="line">.write = misc_write,</span><br><span class="line">.release = misc_release,</span><br><span class="line">.open = misc_open,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//misc设备的结构</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">misc_dev</span> =</span> &#123;</span><br><span class="line">.fops = &amp;misc_fops, <span class="comment">//设备文件操作方法</span></span><br><span class="line">.minor = <span class="number">255</span>, <span class="comment">//次设备号</span></span><br><span class="line">.name = DEV_NAME, <span class="comment">//设备名/dev/下的设备节点名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//总线结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">devicesinfo_bus</span> =</span> &#123;</span><br><span class="line">.name = BUS_DEV_NAME, <span class="comment">//总线名字</span></span><br><span class="line">.match = devicesinfo_bus_match, <span class="comment">//总线match函数指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//内核模块入口函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">miscdrv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;INIT misc\n&quot;</span>)；</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内核模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">miscdrv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;EXIT,misc\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(miscdrv_init);<span class="comment">//申明内核模块入口函数</span></span><br><span class="line">module_exit(miscdrv_exit);<span class="comment">//申明内核模块退出函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//模块许可</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;LMOS&quot;</span>);<span class="comment">//模块开发者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 建立设备</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">miscdrv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(KERN_EMERG <span class="string">&quot;INIT misc\n&quot;</span>);</span><br><span class="line">  busok = bus_register(&amp;devicesinfo_bus);<span class="comment">//注册总线</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bus_register</span><span class="params">(<span class="keyword">struct</span> bus_type *bus)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">priv</span>;</span></span><br><span class="line"><span class="comment">//分配一个subsys_private结构</span></span><br><span class="line">priv = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> subsys_private), GFP_KERNEL);</span><br><span class="line"><span class="comment">//bus_type和subsys_private结构互相指向</span></span><br><span class="line">priv-&gt;bus = bus;</span><br><span class="line">bus-&gt;p = priv;</span><br><span class="line"><span class="comment">//把总线的名称加入subsys_private的kobject中</span></span><br><span class="line">retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">&quot;%s&quot;</span>, bus-&gt;name);</span><br><span class="line">priv-&gt;subsys.kobj.kset = bus_kset;<span class="comment">//指向bus_kset</span></span><br><span class="line"><span class="comment">//把subsys_private中的kset注册到系统中</span></span><br><span class="line">retval = kset_register(&amp;priv-&gt;subsys);</span><br><span class="line"><span class="comment">//建立总线的文件结构在sysfs中</span></span><br><span class="line">retval = bus_create_file(bus, &amp;bus_attr_uevent);</span><br><span class="line"><span class="comment">//建立subsys_private中的devices和drivers的kset</span></span><br><span class="line">priv-&gt;devices_kset = kset_create_and_add(<span class="string">&quot;devices&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">&amp;priv-&gt;subsys.kobj);</span><br><span class="line">priv-&gt;drivers_kset = kset_create_and_add(<span class="string">&quot;drivers&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">&amp;priv-&gt;subsys.kobj);</span><br><span class="line"><span class="comment">//建立subsys_private中的devices和drivers链表，用于属于总线的设备和驱动</span></span><br><span class="line">klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span><br><span class="line">klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态定义了 miscdevice 结构的变量 misc_dev</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_NAME <span class="string">&quot;devicesinfo&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">misc_fops</span> =</span> &#123;</span><br><span class="line">.read = misc_read,</span><br><span class="line">.write = misc_write,</span><br><span class="line">.release = misc_release,</span><br><span class="line">.open = misc_open,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">misc_dev</span> =</span> &#123;</span><br><span class="line">.fops = &amp;misc_fops, <span class="comment">//设备文件操作方法</span></span><br><span class="line">.minor = <span class="number">255</span>, <span class="comment">//次设备号</span></span><br><span class="line">.name = DEV_NAME, <span class="comment">//设备名/dev/下的设备节点名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">miscdrv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">misc_register(&amp;misc_dev);<span class="comment">//注册misc杂项设备</span></span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;INIT misc busok\n&quot;</span>);</span><br><span class="line">busok = bus_register(&amp;devicesinfo_bus);<span class="comment">//注册总线</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// misc_register 函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">misc_register</span><span class="params">(<span class="keyword">struct</span> miscdevice *misc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">dev_t</span> dev;</span><br><span class="line">  <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> is_dynamic = (misc-&gt;minor == MISC_DYNAMIC_MINOR);</span><br><span class="line">  INIT_LIST_HEAD(&amp;misc-&gt;<span class="built_in">list</span>);</span><br><span class="line">  mutex_lock(&amp;misc_mtx);</span><br><span class="line">  <span class="keyword">if</span> (is_dynamic) &#123;<span class="comment">//minor次设备号如果等于255就自动分配次设备</span></span><br><span class="line">    <span class="type">int</span> i = find_first_zero_bit(misc_minors, DYNAMIC_MINORS);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= DYNAMIC_MINORS) &#123;</span><br><span class="line">      err = -EBUSY;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    misc-&gt;minor = DYNAMIC_MINORS - i - <span class="number">1</span>;</span><br><span class="line">    set_bit(i, misc_minors);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则检查次设备号是否已经被占有</span></span><br><span class="line">    <span class="keyword">struct</span> miscdevice *c;</span><br><span class="line">    list_for_each_entry(c, &amp;misc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c-&gt;minor == misc-&gt;minor) &#123;</span><br><span class="line">        err = -EBUSY;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dev = MKDEV(MISC_MAJOR, misc-&gt;minor);<span class="comment">//合并主、次设备号</span></span><br><span class="line">  <span class="comment">//建立设备</span></span><br><span class="line">  misc-&gt;this_device =</span><br><span class="line">  device_create_with_groups(misc_class, misc-&gt;parent, dev,</span><br><span class="line">  misc, misc-&gt;groups, <span class="string">&quot;%s&quot;</span>, misc-&gt;name);</span><br><span class="line">  <span class="comment">//把这个misc加入到全局misc_list链表</span></span><br><span class="line">  list_add(&amp;misc-&gt;<span class="built_in">list</span>, &amp;misc_list);</span><br><span class="line">  out:</span><br><span class="line">  mutex_unlock(&amp;misc_mtx);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create_with_groups</span><span class="params">(<span class="keyword">struct</span> class *class,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> device *parent, <span class="type">dev_t</span> devt,<span class="type">void</span> *drvdata,<span class="type">const</span> <span class="keyword">struct</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">va_list vargs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">va_start(vargs, fmt);</span><br><span class="line">dev = device_create_groups_vargs(class, parent, devt, drvdata, groups,fmt,</span><br><span class="line">va_end(vargs);</span><br><span class="line"><span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> device *device_create_groups_vargs(<span class="keyword">struct</span> class *class, <span class="keyword">struct</span> device *</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> device *dev = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> retval = -ENODEV;</span><br><span class="line">  dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);<span class="comment">//分配设备结构的内存空间</span></span><br><span class="line">  device_initialize(dev);<span class="comment">//初始化设备结构</span></span><br><span class="line">  dev-&gt;devt = devt;<span class="comment">//设置设备号</span></span><br><span class="line">  dev-&gt;class = class;<span class="comment">//设置设备类</span></span><br><span class="line">  dev-&gt;parent = parent;<span class="comment">//设置设备的父设备</span></span><br><span class="line">  dev-&gt;groups = groups;<span class="comment">////设置设备属性</span></span><br><span class="line">  dev-&gt;release = device_create_release;</span><br><span class="line">  dev_set_drvdata(dev, drvdata);<span class="comment">//设置miscdev的地址到设备结构中</span></span><br><span class="line">  retval = kobject_set_name_vargs(&amp;dev-&gt;kobj, fmt, args);<span class="comment">//把名称设置到设备的ko</span></span><br><span class="line">  retval = device_add(dev);<span class="comment">//把设备加入到系统中</span></span><br><span class="line">  <span class="keyword">if</span> (retval)</span><br><span class="line">  <span class="keyword">goto</span> error;</span><br><span class="line">  <span class="keyword">return</span> dev;<span class="comment">//返回设备</span></span><br><span class="line">  error:</span><br><span class="line">  put_device(dev);</span><br><span class="line">  <span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#第一步在终端中执行如下指令</span><br><span class="line">sudo cat /proc/kmsg</span><br><span class="line">#第二步在另一个终端中执行如下指令</span><br><span class="line">make</span><br><span class="line">sudo insmod miscdrv.ko</span><br><span class="line">#不用这个模块了可以用以下指令卸载</span><br><span class="line">sudo rmmod miscdrv.ko</span><br><span class="line"><span class="comment">// insmod 指令是加载一个内核模块，一旦加载成功就会执行 miscdrv_init 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------</span></span><br><span class="line"><span class="comment">// 打开,关系,读写函数</span></span><br><span class="line"><span class="comment">// -----------------</span></span><br><span class="line"><span class="comment">//打开</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> misc_open(<span class="keyword">struct</span> inode *pinode, <span class="keyword">struct</span> file *pfile)</span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;line:%d,%s is call\n&quot;</span>,__LINE__,__FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> misc_release(<span class="keyword">struct</span> inode *pinode, <span class="keyword">struct</span> file *pfile)</span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;line:%d,%s is call\n&quot;</span>,__LINE__,__FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> misc_write(<span class="keyword">struct</span> file *pfile, <span class="type">const</span> <span class="type">char</span> __user *buff, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;line:%d,%s is call\n&quot;</span>,__LINE__,__FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_subsys_private(obj) container_of(obj, struct subsys_private, subsys *p)</span></span><br><span class="line"><span class="keyword">struct</span> kset *ret_buskset(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> subsys_private *p;</span><br><span class="line"><span class="keyword">if</span>(busok)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(!devicesinfo_bus.p)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">p = devicesinfo_bus.p;</span><br><span class="line"><span class="keyword">if</span>(!p-&gt;subsys.kobj.kset)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//返回devicesinfo_bus总线上的kset，正是bus_kset</span></span><br><span class="line"><span class="keyword">return</span> p-&gt;subsys.kobj.kset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> misc_find_match(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> bus_type* b = (<span class="keyword">struct</span> bus_type*)data;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;%s----&gt;device name is:%s\n&quot;</span>, b-&gt;name, dev-&gt;kobj.name);/</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> misc_read (<span class="keyword">struct</span> file *pfile, <span class="type">char</span> __user *buff, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> kobject* kobj;</span><br><span class="line"><span class="keyword">struct</span> kset* kset;</span><br><span class="line"><span class="keyword">struct</span> subsys_private* p;</span><br><span class="line">kset = ret_buskset();<span class="comment">//获取bus_kset的地址</span></span><br><span class="line"><span class="keyword">if</span>(!kset)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;line:%d,%s is call\n&quot;</span>,__LINE__,__FUNCTION__);<span class="comment">//打印这个函</span></span><br><span class="line"><span class="comment">//扫描所有总线的kobject</span></span><br><span class="line">list_for_each_entry(kobj, &amp;kset-&gt;<span class="built_in">list</span>, entry)</span><br><span class="line">&#123;</span><br><span class="line">p = to_subsys_private(kobj);</span><br><span class="line">printk(KERN_EMERG <span class="string">&quot;Bus name is:%s\n&quot;</span>,p-&gt;bus-&gt;name);</span><br><span class="line"><span class="comment">//遍历具体总线上的所有设备</span></span><br><span class="line">bus_for_each_dev(p-&gt;bus, <span class="literal">NULL</span>, p-&gt;bus, misc_find_match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 测试驱动</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_NAME <span class="string">&quot;/dev/devicesinfo&quot;</span></span></span><br><span class="line"><span class="type">int</span> main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">//打开设备文件</span></span><br><span class="line">fd = open(DEV_NAME, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开 :%s 失败!\n&quot;</span>, DEV_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写数据到内核空间</span></span><br><span class="line">write(fd, buf, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//从内核空间中读取数据</span></span><br><span class="line">read(fd, buf, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//关闭设备,也可以不调用，程序关闭时系统自动调用</span></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="9-文件系统"><a class="markdownIt-Anchor" href="#9-文件系统"></a> 9 文件系统</h1>
</div><div class="story post-story"><h2 id="91-如何组织文件"><a class="markdownIt-Anchor" href="#91-如何组织文件"></a> 9.1 如何组织文件</h2>
<ul>
<li><strong>什么是文件系统</strong>
<ul>
<li>文件系统解决的是如何把许多文件储存在某一种储存设备上,方便进程对各种文件执行打开，关系，读写，增加和删除等操作，操作系统中分出一个子系统专门处理问题，该系统是<strong>文件系统</strong></li>
<li>文件系统在上层为用户或进程提供了一个逻辑视图,也就是目录结构</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-21-44.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-21-44.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="文件组织结构" /></p>
<ul>
<li><strong>文件系统只是一个设备</strong>
<ul>
<li>文件系统建立的文件系统格式:FAT32,NTFS,Ext4,Btrfs,ZFS,HPFS等</li>
<li>文件系统组件是独立的与内核分开的</li>
<li>操作系统需要动态加载和删除不同的文件系统组件</li>
<li>文件系统是系统内核下的一个设备，因为不同的设备驱动程序可以动态加载，而且可以建立多个文件系统设备,对各个文件系统设备驱动程序的实现就是各个文件系统的实现</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-31-46.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-31-46.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="文件系统架构示意图" /></p>
<ul>
<li>为了减少程序的复杂度使用4mb大小的内存地址来模拟储存设备
<ul>
<li>在文件系统设备驱动程序的入口函数中，分配4MB大小的内存空间</li>
</ul>
</li>
<li><strong>文件格式与储存块</strong>
<ul>
<li>一个文件就是一个可以动态增加,减少的线性字节数组,即文件数据的每个字节都一一对应到这个线性数组中的每个元素</li>
<li>文件系统把文件数据定义成一个<strong>动态的线性字节数组</strong>
<ul>
<li>一开始不知道数组大小，需要分配多少个物理储存块,最好把动态的线性字节数组分成一个个数据块</li>
<li>不同的储存设备的物理储存块的大小不同,为了文件系统在不同的储存设备上,故将数据块定义为文件系统逻辑块,其大小为4096字节,最后将逻辑块映射到一个或多个物理储存块</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-37-42.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-37-42.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="文件字节数组" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-46-21.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-46-21.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="文件逻辑块映射" /></p>
<ul>
<li><strong>如何组织文件</strong>
<ul>
<li>使用文件目录或文件夹(目录)进行组织,可以建立层次关系</li>
<li>整个文件层次结构为树结构</li>
</ul>
</li>
<li><strong>文件系统数据结构</strong>
<ul>
<li>表示文件系统本身的一些数据结构称为<strong>文件系统元数据</strong></li>
</ul>
</li>
<li><strong>设计超级块</strong>
<ul>
<li>一个文件系统有很多信息,如文件系统标识,版本,状态,储存介质大小,文件系统逻辑储存块大小,位图所在的储存块,根目录等,包含这些信息的数据块叫做<strong>文件系统的超级块或文件系统描述块</strong></li>
<li>在 cosmos/include/drvinc目录下建立 drvrfs_t.h文件写下 rfssublk_t结构</li>
<li>建立的文件系统的超级块保存在储存设备的第一个 4KB 大小的逻辑储存块中，但是其本身的大小没有 4KB，多余的空间用于以后扩展
<ul>
<li>rfsdir_t 数据结构是一个目录数据结构</li>
</ul>
</li>
</ul>
</li>
<li><strong>位图</strong>
<ul>
<li>使用位图来表示逻辑储存块是空闲还是分配占用状态,利用一块储存空间中所有位的状态达到映射逻辑储存块状态的目的</li>
<li>一个字节是 8 个位，那么 4KB 的储存空间中，就有（4096*8）个位，这每个位映射到一个逻辑储存块，其中一个位的值为 0，就表示该位对应的逻辑储存块是空闲的，反之就表示对应的逻辑储存块是占用的</li>
<li>在实际操作中,把位图这个储存块当做一个字节数组
<ul>
<li>用了一块 4MB 的内存空间模拟储存设备，所以一共只有 1024个 4KB 大小的逻辑储存块。因为远远小于 4096，所以用不着把所有位都利用起来，操作一个个位很麻烦，完全可以用一个字节表示一个逻辑储存块是否空闲还是占用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-53-28.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-53-28.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="位图块" /></p>
<ul>
<li><strong>文件系统</strong>
<ul>
<li>目录也是一种数据结构，其中包含了目录类型，状态，指向文件数据管理头的块号，名称等信息</li>
<li>将这些信息整理成 rfsdir_t 数据结构,写在 drvrfs_t.h 文件中</li>
<li>DR_NM_MAX 宏，可以看出 rfsdir_t 数据结构最多只有 128 字节大小。而名称数组的大小就是 128 减去 3 个 8 字节，由于储存设备不能用字节地址访问，它只能一块一块的访问，所以 rfsdir_t 结构中有个域，指向文件数据管理头的块号</li>
<li><strong>为什么 rfsdir_t 结构中会有很多类型呢</strong>，目录也是一种特殊的文件，里面就是保存着一系列 rfsdir_t 结构的实例变量,再次表明它代表的是一个文件，还是一个目录</li>
<li>超级块中的 rfsdir_t 结构保存了根目录的名称和指向管理根目录数据的文件管理头的块号。而实际的目录数据保存在逻辑储存块中，这表明目录也是一种数据</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-58-19.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-12-58-19.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="目录结构" /></p>
<ul>
<li><strong>文件管理头</strong>
<ul>
<li>文件管理头包含,文件名,状态,类型,创建时间，访问时间，大小，使用那些逻辑储存块等信息</li>
<li>在 drvrfs_t.h 文件中建立 fimgrhd_t 文件管理头
<ul>
<li>fmd_fleblk 数组,里面的每个元素都保存一块连续的逻辑储存块</li>
<li>文件特别大时,fmd_fleblk 数组元素不够用,再分配一个逻辑储存块,在里面再次存放同一个文件的 fimgrhd_t 结构，让上一个 fimgrhd_t 结构中的 fmd_linknblk域指向这个逻辑储存块，再让这个逻辑储存块中 fimgrhd_t 结构中的 fmd_linkpblk 域，指向上一个 fimgrhd_t 结构所在的逻辑储存块</li>
</ul>
</li>
<li>fimgrhd_t 结构如何管理一个文件占有的所有逻辑储存块，并且可以通过类似链表的形式动态增加 fimgrhd_t 结构，实际上就是在动态增加文件的逻辑储存块。同时我们不难发现，文件的第一个逻辑储存块的首个 512 字节空间中，存放的就是 fimgrhd_t 数据结构</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-13-05-13.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-13-05-13.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="文件管理头" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_RFSSUBLK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">spinlock_t</span> rsb_lock;<span class="comment">//超级块在内存中使用的自旋锁</span></span><br><span class="line">  <span class="type">uint_t</span> rsb_mgic;<span class="comment">//文件系统标识</span></span><br><span class="line">  <span class="type">uint_t</span> rsb_vec;<span class="comment">//文件系统版本</span></span><br><span class="line">  <span class="type">uint_t</span> rsb_flg;<span class="comment">//标志</span></span><br><span class="line">  <span class="type">uint_t</span> rsb_stus;<span class="comment">//状态</span></span><br><span class="line">  <span class="type">size_t</span> rsb_sz;<span class="comment">//该数据结构本身的大小</span></span><br><span class="line">  <span class="type">size_t</span> rsb_sblksz;<span class="comment">//超级块大小</span></span><br><span class="line">  <span class="type">size_t</span> rsb_dblksz;<span class="comment">//文件系统逻辑储存块大小，我们这里用的是4KB</span></span><br><span class="line">  <span class="type">uint_t</span> rsb_bmpbks;<span class="comment">//位图的开始逻辑储存块</span></span><br><span class="line">  <span class="type">uint_t</span> rsb_bmpbknr;<span class="comment">//位图占用多少个逻辑储存块</span></span><br><span class="line">  <span class="type">uint_t</span> rsb_fsysallblk;<span class="comment">//文件系统有多少个逻辑储存块</span></span><br><span class="line">  <span class="type">rfsdir_t</span> rsb_rootdir;<span class="comment">//根目录，后面会看到这个数据结构的</span></span><br><span class="line">&#125;<span class="type">rfssublk_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 文件系统</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DR_NM_MAX (128-(sizeof(uint_t)*3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RDR_NUL_TYPE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RDR_DIR_TYPE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RDR_FIL_TYPE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RDR_DEL_TYPE 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_RFSDIR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">uint_t</span> rdr_stus;<span class="comment">//目录状态</span></span><br><span class="line"><span class="type">uint_t</span> rdr_type;<span class="comment">//目录类型，可以是空类型、目录类型、文件类型、已删除的类型</span></span><br><span class="line"><span class="type">uint_t</span> rdr_blknr;<span class="comment">//指向文件数据管理头的块号，不像内存可以用指针，只能按块访问</span></span><br><span class="line"><span class="type">char_t</span> rdr_name[DR_NM_MAX];<span class="comment">//名称数组，大小为DR_NM_MAX</span></span><br><span class="line">&#125;rfsdir t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 文件管理头</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBLKS_MAX 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMD_NUL_TYPE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMD_DIR_TYPE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMD_FIL_TYPE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FMD_DEL_TYPE 5<span class="comment">//文件管理头也需要表明它管理的是目录文件还是普通文件</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_FILBLKS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">uint_t</span> fb_blkstart;<span class="comment">//开始的逻辑储存块号</span></span><br><span class="line"><span class="type">uint_t</span> fb_blknr;<span class="comment">//逻辑储存块的块数，从blkstart开始的连续块数</span></span><br><span class="line">&#125;<span class="type">filblks_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_fimgrhd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">uint_t</span> fmd_stus;<span class="comment">//文件状态</span></span><br><span class="line"><span class="type">uint_t</span> fmd_type;<span class="comment">//文件类型：可以是目录文件、普通文件、空文件、已删除的文件</span></span><br><span class="line"><span class="type">uint_t</span> fmd_flg;<span class="comment">//文件标志</span></span><br><span class="line"><span class="type">uint_t</span> fmd_sfblk;<span class="comment">//文件管理头自身所在的逻辑储存块</span></span><br><span class="line"><span class="type">uint_t</span> fmd_acss;<span class="comment">//文件访问权限</span></span><br><span class="line"><span class="type">uint_t</span> fmd_newtime;<span class="comment">//文件的创建时间，换算成秒</span></span><br><span class="line"><span class="type">uint_t</span> fmd_acstime;<span class="comment">//文件的访问时间，换算成秒</span></span><br><span class="line"><span class="type">uint_t</span> fmd_fileallbk;<span class="comment">//文件一共占用多少个逻辑储存块</span></span><br><span class="line"><span class="type">uint_t</span> fmd_filesz;<span class="comment">//文件大小</span></span><br><span class="line"><span class="type">uint_t</span> fmd_fileifstbkoff;<span class="comment">//文件数据在第一块逻辑储存块中的偏移</span></span><br><span class="line"><span class="type">uint_t</span> fmd_fileiendbkoff;<span class="comment">//文件数据在最后一块逻辑储存块中的偏移</span></span><br><span class="line"><span class="type">uint_t</span> fmd_curfwritebk;<span class="comment">//文件数据当前将要写入的逻辑储存块</span></span><br><span class="line"><span class="type">uint_t</span> fmd_curfinwbkoff;<span class="comment">//文件数据当前将要写入的逻辑储存块中的偏移</span></span><br><span class="line"><span class="type">filblks_t</span> fmd_fleblk[FBLKS_MAX];<span class="comment">//文件占用逻辑储存块的数组，一共32个filblks_t结构</span></span><br><span class="line"><span class="type">uint_t</span> fmd_linkpblk;<span class="comment">//指向文件的上一个文件管理头的逻辑储存块</span></span><br><span class="line"><span class="type">uint_t</span> fmd_linknblk;<span class="comment">//指向文件的下一个文件管理头的逻辑储存块</span></span><br><span class="line">&#125;fimgrhd t;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="92-文件系统的格式化操作"><a class="markdownIt-Anchor" href="#92-文件系统的格式化操作"></a> 9.2 文件系统的格式化操作</h2>
<ul>
<li><strong>文件系统设备</strong>
<ul>
<li>首先需要编写相应的设备驱动程序,在 cosmos/drivers目录下建立 drvrfs.c 文件,编写文件系统驱动程序框架</li>
<li>4MB大小的内存空间的数据结构的分配内存空间,使用一个数据结构来描述:
<ul>
<li>new_rfsdevext_mmblk 函数分配了一个内存空间和一个 rfsdevext_t 结构实例变量</li>
<li>rfsdevext_t 结构保存了内存空间的地址和大小</li>
<li>rfsdevext_t 结构的地址存放在 device_t 结构的 dev_extdata 字段中</li>
</ul>
</li>
<li>建立文件系统设备,与建立systick驱动程序差不多,需要分配一个模拟储存设备的空间,并把它放在 device_t 结构相关字段中,这个设备类型需要在 rfs_set_device 函数中设置好,设置为文件系统类型</li>
<li>需要将 rfs_entry 函数放在驱动表中,文件系统程序才能运行,在系统启动时,在 init_krldriver 函数中会运行 rfs_entry 函数</li>
</ul>
</li>
<li><strong>文件系统格式化</strong>
<ul>
<li>格式化操作是在这个设备上重建了文件系统用于管理文件的那一套数据结构</li>
<li>在储存设备上建立文件系统其实就是执行格式化操作,即重建文件系统的数据结构</li>
</ul>
</li>
<li><strong>建立超级块</strong>:即初始化超级块的数据结构将其写入到储存设备中的第一块逻辑储存块
<ul>
<li>现在内存缓冲区建立文件系统的超级块,最后调用 write_rfsdevblk 函数</li>
<li>由于使用内存模拟储存设备,故需要 ret_rfsdevext 函数返回设备扩展数据结构,该函数和 ret_rfsdevblk 函数一起根据块号,计算出内存地址，然后将缓冲区的内容复制到这个地址开始的内存空间</li>
</ul>
</li>
<li><strong>建立位图</strong>
<ul>
<li>使用一个逻辑储存块空间中的所有字节来管理逻辑储存块的状态</li>
<li>建立位图就是把储存设备中的位图块清零</li>
<li>位图块的块号和储存介质的逻辑储存块总数都保存在超级块中,需要实现获取,释放超级块的函数,还需要一个读取逻辑储存块的函数,写入逻辑储存块的函数
<ul>
<li>第0块是超级块,第1块是位图本身,故代码从缓冲区中的第3个字节开始清零,一直到 devmaxblk 个字节(devmaxblk是储存介质的逻辑储存块总数)</li>
</ul>
</li>
<li>最后把缓冲区的数据写入到储存介质的第 bitmapblk 个逻辑储存块中就完成了位图的建立</li>
</ul>
</li>
<li><strong>建立根目录</strong>
<ul>
<li>根目录是文件,要为其分配相应的逻辑储存块,根目录下的文件和目录对应的 rfsdir_t 结构就是保存在这个逻辑储存块中
<ul>
<li>需要在逻辑储存块的首512字节空间中建立 fimgrhd_t 结构,即文件管理头数据结构</li>
<li>最后要将这个逻辑储存块的块号储存在超级块中的 rfsdir_t 结构中,同事修改该 rfsdir_t 结构中的文件名为&quot;/&quot;
<ul>
<li>获取位图块:根据超级块中的位图块号,把储存设备中的位图数据块读取到缓冲区中</li>
<li>释放位图块:把缓冲区的输入写入到储存设备对应的逻辑块中</li>
<li>扫描位图块找出空闲的逻辑储存块,rfs_new_blk 函数会返回新分配的逻辑储存块号，如果没有空闲的逻辑储存块了，就会返回0</li>
<li>建立根目录:首先分配一个新的逻辑储存区,接着设置超级块中的 rfsdir_t 结构中的名称以及类型和块号;然后设置文件管理头,类型为 FMD_DIR_TYPE,表示文件数据存放的是目录结构,最后回写对应的逻辑储存块即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>串联</strong>
<ul>
<li>rfs_fmat函数将操作包装,调用它们完成文件系统格式化流程;还可以把 init_rfs 函数实现调用 rfs_fmat函数，随后 init_rfs 函数本身会在 rfs_entry 函数最后被调用</li>
</ul>
</li>
<li><strong>测试文件系统的超级块</strong>
<ul>
<li>需要把超级块读取到一个缓冲区中,然后把其中重要的数据打印出来</li>
</ul>
</li>
<li><strong>测试文件系统位图</strong>
<ul>
<li>先读取位图块到一个缓冲区,然后循环扫描缓冲区,看里面有多少个为0的字节,即表明存储介质上有多少个空闲的逻辑储存块</li>
</ul>
</li>
<li><strong>测试文件系统根目录</strong>
<ul>
<li>先得到根目录文件的 rfsdir_t 结构，然后读取其中指向的逻辑储存块到缓冲区,最后将数据打印出来</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 文件系统设备</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_entry</span><span class="params">(<span class="type">driver_t</span>* drvp,<span class="type">uint_t</span> val,<span class="type">void</span>* p)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_exit</span><span class="params">(<span class="type">driver_t</span>* drvp,<span class="type">uint_t</span> val,<span class="type">void</span>* p)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_open</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_close</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_read</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_write</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_lseek</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_ioctrl</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_dev_start</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_dev_stop</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_set_powerstus</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_enum_dev</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_flush</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_shutdown</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span>&#123;……&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4MB大小的内存空间的数据结构的分配内存空间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_RFSDEVEXT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> rde_lock;<span class="comment">//自旋锁</span></span><br><span class="line"><span class="type">list_h_t</span> rde_list;<span class="comment">//链表</span></span><br><span class="line"><span class="type">uint_t</span> rde_flg;<span class="comment">//标志</span></span><br><span class="line"><span class="type">uint_t</span> rde_stus;<span class="comment">//状态</span></span><br><span class="line"><span class="type">void</span>* rde_mstart;<span class="comment">//用于模拟储存介质的内存块的开始地址</span></span><br><span class="line"><span class="type">size_t</span> rde_msize;<span class="comment">//内存块的大小</span></span><br><span class="line"><span class="type">void</span>* rde_ext;<span class="comment">//扩展所用</span></span><br><span class="line">&#125;<span class="type">rfsdevext_t</span>;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">new_rfsdevext_mmblk</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">size_t</span> blksz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//分配模拟储存介质的内存空间，大小为4MB</span></span><br><span class="line"><span class="type">adr_t</span> blkp= krlnew(blksz);</span><br><span class="line"><span class="comment">//分配rfsdevext_t结构实例的内存空间</span></span><br><span class="line"><span class="type">rfsdevext_t</span>* rfsexp=(<span class="type">rfsdevext_t</span>*)krlnew(<span class="keyword">sizeof</span>(<span class="type">rfsdevext_t</span>));</span><br><span class="line"><span class="comment">//初始化rfsdevext_t结构</span></span><br><span class="line">rfsdevext_t_init(rfsexp);</span><br><span class="line">rfsexp-&gt;rde_mstart=(<span class="type">void</span>*)blkp;</span><br><span class="line">rfsexp-&gt;rde_msize=blksz;</span><br><span class="line"><span class="comment">//把rfsdevext_t结构的地址放入device_t 结构的dev_extdata字段中，这里dev_extdata字</span></span><br><span class="line">devp-&gt;dev_extdata=(<span class="type">void</span>*)rfsexp;.</span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立文件系统设备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rfs_set_device</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">driver_t</span>* drvp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设备类型为文件系统类型</span></span><br><span class="line">devp-&gt;dev_id.dev_mtype = FILESYS_DEVICE;</span><br><span class="line">devp-&gt;dev_id.dev_stype = <span class="number">0</span>;</span><br><span class="line">devp-&gt;dev_id.dev_nr = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//设备名称为rfs</span></span><br><span class="line">devp-&gt;dev_name = <span class="string">&quot;rfs&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_entry</span><span class="params">(<span class="type">driver_t</span>* drvp,<span class="type">uint_t</span> val,<span class="type">void</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//分配device_t结构并对其进行初级初始化</span></span><br><span class="line"><span class="type">device_t</span>* devp = new_device_dsc();</span><br><span class="line">rfs_set_driver(drvp);</span><br><span class="line">rfs_set_device(devp,drvp);</span><br><span class="line"><span class="comment">//分配模拟储存设备的内存空间</span></span><br><span class="line"><span class="keyword">if</span>(new_rfsdevext_mmblk(devp,FSMM_BLK) == DFCERRSTUS)&#123;……&#125;</span><br><span class="line"><span class="comment">//把设备加入到驱动程序之中</span></span><br><span class="line"><span class="keyword">if</span>(krldev_add_driver(devp,drvp) == DFCERRSTUS)&#123;……&#125;</span><br><span class="line"><span class="comment">//向内核注册设备</span></span><br><span class="line"><span class="keyword">if</span>(krlnew_device(devp)==DFCERRSTUS)&#123;……&#125;</span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 rfs_entry 函数放在驱动表中</span></span><br><span class="line"><span class="comment">//cosmos/kernel/krlglobal.c</span></span><br><span class="line">KRL_DEFGLOB_VARIABLE(<span class="type">drventyexit_t</span>,osdrvetytabl)[]=&#123;systick_entry,rfs_entry,<span class="literal">NULL</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// 建立超级块</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="type">void</span> *new_buf(<span class="type">size_t</span> bufsz)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span> *)krlnew(bufsz);<span class="comment">//分配缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">del_buf</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> bufsz)</span></span><br><span class="line">&#123;</span><br><span class="line">krldelete((<span class="type">adr_t</span>)buf, bufsz)<span class="comment">//释放缓冲区</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rfssublk_t_init</span><span class="params">(<span class="type">rfssublk_t</span>* initp)</span></span><br><span class="line">&#123;</span><br><span class="line">krlspinlock_init(&amp;initp-&gt;rsb_lock);</span><br><span class="line">initp-&gt;rsb_mgic = <span class="number">0x142422</span>;<span class="comment">//标志就是一个数字而已，无其它意义</span></span><br><span class="line">initp-&gt;rsb_vec = <span class="number">1</span>;<span class="comment">//文件系统版本为1</span></span><br><span class="line">initp-&gt;rsb_flg = <span class="number">0</span>;</span><br><span class="line">initp-&gt;rsb_stus = <span class="number">0</span>;</span><br><span class="line">initp-&gt;rsb_sz = <span class="keyword">sizeof</span>(<span class="type">rfssublk_t</span>);<span class="comment">//超级块本身的大小</span></span><br><span class="line">initp-&gt;rsb_sblksz = <span class="number">1</span>;<span class="comment">//超级块占用多少个逻辑储存块</span></span><br><span class="line">initp-&gt;rsb_dblksz = FSYS_ALCBLKSZ;<span class="comment">//逻辑储存块的大小为4KB</span></span><br><span class="line"><span class="comment">//位图块从第1个逻辑储存块开始，超级块占用第0个逻辑储存块</span></span><br><span class="line">initp-&gt;rsb_bmpbks = <span class="number">1</span>;</span><br><span class="line">initp-&gt;rsb_bmpbknr = <span class="number">0</span>;</span><br><span class="line">initp-&gt;rsb_fsysallblk = <span class="number">0</span>;</span><br><span class="line">rfsdir_t_init(&amp;initp-&gt;rsb_rootdir);<span class="comment">//初始化根目录</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">create_superblk</span><span class="params">(<span class="type">device_t</span> *devp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *buf = new_buf(FSYS_ALCBLKSZ);<span class="comment">//分配4KB大小的缓冲区，清零</span></span><br><span class="line">hal_memset(buf, <span class="number">0</span>, FSYS_ALCBLKSZ);</span><br><span class="line"><span class="comment">//使rfssublk_t结构的指针指向缓冲区并进行初始化</span></span><br><span class="line"><span class="type">rfssublk_t</span> *sbp = (<span class="type">rfssublk_t</span> *)buf;</span><br><span class="line">rfssublk_t_init(sbp);</span><br><span class="line"><span class="comment">//获取储存设备的逻辑储存块数并保存到超级块中</span></span><br><span class="line">sbp-&gt;rsb_fsysallblk = ret_rfsdevmaxblknr(devp);</span><br><span class="line"><span class="comment">//把缓冲区中超级块的数据写入到储存设备的第0个逻辑储存块中</span></span><br><span class="line"><span class="keyword">if</span> (write_rfsdevblk(devp, buf, <span class="number">0</span>) == DFCERRSTUS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">del_buf(buf, FSYS_ALCBLKSZ);<span class="comment">//释放缓冲区</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write_rfsdevblk 函数</span></span><br><span class="line"><span class="comment">//返回设备扩展数据结构</span></span><br><span class="line"><span class="type">rfsdevext_t</span>* <span class="title function_">ret_rfsdevext</span><span class="params">(<span class="type">device_t</span>* devp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">rfsdevext_t</span>*)devp-&gt;dev_extdata;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据块号返回储存设备的块地址</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">ret_rfsdevblk</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">uint_t</span> blknr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">rfsdevext_t</span>* rfsexp = ret_rfsdevext(devp);</span><br><span class="line"><span class="comment">//块号乘于块大小的结果再加上开始地址（用于模拟储存设备的内存空间的开始地址）</span></span><br><span class="line"><span class="type">void</span>* blkp = rfsexp-&gt;rde_mstart + (blknr*FSYS_ALCBLKSZ);</span><br><span class="line"><span class="comment">//如果该地址没有落在储存入设备的空间中，就返回NULL表示出错</span></span><br><span class="line"><span class="keyword">if</span>(blkp &gt;= (<span class="type">void</span>*)((<span class="type">size_t</span>)rfsexp-&gt;rde_mstart+rfsexp-&gt;rde_msize))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//返回块地址</span></span><br><span class="line"><span class="keyword">return</span> blkp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把4KB大小的缓冲区中的内容，写入到储存设备的某个逻辑储存块中</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">write_rfsdevblk</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* weadr,<span class="type">uint_t</span> blknr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//返回储存设备中第blknr块的逻辑存储块的地址</span></span><br><span class="line"><span class="type">void</span>* p = ret_rfsdevblk(devp,blknr);</span><br><span class="line"><span class="comment">//复制数据到逻辑储存块中</span></span><br><span class="line">hal_memcpy(weadr,p,FSYS_ALCBLKSZ);</span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// 建立位图</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">//把逻辑储存块中的数据，读取到4KB大小的缓冲区中</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">read_rfsdevblk</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* rdadr,<span class="type">uint_t</span> blknr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取逻辑储存块地址</span></span><br><span class="line"><span class="type">void</span>* p=ret_rfsdevblk(devp,blknr);</span><br><span class="line"><span class="comment">//把逻辑储存块中的数据复制到缓冲区中</span></span><br><span class="line">hal_memcpy(p,rdadr,FSYS_ALCBLKSZ);</span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取超级块</span></span><br><span class="line"><span class="type">rfssublk_t</span>* <span class="title function_">get_superblk</span><span class="params">(<span class="type">device_t</span>* devp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//分配4KB大小的缓冲区</span></span><br><span class="line"><span class="type">void</span>* buf=new_buf(FSYS_ALCBLKSZ);</span><br><span class="line"><span class="comment">//清零缓冲区</span></span><br><span class="line">hal_memset(buf,FSYS_ALCBLKSZ,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//读取第0个逻辑储存块中的数据到缓冲区中，如果读取失败则释放缓冲区</span></span><br><span class="line">read_rfsdevblk(devp,buf,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//返回超级块数据结构的地址，即缓冲区的首地址</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">rfssublk_t</span>*)buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放超级块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_superblk</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">rfssublk_t</span>* sbp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//回写超级块，因为超级块中的数据可能已经发生了改变，如果出错则死机</span></span><br><span class="line">write_rfsdevblk(devp,(<span class="type">void</span>*)sbp,<span class="number">0</span>);<span class="comment">//释放先前分配的4KB大小的缓冲区</span></span><br><span class="line">del_buf((<span class="type">void</span>*)sbp,FSYS_ALCBLKSZ);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立位图</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">create_bitmap</span><span class="params">(<span class="type">device_t</span>* devp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool_t</span> rets=FALSE;</span><br><span class="line"><span class="comment">//获取超级块，失败则返回FALSE</span></span><br><span class="line"><span class="type">rfssublk_t</span>* sbp = get_superblk(devp);</span><br><span class="line"><span class="comment">//分配4KB大小的缓冲区</span></span><br><span class="line"><span class="type">void</span>* buf = new_buf(FSYS_ALCBLKSZ);</span><br><span class="line"><span class="comment">//获取超级块中位图块的开始块号</span></span><br><span class="line"><span class="type">uint_t</span> bitmapblk=sbp-&gt;rsb_bmpbks;</span><br><span class="line"><span class="comment">//获取超级块中储存介质的逻辑储存块总数</span></span><br><span class="line"><span class="type">uint_t</span> devmaxblk=sbp-&gt;rsb_fsysallblk;</span><br><span class="line"><span class="comment">//如果逻辑储存块总数大于4096，就认为出错了</span></span><br><span class="line"><span class="keyword">if</span>(devmaxblk&gt;FSYS_ALCBLKSZ)</span><br><span class="line">&#123;</span><br><span class="line">rets=FALSE;</span><br><span class="line"><span class="keyword">goto</span> errlable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把缓冲区中每个字节都置成1</span></span><br><span class="line">hal_memset(buf,FSYS_ALCBLKSZ,<span class="number">1</span>);</span><br><span class="line"><span class="type">u8_t</span>* bitmap=(<span class="type">u8_t</span>*)buf;</span><br><span class="line"><span class="comment">//把缓冲区中的第3个字节到第devmaxblk个字节都置成0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint_t</span> bi=<span class="number">2</span>;bi&lt;devmaxblk;bi++)</span><br><span class="line">&#123;</span><br><span class="line">bitmap[bi]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把缓冲区中的数据写入到储存介质中的第bitmapblk个逻辑储存块中，即位图块中</span></span><br><span class="line"><span class="keyword">if</span>(write_rfsdevblk(devp,buf,bitmapblk)==DFCERRSTUS)&#123;</span><br><span class="line">rets = FALSE;</span><br><span class="line"><span class="keyword">goto</span> errlable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置返回状态</span></span><br><span class="line">rets=TRUE;</span><br><span class="line">errlable:</span><br><span class="line"><span class="comment">//释放超级块</span></span><br><span class="line">del_superblk(devp,sbp);</span><br><span class="line"><span class="comment">//释放缓冲区</span></span><br><span class="line">del_buf(buf,FSYS_ALCBLKSZ);</span><br><span class="line"><span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 建立根目录</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 辅助功能函数，实现获取 / 释放位图块的代码</span></span><br><span class="line"><span class="comment">//获取位图块</span></span><br><span class="line"><span class="type">u8_t</span>* <span class="title function_">get_bitmapblk</span><span class="params">(<span class="type">device_t</span>* devp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取超级块</span></span><br><span class="line"><span class="type">rfssublk_t</span>* sbp = get_superblk(devp);</span><br><span class="line"><span class="comment">//分配4KB大小的缓冲区</span></span><br><span class="line"><span class="type">void</span>* buf = new_buf(FSYS_ALCBLKSZ);</span><br><span class="line"><span class="comment">//缓冲区清零</span></span><br><span class="line">hal_memset(buf, FSYS_ALCBLKSZ, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//读取sbp-&gt;rsb_bmpbks块（位图块），到缓冲区中</span></span><br><span class="line">read_rfsdevblk(devp, buf, sbp-&gt;rsb_bmpbks)</span><br><span class="line"><span class="comment">//释放超级块</span></span><br><span class="line">del_superblk(devp, sbp);</span><br><span class="line"><span class="comment">//返回缓冲区的首地址</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">u8_t</span>*)buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放位图块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_bitmapblk</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">u8_t</span>* bitmap)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取超级块</span></span><br><span class="line"><span class="type">rfssublk_t</span>* sbp = get_superblk(devp);</span><br><span class="line"><span class="comment">//回写位图块，因为位图块中的数据可能已经发生改变</span></span><br><span class="line">write_rfsdevblk(devp, (<span class="type">void</span>*)bitmap, sbp-&gt;rsb_bmpbks)</span><br><span class="line"><span class="comment">//释放超级块和存放位图块的缓冲区</span></span><br><span class="line">del_superblk(devp, sbp);</span><br><span class="line">del_buf((<span class="type">void</span>*)bitmap, FSYS_ALCBLKSZ);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配新的空闲逻辑储存块</span></span><br><span class="line"><span class="type">uint_t</span> <span class="title function_">rfs_new_blk</span><span class="params">(<span class="type">device_t</span>* devp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint_t</span> retblk=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取位图块</span></span><br><span class="line"><span class="type">u8_t</span>* bitmap = get_bitmapblk(devp);</span><br><span class="line"><span class="keyword">if</span>(bitmap == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint_t</span> blknr = <span class="number">2</span>; blknr &lt; FSYS_ALCBLKSZ; blknr++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到一个为0的字节就置为1，并返回该字节对应的空闲块号</span></span><br><span class="line"><span class="keyword">if</span>(bitmap[blknr] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">bitmap[blknr] = <span class="number">1</span>;</span><br><span class="line">retblk = blknr;</span><br><span class="line"><span class="keyword">goto</span> retl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果到这里就说明没有空闲块了，所以返回0</span></span><br><span class="line">retblk=<span class="number">0</span>;</span><br><span class="line">retl:</span><br><span class="line"><span class="comment">//释放位图块</span></span><br><span class="line">del_bitmapblk(devp,bitmap);</span><br><span class="line"><span class="keyword">return</span> retblk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立根目录</span></span><br><span class="line"><span class="type">bool_t</span> <span class="title function_">create_rootdir</span><span class="params">(<span class="type">device_t</span>* devp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool_t</span> rets = FALSE;</span><br><span class="line">  <span class="comment">//获取超级块</span></span><br><span class="line">  <span class="type">rfssublk_t</span>* sbp = get_superblk(devp);</span><br><span class="line">  <span class="comment">//分配4KB大小的缓冲区</span></span><br><span class="line">  <span class="type">void</span>* buf = new_buf(FSYS_ALCBLKSZ);</span><br><span class="line">  <span class="comment">//缓冲区清零</span></span><br><span class="line">  hal_memset(buf,FSYS_ALCBLKSZ,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//分配一个空闲的逻辑储存块</span></span><br><span class="line">  <span class="type">uint_t</span> blk = rfs_new_blk(devp);</span><br><span class="line">  <span class="keyword">if</span>(blk == <span class="number">0</span>) &#123;</span><br><span class="line">    rets = FALSE;</span><br><span class="line">    <span class="keyword">goto</span> errlable;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置超级块中的rfsdir_t结构中的名称为“/”</span></span><br><span class="line">  sbp-&gt;rsb_rootdir.rdr_name[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="comment">//设置超级块中的rfsdir_t结构中的类型为目录类型</span></span><br><span class="line">  sbp-&gt;rsb_rootdir.rdr_type = RDR_DIR_TYPE;</span><br><span class="line">  <span class="comment">//设置超级块中的rfsdir_t结构中的块号为新分配的空闲逻辑储存块的块号</span></span><br><span class="line">  sbp-&gt;rsb_rootdir.rdr_blknr = blk;</span><br><span class="line">  <span class="type">fimgrhd_t</span>* fmp = (<span class="type">fimgrhd_t</span>*)buf;</span><br><span class="line">  <span class="comment">//初始化fimgrhd_t结构</span></span><br><span class="line">  fimgrhd_t_init(fmp);</span><br><span class="line">  <span class="comment">//因为这是目录文件所以fimgrhd_t结构的类型设置为目录类型</span></span><br><span class="line">  fmp-&gt;fmd_type = FMD_DIR_TYPE;</span><br><span class="line">  <span class="comment">//fimgrhd_t结构自身所在的块设置为新分配的空闲逻辑储存块</span></span><br><span class="line">  fmp-&gt;fmd_sfblk = blk;</span><br><span class="line">  <span class="comment">//fimgrhd_t结构中正在写入的块设置为新分配的空闲逻辑储存块</span></span><br><span class="line">  fmp-&gt;fmd_curfwritebk = blk;</span><br><span class="line">  <span class="comment">//fimgrhd_t结构中正在写入的块的偏移设置为512字节</span></span><br><span class="line">  fmp-&gt;fmd_curfinwbkoff = <span class="number">0x200</span>;</span><br><span class="line">  <span class="comment">//设置文件数据占有块数组的第0个元素</span></span><br><span class="line">  fmp-&gt;fmd_fleblk[<span class="number">0</span>].fb_blkstart = blk;</span><br><span class="line">  fmp-&gt;fmd_fleblk[<span class="number">0</span>].fb_blknr = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//把缓冲区中的数据写入到新分配的空闲逻辑储存块中，其中包含已经设置好的 fimgrhd_t结</span></span><br><span class="line">  <span class="keyword">if</span>(write_rfsdevblk(devp, buf, blk) == DFCERRSTUS) &#123;</span><br><span class="line">    rets = FALSE;</span><br><span class="line">    <span class="keyword">goto</span> errlable;</span><br><span class="line">  &#125;</span><br><span class="line">  rets = TRUE;</span><br><span class="line">  errlable:</span><br><span class="line">  <span class="comment">//释放缓冲区</span></span><br><span class="line">  del_buf(buf, FSYS_ALCBLKSZ);</span><br><span class="line">  errlable1:</span><br><span class="line">  <span class="comment">//释放超级块</span></span><br><span class="line">  del_superblk(devp, sbp);</span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----</span></span><br><span class="line"><span class="comment">// 串联</span></span><br><span class="line"><span class="comment">// ----</span></span><br><span class="line"><span class="comment">//rfs初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_rfs</span><span class="params">(<span class="type">device_t</span> *devp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//格式化rfs</span></span><br><span class="line">rfs_fmat(devp);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rfs格式化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rfs_fmat</span><span class="params">(<span class="type">device_t</span> *devp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//建立超级块</span></span><br><span class="line"><span class="keyword">if</span> (create_superblk(devp) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line">hal_sysdie(<span class="string">&quot;create superblk err&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立位图</span></span><br><span class="line"><span class="keyword">if</span> (create_bitmap(devp) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line">hal_sysdie(<span class="string">&quot;create bitmap err&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立根目录</span></span><br><span class="line"><span class="keyword">if</span> (create_rootdir(devp) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line">hal_sysdie(<span class="string">&quot;create rootdir err&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rfs驱动程序入口</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_entry</span><span class="params">(<span class="type">driver_t</span> *drvp, <span class="type">uint_t</span> val, <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">init_rfs(devp);<span class="comment">//初始化rfs</span></span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// 测试文件系统超级块</span></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">//测试文件系统超级块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_rfs_superblk</span><span class="params">(<span class="type">device_t</span> *devp)</span></span><br><span class="line">&#123;</span><br><span class="line">kprint(<span class="string">&quot;开始文件系统超级块测试\n&quot;</span>);</span><br><span class="line"><span class="type">rfssublk_t</span> *sbp = get_superblk(devp);</span><br><span class="line">kprint(<span class="string">&quot;文件系统标识:%d,版本:%d\n&quot;</span>, sbp-&gt;rsb_mgic, sbp-&gt;rsb_vec);</span><br><span class="line">kprint(<span class="string">&quot;文件系统超级块占用的块数:%d,逻辑储存块大小:%d\n&quot;</span>, sbp-&gt;rsb_sblksz, sbp-&gt;</span><br><span class="line">kprint(<span class="string">&quot;文件系统位图块号:%d,文件系统整个逻辑储存块数:%d\n&quot;</span>, sbp-&gt;rsb_bmpbks, sbpkprint(<span class="string">&quot;文件系统根目录块号:%d 类型:%d\n&quot;</span>, sbp-&gt;rsb_rootdir.rdr_blknr, sbp-&gt;rsb</span><br><span class="line">kprint(<span class="string">&quot;文件系统根目录名称:%s\n&quot;</span>, sbp-&gt;rsb_rootdir.rdr_name);</span><br><span class="line">del_superblk(devp, sbp);</span><br><span class="line">hal_sysdie(<span class="string">&quot;结束文件系统超级块测试&quot;</span>);<span class="comment">//死机用于观察测试结果</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rfs驱动程序入口</span></span><br><span class="line"><span class="type">drvstus_t</span> rfs_entry(<span class="type">driver_t</span> *drvp, <span class="type">uint_t</span> val, <span class="type">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">init_rfs(devp);<span class="comment">//初始化rfs</span></span><br><span class="line">test_rfs_superblk(devp);<span class="comment">//测试文件系统超级块</span></span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="comment">// 测试文件系统位图</span></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="comment">// 需要在 rfs_entry 函数的末尾调用</span></span><br><span class="line"><span class="type">void</span> test_rfs_bitmap(<span class="type">device_t</span> *devp)</span><br><span class="line">&#123;</span><br><span class="line">kprint(<span class="string">&quot;开始文件系统位图测试\n&quot;</span>);</span><br><span class="line"><span class="type">void</span> *buf = new_buf(FSYS_ALCBLKSZ);</span><br><span class="line">hal_memset(buf, <span class="number">0</span>, FSYS_ALCBLKSZ);</span><br><span class="line">read_rfsdevblk(devp, buf, <span class="number">1</span>)<span class="comment">//读取位图块</span></span><br><span class="line"><span class="type">u8_t</span> *bmp = (<span class="type">u8_t</span> *)buf;</span><br><span class="line"><span class="type">uint_t</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//扫描位图块</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint_t</span> i = <span class="number">0</span>; i &lt; FSYS_ALCBLKSZ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bmp[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">b++;<span class="comment">//记录空闲块</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kprint(<span class="string">&quot;文件系统空闲块数:%d\n&quot;</span>, b);</span><br><span class="line">del_buf(buf, FSYS_ALCBLKSZ);</span><br><span class="line">hal_sysdie(<span class="string">&quot;结束文件系统位图测试\n&quot;</span>);<span class="comment">//死机用于观察测试结果</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// 测试文件系统根目录</span></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// 需要在 rfs_entry 函数的末尾调用</span></span><br><span class="line"><span class="type">void</span> test_rfs_rootdir(<span class="type">device_t</span> *devp)</span><br><span class="line">&#123;</span><br><span class="line">kprint(<span class="string">&quot;开始文件系统根目录测试\n&quot;</span>);</span><br><span class="line"><span class="type">rfsdir_t</span> *dr = get_rootdir(devp);</span><br><span class="line"><span class="type">void</span> *buf = new_buf(FSYS_ALCBLKSZ);</span><br><span class="line">hal_memset(buf, <span class="number">0</span>, FSYS_ALCBLKSZ);</span><br><span class="line">read_rfsdevblk(devp, buf, dr-&gt;rdr_blknr)</span><br><span class="line"><span class="type">fimgrhd_t</span> *fmp = (<span class="type">fimgrhd_t</span> *)buf;</span><br><span class="line">kprint(<span class="string">&quot;文件管理头类型:%d 文件数据大小:%d 文件在开始块中偏移:%d 文件在结束块中的偏移:</span></span><br><span class="line"><span class="string">fmp-&gt;fmd_type, fmp-&gt;fmd_filesz, fmp-&gt;fmd_fileifstbkoff, fmp-&gt;fmd_f</span></span><br><span class="line"><span class="string">kprint(&quot;</span>文件第一组开始块号:%d 块数:%d\n<span class="string">&quot;, fmp-&gt;fmd_fleblk[0].fb_blkstart, fmpdel_buf(buf, FSYS_ALCBLKSZ);</span></span><br><span class="line"><span class="string">del_rootdir(devp, dr);</span></span><br><span class="line"><span class="string">hal_sysdie(&quot;</span>结束文件系统根目录测试\n<span class="string">&quot;);//死机用于观察测试结果</span></span><br><span class="line"><span class="string">return;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="93-如何实现文件的六大基础操作"><a class="markdownIt-Anchor" href="#93-如何实现文件的六大基础操作"></a> 9.3 如何实现文件的六大基础操作</h2>
<ul>
<li><strong>操作根目录文件</strong>
<ul>
<li>不管是新建,删除,打开一个文件,首先都要找到与该文件对应的 rfsdir_t 结构</li>
<li>一个文件的 rfsdir_t 结构储存在根目录文件中,故需要获取和释放根目录文件</li>
<li>获取根目录文件:根据超级块中的 rfsdir_t 结构中的信息,读取根目录文件的逻辑储存块即可
<ul>
<li>get_rootdir函数:读取文件系统超级块中 rfsdir_t 结构到一个缓冲区</li>
</ul>
</li>
<li>释放根目录文件:把根目录中的储存块回写到储存设备中,最后释放对应的缓冲器即可
<ul>
<li>del_rootdir函数:释放缓冲区</li>
</ul>
</li>
</ul>
</li>
<li><strong>获取文件名</strong>
<ul>
<li>实现去除路径分隔符提取文件名称</li>
<li>rfs_chkfilepath 函数检查路径名是不是/xxx形式,<strong>实现获取文件名的必要前提</strong></li>
<li>rfs_ret_fname 函数可以把 fpath 指向的路径名中的文件名提取出来,放到buf指向的缓冲区中</li>
</ul>
</li>
<li><strong>判断文件是否存在</strong>
<ul>
<li>rfs_chkfileisindev 函数首先检查文件名的长度,接着获取根目录文件,然后遍历根目录中所有 rfsdir_t 结构并比较文件名是否相同,相同返回1,最后释放根目录文件</li>
<li>get_rootdirfile_blk 函数已将根目录文件读取到内存里,故可用 dirp 指针和 maxchkp 指针操作其中的数据</li>
</ul>
</li>
<li><strong>新建文件</strong>
<ul>
<li>分成4步进行:
<ul>
<li>从文件路径名中提取出纯文件名,检查储存设备上是否存在该文件</li>
<li>分配一个空闲的逻辑储存块，并在根目录文件的末尾写入新建文件对应的 rfsdir_t结构</li>
<li>在一个新的4KB大小的缓冲区中初始化新建文件对应的 fimgrhd_t 结构</li>
<li>把第3步对应的缓冲区里的数据写入到先前分配的空间逻辑储存块中</li>
</ul>
</li>
<li>rfs_new_dirfileblk 函数两个关键点:
<ul>
<li>目录文件中存放的就是一系列的 rfsdir_t 结构</li>
<li>fmp 和 ffmp 这两个指针很重要
<ul>
<li>fmp 指针指向的是根目录文件的 fimgrhd_t 结构，因为要写入一个新的 rfsdir_t 结构，所以要获取并改写根目录文件的 fimgrhd_t 结构中的数据</li>
<li>ffmp 指针指向的是新建文件的 fimgrhd_t 结构，并且初始化了其中的一些数据。最后，该函数把这个缓冲区中的数据写入到分配的空闲逻辑储存块中，同时释放了根目录文件和缓冲区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>删除文件</strong>
<ul>
<li>分成4步进行
<ul>
<li>从文件路径中提取出纯文件名</li>
<li>获取根目录文件,从根目录文件中查找待删除文件的 rfsdir_t 结构,然后释放该文件占用的逻辑储存块</li>
<li>初始化与待删除文件对应的 rfsdir_t 结构，并设置 rfsdir_t结构的类型为 RDR_DEL_TYPE</li>
<li>释放根目录文件</li>
</ul>
</li>
<li>删除一个文件，就是把这个文件对应的 rfsdir_t 结构中的数据清空(无法查找到文件)</li>
<li>同时要释放该文件占用的逻辑储存块(避免反删除软件找回文件)</li>
</ul>
</li>
<li><strong>打开文件</strong>
<ul>
<li>Cosmos 内核上层组件调用设备驱动程序时，都需要建立一个相应的 objnode_t 结构，把I/O包发送给相应的驱动程序，但是 objnode_t 结构不仅仅是用于驱动程序，它还用于表示进程使用了哪些资源，例如打开了哪些设备或者文件，而每打开一个设备或者文件就建立一个 objnode_t 结构，放在特定进程的资源表中</li>
<li>为了适应文件系统设备驱动程序，在 cosmos/include/krlinc/krlobjnode_t.h 文件中需要在 objnode_t 结构中增加一些东西
<ul>
<li>objnode_t 结构里增加了两个字段，指向文件路径名的指针表示打开哪个文件；增加了指向对应文件的 fimgrhd_t 结构指针</li>
</ul>
</li>
<li><strong>打开文件的四步</strong>
<ul>
<li>从 objnode_t 结构的文件路径提取文件名</li>
<li>获取根目录文件，在该文件中搜索对应的 rfsdir_t 结构，看看文件是否存在</li>
<li>分配一个 4KB 缓存区，把该文件对应的 rfsdir_t 结构中指向的逻辑储存块读取到缓存区中，然后释放根目录文件</li>
<li>把缓冲区中的 fimgrhd_t 结构的地址，保存到 objnode_t 结构的 on_finode 域中</li>
</ul>
</li>
<li>通过 rfs_openfileblk 函数中的 for 循环，可以遍历要打开的文件在根目录文件中对应的 rfsdir_t 结构，然后把对应文件占用的逻辑储存块读取到缓冲区中，最后返回这个缓冲区的首地址;因为这个缓冲区开始的空间中，就存放着其文件对应的 fimgrhd_t 结构，所以返回fimgrhd_t 结构的地址，整个打开文件的流程就结束了</li>
</ul>
</li>
<li><strong>读写文件</strong>
<ul>
<li>读取已经打开的文件的大致流程:
<ul>
<li>检查 objnode_t 结构中用于存放文件数据的缓冲区及其大小</li>
<li>检查 imgrhd_t 结构中文件相关的信息</li>
<li>把文件的数据读取到 objnode_t 结构中指向的缓冲区中</li>
</ul>
</li>
<li>写文件:将写入的数据复制到打开文件时为其分配的缓存区中,最后把打开文件时为其分配的缓冲区中的数据写入到相应的逻辑储存块中
<ul>
<li>rfs_writefileblk 函数永远都是从 fimgrhd_t 结构的  fmd_curfinwbkoff 字段中的偏移量开始写入文件数据的，为<strong>追加写入数据</strong>方式;函数最后调用 write_rfsdevblk函数把文件数据写入到相应的逻辑储存块中完成数据同步</li>
</ul>
</li>
</ul>
</li>
<li><strong>关闭文件</strong>
<ul>
<li>流程:
<ul>
<li>首先检查文件是否打开</li>
<li>然后把文件写入到对应的逻辑储存块中,完成数据的同步</li>
<li>最后释放文件数据占用的缓冲区</li>
</ul>
</li>
<li>rfs_closefileblk 函数没有必要调用write_rfsdevblk 函数，因为前面在写入文件数据的同时，就已经把文件的数据写入到逻辑储存块中。最后释放了先前打开文件时分配的缓冲区，而 objnode_t 结构不应该在此释放，它是由 Cosmos 内核上层组件进行释放的</li>
</ul>
</li>
<li><strong>测试</strong>
<ul>
<li><strong>cosmos下任何设备驱动程序都必须要有 objnode_t 结构才能运行</strong>
<ul>
<li>故手动建立 objnode_t 结构并设置好其中字段进行测试</li>
</ul>
</li>
<li>测试逻辑：开始会建立并打开一个文件，接着写入数据，然后读取文件中数据进行比较，看看是不是和之前写入的数据相等，最后删除这个文件并再次打开，看是否会出错。因为文件已经删除了，打开一个已经删除的文件自然要出错，出错就说明测试成功
<ul>
<li><strong>把 test_fsys 函数放在 rfs_entry 函数的最后调用进行测试</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 操作根目录文件</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">//获取根目录文件</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">get_rootdirfile_blk</span><span class="params">(<span class="type">device_t</span>* devp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* retptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">rfsdir_t</span>* rtdir = get_rootdir(devp);<span class="comment">//获取根目录文件的rfsdir_t结构</span></span><br><span class="line"><span class="comment">//分配4KB大小的缓冲区并清零</span></span><br><span class="line"><span class="type">void</span>* buf = new_buf(FSYS_ALCBLKSZ);</span><br><span class="line">hal_memset(buf, FSYS_ALCBLKSZ, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//读取根目录文件的逻辑储存块到缓冲区中</span></span><br><span class="line">read_rfsdevblk(devp, buf, rtdir-&gt;rdr_blknr)</span><br><span class="line">retptr = buf;<span class="comment">//设置缓冲区的首地址为返回值</span></span><br><span class="line"><span class="keyword">goto</span> errl1;</span><br><span class="line">errl:</span><br><span class="line">del_buf(buf, FSYS_ALCBLKSZ);</span><br><span class="line">errl1:</span><br><span class="line">del_rootdir(devp, rtdir);<span class="comment">//释放根目录文件的rfsdir_t结构</span></span><br><span class="line"><span class="keyword">return</span> retptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放根目录文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_rootdirfile_blk</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* blkp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//因为逻辑储存块的头512字节的空间中，保存的就是fimgrhd_t结构</span></span><br><span class="line"><span class="type">fimgrhd_t</span>* fmp = (<span class="type">fimgrhd_t</span>*)blkp;</span><br><span class="line"><span class="comment">//把根目录文件回写到储存设备中去，块号为fimgrhd_t结构自身所在的块号</span></span><br><span class="line">write_rfsdevblk(devp, blkp, fmp-&gt;fmd_sfblk)</span><br><span class="line"><span class="comment">//释放缓冲区</span></span><br><span class="line">del_buf(blkp, FSYS_ALCBLKSZ);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 获取文件名</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">//检查文件路径名</span></span><br><span class="line"><span class="type">sint_t</span> <span class="title function_">rfs_chkfilepath</span><span class="params">(<span class="type">char_t</span>* fname)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char_t</span>* chp = fname;</span><br><span class="line"><span class="comment">//检查文件路径名的第一个字符是否为“/”，不是则返回2</span></span><br><span class="line"><span class="keyword">if</span>(chp[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint_t</span> i = <span class="number">1</span>; ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查除第1个字符外其它字符中还有没有为“/”的，有就返回3</span></span><br><span class="line"><span class="keyword">if</span>(chp[i] == <span class="string">&#x27;/&#x27;</span>) &#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line"><span class="comment">//如果这里i大于等于文件名称的最大长度，就返回4</span></span><br><span class="line"><span class="keyword">if</span>(i &gt;= DR_NM_MAX) &#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line"><span class="comment">//到文件路径字符串的末尾就跳出循环</span></span><br><span class="line"><span class="keyword">if</span>(chp[i] == <span class="number">0</span> &amp;&amp; i &gt; <span class="number">1</span>) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回0表示正确</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提取纯文件名</span></span><br><span class="line"><span class="type">sint_t</span> <span class="title function_">rfs_ret_fname</span><span class="params">(<span class="type">char_t</span>* buf,<span class="type">char_t</span>* fpath)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查文件路径名是不是“/xxxx”的形式</span></span><br><span class="line"><span class="type">sint_t</span> stus = rfs_chkfilepath(fpath);</span><br><span class="line"><span class="comment">//如果不为0就直接返回这个状态值表示错误</span></span><br><span class="line"><span class="keyword">if</span>(stus != <span class="number">0</span>) &#123; <span class="keyword">return</span> stus; &#125;</span><br><span class="line"><span class="comment">//从路径名字符串的第2个字符开始复制字符到buf中</span></span><br><span class="line">rfs_strcpy(&amp;fpath[<span class="number">1</span>], buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="comment">// 判断文件是否存在</span></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="type">sint_t</span> <span class="title function_">rfs_chkfileisindev</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">char_t</span>* fname)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">sint_t</span> rets = <span class="number">6</span>;</span><br><span class="line"><span class="type">sint_t</span> ch = rfs_strlen(fname);<span class="comment">//获取文件名的长度，注意不是文件路径名</span></span><br><span class="line"><span class="comment">//检查文件名的长度是不是合乎要求</span></span><br><span class="line"><span class="keyword">if</span>(ch &lt; <span class="number">1</span> || ch &gt;= (<span class="type">sint_t</span>)DR_NM_MAX) &#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line"><span class="type">void</span>* rdblkp = get_rootdirfile_blk(devp);</span><br><span class="line"><span class="type">fimgrhd_t</span>* fmp = (<span class="type">fimgrhd_t</span>*)rdblkp;</span><br><span class="line"><span class="comment">//检查该fimgrhd_t结构的类型是不是FMD_DIR_TYPE，即这个文件是不是目录文件</span></span><br><span class="line"><span class="keyword">if</span>(fmp-&gt;fmd_type != FMD_DIR_TYPE) &#123; rets = <span class="number">3</span>; <span class="keyword">goto</span> err; &#125;</span><br><span class="line"><span class="comment">//检查根目录文件是不是为空，即没有写入任何数据，所以返回0，表示根目录下没有对应的文件</span></span><br><span class="line"><span class="keyword">if</span>(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[<span class="number">0</span>].fb_blkstart &amp;&amp;</span><br><span class="line">fmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) &#123;</span><br><span class="line">rets = <span class="number">0</span>; <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">rfsdir_t</span>* dirp = (<span class="type">rfsdir_t</span>*)((<span class="type">uint_t</span>)(fmp) + fmp-&gt;fmd_fileifstbkoff);<span class="comment">//指向</span></span><br><span class="line"><span class="comment">//指向根目录文件的结束地址</span></span><br><span class="line"><span class="type">void</span>* maxchkp = (<span class="type">void</span>*)((<span class="type">uint_t</span>)rdblkp + FSYS_ALCBLKSZ - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//当前的rfsdir_t结构的指针比根目录文件的结束地址小，就继续循环</span></span><br><span class="line"><span class="keyword">for</span>(;(<span class="type">void</span>*)dirp &lt; maxchkp;) &#123;</span><br><span class="line"><span class="comment">//如果这个rfsdir_t结构的类型是RDR_FIL_TYPE，说明它对应的是文件而不是目录，所以下</span></span><br><span class="line"><span class="keyword">if</span>(dirp-&gt;rdr_type == RDR_FIL_TYPE) &#123;</span><br><span class="line"><span class="keyword">if</span>(rfs_strcmp(dirp-&gt;rdr_name,fname) == <span class="number">1</span>) &#123;<span class="comment">//比较其文件名</span></span><br><span class="line">rets = <span class="number">1</span>; <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dirp++;</span><br><span class="line">&#125;</span><br><span class="line">rets = <span class="number">0</span>; <span class="comment">//到了这里说明没有找到相同的文件</span></span><br><span class="line">err:</span><br><span class="line">del_rootdirfile_blk(devp,rdblkp);<span class="comment">//释放根目录文件</span></span><br><span class="line"><span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 新建文件</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">//新建文件的接口函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_new_file</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">char_t</span>* fname, <span class="type">uint_t</span> flg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在栈中分配一个字符缓冲区并清零</span></span><br><span class="line"><span class="type">char_t</span> fne[DR_NM_MAX];</span><br><span class="line">hal_memset((<span class="type">void</span>*)fne, DR_NM_MAX, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//从文件路径名中提取出纯文件名</span></span><br><span class="line"><span class="keyword">if</span>(rfs_ret_fname(fne, fname) != <span class="number">0</span>) &#123; <span class="keyword">return</span> DFCERRSTUS; &#125;</span><br><span class="line"><span class="comment">//检查储存介质上是否已经存在这个新建的文件，如果是则返回错误</span></span><br><span class="line"><span class="keyword">if</span>(rfs_chkfileisindev(devp, fne) != <span class="number">0</span>) &#123;<span class="keyword">return</span> DFCERRSTUS; &#125;</span><br><span class="line"><span class="comment">//调用实际建立文件的函数</span></span><br><span class="line"><span class="keyword">return</span> rfs_new_dirfileblk(devp, fne, RDR_FIL_TYPE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建文件的函数 rfs_new_dirfileblk</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_new_dirfileblk</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">char_t</span>* fname,<span class="type">uint_t</span> flgtype,<span class="type">uint_t</span> flg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">drvstus_t</span> rets = DFCERRSTUS;</span><br><span class="line"><span class="type">void</span>* buf = new_buf(FSYS_ALCBLKSZ);<span class="comment">//分配一个4KB大小的缓冲区</span></span><br><span class="line">hal_memset(buf, FSYS_ALCBLKSZ, <span class="number">0</span>);<span class="comment">//清零该缓冲区</span></span><br><span class="line"><span class="type">uint_t</span> fblk = rfs_new_blk(devp);<span class="comment">//分配一个新的空闲逻辑储存块</span></span><br><span class="line"><span class="type">void</span>* rdirblk = get_rootdirfile_blk(devp);<span class="comment">//获取根目录文件</span></span><br><span class="line"><span class="type">fimgrhd_t</span>* fmp = (<span class="type">fimgrhd_t</span>*)rdirblk;</span><br><span class="line"><span class="comment">//指向文件当前的写入地址，因为根目录文件已经被读取到内存中了</span></span><br><span class="line"><span class="type">rfsdir_t</span>* wrdirp = (<span class="type">rfsdir_t</span>*)((<span class="type">uint_t</span>)rdirblk + fmp-&gt;fmd_curfinwbkoff);</span><br><span class="line"><span class="comment">//对文件当前的写入地址进行检查</span></span><br><span class="line"><span class="keyword">if</span>(((<span class="type">uint_t</span>)wrdirp) &gt;= ((<span class="type">uint_t</span>)rdirblk + FSYS_ALCBLKSZ)) &#123;</span><br><span class="line">rets=DFCERRSTUS; <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">wrdirp-&gt;rdr_stus = <span class="number">0</span>;</span><br><span class="line">wrdirp-&gt;rdr_type = flgtype;<span class="comment">//设为文件类型</span></span><br><span class="line">wrdirp-&gt;rdr_blknr = fblk;<span class="comment">//设为刚刚分配的空闲逻辑储存块</span></span><br><span class="line">rfs_strcpy(fname, wrdirp-&gt;rdr_name);<span class="comment">//把文件名复制到rfsdir_t结构</span></span><br><span class="line">fmp-&gt;fmd_filesz += (<span class="type">uint_t</span>)(<span class="keyword">sizeof</span>(<span class="type">rfsdir_t</span>));<span class="comment">//增加根目录文件的大小</span></span><br><span class="line"><span class="comment">//增加根目录文件当前的写入地址，保证下次不被覆盖</span></span><br><span class="line">fmp-&gt;fmd_curfinwbkoff += (<span class="type">uint_t</span>)(<span class="keyword">sizeof</span>(<span class="type">rfsdir_t</span>));</span><br><span class="line"><span class="type">fimgrhd_t</span>* ffmp = (<span class="type">fimgrhd_t</span>*)buf;<span class="comment">//指向新分配的缓冲区</span></span><br><span class="line">fimgrhd_t_init(ffmp);<span class="comment">//调用fimgrhd_t结构默认的初始化函数</span></span><br><span class="line">ffmp-&gt;fmd_type = FMD_FIL_TYPE;<span class="comment">//因为建立的是文件，所以设为文件类型</span></span><br><span class="line">ffmp-&gt;fmd_sfblk = fblk;<span class="comment">//把自身所在的块，设为分配的逻辑储存块</span></span><br><span class="line">ffmp-&gt;fmd_curfwritebk = fblk;<span class="comment">//把当前写入的块，设为分配的逻辑储存块</span></span><br><span class="line">ffmp-&gt;fmd_curfinwbkoff = <span class="number">0x200</span>;<span class="comment">//把当前写入块的写入偏移量设为512</span></span><br><span class="line"><span class="comment">//把文件储存块数组的第1个元素的开始块，设为刚刚分配的空闲逻辑储存块</span></span><br><span class="line">ffmp-&gt;fmd_fleblk[<span class="number">0</span>].fb_blkstart = fblk;</span><br><span class="line"><span class="comment">//因为只分配了一个逻辑储存块，所以设为1</span></span><br><span class="line">ffmp-&gt;fmd_fleblk[<span class="number">0</span>].fb_blknr = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//把缓冲区中的数据写入到刚刚分配的空闲逻辑储存块中</span></span><br><span class="line"><span class="keyword">if</span>(write_rfsdevblk(devp, buf, fblk) == DFCERRSTUS) &#123;</span><br><span class="line">rets = DFCERRSTUS; <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">rets = DFCOKSTUS;</span><br><span class="line">err:</span><br><span class="line">del_rootdirfile_blk(devp, rdirblk);<span class="comment">//释放根目录文件</span></span><br><span class="line">err1:</span><br><span class="line">del_buf(buf, FSYS_ALCBLKSZ);<span class="comment">//释放缓冲区</span></span><br><span class="line"><span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 删除文件</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">//文件删除的接口函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_del_file</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">char_t</span>* fname, <span class="type">uint_t</span> flg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flg != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rfs_del_dirfileblk(devp, fname, RDR_FIL_TYPE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_del_dirfileblk</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">char_t</span>* fname, <span class="type">uint_t</span> flgtype, <span class="type">uint_t</span> flg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(flgtype != RDR_FIL_TYPE || val != <span class="number">0</span>) &#123; <span class="keyword">return</span> DFCERRSTUS; &#125;</span><br><span class="line"><span class="type">char_t</span> fne[DR_NM_MAX];</span><br><span class="line">hal_memset((<span class="type">void</span>*)fne, DR_NM_MAX, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//提取纯文件名</span></span><br><span class="line"><span class="keyword">if</span>(rfs_ret_fname(fne,fname) != <span class="number">0</span>) &#123; <span class="keyword">return</span> DFCERRSTUS; &#125;</span><br><span class="line"><span class="comment">//调用删除文件的核心函数</span></span><br><span class="line"><span class="keyword">if</span>(del_dirfileblk_core(devp, fne) != <span class="number">0</span>) &#123; <span class="keyword">return</span> DFCERRSTUS; &#125;</span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rfs_del_dirfileblk 函数只是提取了文件名，然后调用删除文件的核心函数 del_dirfileblk_core</span></span><br><span class="line"><span class="comment">//删除文件的核心函数</span></span><br><span class="line"><span class="type">sint_t</span> <span class="title function_">del_dirfileblk_core</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">char_t</span>* fname)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">sint_t</span> rets = <span class="number">6</span>;</span><br><span class="line">  <span class="type">void</span>* rblkp=get_rootdirfile_blk(devp);<span class="comment">//获取根目录文件</span></span><br><span class="line">  <span class="type">fimgrhd_t</span>* fmp = (<span class="type">fimgrhd_t</span>*)rblkp;</span><br><span class="line">  <span class="keyword">if</span>(fmp-&gt;fmd_type!=FMD_DIR_TYPE) &#123; <span class="comment">//检查根目录文件的类型</span></span><br><span class="line">    rets=<span class="number">4</span>; <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[<span class="number">0</span>].fb_blkstart &amp;&amp; fmp-&gt;fmd_curf)&#123;</span><br><span class="line">    rets = <span class="number">3</span>; <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">rfsdir_t</span>* dirp = (<span class="type">rfsdir_t</span>*)((<span class="type">uint_t</span>)(fmp) + fmp-&gt;fmd_fileifstbkoff);</span><br><span class="line">  <span class="type">void</span>* maxchkp = (<span class="type">void</span>*)((<span class="type">uint_t</span>)rblkp + FSYS_ALCBLKSZ<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;(<span class="type">void</span>*)dirp &lt; maxchkp;) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dirp-&gt;rdr_type == RDR_FIL_TYPE) &#123;<span class="comment">//检查其类型是否为文件类型</span></span><br><span class="line">      <span class="comment">//如果文件名相同，就执行以下删除动作</span></span><br><span class="line">      <span class="keyword">if</span>(rfs_strcmp(dirp-&gt;rdr_name, fname) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//释放rfsdir_t结构的rdr_blknr中指向的逻辑储存块</span></span><br><span class="line">        rfs_del_blk(devp, dirp-&gt;rdr_blknr);</span><br><span class="line">        <span class="comment">//初始化rfsdir_t结构，实际上是清除其中的数据</span></span><br><span class="line">        rfsdir_t_init(dirp);</span><br><span class="line">        <span class="comment">//设置rfsdir_t结构的类型为删除类型，表示它已经删除</span></span><br><span class="line">        dirp-&gt;rdr_type = RDR_DEL_TYPE;</span><br><span class="line">        rets = <span class="number">0</span>; <span class="keyword">goto</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dirp++;<span class="comment">//下一个rfsdir_t</span></span><br><span class="line">  &#125;</span><br><span class="line">  rets=<span class="number">1</span>;</span><br><span class="line">  err:</span><br><span class="line">  del_rootdirfile_blk(devp,rblkp);<span class="comment">//释放根目录文件</span></span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 在 cosmos/include/krlinc/krlobjnode_t.h 文件中在 objnode_t 结构中增加一些东西</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJN_TY_DEV 1<span class="comment">//设备类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJN_TY_FIL 2<span class="comment">//文件类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJN_TY_NUL 0<span class="comment">//默认类型</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_OBJNODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> on_lock;</span><br><span class="line"><span class="type">list_h_t</span> on_list;</span><br><span class="line"><span class="type">sem_t</span> on_complesem;</span><br><span class="line"><span class="type">uint_t</span> on_flgs;</span><br><span class="line"><span class="type">uint_t</span> on_stus;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="type">void</span>* on_fname;<span class="comment">//文件路径名指针</span></span><br><span class="line"><span class="type">void</span>* on_finode;<span class="comment">//文件对应的fimgrhd_t结构指针</span></span><br><span class="line"><span class="type">void</span>* on_extp;<span class="comment">//扩展所用</span></span><br><span class="line">&#125;<span class="type">objnode_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件的接口函数</span></span><br><span class="line"><span class="comment">//打开文件的接口函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_open_file</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">void</span>* iopack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">objnode_t</span>* obp = (<span class="type">objnode_t</span>*)iopack;</span><br><span class="line"><span class="comment">//检查objnode_t中的文件路径名</span></span><br><span class="line"><span class="keyword">if</span>(obp-&gt;on_fname == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用打开文件的核心函数</span></span><br><span class="line"><span class="type">void</span>* fmdp = rfs_openfileblk(devp, (<span class="type">char_t</span>*)obp-&gt;on_fname);</span><br><span class="line"><span class="keyword">if</span>(fmdp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把返回的fimgrhd_t结构的地址保存到objnode_t中的on_finode字段中</span></span><br><span class="line">obp-&gt;on_finode = fmdp;</span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件的核心函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">rfs_openfileblk</span><span class="params">(<span class="type">device_t</span> *devp, <span class="type">char_t</span>* fname)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char_t</span> fne[DR_NM_MAX]; <span class="type">void</span>* rets = <span class="literal">NULL</span>,*buf = <span class="literal">NULL</span>;</span><br><span class="line">hal_memset((<span class="type">void</span>*)fne,DR_NM_MAX,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(rfs_ret_fname(fne, fname) != <span class="number">0</span>) &#123;<span class="comment">//从文件路径名中提取纯文件名</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* rblkp = get_rootdirfile_blk(devp); <span class="comment">//获取根目录文件</span></span><br><span class="line"><span class="type">fimgrhd_t</span>* fmp = (<span class="type">fimgrhd_t</span>*)rblkp;</span><br><span class="line"><span class="keyword">if</span>(fmp-&gt;fmd_type != FMD_DIR_TYPE) &#123;<span class="comment">//判断根目录文件的类型是否合理</span></span><br><span class="line">rets = <span class="literal">NULL</span>; <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断根目录文件里有没有数据</span></span><br><span class="line"><span class="keyword">if</span>(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[<span class="number">0</span>].fb_blkstart &amp;&amp;</span><br><span class="line">fmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) &#123;</span><br><span class="line">rets = <span class="literal">NULL</span>; <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">rfsdir_t</span>* dirp = (<span class="type">rfsdir_t</span>*)((<span class="type">uint_t</span>)(fmp) + fmp-&gt;fmd_fileifstbkoff);</span><br><span class="line"><span class="type">void</span>* maxchkp = (<span class="type">void</span>*)((<span class="type">uint_t</span>)rblkp + FSYS_ALCBLKSZ - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(;(<span class="type">void</span>*)dirp &lt; maxchkp;) &#123;<span class="comment">//开始遍历文件对应的rfsdir_t结构</span></span><br><span class="line"><span class="keyword">if</span>(dirp-&gt;rdr_type == RDR_FIL_TYPE) &#123;</span><br><span class="line"><span class="comment">//如果文件名相同就跳转到opfblk标号处运行</span></span><br><span class="line"><span class="keyword">if</span>(rfs_strcmp(dirp-&gt;rdr_name, fne) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> opfblk;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dirp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果到这里说明没有找到该文件对应的rfsdir_t结构，所以设置返回值为NULL</span></span><br><span class="line">rets = <span class="literal">NULL</span>; <span class="keyword">goto</span> err;</span><br><span class="line">opfblk:</span><br><span class="line">buf = new_buf(FSYS_ALCBLKSZ);<span class="comment">//分配4KB大小的缓冲区</span></span><br><span class="line"><span class="comment">//读取该文件占用的逻辑储存块</span></span><br><span class="line"><span class="keyword">if</span>(read_rfsdevblk(devp, buf, dirp-&gt;rdr_blknr) == DFCERRSTUS) &#123;</span><br><span class="line">rets = <span class="literal">NULL</span>; <span class="keyword">goto</span> err1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">fimgrhd_t</span>* ffmp = (<span class="type">fimgrhd_t</span>*)buf;</span><br><span class="line"><span class="keyword">if</span>(ffmp-&gt;fmd_type == FMD_NUL_TYPE || ffmp-&gt;fmd_fileifstbkoff != <span class="number">0x200</span>) &#123;<span class="comment">//</span></span><br><span class="line">rets = <span class="literal">NULL</span>; <span class="keyword">goto</span> err1;</span><br><span class="line">&#125;</span><br><span class="line">rets = buf; <span class="keyword">goto</span> err;<span class="comment">//设置缓冲区首地址为返回值</span></span><br><span class="line">err1:</span><br><span class="line">del_buf(buf, FSYS_ALCBLKSZ); <span class="comment">//上面的步骤若出现问题就要释放缓冲区</span></span><br><span class="line">err:</span><br><span class="line">del_rootdirfile_blk(devp, rblkp); <span class="comment">//释放根目录文件</span></span><br><span class="line"><span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 读写文件</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">//读取文件数据的接口函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_read_file</span><span class="params">(<span class="type">device_t</span>* devp,<span class="type">void</span>* iopack)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">objnode_t</span>* obp = (<span class="type">objnode_t</span>*)iopack;</span><br><span class="line">  <span class="comment">//检查文件是否已经打开，以及用于存放文件数据的缓冲区和它的大小是否合理</span></span><br><span class="line">  <span class="keyword">if</span>(obp-&gt;on_finode == <span class="literal">NULL</span> || obp-&gt;on_buf == <span class="literal">NULL</span> || obp-&gt;on_bufsz != FSYS)&#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rfs_readfileblk(devp, (<span class="type">fimgrhd_t</span>*)obp-&gt;on_finode, obp-&gt;on_buf, obp-&gt;on_finode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际读取文件数据的函数</span></span><br><span class="line"><span class="type">drvstus_t</span> rfs_readfileblk(<span class="type">device_t</span>* devp, <span class="type">fimgrhd_t</span>* fmp, <span class="type">void</span>* buf, <span class="type">uint_t</span> leal)&#123;</span><br><span class="line">  <span class="comment">//检查文件的相关信息是否合理</span></span><br><span class="line">  <span class="keyword">if</span>(fmp-&gt;fmd_sfblk != fmp-&gt;fmd_curfwritebk || fmp-&gt;fmd_curfwritebk != fmp-&gt;fmd_sfblk)&#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//检查读取文件数据的长度是否大于（4096-512）</span></span><br><span class="line">  <span class="keyword">if</span>(len &gt; (FSYS_ALCBLKSZ - fmp-&gt;fmd_fileifstbkoff)) &#123;</span><br><span class="line">    <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//指向文件数据的开始地址</span></span><br><span class="line">  <span class="type">void</span>* wrp = (<span class="type">void</span>*)((<span class="type">uint_t</span>)fmp + fmp-&gt;fmd_fileifstbkoff);</span><br><span class="line">  <span class="comment">//把文件开始处的数据复制len个字节到buf指向的缓冲区中</span></span><br><span class="line">  hal_memcpy(wrp, buf, len);</span><br><span class="line">  <span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件的接口函数和核心函数</span></span><br><span class="line"><span class="comment">//写入文件数据的接口函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_write_file</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">void</span>* iopack)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">objnode_t</span>* obp = (<span class="type">objnode_t</span>*)iopack;</span><br><span class="line">  <span class="comment">//检查文件是否已经打开，以及用于存放文件数据的缓冲区和它的大小是否合理</span></span><br><span class="line">  <span class="keyword">if</span>(obp-&gt;on_finode == <span class="literal">NULL</span> || obp-&gt;on_buf == <span class="literal">NULL</span> || obp-&gt;on_bufsz != FSYS)&#123;</span><br><span class="line">  <span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rfs_writefileblk(devp, (<span class="type">fimgrhd_t</span>*)obp-&gt;on_finode, obp-&gt;on_buf, obp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际写入文件数据的函数</span></span><br><span class="line"><span class="type">drvstus_t</span> rfs_writefileblk(<span class="type">device_t</span>* devp, <span class="type">fimgrhd_t</span>* fmp, <span class="type">void</span>* buf)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查文件的相关信息是否合理</span></span><br><span class="line"><span class="keyword">if</span>(fmp-&gt;fmd_sfblk != fmp-&gt;fmd_curfwritebk || fmp-&gt;fmd_curfwritebk != fmp-&gt;fmd_sfblk)</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查当前将要写入数据的偏移量加上写入数据的长度，是否大于等于4KB</span></span><br><span class="line"><span class="keyword">if</span>((fmp-&gt;fmd_curfinwbkoff + len) &gt;= FSYS_ALCBLKSZ) &#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向将要写入数据的内存空间</span></span><br><span class="line"><span class="type">void</span>* wrp = (<span class="type">void</span>*)((<span class="type">uint_t</span>)fmp + fmp-&gt;fmd_curfinwbkoff);</span><br><span class="line"><span class="comment">//把buf缓冲区中的数据复制len个字节到wrp指向的内存空间中去</span></span><br><span class="line">hal_memcpy(buf, wrp, len);</span><br><span class="line">fmp-&gt;fmd_filesz += len;<span class="comment">//增加文件大小</span></span><br><span class="line"><span class="comment">//使fmd_curfinwbkoff指向下一次将要写入数据的位置</span></span><br><span class="line">fmp-&gt;fmd_curfinwbkoff += len;</span><br><span class="line"><span class="comment">//把文件数据写入到相应的逻辑储存块中，完成数据同步</span></span><br><span class="line">write_rfsdevblk(devp, (<span class="type">void</span>*)fmp, fmp-&gt;fmd_curfwritebk);</span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">//关闭文件的接口函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_close_file</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">void</span>* iopack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">objnode_t</span>* obp = (<span class="type">objnode_t</span>*)iopack;</span><br><span class="line"><span class="comment">//检查文件是否已经打开了</span></span><br><span class="line"><span class="keyword">if</span>(obp-&gt;on_finode == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rfs_closefileblk(devp, obp-&gt;on_finode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件的核心函数</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_closefileblk</span><span class="params">(<span class="type">device_t</span> *devp, <span class="type">void</span>* fblkp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//指向文件的fimgrhd_t结构</span></span><br><span class="line"><span class="type">fimgrhd_t</span>* fmp = (<span class="type">fimgrhd_t</span>*)fblkp;</span><br><span class="line"><span class="comment">//完成文件数据的同步</span></span><br><span class="line">write_rfsdevblk(devp, fblkp, fmp-&gt;fmd_sfblk);</span><br><span class="line"><span class="comment">//释放缓冲区</span></span><br><span class="line">del_buf(fblkp, FSYS_ALCBLKSZ);</span><br><span class="line"><span class="keyword">return</span> DFCOKSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 串联整合</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 串联整合文件系统打开文件操作和新建文件操作</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_open</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">void</span>* iopack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">objnode_t</span>* obp=(<span class="type">objnode_t</span>*)iopack;</span><br><span class="line"><span class="comment">//根据objnode_t结构中的访问标志进行判断</span></span><br><span class="line"><span class="keyword">if</span>(obp-&gt;on_acsflgs == FSDEV_OPENFLG_OPEFILE) &#123;</span><br><span class="line"><span class="keyword">return</span> rfs_open_file(devp, iopack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(obp-&gt;on_acsflgs == FSDEV_OPENFLG_NEWFILE) &#123;</span><br><span class="line"><span class="keyword">return</span> rfs_new_file(devp, obp-&gt;on_fname, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整合关闭文件操作</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_close</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">void</span>* iopack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> rfs_close_file(devp, iopack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整合文件读写操作</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_read</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">void</span>* iopack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//调用读文件操作的接口函数</span></span><br><span class="line"><span class="keyword">return</span> rfs_read_file(devp, iopack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_write</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">void</span>* iopack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//调用写文件操作的接口函数</span></span><br><span class="line"><span class="keyword">return</span> rfs_write_file(devp, iopack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整合删除文件操作</span></span><br><span class="line"><span class="type">drvstus_t</span> <span class="title function_">rfs_ioctrl</span><span class="params">(<span class="type">device_t</span>* devp, <span class="type">void</span>* iopack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">objnode_t</span>* obp = (<span class="type">objnode_t</span>*)iopack;</span><br><span class="line"><span class="comment">//根据objnode_t结构中的控制码进行判断</span></span><br><span class="line"><span class="keyword">if</span>(obp-&gt;on_ioctrd == FSDEV_IOCTRCD_DELFILE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//调用删除文件操作的接口函数</span></span><br><span class="line"><span class="keyword">return</span> rfs_del_file(devp, obp-&gt;on_fname, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DFCERRSTUS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----</span></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// ----</span></span><br><span class="line"><span class="comment">// 写 test_fsys 函数进行测试</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_fsys</span><span class="params">(<span class="type">device_t</span> *devp)</span></span><br><span class="line">&#123;</span><br><span class="line">kprint(<span class="string">&quot;开始文件操作测试\n&quot;</span>);</span><br><span class="line"><span class="type">void</span> *rwbuf = new_buf(FSYS_ALCBLKSZ);<span class="comment">//分配缓冲区</span></span><br><span class="line"><span class="comment">//把缓冲区中的所有字节都置为0xff</span></span><br><span class="line">hal_memset(rwbuf, <span class="number">0xff</span>, FSYS_ALCBLKSZ);</span><br><span class="line"><span class="type">objnode_t</span> *ondp = krlnew_objnode();<span class="comment">//新建一个objnode_t结构</span></span><br><span class="line">ondp-&gt;on_acsflgs = FSDEV_OPENFLG_NEWFILE;<span class="comment">//设置新建文件标志</span></span><br><span class="line">ondp-&gt;on_fname = <span class="string">&quot;/testfile&quot;</span>;<span class="comment">//设置新建文件名</span></span><br><span class="line">ondp-&gt;on_buf = rwbuf;<span class="comment">//设置缓冲区</span></span><br><span class="line">ondp-&gt;on_bufsz = FSYS_ALCBLKSZ;<span class="comment">//设置缓冲区大小</span></span><br><span class="line">ondp-&gt;on_len = <span class="number">512</span>;<span class="comment">//设置读写多少字节</span></span><br><span class="line">ondp-&gt;on_ioctrd = FSDEV_IOCTRCD_DELFILE;<span class="comment">//设置控制码</span></span><br><span class="line"><span class="keyword">if</span> (rfs_open(devp, ondp) == DFCERRSTUS) &#123;<span class="comment">//新建文件</span></span><br><span class="line">hal_sysdie(<span class="string">&quot;新建文件错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ondp-&gt;on_acsflgs = FSDEV_OPENFLG_OPEFILE;<span class="comment">//设置打开文件标志</span></span><br><span class="line"><span class="keyword">if</span> (rfs_open(devp, ondp) == DFCERRSTUS) &#123;<span class="comment">//打开文件</span></span><br><span class="line">hal_sysdie(<span class="string">&quot;打开文件错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rfs_write(devp, ondp) == DFCERRSTUS) &#123;<span class="comment">//把数据写入文件</span></span><br><span class="line">hal_sysdie(<span class="string">&quot;写入文件错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">hal_memset(rwbuf, <span class="number">0</span>, FSYS_ALCBLKSZ);<span class="comment">//清零缓冲区</span></span><br><span class="line"><span class="keyword">if</span> (rfs_read(devp, ondp) == DFCERRSTUS) &#123;<span class="comment">//读取文件数据</span></span><br><span class="line">hal_sysdie(<span class="string">&quot;读取文件错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rfs_close(devp, ondp) == DFCERRSTUS) &#123;<span class="comment">//关闭文件</span></span><br><span class="line">hal_sysdie(<span class="string">&quot;关闭文件错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">u8_t</span> *cb = (<span class="type">u8_t</span> *)rwbuf;<span class="comment">//指向缓冲区</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint_t</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;<span class="comment">//检查缓冲区空间中的头512个字节的数据，是否为0x</span></span><br><span class="line"><span class="keyword">if</span> (cb[i] != <span class="number">0xff</span>) &#123;<span class="comment">//如果不等于0xff就死机</span></span><br><span class="line">hal_sysdie(<span class="string">&quot;检查文件内容错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">kprint(<span class="string">&quot;testfile文件第[%x]个字节数据:%x\n&quot;</span>, i, (<span class="type">uint_t</span>)cb[i]);<span class="comment">//打印文件内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rfs_ioctrl(devp, ondp) == DFCERRSTUS)&#123;<span class="comment">//删除文件</span></span><br><span class="line">hal_sysdie(<span class="string">&quot;删除文件错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ondp-&gt;on_acsflgs = FSDEV_OPENFLG_OPEFILE;<span class="comment">//再次设置打开文件标志</span></span><br><span class="line"><span class="keyword">if</span> (rfs_open(devp, ondp) == DFCERRSTUS) &#123;<span class="comment">//再次打开文件</span></span><br><span class="line">hal_sysdie(<span class="string">&quot;再次打开文件失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">hal_sysdie(<span class="string">&quot;结束文件操作测试&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="94-瞧一瞧linux虚拟文件系统如何管理文件"><a class="markdownIt-Anchor" href="#94-瞧一瞧linux虚拟文件系统如何管理文件"></a> 9.4 瞧一瞧Linux:虚拟文件系统如何管理文件</h2>
<ul>
<li><strong>什么VFS</strong>
<ul>
<li>VFS像伙伴系统,SLAB内存管理算法一样是SUN公司实现的虚拟文件系统,可理解为通用文件系统抽象层</li>
<li>在Linux中,支持ext,xfs,ntfs等文件系统,统一使用open(),read(),write(),close()接口
<ul>
<li>为适应不同的文件系统,VFS提供抽象层,让不同文件系统表现一致的行为</li>
<li>对用户空间和内核空间的其他部分,各种文件系统一样:文件都有目录,都支持建立,打开,读写,关闭和删除操作,不用关注不同文件系统的细节</li>
</ul>
</li>
<li>Linux的VFS层是应用和许多文件系统之间的抽象层,向上对应用提供操作文件的标准接口,向下规范率文件系统要介入VFS必需要实现的机制
<ul>
<li>VFS提供一系列数据结构和具体文件系统应实现的回调函数,一个文件系统就可以被安装到VFS中,操作具体文件时,VFS会根据需要调用具体文件系统的函数</li>
<li>文件系统的细节被VFS屏蔽了,应用程序只需要调用标准接口即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-18-37-18.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-18-37-18.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="VFS结构图" /></p>
<ul>
<li><strong>VFS数据结构</strong>
<ul>
<li>VFS为屏蔽各个文件系统的差异需要定义一组通用的数据结构,规范各个文件系统的实现,每种结构都对应一套回调函数集合(<strong>面向对象的设计方法</strong>)</li>
<li>这些数据结构包含描述文件系统信息的超级块,表示文件名称的目录结构,描述文件自身信息的索引节点结构,表示打开一个文件的实例结构</li>
</ul>
</li>
<li><strong>超级块结构</strong>
<ul>
<li>该结构用于一个具体文件系统的相关信息,其中包含了VFS规定的标准信息,也有具体文件系统的特有信息</li>
<li>Linux系统中的超级块结构是一个文件系统安装在VFS中的标识
<ul>
<li>在文件系统被挂载到 VFS 的某个目录下时，VFS 会调用获取文件系统自己的超级块的函数，用具体文件系统的信息构造一个上述结构的实例，有了这个结构实例，VFS 就能感知到一个文件系统插入了</li>
</ul>
</li>
<li><strong>超级块函数集合</strong>: super_operations 结构中所有函数指针所指向的函数都要由一个具体文件系统实现</li>
<li>文件系统只要实现了 super_block 和 super_operations 两个结构，就可以插入到 VFS 中,但该文件系统每任何实质性的功能</li>
</ul>
</li>
<li><strong>目录结构</strong>
<ul>
<li>randomize_layout 中的 dentry 结构中包含了目录的名字和挂载子目录的链表,同时也能指向父目录</li>
<li>目录也是文件,需要用 inode 索引结构来管理目录文件数据</li>
<li>该目录文件数据,可以想象成一个表,表有三列，分别为名称,类型,inode号</li>
</ul>
</li>
<li><strong>文件索引点</strong>
<ul>
<li>VFS用inode结构表示一个文件索引节点,里面包含文件权限,文件所属用户,文件访问和修改时间,文件数据块等一个文件的全部信息,<strong>一个inode结构对应一个文件,表示一个文件的全部信息,但该inode结构时VFS使用的,跟具体文件系统上的inode并不一一对应</strong></li>
<li>inode结构有一套函数集合,用于具体文件系统根据信息构造出VFS使用的inode结构</li>
<li>VFS 通过定义 inode 结构和函数集合，并让具体文件系统实现这些函数，使得 VFS 及其上层只要关注 inode 结构，底层的具体文件系统根据自己的文件信息生成相应的 inode 结构，达到了 VFS 表示一个文件的目的</li>
</ul>
</li>
<li><strong>打开的文件</strong>
<ul>
<li>VFS设计文件对象结构解决表示应用程序打开的不同文件的问题，文件对象结构表示进程已打开的文件</li>
<li>文件对象结构包含了访问模式,当前读写偏移等信息</li>
<li>进程结构中具有文件表,该表是 file 结构的指针数组，进程每打开一个文件就会建立一个 file 结构实例，并将其地址放入数组中，最后返回对应的数组下标，就是调用 open 函数返回的那个整数</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// VFS数据结构</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_list</span>;</span> <span class="comment">//超级块链表</span></span><br><span class="line">  <span class="type">dev_t</span> s_dev; <span class="comment">//设备标识</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> s_blocksize_bits;<span class="comment">//以位为单位的块大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> s_blocksize;<span class="comment">//以字节为单位的块大小</span></span><br><span class="line">  <span class="type">loff_t</span> s_maxbytes; <span class="comment">//一个文件最大多少字节</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">s_type</span>;</span> <span class="comment">//文件系统类型</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> *<span class="title">s_op</span>;</span><span class="comment">//超级块函数集合</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span> *<span class="title">dq_op</span>;</span><span class="comment">//磁盘限额函数集合</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> s_flags;<span class="comment">//挂载标志</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> s_magic;<span class="comment">//文件系统魔数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">s_root</span>;</span><span class="comment">//挂载目录</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">s_umount</span>;</span><span class="comment">//卸载信号量</span></span><br><span class="line">  <span class="type">int</span> s_count;<span class="comment">//引用计数</span></span><br><span class="line">  <span class="type">atomic_t</span> s_active;<span class="comment">//活动计数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">s_bdev</span>;</span><span class="comment">//块设备</span></span><br><span class="line">  <span class="type">void</span> *s_fs_info;<span class="comment">//文件系统信息</span></span><br><span class="line">  <span class="type">time64_t</span> s_time_min;<span class="comment">//最小时间限制</span></span><br><span class="line">  <span class="type">time64_t</span> s_time_max;<span class="comment">//最大时间限制</span></span><br><span class="line">  <span class="type">char</span> s_id[<span class="number">32</span>]; <span class="comment">//标识名称</span></span><br><span class="line">  <span class="type">uuid_t</span> s_uuid; <span class="comment">//文件系统的UUID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_lru</span> <span class="title">s_dentry_lru</span>;</span><span class="comment">//LRU方式挂载的目录</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_lru</span> <span class="title">s_inode_lru</span>;</span><span class="comment">//LRU方式挂载的索引结点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">s_sync_lock</span>;</span><span class="comment">//同步锁</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_inodes</span>;</span> <span class="comment">//所有的索引节点</span></span><br><span class="line">  <span class="type">spinlock_t</span> s_inode_wblist_lock;<span class="comment">//回写索引节点的锁</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_inodes_wb</span>;</span> <span class="comment">//挂载所有要回写的索引节点</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超级块函数集合</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">  <span class="comment">//分配一个新的索引结点结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span></span><br><span class="line">  <span class="comment">//销毁给定的索引节点</span></span><br><span class="line">  <span class="type">void</span> (*destroy_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line">  <span class="comment">//释放给定的索引节点</span></span><br><span class="line">  <span class="type">void</span> (*free_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line">  <span class="comment">//VFS在索引节点为脏(改变)时，会调用此函数</span></span><br><span class="line">  <span class="type">void</span> (*dirty_inode) (<span class="keyword">struct</span> inode *, <span class="type">int</span> flags);</span><br><span class="line">  <span class="comment">//该函数用于将给定的索引节点写入磁盘</span></span><br><span class="line">  <span class="type">int</span> (*write_inode) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> writeback_control *wbc);</span><br><span class="line">  <span class="comment">//在最后一个指向索引节点的引用被释放后，VFS会调用该函数</span></span><br><span class="line">  <span class="type">int</span> (*drop_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">  <span class="type">void</span> (*evict_inode) (<span class="keyword">struct</span> inode *);</span><br><span class="line">  <span class="comment">//减少超级块计数调用</span></span><br><span class="line">  <span class="type">void</span> (*put_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">  <span class="comment">//同步文件系统调用</span></span><br><span class="line">  <span class="type">int</span> (*sync_fs)(<span class="keyword">struct</span> super_block *sb, <span class="type">int</span> wait);</span><br><span class="line">  <span class="comment">//释放超级块调用</span></span><br><span class="line">  <span class="type">int</span> (*freeze_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">  <span class="comment">//释放文件系统调用</span></span><br><span class="line">  <span class="type">int</span> (*freeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">  <span class="type">int</span> (*thaw_super) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">  <span class="type">int</span> (*unfreeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">  <span class="comment">//VFS通过调用该函数，获取文件系统状态</span></span><br><span class="line">  <span class="type">int</span> (*statfs) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstatfs *);</span><br><span class="line">  <span class="comment">//当指定新的安装选项重新安装文件系统时，VFS会调用此函数</span></span><br><span class="line">  <span class="type">int</span> (*remount_fs) (<span class="keyword">struct</span> super_block *, <span class="type">int</span> *, <span class="type">char</span> *);</span><br><span class="line">  <span class="comment">//VFS调用该函数中断安装操作。该函数被网络文件系统使用，如NFS</span></span><br><span class="line">  <span class="type">void</span> (*umount_begin) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 目录结构</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// VFS表示目录的数据结构</span></span><br><span class="line"><span class="comment">//快速字符串保存关于字符串的 &quot;元数据&quot;（即长度和哈希值）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      HASH_LEN_DECLARE;</span><br><span class="line">    &#125;;</span><br><span class="line">    u64 hash_len;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *name;<span class="comment">//指向名称字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> d_flags; <span class="comment">//目录标志</span></span><br><span class="line">  <span class="type">seqcount_spinlock_t</span> d_seq; <span class="comment">//锁</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span><span class="comment">//目录的哈希链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span> <span class="comment">//指向父目录</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span> <span class="comment">//目录名称</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span> <span class="comment">//指向目录文件的索引节点</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> d_iname[DNAME_INLINE_LEN]; <span class="comment">//短目录名</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span> <span class="comment">//目录锁与计数</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span><span class="comment">//目录的函数集</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span> <span class="comment">//指向超级块</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> d_time; <span class="comment">//时间</span></span><br><span class="line">  <span class="type">void</span> *d_fsdata; <span class="comment">//指向具体文件系统的数据</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span> <span class="comment">//LRU链表</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> *d_wait;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span> <span class="comment">//挂入父目录的链表节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span> <span class="comment">//挂载所有子目录的链表</span></span><br><span class="line">&#125; randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目录函数集</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> &#123;</span></span><br><span class="line">  <span class="comment">//该函数判断目录对象是否有效</span></span><br><span class="line">  <span class="type">int</span> (*d_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*d_weak_revalidate)(<span class="keyword">struct</span> dentry *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="comment">//该函数为目录项生成散列值，当目录项要加入散列表中时，VFS调用该函数</span></span><br><span class="line">  <span class="type">int</span> (*d_hash)(<span class="type">const</span> <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> qstr *);</span><br><span class="line">  <span class="comment">//VFS调用该函数来比较name1和name2两个文件名。多数文件系统使用VFS的默认操作</span></span><br><span class="line">  <span class="type">int</span> (*d_compare)(<span class="type">const</span> <span class="keyword">struct</span> dentry *,</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="keyword">struct</span> qstr *);</span><br><span class="line">  <span class="comment">//当目录项对象的计数值等于0时，VFS调用该函数</span></span><br><span class="line">  <span class="type">int</span> (*d_delete)(<span class="type">const</span> <span class="keyword">struct</span> dentry *);</span><br><span class="line">  <span class="comment">//当分配目录时调用</span></span><br><span class="line">  <span class="type">int</span> (*d_init)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">  <span class="comment">//当目录项对象要被释放时，VFS调用该函数，默认情况下，它什么也不做</span></span><br><span class="line">  <span class="type">void</span> (*d_release)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">  <span class="type">void</span> (*d_prune)(<span class="keyword">struct</span> dentry *);</span><br><span class="line">  <span class="comment">//当一个目录项对象丢失了相关索引节点时，VFS调用该函数。默认情况下VFS会调用iput()函数</span></span><br><span class="line">  <span class="type">void</span> (*d_iput)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *);</span><br><span class="line">  <span class="comment">//当需要生成一个dentry的路径名时被调用</span></span><br><span class="line">  <span class="type">char</span> *(*d_dname)(<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">int</span>);</span><br><span class="line">  <span class="comment">//当要遍历一个自动挂载时被调用（可选），这应该创建一个新的VFS挂载记录并将该记录返回给调用函数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *(*<span class="title">d_automount</span>)(<span class="keyword">struct</span> <span class="title">path</span> *);</span></span><br><span class="line">  <span class="comment">//文件系统管理从dentry的过渡（可选）时，被调用</span></span><br><span class="line">  <span class="type">int</span> (*d_manage)(<span class="type">const</span> <span class="keyword">struct</span> path *, <span class="type">bool</span>);</span><br><span class="line">  <span class="comment">//叠加/联合类型的文件系统实现此方法</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">d_real</span>)(<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="title">const</span> <span class="keyword">struct</span> <span class="title">inode</span> *);</span></span><br><span class="line">&#125; ____cacheline_aligned;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// 文件索引节点</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  <span class="type">umode_t</span> i_mode;<span class="comment">//文件访问权限</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> i_opflags;<span class="comment">//打开文件时的标志</span></span><br><span class="line">  <span class="type">kuid_t</span> i_uid;<span class="comment">//文件所属的用户id</span></span><br><span class="line">  <span class="type">kgid_t</span> i_gid;<span class="comment">//文件所属的用户组id</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i_flags;<span class="comment">//标志</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">i_op</span>;</span><span class="comment">//inode函数集</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">i_sb</span>;</span><span class="comment">//指向所属超级块</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">i_mapping</span>;</span><span class="comment">//文件数据在内存中的页缓存</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> i_ino;<span class="comment">//inode号</span></span><br><span class="line">  <span class="type">dev_t</span> i_rdev;<span class="comment">//实际设备标志符</span></span><br><span class="line">  <span class="type">loff_t</span> i_size;<span class="comment">//文件大小，以字节为单位</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">i_atime</span>;</span><span class="comment">//文件访问时间</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">i_mtime</span>;</span><span class="comment">//文件修改时间</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">i_ctime</span>;</span><span class="comment">//最后修改时间</span></span><br><span class="line">  <span class="type">spinlock_t</span> i_lock; <span class="comment">//保护inode的自旋锁</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> i_bytes;<span class="comment">//使用的字节数</span></span><br><span class="line">  u8 i_blkbits;<span class="comment">//以位为单位的块大小；</span></span><br><span class="line">  u8 i_write_hint;</span><br><span class="line">  <span class="type">blkcnt_t</span> i_blocks;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_io_list</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_lru</span>;</span> <span class="comment">//在缓存LRU中的链表节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_sb_list</span>;</span><span class="comment">//在超级块中中的链表节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_wb_list</span>;</span></span><br><span class="line">  <span class="type">atomic64_t</span> i_version;<span class="comment">//版本号</span></span><br><span class="line">  <span class="type">atomic64_t</span> i_sequence;</span><br><span class="line">  <span class="type">atomic_t</span> i_count;<span class="comment">//计数</span></span><br><span class="line">  <span class="type">atomic_t</span> i_dio_count;<span class="comment">//直接io进程计数</span></span><br><span class="line">  <span class="type">atomic_t</span> i_writecount;<span class="comment">//写进程计数</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">i_fop</span>;</span><span class="comment">//文件函数集合</span></span><br><span class="line">    <span class="type">void</span> (*free_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span> *<span class="title">i_flctx</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> <span class="title">i_data</span>;</span></span><br><span class="line">  <span class="type">void</span> *i_private; <span class="comment">//私有数据指针</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数集合</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">  <span class="comment">//VFS通过系统create()和open()接口来调用该函数，从而为dentry对象创建一个新的索引节点</span></span><br><span class="line">  <span class="type">int</span> (*create) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *,<span class="type">int</span>);</span><br><span class="line">  <span class="comment">//该函数在特定目录中寻找索引节点，该索引节点要对应于dentry中给出的文件名</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *, <span class="keyword">struct</span> <span class="title">dentry</span> *);</span></span><br><span class="line">  <span class="comment">//被系统link()接口调用，用来创建硬连接。硬链接名称由dentry参数指定</span></span><br><span class="line">  <span class="type">int</span> (*link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">  <span class="comment">//被系统unlink()接口调用，删除由目录项dentry链接的索引节点对象</span></span><br><span class="line">  <span class="type">int</span> (*unlink) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">  <span class="comment">//被系统symlik()接口调用，创建符号连接，该符号连接名称由symname指定，连接对象是dir目录</span></span><br><span class="line">  <span class="type">int</span> (*symlink) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">  <span class="comment">//被mkdir()接口调用，创建一个新目录。</span></span><br><span class="line">  <span class="type">int</span> (*mkdir) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">int</span>);</span><br><span class="line">  <span class="comment">//被rmdir()接口调用，删除dentry目录项代表的文件</span></span><br><span class="line">  <span class="type">int</span> (*rmdir) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *);</span><br><span class="line">  <span class="comment">//被mknod()接口调用，创建特殊文件(设备文件、命名管道或套接字)。</span></span><br><span class="line">  <span class="type">int</span> (*mknod) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="type">int</span>, <span class="type">dev_t</span>);</span><br><span class="line">  <span class="comment">//VFS调用该函数来移动文件。文件源路径在old_dir目录中</span></span><br><span class="line">  <span class="type">int</span> (*rename) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *, <span class="keyword">struct</span> den</span><br><span class="line">  <span class="comment">//被系统readlink()接口调用，拷贝数据到特定的缓冲buffer中。拷贝的数据来自dentry指定的</span></span><br><span class="line">  <span class="type">int</span> (*readlink) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">int</span>);</span><br><span class="line">  <span class="comment">//被VFS调用，从一个符号连接查找他指向的索引节点</span></span><br><span class="line">  <span class="type">int</span> (*follow_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> nameidata *);</span><br><span class="line">  <span class="comment">//在follow_link()调用之后，该函数由vfs调用进行清除工作</span></span><br><span class="line">  <span class="type">int</span> (*put_link) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> nameidata *);</span><br><span class="line">  <span class="comment">//被VFS调用，修改文件的大小，在调用之前，索引节点的i_size项必须被设置成预期的大小</span></span><br><span class="line">  <span class="type">void</span> (*truncate) (<span class="keyword">struct</span> inode *);</span><br><span class="line">  <span class="comment">//该函数用来检查给定的inode所代表的文件是否允许特定的访问模式，如果允许特定的访问模式，返</span></span><br><span class="line">  <span class="type">int</span> (*permission) (<span class="keyword">struct</span> inode *, <span class="type">int</span>);</span><br><span class="line">  <span class="comment">//被notify_change接口调用，在修改索引节点之后，通知发生了改变事件</span></span><br><span class="line">  <span class="type">int</span> (*setattr) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> iattr *);</span><br><span class="line">  <span class="comment">//在通知索引节点需要从磁盘中更新时，VFS会调用该函数</span></span><br><span class="line">  <span class="type">int</span> (*getattr) (<span class="keyword">struct</span> vfsmount *, <span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstat *);</span><br><span class="line">  <span class="comment">//被VFS调用，向dentry指定的文件设置扩展属性</span></span><br><span class="line">  <span class="type">int</span> (*setxattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">int</span>)</span><br><span class="line">  <span class="comment">//被VFS调用，拷贝给定文件的扩展属性name对应的数值</span></span><br><span class="line">  <span class="type">ssize_t</span> (*getxattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *, <span class="type">size_t</span>);</span><br><span class="line">  <span class="comment">//该函数将特定文件所有属性列表拷贝到一个缓冲列表中</span></span><br><span class="line">  <span class="type">ssize_t</span> (*listxattr) (<span class="keyword">struct</span> dentry *, <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">  <span class="comment">//该函数从给定文件中删除指定的属性</span></span><br><span class="line">  <span class="type">int</span> (*removexattr) (<span class="keyword">struct</span> dentry *, <span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 打开的文件</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="keyword">struct</span> file &#123;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> llist_node fu_llist;</span><br><span class="line">    <span class="keyword">struct</span> rcu_head fu_rcuhead;</span><br><span class="line">  &#125; f_u;</span><br><span class="line">  <span class="keyword">struct</span> path f_path; <span class="comment">//文件路径</span></span><br><span class="line">  <span class="keyword">struct</span> inode *f_inode; <span class="comment">//文件对应的inode</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> file_operations *f_op;<span class="comment">//文件函数集合</span></span><br><span class="line">  <span class="type">spinlock_t</span> f_lock; <span class="comment">//自旋锁</span></span><br><span class="line">  <span class="keyword">enum</span> rw_hint f_write_hint;</span><br><span class="line">  <span class="type">atomic_long_t</span> f_count;<span class="comment">//文件对象计数据。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> f_flags;<span class="comment">//文件标志</span></span><br><span class="line">  <span class="type">fmode_t</span> f_mode;<span class="comment">//文件权限</span></span><br><span class="line">  <span class="keyword">struct</span> mutex f_pos_lock;<span class="comment">//文件读写位置锁</span></span><br><span class="line">  <span class="type">loff_t</span> f_pos;<span class="comment">//进程读写文件的当前位置</span></span><br><span class="line">  u64 f_version;<span class="comment">//文件版本</span></span><br><span class="line">  <span class="type">void</span> *private_data;<span class="comment">//私有数据</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于file结构具有对应的函数集合 file_operations 结构</span></span><br><span class="line"><span class="keyword">struct</span> file_operations &#123;</span><br><span class="line">  <span class="keyword">struct</span> module *owner;<span class="comment">//所在的模块</span></span><br><span class="line">  <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);<span class="comment">//调整读写偏移</span></span><br><span class="line">  <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);<span class="comment">//读</span></span><br><span class="line">  <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);<span class="comment">//</span></span><br><span class="line">  <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);<span class="comment">//映射</span></span><br><span class="line">  <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);<span class="comment">//打开</span></span><br><span class="line">  <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);<span class="comment">//刷新</span></span><br><span class="line">  <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);<span class="comment">//关闭</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>四个对象结构的关系</strong></li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-19-18-18.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-19-18-18.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="VFS对象关系示意图" /></p>
<ul>
<li><strong>打开文件</strong></li>
<li>在对文件进行读写之前,需要先用open函数打开文件(使用标准库的open函数)</li>
<li>在x86_64架构中,open函数会执行syscall指令，从用户态切换到内核态,并且最终调用到 do_sys_open 函数,然后调用 do_sys_openat2 函数</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-19-21-09.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-19-21-09.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="打开文件流程" /></p>
<ul>
<li><strong>读写文件</strong>
<ul>
<li>读操作是数据从文件经由内核流向进程,写操作是数据从进程经由内核流向文件</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-19-22-12.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-19-22-12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="读文件流程示意图" /></p>
<ul>
<li><strong>关闭文件</strong>
<ul>
<li>回收file结构,其中最重要的是<strong>调用文件系统的flush函数</strong>,给文件系统一个刷新缓冲区,将数据写回储存设备保证储存设备的一致性</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-19-22-37.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-19-22-37.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="关闭文件流程示意图" /></p>
<ul>
<li><strong>文件系统实例</strong>
<ul>
<li>trfs内存文件系统,支持文件的建立,打开,读写，关闭等操作,通过内存块存放数据</li>
</ul>
</li>
<li><strong>注册trfs</strong>
<ul>
<li>需要在模块初始化函数中注册文件系统</li>
</ul>
</li>
<li><strong>使用trfs文件系统</strong>
<ul>
<li>首先是编译 trfs 内核模块代码，在终端中 cd 到对应的目录下执行 make，然后把编译好的内核模块插入到系统中，最后就是将这个文件系统挂载到一个具体的目录下</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 注册trfs</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">trfs_fs_type</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.name = <span class="string">&quot;trfs&quot;</span>,<span class="comment">//文件系统名字</span></span><br><span class="line">.mount = trfs_mount,<span class="comment">//文件系统挂载函数</span></span><br><span class="line">.kill_sb = trfs_kill_superblock,<span class="comment">//文件系统卸载函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">trfs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">init_fileinfo();<span class="comment">//初始化trfs文件系统数据结构</span></span><br><span class="line">ret = register_filesystem(&amp;trfs_fs_type);<span class="comment">//注册文件系统</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">printk(KERN_EMERG<span class="string">&quot;register trfs failed\n&quot;</span>);</span><br><span class="line">printk(KERN_EMERG<span class="string">&quot;trfs is ok\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trfs_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">exit_fileinfo();<span class="comment">//释放trfs文件系统数据结构</span></span><br><span class="line">unregister_filesystem(&amp;trfs_fs_type);<span class="comment">//卸载文件系统</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(trfs_init);</span><br><span class="line">module_exit(trfs_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="comment">// 使用trfs文件系统</span></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line">make <span class="comment">//编译内核模块</span></span><br><span class="line">sudo insmod trfs.ko <span class="comment">//把内核模块插入到内核</span></span><br><span class="line">sudo mount -t trfs none /mnt/ <span class="comment">// 挂载trfs文件系统到mnt目录</span></span><br><span class="line"><span class="comment">// 随后可以使用touch建立文件，然后用cat读取该文件</span></span><br></pre></td></tr></table></figure>
<hr />
<h1 id="10-网络"><a class="markdownIt-Anchor" href="#10-网络"></a> 10 网络</h1>
</div><div class="story post-story"><h2 id="101-如何全局观察网络数据流动"><a class="markdownIt-Anchor" href="#101-如何全局观察网络数据流动"></a> 10.1 如何全局观察网络数据流动</h2>
<ul>
<li><strong>输入URL的请求到响应发生的事</strong>
<ul>
<li>常规的网络交互过程是从客户端发起网络请求,用户态的应用程序(浏览器)会生成HTTP请求报文,并通过DNS协议查找到对应的远端IP地址</li>
<li>在套接字生成之后进入内核态,浏览器会委托操作系统内核协议栈中的上半部分(TCP/UDP协议发起连接请求)</li>
<li>然后经由协议栈下半部分的IP协议进行封装,使数据包具有远程定位能力</li>
<li>经过MAC层梳理,找到接收方的目标MAC地址</li>
<li>最终数据包在经过网卡转化成电信号经过交换机,路由器发送到服务端,服务端经过处理拿到数据，再通过各种网络协议栈把数据响应给客户端</li>
<li>客户端拿到数据进行渲染</li>
<li>客户端和服务端之间反复交换数据,客户端的页面数据就会发生变化</li>
</ul>
</li>
<li><strong>前置知识:网络分层和网络协议</strong>
<ul>
<li>当前网络主要遵循IEEE802.3标准给予OSI模型提出,主要定义的是<strong>物理层和数据链路层有限物理数据流传输标准</strong></li>
<li>网络分层解决了网络复杂的问题,在网路中传输数据中，对不同设备之间的传输数据的格式需要定义一个数据标准，即定义网络协议
<ul>
<li>以TCP/IP层的体系结构为例分析</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-20-30-54.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-20-30-54.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ISO_OSI通信流转" /></p>
<ul>
<li><strong>发起请求阶段(应用层)</strong>
<ul>
<li>应用层只需要专注于用户提供应用功能,不需要关心数据如何传输</li>
</ul>
</li>
<li><strong>用户输入:在浏览器中输入URL</strong>
<ul>
<li>浏览器会根据输入内容,先匹配对应的URL以及关键词,给出输入建议,同时检验URL的合法性,并且在URL前后补全URL
<ul>
<li>URL一般语法由5个分层序列组成
<blockquote>
<p>URI = scheme:[//authority]path[?query][#fragment]<br />
URI = 方案:[//授权]路径[?查询][#片段ID]</p>
</blockquote>
</li>
</ul>
</li>
<li>接着,浏览器从URL中会提取网络的地址(主机名host),一般主机名可以为域名或IP地址,以此使用域名</li>
<li>对URL进行解析之后,浏览器确定了服务器的主机名和请求路径,根据信息生成HTTP请求消息</li>
</ul>
</li>
<li><strong>网络请求前:查看浏览器缓存</strong>
<ul>
<li>浏览器在HTTP报文生成完成后,并不是马上开始网络请求</li>
<li>在请求发出之前,浏览器首先会检查保存在本地的缓存,若访问过当前的URL,会先进入缓存中查询是否有请求的文件</li>
<li>若没有在浏览器缓存里没有命中缓存,浏览器会做一个系统调用获得系统缓存中的记录,gethostbyname方法通过域名获取IP地址,返回hostent结构数据</li>
<li>若没有访问过该URL，则跳过缓存这一步进入网络操作</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> *h_name;<span class="comment">// 主机的别名.www.cosmos.com就是google他自己的别名</span></span><br><span class="line"><span class="type">char</span> **h_aliases;<span class="comment">// 主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6)</span></span><br><span class="line"><span class="type">int</span> h_addrtype;<span class="comment">// 主机ip地址的长度</span></span><br><span class="line"><span class="type">int</span> h_length;<span class="comment">// 主机ip地址的长度</span></span><br><span class="line"><span class="type">char</span> **h_addr_list; <span class="comment">// 主机的ip地址，注意，这个是以网络字节序存储的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> h_addr h_addr_list[0] 这个函数，是将类型为af的网络地址结构src，转换成主机序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>域名解析:DNS</strong>
<ul>
<li>在发送消息之前,需要查找服务端的IP地址,因为操作系统在发送消息时必须知道对应的IP地址才能发送</li>
<li>DNS服务器:将IP地址映射为域名,维护IP和域名的映射关系
<ul>
<li>DNS按照树形结构组织,可以一层层递归和迭代查找</li>
</ul>
<blockquote>
<p>DNS解析 &gt; 浏览器DNS缓存 &gt; hosts文件 &gt; 本地DNS服务器 &gt; ISP DNS服务器</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>操作系统协议栈(传输层和网络层)</strong>
<ul>
<li>TCP/IP 协议栈是现在使用最广泛的网络协议栈，Internet 就是建立在 TCP/IP 协议栈基础上的</li>
<li>协议栈内部分为几部分，分别承担着不同的作用
<ul>
<li>协议栈的上半部分负责和应用层通过套接字（Socket）进行交互，它可以是 TCP 协议或 UDP 协议。应用层会委托协议栈的上部分完成收发数据的工作</li>
<li>协议栈的下半部分则负责把数据发送给到指定方的 IP 协议，由IP 协议连接下层的网卡驱动</li>
</ul>
</li>
</ul>
</li>
<li><strong>可靠性传输:建立TCP连接</strong>
<ul>
<li>浏览器通过 DNS 解析拿到操作系统的 IP 地址后， 浏览器取出 URL 的端口（HTTP 默认 80，HTTPS 默认 443）</li>
<li>随即浏览器会委托操作系统协议栈的上半部分创建新的套接字（Socket）向对应的 IP 发起 TCP 连接请求</li>
<li>为了确保通信的可靠性,建立TCP首先会进行<strong>三次握手</strong>
<ol>
<li>首先浏览器作为客户端会发送一个小的 TCP 分组，这个分组设置了一个特殊的 SYN 标记，用来表示这是一条连接请求。同时设置初始序列号为 x 赋值给 Seq （这次捕获组的数据为: SYN=1, Seq=1）</li>
<li>服务器接受到客户端的 SYN 连接后，会选择服务器初始序号 y。同时向客户端发送含有连接确认（SYN+ACK）、Seq=0（本例中的服务器初始序号）、Ack=1（客户端的序号x+1）等信息的 TCP 分组</li>
<li>客户端收到了服务器的确定字段后，向服务器发送带有 ACK=1、Seq=1 (x+1)、Ack=1（服务器 Ack 信息的拷贝）等字段的 TCP 分组给服务器</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-20-52-28.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-20-52-28.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TCP握手示意图" /></p>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-20-53-26.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-20-53-26.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TCP包头" /></p>
<ul>
<li><strong>目的地定位:IP层</strong>
<ul>
<li>TCP在维护状态的过程中，都需要委托 IP 层将数据封装，发送和处理网络数据包进入网络层
<ul>
<li>IP 协议是 TCP/IP 协议栈的核心，规定了在 Internet 上进行通信时应遵循的规则，包括 IP 数据包应如何构成、数据包的路由等，而 IP 层实现了网络上的点对点通信</li>
</ul>
</li>
<li>IP层协议的函数对网络数据包进行5步操作
<ol>
<li>数据包校验和检验</li>
<li>防火墙对数据包过滤</li>
<li>IP 选项处理</li>
<li>数据分片和重组</li>
<li>接收、发送和前送</li>
</ol>
</li>
<li><strong>IP层被设计为三部分:IP寻址,路由和分包组包</strong></li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-20-56-22.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-20-56-22.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IP头部" /></p>
<ul>
<li><strong>点对点传输:MAC(链路层)</strong>
<ul>
<li>MAC地址为计算机网卡的物理地址,被固化到网卡中,用来标识一个网络设备
<ul>
<li>MAC地址唯一且无重复</li>
</ul>
</li>
<li>网络数据在 IP 层中加上 IP 头后，形成了 IP 包，进入 MAC 层对 IP 包加上 MAC 头，这个 MAC 头包括发送方的 MAC 头和接收方的 MAC 头，用于两个物理地址点对点的传输
<ul>
<li>此外还有一个头部字段为协议类型，在常规的 TCP/IP 协议中，MAC 头的协议类型只有 IP 和 ARP 两种</li>
</ul>
</li>
<li>发送方的 MAC 头比较容易获取，读取当前设备网卡的 MAC 地址就可以获取
<ul>
<li>接收方的 MAC 头则需要通过 ARP 协议在网络中携带 IP 地址，在一个网络中发送广播信息就能获取网络中的 IP 地址对应的 MAC 地址，然后就能给 IP 包加上 MAC头了，最后这个加上 MAC 头的 IP 包，成为一个 MAC 数据包，就可以准备发送出去了</li>
</ul>
</li>
</ul>
</li>
<li><strong>电信号的出口:网卡(物理层)</strong>
<ul>
<li>MAC 数据包会交给网卡驱动程序，而网卡驱动程序会将 MAC 数据包写入网卡的缓冲区（网卡上的内存）</li>
<li>网卡会在 MAC 数据包的起止位置加入起止帧和校验序列，最后网卡会将加入起止帧和校验序列的 MAC 数据包转化为电信号，发送出去</li>
</ul>
</li>
<li><strong>客户端服务端的持续数据交换(应用层)</strong>
<ul>
<li>数据通过网卡离开计算机，进入到局域网，通过局域网中的设备，集线器、交换机和路由器等，数据会进入到互联网，最终到达目标服务器</li>
<li>接着，服务器就会先取下数据包的 MAC 头部，查看是否匹配自己 MAC 地址。然后继续取下数据包的 IP 头，数据包中的目标 IP 地址和自己的 IP 地址匹配，再根据 IP 头中协议项，知道自己上层是 TCP 协议</li>
<li>之后，还要继续取下数据包 TCP 的头。完成一系列的顺序校验和状态变更后，TCP 头部里面还有端口号，此时 HTTP 的 server 正在监听这个端口号，就把数据包再发给对应的 HTTP 进程</li>
<li>HTTP 进程从服务器中拿到对应的资源，再交给操作系统对数据进行处理。然后再重复上面的过程，层层携带 TCP、IP、MAC 头部</li>
<li>接下来数据从网卡出去，到达客户端，再重复刚才的过程拿到相应数据</li>
<li>客户端拿到对应的 HTML 资源，浏览器就可以开始解析渲染了，操作完成后，用户最终就能通过浏览器看到相应的页面</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-21-02-51.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-21-02-51.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TCP_IP协议栈" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-21-03-08.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-24-21-03-08.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="交互过程示意图" /></p>
<ul>
<li><mark>关闭网络需要进行四次挥手，两边的网络传输过程至此完成</mark></li>
</ul>
</div><div class="story post-story"><h2 id="102-网络数据在内核中如何流转"><a class="markdownIt-Anchor" href="#102-网络数据在内核中如何流转"></a> 10.2 网络数据在内核中如何流转</h2>
<ul>
<li><strong>发送过程总览</strong>
<ul>
<li>应用程序通过网络发送数据的全过程
<ul>
<li>应用程序首先会准备好数据,调用用户态下的库函数</li>
<li>接着调用系统API接口函数，进入到内核态</li>
<li>内核态对应的系统服务函数会复制应用程序的数据到内核的内存空间,然后将数据交给网络协议栈,在网络协议栈中将数据层层打包</li>
<li>最好包装好的数据会交给网卡驱动,负责将打包好的数据写入网卡并让其发送出去</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-10-08-26.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-10-08-26.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="发送过程总览" /></p>
<ul>
<li><strong>接受过程总览</strong>
<ul>
<li>首先网卡接受到数据,通过DMA复制到指定的内存</li>
<li>发送中断,以通知网卡驱动，由网卡驱动处理中断复制数据</li>
<li>然后网络协议收到网卡驱动传来的数据，层层解包,获取真正的有效数据</li>
<li>最后数据发送给用户态监听的应用进程</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-10-24-34.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-10-24-34.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="接受过程总览" /></p>
<ul>
<li><strong>认识IwIP架构</strong>
<ul>
<li>IwIP是TCP/IP协议的轻量级开源项目</li>
<li>IwIP尽量用少量资源消耗,实现一个相对完整的TCP/IP协议栈,实现的关键点在于保持TCP协议主要功能的基础上减少对RAM的占用</li>
<li>IwIP在结构上可分为:OS层,API层,核心层,硬件驱动层</li>
<li>第一层
<ul>
<li>MCU 的业务层是 lwIP 的服务对象，也是其自身代码使用 lwIP 的地方</li>
<li>在典型的 TCP 通信的客户端应用程序中，一般先要通过 netconn_new 创建一个 structnetconn 对象，然后调用 netconn_connect 连接到服务器，并返回成功或失败</li>
<li>成功后，可以调用 netconn_write 向服务器发送数据，也可以调用 netconn_recv 接收数据</li>
<li>最后，关闭连接并通过 netconn_close 释放资源</li>
</ul>
</li>
<li>第二层
<ul>
<li>api层是netconn的功能代码所在的层,负责为上层代码提供netconn的api</li>
<li>可以使用 lwip_socket等函数以标准的socket方式调用IwIP</li>
</ul>
</li>
<li>第三层
<ul>
<li>IwIP的核心层存放了TCP/IP协议栈的核心代码,不仅实现了大部分的TCP和UDP功能,还实现了DNS,ICMP,IGMP等协议,同时也实现了内存管理和网络接口功能</li>
</ul>
</li>
<li>第四层
<ul>
<li>硬件驱动层提供了PHY芯片驱动，用来匹配IwIP的使用,IwIP会调用该层的代码将组装好的数据包发送到网络，同时从网络接受数据包进行分析,实现通信功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-10-27-22.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-10-27-22.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="IwIP架构图" /></p>
<ul>
<li><strong>IwIP的三套应用程序编程接口</strong>
<ul>
<li>原始API:通过事件回调机制开发应用程序,提供了最佳的性能和优化的代码长度,增加了应用程序开发的复杂性</li>
<li>Netconn API:高级的有序API,需要实时操作系统的支持,支持多线程</li>
<li>BSD套接字API:类似伯克利的套接字API</li>
</ul>
</li>
<li><strong>IwIP执行流程</strong></li>
<li><strong>数据发送</strong>
<ul>
<li>内核上层首先会调用IwIP的netconn层的接口函数netconn_write，通过该函数数据正式流进IwIP组件层</li>
<li>netconn层调用IwIP组件的TCP层的接口函数tcp_write，在TCP层对数据首次进行打包，然后TCP层将打包好的数据通过调用io_output函数向下传递给IwIP组件的IP层,进行打包</li>
<li>最后,IP层将打包好的数据发送给网卡驱动接口层netif,将数据发送出去</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-04-13.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-04-13.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="数据发送逻辑" /></p>
<ul>
<li><strong>数据接收</strong>
<ul>
<li>首先调用IwIP的netconn层的netconn_recv接口</li>
<li>然后由netconn层调用 sys_arch_mbox_fetch函数,进入监听等待相关的mbox</li>
<li>接着数据会进入网卡,驱动程序相关的函数负责将它复制进内存</li>
<li>然后调用 ethernet_input函数,进入ethernet层,完成相关处理后,调用ip4_input函数,数据在IwIP组件的IP层对数据进行解包,进行相关处理之后调用 tcp_input函数,进入IwIP组件的TCP层对数据进行解包</li>
<li>最后,调用 sys_mbox_trypost函数把数据放入特定的mbox，等待监听的应用程序就能得到数据</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-18-30.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-18-30.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="数据接受逻辑" /></p>
<ul>
<li><strong>协议栈移植</strong>
<ul>
<li>一种是NO_SYS，无操作系统模式,一种是操作系统模式</li>
<li>操作系统模式主要需要基于操作系统的 IPC 机制，对网络连接进行了抽象（信号量、邮箱/队列、互斥体等机制），从而保证内核与应用层 API 的通讯
<ul>
<li>好处是 lwIP 内核线程可以只负责数据包的 TCP/IP 封装和拆封，而不用进行数据的应用层处理，从而极大地提高系统对网络数据包的处理效率</li>
<li>操作系统模拟层的函数主要是在 sys.h 中声明的一般在 sys_arch.c 文件中完成其定义</li>
</ul>
</li>
<li>所以带操作系统的移植就是在无操作系统的基础上添加操作系统模拟层</li>
</ul>
</li>
<li><strong>有操作系统模式</strong>
<ul>
<li>在cosmos系统提供的IPC等机制基础上,对照sys.h文件中声明的函数进行实现</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-22-02.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-22-02.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="函数表格" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建一个空的邮箱。*/</span></span><br><span class="line"><span class="type">err_t</span> <span class="title function_">sys_mbox_new</span><span class="params">(<span class="type">sys_mbox_t</span> *mbox, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">osMessageQDef(QUEUE, size, <span class="type">void</span> *);</span><br><span class="line">*mbox = osMessageCreate(osMessageQ(QUEUE), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYS_STATS</span></span><br><span class="line">++lwip_stats.sys.mbox.used;</span><br><span class="line"><span class="keyword">if</span> (lwip_stats.sys.mbox.max &lt; lwip_stats.sys.mbox.used) &#123;</span><br><span class="line">lwip_stats.sys.mbox.max = lwip_stats.sys.mbox.used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SYS_STATS */</span></span></span><br><span class="line"><span class="keyword">if</span> (*mbox == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_MEM;</span><br><span class="line"><span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*重新分配一个邮箱。如果邮箱被释放时，邮箱中仍有消息，在lwIP中这是出现编码错误的指示，并通知开</span></span><br><span class="line"><span class="comment">void sys_mbox_free(sys_mbox_t *mbox)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if( osMessageWaiting(*mbox) )</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">portNOP();</span></span><br><span class="line"><span class="comment">#if SYS_STATS</span></span><br><span class="line"><span class="comment">lwip_stats.sys.mbox.err++;</span></span><br><span class="line"><span class="comment">#endif /* SYS_STATS */</span></span><br><span class="line">&#125;</span><br><span class="line">osMessageDelete(*mbox);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYS_STATS</span></span><br><span class="line">--lwip_stats.sys.mbox.used;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SYS_STATS */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*发送消息到邮箱*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_mbox_post</span><span class="params">(<span class="type">sys_mbox_t</span> *mbox, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(osMessagePut(*mbox, (<span class="type">uint32_t</span>)data, osWaitForever) != osOK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*尝试将消息发送到邮箱*/</span></span><br><span class="line"><span class="type">err_t</span> <span class="title function_">sys_mbox_trypost</span><span class="params">(<span class="type">sys_mbox_t</span> *mbox, <span class="type">void</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">err_t</span> result;</span><br><span class="line"><span class="keyword">if</span> ( osMessagePut(*mbox, (<span class="type">uint32_t</span>)msg, <span class="number">0</span>) == osOK)</span><br><span class="line">&#123;</span><br><span class="line">result = ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">result = ERR_MEM;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYS_STATS</span></span><br><span class="line">lwip_stats.sys.mbox.err++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SYS_STATS */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*阻塞进程从邮箱获取消息*/</span></span><br><span class="line"><span class="type">u32_t</span> <span class="title function_">sys_arch_mbox_fetch</span><span class="params">(<span class="type">sys_mbox_t</span> *mbox, <span class="type">void</span> **msg, <span class="type">u32_t</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">osEvent event;</span><br><span class="line"><span class="type">uint32_t</span> starttime = osKernelSysTick();;</span><br><span class="line"><span class="keyword">if</span>(timeout != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">event = osMessageGet (*mbox, timeout);</span><br><span class="line"><span class="keyword">if</span>(event.status == osEventMessage)</span><br><span class="line">&#123;</span><br><span class="line">*msg = (<span class="type">void</span> *)event.value.v;</span><br><span class="line"><span class="keyword">return</span> (osKernelSysTick() - starttime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> SYS_ARCH_TIMEOUT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">event = osMessageGet (*mbox, osWaitForever);</span><br><span class="line">*msg = (<span class="type">void</span> *)event.value.v;</span><br><span class="line"><span class="keyword">return</span> (osKernelSysTick() - starttime);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*尝试从邮箱获取消息*/</span></span><br><span class="line"><span class="type">u32_t</span> <span class="title function_">sys_arch_mbox_tryfetch</span><span class="params">(<span class="type">sys_mbox_t</span> *mbox, <span class="type">void</span> **msg)</span></span><br><span class="line">&#123;</span><br><span class="line">osEvent event;</span><br><span class="line">event = osMessageGet (*mbox, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(event.status == osEventMessage)</span><br><span class="line">&#123;</span><br><span class="line">*msg = (<span class="type">void</span> *)event.value.v;</span><br><span class="line"><span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> SYS_MBOX_EMPTY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断一个邮箱是否有效*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_mbox_valid</span><span class="params">(<span class="type">sys_mbox_t</span> *mbox)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*mbox == SYS_MBOX_NULL)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设置一个邮箱无效*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_mbox_set_invalid</span><span class="params">(<span class="type">sys_mbox_t</span> *mbox)</span></span><br><span class="line">&#123;</span><br><span class="line">*mbox = SYS_MBOX_NULL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个新的信号量。而 &quot;count&quot;参数指示该信号量的初始状态</span></span><br><span class="line"><span class="type">err_t</span> <span class="title function_">sys_sem_new</span><span class="params">(<span class="type">sys_sem_t</span> *sem, <span class="type">u8_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">osSemaphoreDef(SEM);</span><br><span class="line">*sem = osSemaphoreCreate (osSemaphore(SEM), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(*sem == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYS_STATS</span></span><br><span class="line">++lwip_stats.sys.sem.err;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SYS_STATS */</span></span></span><br><span class="line"><span class="keyword">return</span> ERR_MEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">0</span>) <span class="comment">// Means it can&#x27;t be taken</span></span><br><span class="line">&#123;</span><br><span class="line">osSemaphoreWait(*sem,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYS_STATS</span></span><br><span class="line">++lwip_stats.sys.sem.used;</span><br><span class="line"><span class="keyword">if</span> (lwip_stats.sys.sem.max &lt; lwip_stats.sys.sem.used) &#123;</span><br><span class="line">lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SYS_STATS */</span></span></span><br><span class="line"><span class="keyword">return</span> ERR_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外还有一些函数也是协议栈需要的函数，特别是 sys_thread_new 函数，不但协议栈在初始化时需要用到，在后续实现各类基于 lwIP 的应用时也会用得到</span></span><br><span class="line"><span class="comment">// 它的具体实现如下</span></span><br><span class="line"><span class="type">sys_thread_t</span> <span class="title function_">sys_thread_new</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, lwip_thread_fn thread , <span class="type">void</span> *ar</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="type">const</span> osThreadDef_t os_thread_def = &#123; (<span class="type">char</span> *)name, (os_pthread)thread, (osPri</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> osThreadCreate(&amp;os_thread_def, arg);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">osThreadId osThreadCreate (<span class="type">const</span> osThreadDef_t *thread_def, <span class="type">void</span> *argument)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">TaskHandle_t handle;</span></span><br><span class="line"><span class="params">#<span class="keyword">if</span>( configSUPPORT_STATIC_ALLOCATION == <span class="number">1</span> ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCAT</span></span><br><span class="line"><span class="params"><span class="keyword">if</span>((thread_def-&gt;buffer != <span class="literal">NULL</span>) &amp;&amp; (thread_def-&gt;controlblock != <span class="literal">NULL</span>)) &#123;</span></span><br><span class="line"><span class="params">handle = xTaskCreateStatic((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR</span></span><br><span class="line"><span class="params">thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span></span><br><span class="line"><span class="params">thread_def-&gt;buffer, thread_def-&gt;controlblock);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (xTaskCreate((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_d</span></span><br><span class="line"><span class="params">thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span></span><br><span class="line"><span class="params">&amp;handle) != pdPASS) &#123;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">#elif( configSUPPORT_STATIC_ALLOCATION == <span class="number">1</span> )</span></span><br><span class="line"><span class="params">handle = xTaskCreateStatic((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR</span></span><br><span class="line"><span class="params">thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span></span><br><span class="line"><span class="params">thread_def-&gt;buffer, thread_def-&gt;controlblock);</span></span><br><span class="line"><span class="params">#<span class="keyword">else</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (xTaskCreate((TaskFunction_t)thread_def-&gt;pthread,(<span class="type">const</span> portCHAR *)thread_d</span></span><br><span class="line"><span class="params">thread_def-&gt;stacksize, argument, makeFreeRtosPriority(thread_def-&gt;tpriority),</span></span><br><span class="line"><span class="params">&amp;handle) != pdPASS) &#123;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">#endif</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> handle;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="103-详解操作系统的宏观网络架构"><a class="markdownIt-Anchor" href="#103-详解操作系统的宏观网络架构"></a> 10.3 详解操作系统的宏观网络架构</h2>
<ul>
<li><strong>传统网络架构</strong>
<ul>
<li>三层网咯架构设计主要包括：<strong>核心层，汇聚层，接入层</strong></li>
<li><strong>核心层</strong>
<ul>
<li>交换层的核心交换机为进出数据中心的数据包提供高速转发的功能，为多个汇聚层提供连通性，同时为整个网络提供灵活的L3路由网络</li>
<li>汇聚层:汇聚交换机与接入交换机相连，提供防火墙,SSL卸载，入侵检测，网络分析等其他服务</li>
<li>接入层:接入交换机位于机架的顶部，称为ToR交换机，并且与服务器物理连接</li>
</ul>
</li>
<li>经典的IP网络是逐跳转发数据,转发数据时，每台路由器都要根据包头的目的地址查询路由表，已获得下一跳的出口</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-30-40.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-30-40.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="三层网络架构示意图" /></p>
<ul>
<li><strong>优化与迭代:MPLS技术</strong>
<ul>
<li>传统网络架构转发路径不够灵活，在第二层之上第三层之下引入2.5层的技术方案为多协议标签交换(MPLS)技术</li>
<li>MPLS通过LDP标签分发协议,而路径计算元素协议最大的优点是<strong>收集整个网络的拓扑和链路状态信息</strong>
<ul>
<li>通过扩展的资源预留协议,可以实现灵活的转发路径选择或规划</li>
<li>只在OSI的2，3层之间做优化远远不够,为了满足百G传输需求，物理层也经历了从DWDM波分复用系统这种波分复用技术到OTN的技术演进</li>
</ul>
</li>
<li>MPLS技术加重了耦合,并且存在资源利用率低,复杂度高,价格昂贵等缺点
<ul>
<li>SR技术可解决上述问题,随着IPv6的演进,用SRv6代替MPLS技术大势所趋</li>
</ul>
</li>
<li>简单的CLOW网络是包含输入级别,中间级别和输出级别的三级互连体系结构
<ul>
<li>矩形表示规模较小的转发单元，其成本显然也相对较低</li>
<li>CLOS 的本质可以简单理解为是一种多级交换的架构思想，并且这种架构很适合在输入和输出持续增加的情况下将中间交叉数降至最低</li>
<li>m 是每个子模块的输入端口数，n 是每个子模块的输出端口数，r 是每一级的子模块数，经过合理的重排，只要满足公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mn>2</mn><mo>&gt;</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>m</mi><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r2&gt;=max(m1,n3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>对于任意的输入到输出，总是能找到一条无阻塞的通路</li>
<li>应用CLOS架构的交换机的开始密度与交换机端口数量N的关系:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^{3/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
<ul>
<li>在N较大时CLOS模型能降低交换机内部的开关密度</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-41-55.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-41-55.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="MPLS核心结构图" /></p>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-50-12.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-50-12.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CLOS图解" /></p>
<ul>
<li><strong>谈谈Google B4</strong>
<ul>
<li>B4网络的核心架构由Google设计的控制软件和白盒交换机组成</li>
<li>谷歌的目标是建立一个类似于广域网的镜像网络,随着网络规模不断扩展,谷歌大部分业务都已运行在B4上</li>
<li>B4网络由三层组成:物理设备层,局部网络控制层和全局控制层</li>
<li>第一层:物理设备层
<ul>
<li>是Google自研的白盒交换机,使用了24颗16*10Gb的芯片,还携带了128个10Gb网口</li>
<li>交换机运行的是OpenFlow协议</li>
<li>专用的交换机跟OpenFlow进行协同,使用TTP方案,实际运行时交换机将访问控制列表(ACL),路由表,隧道表之类的关键数据通过BGP/IS-IS协议报文送到Controller,由Controller进行处理</li>
</ul>
</li>
<li>第二层:局部网络控制层
<ul>
<li>一个交换机是可以连接多个Controller服务的,而同一时间只会有一个Controller服务为这台交换机提供服务,并且一个数据中心中会包含由多个Controller服务实例构成的服务集群</li>
<li>在局部网络控制层中,会使用Paxos协议负责所有控制功能的领导者选举</li>
<li>具体过程:每个节点上的 Paxos 实例对给定控制功能的可用副本集做应用程序级别的健康检测。当大多数的 Paxos 实例检测到故障时就会从剩余的可用服务器集中选出一个新的负责人。然后，Paxos 会将递增的 ID 号回调给当选的 leader。leader 使用这个 ID 来向客户表明自己的身份</li>
</ul>
</li>
<li>第三层:全局控制层
<ul>
<li>负责全局控制的 TE Server 通过 SDN Gateway 从各个数据中心的控制器收集链路信息，从而掌握路径状态。这些路径以 IP-In-IP 隧道的方式创建，通过 SDN 网关到达 Onix 控制器，最后下达到交换机</li>
<li>当一个新的业务数据需要传输时，应用程序会估计它在传输时需要的带宽，并为它选择一个最佳路径，这样可以让链路的带宽利用率达到整体最佳</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-56-37.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-12-56-37.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="B4网络架构图" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-14-37-39.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-14-37-39.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="物理设备层" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-14-41-06.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-14-41-06.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="局部网络控制层" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-14-41-19.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-14-41-19.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="全局控制层" /></p>
<ul>
<li><strong>SDN原理</strong>
<ul>
<li>SDN架构也分为三层</li>
<li>应用层是由包含了各种不同的业务逻辑的应用构成的</li>
<li>控制层主要负责数据平面相关的资源的编排,调度,网络拓扑的维护以及状态信息管理等工作</li>
<li>数据层主要负责数据的转发,处理以及运行时的状态收集工作</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-14-43-11.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-14-43-11.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ONF-SDN架构图" /></p>
<ul>
<li><strong>SDN的基本特征和优势</strong>
<ul>
<li>SDN主要包含三个基本特征:
<ul>
<li>控制逻辑与转发逻辑分离。转发平面主要是由受控的转发设备构成，具体的转发方式和相关业务逻辑则由分离在控制面的控制应用程序控制</li>
<li>开放的 API。通过开放的南北向 API，可以实现应用和网络的无缝集成，让应用只需要关注自己的逻辑，不需要关注底层的实现细节</li>
<li>集中控制：集中的控制平面可以获取网络资源的全局信息，并根据业务需求进行全局分配和优化</li>
</ul>
</li>
<li>SDN的优势
<ul>
<li>灵活性，动态调整网络设备的配置，不再需要手动配置每台设备</li>
<li>网络硬件简化（如白盒交换机等）。只需要关注数据处理和转发，与具体业务特性解耦，加速新业务特性的引入</li>
<li>自动化的网络部署、操作和维护以及故障诊断</li>
</ul>
</li>
</ul>
</li>
<li><strong>开放网络操作系统ONOS组网实践</strong>
<ul>
<li>ONOS是开源的分布式网络操作系统控制平台,为控制面的具体实现,Mininet对应数据面实现，分别对应SDN的控制面和数据面</li>
<li>使用ONOS+Mininet可以快速创建一个包含主机,交换机,SDN控制器以及链路的虚拟网络,并且Mininet创建的交换机支持OpenFlow协议,具备高度的灵活性
<ul>
<li>可以轻松在本地搭建SDN开发,调试环境</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-15-01-38.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-15-01-38.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="操作系统网络架构" /></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行文稿中的命令安装docker</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install curl</span><br><span class="line">sudo apt install ssh</span><br><span class="line">curl -fsSL https://get.docker.com  | bash -s docker --mirror Aliyun</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完成之后拉取ONOS镜像</span></span><br><span class="line">docker pull onosproject/onos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建onos容器</span></span><br><span class="line">docker run -t -d --name onos1 onosproject/onos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取onos容器的ip</span></span><br><span class="line">docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; &lt;container-ID&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用ssh登录</span></span><br><span class="line">ssh -p 8101 karaf@172.17.0.2</span><br><span class="line">app activate org.onosproject.openflow #启用openflow</span><br><span class="line">app activate org.onosproject.fwd #启用forward转发功能</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出登录,返回虚拟机中配置mininet连接到onos</span></span><br><span class="line">sudo mn --topo tree,2 --controller remote,ip=172.17.0.2 #创建临时网络</span><br><span class="line">pingall #网路连通性检测</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看拓扑</span></span><br><span class="line">打开 URL：http://172.17.0.2:8181/onos/ui/login.html</span><br><span class="line">账号 / 密码：karaf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">说明：先把容器的网络映射到虚拟机，再把虚拟机的网络映射到本地即可</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run的时候加上 -p 8000:80 这样的参数，就可以映射到虚机了，然后再改一下 VBox 的网络设置</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">onos cli</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">karaf 进入 ONOS 之后，除了开启各类设置，它本身也是一个 CLI，可以查看各类信息，例如后面这些信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">devices：查看交换机</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">links：查看链路</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hosts：查看主机</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">flows &lt;tab 键 &gt;：查看所选交换机之间的路径</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="104-详解socket实现与网络编程接口"><a class="markdownIt-Anchor" href="#104-详解socket实现与网络编程接口"></a> 10.4 详解socket实现与网络编程接口</h2>
<ul>
<li><strong>如何理解套接字</strong>
<ul>
<li>Internet 套接字是TCP/IP协议栈中传输层协议的接口，也是传输层以上所有协议的实现；同时，套接字接口在网络程序功能中是内核与应用层之间的接口</li>
<li>TCP/IP协议栈的所有数据和控制功能都来自于套接字接口，与OSI网络分层模型相比,TCP/IP协议栈本身在传输层以上就不包含任何其他协议</li>
<li>在linux操作系统中,替代传输层以上协议实体的标准接口称为套接字,负责实现传输层以上所有功能,可以说套接字是TCP/IP协议栈对外的窗口
<ul>
<li>Linux套接字API适合所有的应用标准,现在的应用层协议也全部移植到Linux系统中</li>
<li><strong>在套接字层下的基础体系结构实现是Linux系统独有的</strong></li>
</ul>
</li>
<li>创建套接字是可通过参数选择协议族,为应用程序指定不同的网络机制
<ul>
<li>指定为PF_INET协议族,套接字称为INET套接字,接口函数提供TCP/IP网络服务功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-15-29-13.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-15-29-13.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Linux内核支持的socket" /></p>
<ul>
<li><strong>套接字的数据结构</strong>
<ul>
<li>Linux下套接字,套接字属性，套接字传输的数据格式还有管理套接字连接状态的数据结构做了抽象定义</li>
<li>每个程序使用的套接字都<strong>包含struct socket数据结构与 struct sock数据结构的实例</strong>
<ul>
<li>Linux 内核在套接字层定义了包含套接字通用属性的数据结构，分别是 struct socket 与struct sock，独立于具体协议</li>
<li>具体的协议族与协议实例继承了通用套接字的属性，加入协议相关属性，就形成了管理协议本身套接字的结构</li>
</ul>
</li>
</ul>
</li>
<li><strong>struct socket数据结构</strong>
<ul>
<li>struct socket 套接字结构类型，每个套接字在内核中都对应唯一的struct socket结构</li>
</ul>
</li>
<li><strong>struct sock数据结构</strong>
<ul>
<li>struct sock数据一部分描述套接字的共用属性,所有协议族的这些属性相同;另一部分属性定义在 strcut sock_common数据结构中</li>
<li>struct sock数据另一部分为新套接字创建 struct sock数据结构实例时会从协议特有的缓冲槽中分配内存,不再从通用缓冲槽中分配内存</li>
<li>struct sock 数据结构包含了大量的内核管理套接字的信息，内核把最重要的成员存放在struct sock_common 数据结构中，struct sock_common 数据结构嵌入在 struct sock结构中，它是 struct sock 数据结构的第一个成员
<ul>
<li>struct sock_common数据结构时套接字在网络中的最小描述包含了内核管理套接字最重要的集合</li>
</ul>
</li>
<li>系统中 struct sock 数据结构组织在特定协议的哈希链表中，skc_node 是连接哈希链表中成员的哈希节点，skc_hash 是引用的哈希值。接收和发送数据放在数据 struct sock 数据结构的两个等待队列中：sk_receive_queue 和sk_write_queue。这两个队列中包含的都是 Socket Buffer</li>
<li>内核使用 struct sock 数据结构实例中的回调函数，获取套接字上某些事件发生的消息或套接字状态发生变化。其中，使用最频繁的回调函数是 sk_data_ready，用户进程等待数据到达时，就会调用该回调函数</li>
</ul>
</li>
<li><strong>套接字与文件</strong>
<ul>
<li>套接字的连接建立后,用户进程就可以使用常规文件操作访问套接字
<ul>
<li>Linux虚拟文件系统层(VFS)的实现:每个文件都有一个VFS inode结构,每个套接字都分配一个该类型的inode,套接字中的inode指针连接管理常规文件的其他结构,操作文件的函数存放在一个独立的指针表中</li>
</ul>
</li>
<li>套接字的文件描述符的文件访问的重定向,对网络协议栈各层是透明的,inode和socket的链接是通过直接分配一个辅助数据结构来实现</li>
</ul>
</li>
<li><strong>套接字缓存</strong>
<ul>
<li>Socket Buffer为套接字缓存,代表了一个要发送或处理的报文，贯穿于整个TCP/IP协议栈的各层
<ul>
<li>在Linux内核对网络数据打包处理的全过程中,始终伴随Socket Buffer</li>
<li><strong>Socket Buffer是网络数据包在内核中的对象实例</strong></li>
</ul>
</li>
<li>Socket Buffer主要包括两部分:数据包;管理数据结构(struct sk_buff)</li>
<li>struct sk_buff 数据结构中存放了套接字接收 / 发送的数据
<ul>
<li>在发送数据时，在套接字层创建了 Socket Buffer 缓冲区与管理数据结构，存放来自应用程序的数据</li>
<li>在接收数据包时，Socket Buffer 则在网络设备的驱动程序中创建，存放来自网络的数据</li>
<li>在发送和接受数据的过程中，各层协议的头信息会不断从数据包中插入和去掉，sk_buff 结构中描述协议头信息的地址指针也会被不断地赋值和复位</li>
</ul>
</li>
</ul>
</li>
<li><strong>套接字的初始化</strong>
<ul>
<li>Linux 内核支持的地址族非常多，TCP/IP 协议栈在套接字层注册的地址族是 AF_INET，AF_INET 地址族是在内核启动时注册到内核中的。TCP/IP 协议栈与 AF_INET 地址族相连的处理函数，既可以在套接字初始化时与 AF_INET 地址连接起来，也可以在套接字中动态地注册新的协议栈</li>
<li>套接字层的初始化要为以后各协议初始化 struct sock 数据结构对象、套接字缓冲区Socket Buffer 对象等做好准备，预留内存空间</li>
<li>基本任务
<ul>
<li>初始化套接字的缓存槽</li>
<li>为 Socket Buffer 创建内存缓存槽</li>
<li>创建虚拟文件系统</li>
</ul>
</li>
</ul>
</li>
<li><strong>地址族的值和协议交换表</strong>
<ul>
<li>套接字是一个通用接口，它可以与多个协议族建立接口，每个协议族中又可以实现多个协议实例</li>
<li>TCP/IP 协议栈处理完输入数据包后，将数据包交给套接字层，放在套接字的接收缓冲区队列（sk_rcv_queue）。然后数据包从套接字层离开内核，送给应用层等待数据包的用户程序。用户程序向外发送的数据包缓存在套接字的传送缓冲区队列（sk_write_queue），从套接字层进入内核地址空间</li>
<li>如何确定哪个套接字是当前数据包的目标套接字
<ul>
<li>使用 struct inet_protosw 数据结构，管理和描述 struct proto_ops 和 struct proto 之间的对应关系
<ul>
<li>structproto_ops 就是系统调用套接字的操作函数块</li>
<li>struct proto 就是跟内核协议相关的套接字操作函数块</li>
</ul>
</li>
</ul>
</li>
<li>内核使用 struct inet_protosw 数据结构实现的协议交换表，将应用程序通过 socketcall 系统调用指定的套接字操作，转换成对某个协议实例实现的套接字操作函数的调用
<ul>
<li>struct inet_protosw 类型把 INET 套接字的协议族操作集与传输层协议操作集关联起来。该类型的 inetsw_array 数组变量实现了 INET 套接字的协议族操作集与具体的传输层协议关联。由 struct inet_protosw 数据结构类型数组 inetsw_array[]构成的向量表，称为协议交换表，协议交换表满足了套接字支持多协议栈功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="comment">// struct socket数据结构</span></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">  socket_state state; <span class="comment">// 套接字的状态</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">// 套接字的设置标志。存放套接字等待缓冲区的状态信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_list</span>;</span> <span class="comment">// 等待被唤醒的套接字列表，该链表用于异步文</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 套接字所属的文件描述符</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span> <span class="comment">// 指向存放套接字属性的结构指针</span></span><br><span class="line">  <span class="type">wait_queue_head_t</span> wait; <span class="comment">//套接字的等待队列</span></span><br><span class="line">  <span class="type">short</span> type; <span class="comment">// 套接字的类型。其取值为SOCK_XXXX形式</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span> <span class="comment">// 套接字层的操作函数块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"><span class="comment">// struct sock数据结构</span></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> skc_family; <span class="comment">/*地址族*/</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> skc_state; <span class="comment">/*连接状态*/</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> skc_reuse; <span class="comment">/*SO_REUSEADDR设置*/</span></span><br><span class="line">  <span class="type">int</span> skc_bound_dev_if;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">skc_node</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">skc_bind_node</span>;</span> <span class="comment">/*哈希表相关*/</span></span><br><span class="line">  <span class="type">atomic_t</span> skc_refcnt; <span class="comment">/*引用计数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 套接字与文件</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operation</span> *<span class="title">i_fop</span> // 指向默认文件操作函数块</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_slloc</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// 套接字的初始化</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sock_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 初始化.sock缓存</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  sk_init();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 初始化sk_buff缓存</span></span><br><span class="line"><span class="comment">  skb_init();</span></span><br><span class="line"><span class="comment">  /* 初始化协议模块缓存</span></span><br><span class="line"><span class="comment">  init_inodecache();</span></span><br><span class="line"><span class="comment">  /* 注册文件系统类型 */</span></span><br><span class="line">  err = register_filesystem(&amp;sock_fs_type);</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">goto</span> out_fs;</span><br><span class="line">  sock_mnt = kern_mount(&amp;sock_fs_type);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(sock_mnt)) &#123;</span><br><span class="line">    err = PTR_ERR(sock_mnt);</span><br><span class="line">    <span class="keyword">goto</span> out_mount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="comment">// inet_protosw</span></span><br><span class="line"><span class="comment">// ------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> type; <span class="comment">/* AF_INET协议族套接字的类型,如TCP为SOCK_STREAM*/</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> protocol; <span class="comment">/* 协议族中某个协议实例的编号。如TCP协议的编码为IPPROTO_</span></span><br><span class="line"><span class="comment">  struct proto *prot;</span></span><br><span class="line"><span class="comment">  const struct proto_ops *ops;</span></span><br><span class="line"><span class="comment">  unsigned char flags; /* 该套接字属性的相关标志 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="105-详解socket的接口实现"><a class="markdownIt-Anchor" href="#105-详解socket的接口实现"></a> 10.5 详解socket的接口实现</h2>
<ul>
<li><strong>套接字接口</strong>
<ul>
<li>从 TCP/IP 协议栈的角度来看，传输层以上的都是应用程序的一部分，TCP/IP 协议栈驻留在内核中，与内核的其他组件共享内存。传输层以上执行的网络功能，都是在用户地址空间完成的</li>
<li>Linux 使用内核套接字概念与用户空间套接字通信，提供了一套 API 和套接字数据结构，这些服务向下与内核接口，向上与用户空间接口，应用程序正是使用这一套 API 访问内核中的网络功能</li>
</ul>
</li>
<li><strong>套接字的创建</strong>
<ul>
<li>必须调用套接字库函数API创建一个新的套接字,创建好之后对库函数创建套接字调用，会转换为内核套接字创建函数的系统调用,完成通用套接字创建的初始化功能</li>
<li>在应用程序中执行socket函数,产生系统调用中断执行内核的套接字分路函数sys_socketcall，在sys_socketcall套接字函数分路器中将调用传送到sys_socket函数，由sys_socket函数调用创建函数sock_create,该函数完成通用套接字创建,初始化任务后,再调用特定协议族的套接字创建函数</li>
<li>一个新的 struct socket 数据结构起始由 sock_create 函数创建，该函数直接调用__sock_create 函数，__sock_create 函数的任务是为套接字预留需要的内存空间，由sock_alloc 函数完成这项功能</li>
<li>sock_alloc 函数不仅会为 struct socket 数据结构实例预留空间，也会为 struct inode 数据结构实例分配需要的内存空间，可以使两个数据结构的实例相关联</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-16-09-41.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-16-09-41.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="socket创建示意图" /></p>
<ul>
<li><strong>套接字的绑定</strong>
<ul>
<li>完成套接字的创建后,应用程序需要调用 sys_bind 函数将套接字和地址绑定</li>
<li>sys_bind 函数首先会查找套接字对应的 socket 实例，调用sockfd_lookup_light。在绑定之前，将用户空间的地址拷贝到内核空间的缓冲区中，在拷贝过程中会检查用户传入的地址是否正确；上述的准备工作完成后，就会调用 inet_bind 函数来完成绑定操作</li>
</ul>
</li>
<li><strong>主动连接</strong>
<ul>
<li>应用程序是面向连接的网络服务,故需要在请求连接服务的进程与提供服务的进程之间建立连接</li>
<li>当应用程序调用<strong>connect函数</strong>发出连接请求时,内核会启动<strong>sys_connect</strong>
<ul>
<li>连接成功后返回socket描述符,否则返回错误码</li>
</ul>
</li>
</ul>
</li>
<li><strong>监听套接字</strong>
<ul>
<li>调用listen函数,应用程序触发内核的sys_listen函数,将套接字描述符fd对应的套接字设置为监听模式,观察连接请求</li>
</ul>
</li>
<li><strong>被动连接</strong>
<ul>
<li>接受一个客户端的连接请求会调用 accept 函数，应用程序触发内核函数 sys_accept，等待接收连接请求</li>
<li>如果允许连接，则重新创建一个代表该连接的套接字，并返回其套接字描述符</li>
</ul>
</li>
<li><strong>发送数据</strong>
<ul>
<li><strong>套接字应用中最简单的传送函数使send函数</strong>，允许应用程序指定标志,规定如何对待传送数据</li>
<li>调用send函数会触发内核的sys_send函数将发送缓冲区的数据发送出去</li>
<li>sys_send函数具体调用流程
<ul>
<li>应用程序的数据被复制到内核后，sys_send 函数调用 sock_sendmsg，依据协议族类型来执行发送操作</li>
<li>如果是 INET 协议族套接字，sock_sendmsg 将调用 inet_sendmsg 函数</li>
<li>如果采用 TCP 协议，inet_sendmsg 函数将调用 tcp_sendmsg，并按照 TCP 协议规则来发送数据包</li>
</ul>
</li>
</ul>
</li>
<li><strong>接受数据</strong>
<ul>
<li>recv 函数中可以指定标志来控制如何接收数据，调用recv 函数时，应用程序会触发内核的 sys_recv 函数，把网络中的数据递交到应用程序</li>
<li>具体流程
<ul>
<li>sys_recv 函数依次调用sys_recvfrom、sock_recvfrom 和__sock_recvmsg，并依据协议族类型来执行具体的接收操作，将内核的网咯数据转入应用程序的接收缓冲区</li>
<li>如果是 INET 协议族套接字，__sock_recvmsg 将调用 sock_common_recvmsg 函数</li>
<li>如果采用 TCP 协议，sock_common_recvmsg 函数将调用 tcp_recvmsg，按照 TCP协议规则来接收数据包</li>
</ul>
</li>
<li>如果接收方想获取数据包发送端的标识符，应用程序可以调用 sys_recvfrom 函数来获取数据包发送方的源地址</li>
</ul>
</li>
<li><strong>关闭连接</strong>
<ul>
<li>应用程序调用shutdown函数关闭连接内核会启动函数sys_shutdown</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 套接字的创建</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __sock_create(<span class="keyword">struct</span> net *net, <span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol,</span><br><span class="line"><span class="keyword">struct</span> socket **res, <span class="type">int</span> kern)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> *<span class="title">pf</span>;</span></span><br><span class="line"><span class="comment">// 首先检验是否支持协议族</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 检查是否在内核支持的socket范围内</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (family &lt; <span class="number">0</span> || family &gt;= NPROTO)</span><br><span class="line"><span class="keyword">return</span> -EAFNOSUPPORT;</span><br><span class="line"><span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt;= SOCK_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 为新的套接字分配内存空间，分配成功后返回新的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sock = sock_alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> socket *<span class="title function_">sock_alloc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="comment">// 初始化一个可用的inode节点， 在fs/inode.c中</span></span><br><span class="line">inode = new_inode(sock_mnt-&gt;mnt_sb);</span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 实际创建的是socket_alloc复合对象，因此要使用SOCKET_I宏从inode中取出关联的socket</span></span><br><span class="line">sock = SOCKET_I(inode);</span><br><span class="line">kmemcheck_annotate_bitfield(sock, type);</span><br><span class="line"><span class="comment">// 文件类型为套接字</span></span><br><span class="line">inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO;</span><br><span class="line">inode-&gt;i_uid = current_fsuid();</span><br><span class="line">inode-&gt;i_gid = current_fsgid();</span><br><span class="line">percpu_add(sockets_in_use, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数将 struct socket 数据结构的 struct proto_ops *ops 设置为 NULL</span></span><br><span class="line"><span class="comment">// 随后，当某个协议族中的协议成员的套接字创建函数被调用时，ops 将指向协议实例的操作函数</span></span><br><span class="line"><span class="comment">// 这时将 struct socket 数据结构的 flags 数据域设置为 0，创建时还没有任何标志需要设置</span></span><br><span class="line"><span class="comment">// 在之后的调用中，应用程序调用 send 或 receive 套接字库函数时会设置 flags 数据域。最后将其他两个数据域 sk 和 file 初始化为 NULL。sk 数据域随后会把由协议特有的套接字创建函数设置为指向内部套接字结构。file 将在调用 sock_ma_fd 函数时设置为分配的文件返回的指针</span></span><br><span class="line"><span class="comment">// 文件指针用于访问打开套接字的虚拟文件系统的文件状态。在 sock_alloc 函数返回后，sock_create 函数调用协议族的套接字创建函数 err =pf-&gt;create(net, sock, protocol)，它通过访问 net_families 数组获取协议族的创建函数，对于 TCP/IP 协议栈，协议族将设置为 AF_INET</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 套接字的绑定</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sysbind</span> <span class="params">(bind, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, umyaddr, <span class="type">int</span></span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> socket *sock;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sockaddr_storage address;</span></span><br><span class="line"><span class="params"><span class="type">int</span> err, fput_needed;</span></span><br><span class="line"><span class="params"><span class="comment">// 获取socket实例</span></span></span><br><span class="line"><span class="params">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (sock) &#123;</span></span><br><span class="line"><span class="params">err = move_addr_to_kernel(umyaddr, addrlen, (<span class="keyword">struct</span> sockaddr *)&amp;address);</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="params">err = security_socket_bind(sock,</span></span><br><span class="line"><span class="params">(<span class="keyword">struct</span> sockaddr *)&amp;address,</span></span><br><span class="line"><span class="params">addrlen);</span></span><br><span class="line"><span class="params"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="params">* 如果是TCP套接字，sock-&gt;ops指向的是inet_stream_ops，</span></span></span><br><span class="line"><span class="comment"><span class="params">* sock-&gt;ops是在inet_create()函数中初始化，所以bind接口</span></span></span><br><span class="line"><span class="comment"><span class="params">* 调用的是inet_bind()函数。</span></span></span><br><span class="line"><span class="comment"><span class="params">*/</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (!err)</span></span><br><span class="line"><span class="params">err = sock-&gt;ops-&gt;bind(sock,</span></span><br><span class="line"><span class="params">(<span class="keyword">struct</span> sockaddr *)</span></span><br><span class="line"><span class="params">&amp;address, addrlen);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">fput_light(sock-&gt;file, fput_needed);</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> err;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="type">int</span> inet_bind(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sockaddr_in *addr = (<span class="keyword">struct</span> sockaddr_in *)uaddr;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> sock *sk = sock-&gt;sk;</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> inet_sock *inet = inet_sk(sk);</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">short</span> snum;</span></span><br><span class="line"><span class="params"><span class="type">int</span> chk_addr_ret;</span></span><br><span class="line"><span class="params"><span class="type">int</span> err;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;bind) &#123;<span class="comment">/* 如果传输层接口上实现了bind调用，则回调它。目前只有SOCK_</span></span></span><br><span class="line"><span class="comment"><span class="params">err = sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);</span></span></span><br><span class="line"><span class="comment"><span class="params">goto out;</span></span></span><br><span class="line"><span class="comment"><span class="params">&#125;</span></span></span><br><span class="line"><span class="comment"><span class="params">err = -EINVAL;</span></span></span><br><span class="line"><span class="comment"><span class="params">if (addr_len &lt; sizeof(struct sockaddr_in))</span></span></span><br><span class="line"><span class="comment"><span class="params">goto out;</span></span></span><br><span class="line"><span class="comment"><span class="params">err = -EADDRNOTAVAIL;</span></span></span><br><span class="line"><span class="comment"><span class="params">if (!sysctl_ip_nonlocal_bind &amp;&amp;/* 必须绑定到本地接口的地址 */</span></span></span><br><span class="line"><span class="params">!inet-&gt;freebind &amp;&amp;</span></span><br><span class="line"><span class="params">addr-&gt;sin_addr.s_addr != INADDR_ANY &amp;&amp;<span class="comment">/* 绑定地址不合法 */</span></span></span><br><span class="line"><span class="params">chk_addr_ret != RTN_LOCAL &amp;&amp;</span></span><br><span class="line"><span class="params">chk_addr_ret != RTN_MULTICAST &amp;&amp;</span></span><br><span class="line"><span class="params">chk_addr_ret != RTN_BROADCAST)</span></span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">err = -EACCES;</span><br><span class="line"><span class="keyword">if</span> (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp; !capable(CAP_NET_BIND_SERVICE))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">lock_sock(sk);<span class="comment">/* 对套接口进行加锁，因为后面要对其状态进行判断 */</span></span><br><span class="line"><span class="comment">/* Check these errors (active socket, double bind). */</span></span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果状态不为CLOSE，表示套接口已经处于活动状态，不能再绑定</span></span><br><span class="line"><span class="comment">* 或者已经指定了本地端口号，也不能再绑定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;num)</span><br><span class="line"><span class="keyword">goto</span> out_release_sock;</span><br><span class="line"><span class="comment">/* 设置地址到传输控制块中 */</span></span><br><span class="line">inet-&gt;rcv_saddr = inet-&gt;saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line"><span class="comment">/* 如果是广播或者多播地址，则源地址使用设备地址。 */</span></span><br><span class="line"><span class="keyword">if</span> (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)</span><br><span class="line">inet-&gt;saddr = <span class="number">0</span>; <span class="comment">/* Use device */</span></span><br><span class="line"><span class="comment">/* 调用传输层的get_port来进行地址绑定。如tcp_v4_get_port或udp_v4_get_port */</span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置标志，表示已经绑定了本地地址和端口 */</span></span><br><span class="line"><span class="keyword">if</span> (inet-&gt;rcv_saddr)</span><br><span class="line">sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;</span><br><span class="line"><span class="keyword">if</span> (snum)</span><br><span class="line">sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;</span><br><span class="line">inet-&gt;sport = htons(inet-&gt;num);</span><br><span class="line"><span class="comment">/* 还没有连接到对方，清除远端地址和端口 */</span></span><br><span class="line">inet-&gt;daddr = <span class="number">0</span>;</span><br><span class="line">inet-&gt;dport = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 清除路由缓存 */</span></span><br><span class="line">sk_dst_reset(sk);</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">out_release_sock:</span><br><span class="line">release_sock(sk);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 主动连接</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="type">int</span> __sys_connect(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr __user *uservaddr, <span class="type">int</span> addrlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = -EBADF;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">f = fdget(fd);</span><br><span class="line"><span class="keyword">if</span> (f.file) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">ret = move_addr_to_kernel(uservaddr, addrlen, &amp;address);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="comment">// 调用__sys_connect_file</span></span><br><span class="line">ret = __sys_connect_file(f.file, &amp;address, addrlen, <span class="number">0</span>);</span><br><span class="line">fdput(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 监听套接字</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="type">int</span> __sys_listen(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="type">int</span> err, fput_needed;</span><br><span class="line"><span class="type">int</span> somaxconn;</span><br><span class="line"><span class="comment">// 通过套接字描述符找到struct socket</span></span><br><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (sock) &#123;</span><br><span class="line">somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)backlog &gt; somaxconn)</span><br><span class="line">backlog = somaxconn;</span><br><span class="line">err = security_socket_listen(sock, backlog);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line"><span class="comment">// 根据套接字类型调用监听函数</span></span><br><span class="line">err = sock-&gt;ops-&gt;listen(sock, backlog);</span><br><span class="line">fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 被动接收连接</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="type">int</span> __sys_accept4_file(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> file_flags,</span><br><span class="line"><span class="keyword">struct</span> sockaddr __user *upeer_sockaddr,</span><br><span class="line"><span class="type">int</span> __user *upeer_addrlen, <span class="type">int</span> flags,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nofile)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>, *<span class="title">newsock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line"><span class="type">int</span> err, len, newfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))</span><br><span class="line">flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;</span><br><span class="line">sock = sock_from_file(file, &amp;err);</span><br><span class="line"><span class="keyword">if</span> (!sock)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">err = -ENFILE;</span><br><span class="line"><span class="comment">// 创建一个新套接字</span></span><br><span class="line">newsock = sock_alloc();</span><br><span class="line"><span class="keyword">if</span> (!newsock)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">newsock-&gt;type = sock-&gt;type;</span><br><span class="line">newsock-&gt;ops = sock-&gt;ops;</span><br><span class="line">__module_get(newsock-&gt;ops-&gt;owner);</span><br><span class="line">newfd = __get_unused_fd_flags(flags, nofile);</span><br><span class="line"><span class="keyword">if</span> (unlikely(newfd &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">err = newfd;</span><br><span class="line">sock_release(newsock);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">newfile = sock_alloc_file(newsock, flags, sock-&gt;sk-&gt;sk_prot_creator-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newfile)) &#123;</span><br><span class="line">err = PTR_ERR(newfile);</span><br><span class="line">put_unused_fd(newfd);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">err = security_socket_accept(sock, newsock);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> out_fd;</span><br><span class="line"><span class="comment">// 根据套接字类型调用不同的函数inet_accept</span></span><br><span class="line">err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags | file_flags,</span><br><span class="line"><span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_fd;</span><br><span class="line"><span class="keyword">if</span> (upeer_sockaddr) &#123;</span><br><span class="line">len = newsock-&gt;ops-&gt;getname(newsock,</span><br><span class="line">(<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">err = -ECONNABORTED;</span><br><span class="line"><span class="keyword">goto</span> out_fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从内核复制到用户空间</span></span><br><span class="line">err = move_addr_to_user(&amp;address,</span><br><span class="line">len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* File flags are not inherited via accept() unlike another OSes. */</span></span><br><span class="line">fd_install(newfd, newfile);</span><br><span class="line">err = newfd;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">out_fd:</span><br><span class="line">fput(newfile);</span><br><span class="line">put_unused_fd(newfd);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="type">int</span> __sys_recvfrom(<span class="type">int</span> fd, <span class="type">void</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line"><span class="keyword">struct</span> sockaddr __user *addr, <span class="type">int</span> __user *addr_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"><span class="type">int</span> err, err2;</span><br><span class="line"><span class="type">int</span> fput_needed;</span><br><span class="line">err = import_single_range(READ, ubuf, size, &amp;iov, &amp;msg.msg_iter);</span><br><span class="line"><span class="keyword">if</span> (unlikely(err))</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="comment">// 通过套接字描述符找到struct socket</span></span><br><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (!sock)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">msg.msg_control = <span class="literal">NULL</span>;</span><br><span class="line">msg.msg_controllen = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Save some cycles and don&#x27;t copy the address if not needed */</span></span><br><span class="line">msg.msg_name = addr ? (<span class="keyword">struct</span> sockaddr *)&amp;address : <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* We assume all kernel code knows the size of sockaddr_storage */</span></span><br><span class="line">msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">msg.msg_iocb = <span class="literal">NULL</span>;</span><br><span class="line">msg.msg_flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">flags |= MSG_DONTWAIT;</span><br><span class="line"><span class="comment">// sock_recvmsg为具体的接收函数</span></span><br><span class="line">err = sock_recvmsg(sock, &amp;msg, flags);</span><br><span class="line"><span class="keyword">if</span> (err &gt;= <span class="number">0</span> &amp;&amp; addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">// 从内核复制到用户空间</span></span><br><span class="line">err2 = move_addr_to_user(&amp;address,</span><br><span class="line">msg.msg_namelen, addr, addr_len);</span><br><span class="line"><span class="keyword">if</span> (err2 &lt; <span class="number">0</span>)</span><br><span class="line">err = err2;</span><br><span class="line">&#125;</span><br><span class="line">fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="type">int</span> __sys_shutdown(<span class="type">int</span> fd, <span class="type">int</span> how)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err, fput_needed;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);<span class="comment">/* 通过套接字，描述符找到对应的</span></span><br><span class="line"><span class="comment">if (sock != NULL) &#123;</span></span><br><span class="line"><span class="comment">err = security_socket_shutdown(sock, how);</span></span><br><span class="line"><span class="comment">if (!err)</span></span><br><span class="line"><span class="comment">/* 根据套接字协议族调用关闭函数*/</span></span><br><span class="line">err = sock-&gt;ops-&gt;shutdown(sock, how);</span><br><span class="line">fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建套接字应用程序一般要经过 6 个步骤
<ol>
<li>创建套接字。</li>
<li>将套接字与地址绑定，设置套接字选项。</li>
<li>建立套接字之间的连接。</li>
<li>监听套接字</li>
<li>接收、发送数据。</li>
<li>关闭、释放套接字</li>
</ol>
</li>
</ul>
<hr />
<h1 id="11-接口"><a class="markdownIt-Anchor" href="#11-接口"></a> 11 接口</h1>
</div><div class="story post-story"><h2 id="111-如何搭建沟通桥梁"><a class="markdownIt-Anchor" href="#111-如何搭建沟通桥梁"></a> 11.1 如何搭建沟通桥梁</h2>
<ul>
<li><strong>服务接口的结构</strong>
<ul>
<li>cosmos的API数量很多,分为进程类,内存类,文件类和时间类的API,API被上层C库封装方便应用程序调用</li>
<li>应用程序库分为时间库,进程库,内存库,文件库几类</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-18-36-19.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-18-36-19.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="API框架" /></p>
<ul>
<li><strong>如何进入内核</strong>
<ul>
<li>应用程序和库函数在用户空间中,而系统服务在内核空间中,让代码控制流从用户空间进入内核空间需要穿过CPU保护模式</li>
</ul>
</li>
<li><strong>软中断指令</strong>
<ul>
<li><strong>CPU长模式下处理中断</strong>
<ul>
<li>设备向CPU发送一个中断信号,CPU接受电子信号后在允许响应中断的情况下,会中断当前运行的程序切换到相应的CPU R0特权级,并跳转到中断门描述符中相应的地址运行中断处理代码(操作系统内核的代码,CPU的控制权转移到操作系统内核上)</li>
</ul>
</li>
<li>应用程序也可以向CPU发送中断,<strong>软中断指令</strong>模拟中断的电子信号
<ul>
<li>在x86CPU上为int指令(如int255,常数表示CPU从中断表描述符表中取得第几个中断描述符进入内核)</li>
</ul>
</li>
</ul>
</li>
<li><strong>传递参数</strong>
<ul>
<li>应用程序运行在用户空间时,用的是用户栈,切换到内核空间时用的是内核栈，故参数的传递需要硬性规定，要么所有的参数用寄存器传递，要么所有的参数都保存在用户栈中
<ul>
<li>用寄存器传递所有参数简单(操作系统常用)</li>
<li>使用 RBX、RCX、RDX、RDI、RSI 这 5 个寄存器来传递参数，事实上一个系统服务接口函数不会超过 5 个参数</li>
<li>RAX 寄存器中保存着一个整数，称为系统服务号。在系统服务分发器中，会根据这个系统服务号调用相应的函数</li>
</ul>
</li>
</ul>
</li>
<li><strong>系统服务分发器</strong>
<ul>
<li>只是用一个中断描述符,然后通过系统服务号来区分各个服务，这就是<strong>系统服务器分发器</strong>完成的工作</li>
</ul>
</li>
<li><strong>实现系统服务分发器</strong>
<ul>
<li>系统服务分发器是一个函数，由中断处理代码调用,在内部根据系统服务号来调用相应的服务</li>
<li>系统服务分发器函数:先对服务号进行判断,若大于系统中最大的服务号,就返回一个错误状态表示服务失败,然后判断是否有服务接口函数，最后两个检查通过后,可以调用相应的服务接口</li>
<li>有中断处理的框架函数 hal_syscl_allocator 函数调用 krlservice</li>
</ul>
</li>
<li><strong>系统服务表</strong>
<ul>
<li>系统服务表用来存放各种系统服务的入口函数，在 krlservice函数中根据服务号,调用相应系统服务表中相应的服务入口函数</li>
<li><mark>使用函数指针数组实现系统服务表</mark></li>
<li>执行int指令后CPU会进入中断处理流程，中断处理流程的第一步将CPU的一寄存器压入内核栈,系统传递参数通过寄存器传递,故需要定义一个 stkparame_t 结构用来提取内核栈中的参数
<ul>
<li>接着查看 hal_syscl_allocator函数的第二个参数为传递的RSP寄存器的值,将该值转化为 stkparame_t 结构的地址,就能提取内核栈中的参数</li>
<li>但是目前 osservicetab 数组中为空，是因为没有实现相应服务接口函数</li>
</ul>
</li>
</ul>
</li>
<li><strong>时间库</strong>:实现时间的库函数</li>
<li><strong>时间API接口</strong>
<ul>
<li>在库中需要调用时间API接口,因为库和API接口函数不同层次的,应用程序直接调用API接口函数</li>
<li>建立 cosmos/lib/lapitime.c文件,实现 api_time函数</li>
</ul>
</li>
<li><strong>内核态时间服务接口</strong>
<ul>
<li>执行int指令后进入内核模式下开始执行内核代码</li>
<li>系统服务分发器会根据服务号从系统服务表中取出相应的函数并调用</li>
</ul>
</li>
<li><strong>系统服务函数的执行过程</strong>
<ul>
<li>应用程序在用户空间中运行，调用库函数，库函数调用 API 函数执行 INT 指令，进入中断门，从而运行内核代码。最后内核代码一步步执行了相关服务功能，返回到用户空间继续运行应用程序</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-20-14-28.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-20-14-28.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="系统服务流程示意图" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 传递参数</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 建立 cosmos/include/libinc/lapinrentry.h文件</span></span><br><span class="line"><span class="comment">//传递一个参数所用的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> API_ENTRY_PARE1(intnr,rets,pval1) \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;movq %[inr],%%rax\n\t&quot;</span>\<span class="comment">//系统服务号</span></span></span><br><span class="line"><span class="string">&quot;movq %[prv1],%%rbx\n\t&quot;</span>\<span class="comment">//第一个参数</span></span><br><span class="line"><span class="string">&quot;int $255 \n\t&quot;</span>\<span class="comment">//触发中断</span></span><br><span class="line"><span class="string">&quot;movq %%rax,%[retval] \n\t&quot;</span>\<span class="comment">//处理返回结果</span></span><br><span class="line">:[retval] <span class="string">&quot;=r&quot;</span> (rets)\</span><br><span class="line">:[inr] <span class="string">&quot;r&quot;</span> (intnr),[prv1]<span class="string">&quot;r&quot;</span> (pval1)\</span><br><span class="line">:<span class="string">&quot;rax&quot;</span>,<span class="string">&quot;rbx&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;memory&quot;</span>\</span><br><span class="line">)</span><br><span class="line"><span class="comment">//传递四个参数所用的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> API_ENTRY_PARE4(intnr,rets,pval1,pval2,pval3,pval4) \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;movq %[inr],%%rax \n\t&quot;</span>\<span class="comment">//系统服务号</span></span></span><br><span class="line"><span class="string">&quot;movq %[prv1],%%rbx \n\t&quot;</span>\<span class="comment">//第一个参数</span></span><br><span class="line"><span class="string">&quot;movq %[prv2],%%rcx \n\t&quot;</span>\<span class="comment">//第二个参数</span></span><br><span class="line"><span class="string">&quot;movq %[prv3],%%rdx \n\t&quot;</span>\<span class="comment">//第三个参数</span></span><br><span class="line"><span class="string">&quot;movq %[prv4],%%rsi \n\t&quot;</span>\<span class="comment">//第四个参数</span></span><br><span class="line"><span class="string">&quot;int $255 \n\t&quot;</span>\<span class="comment">//触发中断</span></span><br><span class="line"><span class="string">&quot;movq %%rax,%[retval] \n\t&quot;</span>\<span class="comment">//处理返回结果</span></span><br><span class="line">:[retval] <span class="string">&quot;=r&quot;</span> (rets)\</span><br><span class="line">:[inr] <span class="string">&quot;r&quot;</span> (intnr),[prv1]<span class="string">&quot;g&quot;</span> (pval1),\</span><br><span class="line">[prv2] <span class="string">&quot;g&quot;</span> (pval2),[prv3]<span class="string">&quot;g&quot;</span> (pval3),\</span><br><span class="line">[prv4] <span class="string">&quot;g&quot;</span> (pval4)\</span><br><span class="line">:<span class="string">&quot;rax&quot;</span>,<span class="string">&quot;rbx&quot;</span>,<span class="string">&quot;rcx&quot;</span>,<span class="string">&quot;rdx&quot;</span>,<span class="string">&quot;rsi&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;memory&quot;</span>\</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 上述两个主要功能是用来解决传递参数和触发中断问题，并且还需要处理系统返回的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统服务接口</span></span><br><span class="line"><span class="comment">//请求分配内存服务</span></span><br><span class="line"><span class="comment">// 可以被库函数调用，也可以由应用程序直接调用，它用 API_ENTRY_PARE1 宏传递参数和触发中断进入 Cosmos 内核，最终将由内存管理模块相应分配内存服务的请求</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">api_mallocblk</span><span class="params">(<span class="type">size_t</span> blksz)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* retadr;</span><br><span class="line"><span class="comment">//把系统服务号，返回变量和请求分配的内存大小</span></span><br><span class="line">API_ENTRY_PARE1(INR_MM_ALLOC,retadr,blksz);</span><br><span class="line"><span class="keyword">return</span> retadr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// 实现系统服务分发器</span></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// 在 cosmos/kernel/krlservice.c 文件中实现系统服务分发器</span></span><br><span class="line"><span class="type">sysstus_t</span> <span class="title function_">krlservice</span><span class="params">(<span class="type">uint_t</span> inr, <span class="type">void</span>* sframe)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(INR_MAX &lt;= inr)<span class="comment">//判断服务号是否大于最大服务号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> SYSSTUSERR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == osservicetab[inr])<span class="comment">//判断是否有服务接口函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> SYSSTUSERR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> osservicetab[inr](inr, (<span class="type">stkparame_t</span>*)sframe);<span class="comment">//调用对应的服务接口函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">sysstus_t</span> <span class="title function_">hal_syscl_allocator</span><span class="params">(<span class="type">uint_t</span> inr,<span class="type">void</span>* krnlsframp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> krlservice(inr,krnlsframp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hal_syscl_allocator 函数则是由系统中断处理的第一层汇编代码调用的，这个汇编代码主要是将进程的用户态 CPU 寄存器保存在内核栈中</span></span><br><span class="line"><span class="comment">//cosmos/include/halinc/kernel.inc</span></span><br><span class="line">%macro EXI_SCALL <span class="number">0</span></span><br><span class="line">push rbx<span class="comment">//保存通用寄存器到内核栈</span></span><br><span class="line">push rcx</span><br><span class="line">push rdx</span><br><span class="line">push rbp</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line"><span class="comment">//删除了一些代码</span></span><br><span class="line">mov rdi, rax <span class="comment">//处理hal_syscl_allocator函数第一个参数inr</span></span><br><span class="line">mov rsi, rsp <span class="comment">//处理hal_syscl_allocator函数第二个参数krnlsframp</span></span><br><span class="line">call hal_syscl_allocator <span class="comment">//调用hal_syscl_allocator函数</span></span><br><span class="line"><span class="comment">//删除了一些代码</span></span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br><span class="line">pop rbp</span><br><span class="line">pop rdx</span><br><span class="line">pop rcx</span><br><span class="line">pop rbx<span class="comment">//从内核栈中恢复通用寄存器</span></span><br><span class="line">iretq <span class="comment">//中断返回</span></span><br><span class="line">%endmacro</span><br><span class="line"><span class="comment">//cosmos/hal/x86/kernel.asm</span></span><br><span class="line">exi_sys_call:</span><br><span class="line">EXI_SCALL</span><br><span class="line"><span class="comment">// exi_sys_call 标号的地址保存在第 255 个中断门描述符中</span></span><br><span class="line"><span class="comment">// 这样执行了 int$255 之后，CPU 就会自动跳转到 exi_sys_call 标号处运行，从而进入内核开始运行，最终调用 krlservice 函数，开始执行系统服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 系统服务表</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 放在cosmos/kernel/krlglobal.c 中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_STKPARAME</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">u64_t</span> gs;</span><br><span class="line"><span class="type">u64_t</span> fs;</span><br><span class="line"><span class="type">u64_t</span> es;</span><br><span class="line"><span class="type">u64_t</span> ds;</span><br><span class="line"><span class="type">u64_t</span> r15;</span><br><span class="line"><span class="type">u64_t</span> r14;</span><br><span class="line"><span class="type">u64_t</span> r13;</span><br><span class="line"><span class="type">u64_t</span> r12;</span><br><span class="line"><span class="type">u64_t</span> r11;</span><br><span class="line"><span class="type">u64_t</span> r10;</span><br><span class="line"><span class="type">u64_t</span> r9;</span><br><span class="line"><span class="type">u64_t</span> r8;</span><br><span class="line"><span class="type">u64_t</span> parmv5;<span class="comment">//rdi;</span></span><br><span class="line"><span class="type">u64_t</span> parmv4;<span class="comment">//rsi;</span></span><br><span class="line"><span class="type">u64_t</span> rbp;</span><br><span class="line"><span class="type">u64_t</span> parmv3;<span class="comment">//rdx;</span></span><br><span class="line"><span class="type">u64_t</span> parmv2;<span class="comment">//rcx;</span></span><br><span class="line"><span class="type">u64_t</span> parmv1;<span class="comment">//rbx;</span></span><br><span class="line"><span class="type">u64_t</span> rvsrip;</span><br><span class="line"><span class="type">u64_t</span> rvscs;</span><br><span class="line"><span class="type">u64_t</span> rvsrflags;</span><br><span class="line"><span class="type">u64_t</span> rvsrsp;</span><br><span class="line"><span class="type">u64_t</span> rvsss;</span><br><span class="line">&#125;<span class="type">stkparame_t</span>;</span><br><span class="line"><span class="comment">//服务函数类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">sysstus_t</span> <span class="params">(*<span class="type">syscall_t</span>)</span><span class="params">(<span class="type">uint_t</span> inr,<span class="type">stkparame_t</span>* stkparm)</span>;</span><br><span class="line"><span class="comment">//cosmos/kernel/krlglobal.c</span></span><br><span class="line">KRL_DEFGLOB_VARIABLE(<span class="type">syscall_t</span>,osservicetab)[INR_MAX]=&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----</span></span><br><span class="line"><span class="comment">// 时间库</span></span><br><span class="line"><span class="comment">// -----</span></span><br><span class="line"><span class="comment">// 实现时间的库函数</span></span><br><span class="line"><span class="comment">// 在cosmos/lib/libtime.c文件</span></span><br><span class="line"><span class="comment">//时间库函数</span></span><br><span class="line"><span class="type">sysstus_t</span> <span class="title function_">time</span><span class="params">(<span class="type">times_t</span> *ttime)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">sysstus_t</span> rets = api_time(ttime);<span class="comment">//调用时间API</span></span><br><span class="line">  <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// time库函数非常简单，对系统API封装,应用程序需要传递一个times_t结构的地址,是这个系统API要求，该结构是由系统定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_TIME</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">uint_t</span> year;</span><br><span class="line"><span class="type">uint_t</span> mon;</span><br><span class="line"><span class="type">uint_t</span> day;</span><br><span class="line"><span class="type">uint_t</span> date;</span><br><span class="line"><span class="type">uint_t</span> hour;</span><br><span class="line"><span class="type">uint_t</span> min;</span><br><span class="line"><span class="type">uint_t</span> sec;</span><br><span class="line">&#125;times t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// 时间API接口</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// cosmos/lib/lapitime.c</span></span><br><span class="line"><span class="type">sysstus_t</span> <span class="title function_">api_time</span><span class="params">(<span class="type">buf_t</span> ttime)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">sysstus_t</span> rets;</span><br><span class="line">API_ENTRY_PARE1(INR_TIME,rets,ttime);<span class="comment">//处理参数，执行int指令</span></span><br><span class="line"><span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// INR_TIME 是系统服务号，它经过 API_ENTRY_PARE1 宏处理，把 INR_TIME 和 ttime、rets 关联到相应的寄存器，如果不明白可以参考前面的参数传递中使用寄存器的情况。最后就是执行 int 指令进入内核，开始运行时间服务代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// 内核态时间服务接口</span></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// 响应的是时间服务,取用时间服务的接口函数</span></span><br><span class="line"><span class="comment">// 建立 cosmos/kernel/keltime.c文件,写时间服务的接口函数</span></span><br><span class="line"><span class="type">sysstus_t</span> <span class="title function_">krlsvetabl_time</span><span class="params">(<span class="type">uint_t</span> inr, <span class="type">stkparame_t</span> *stkparv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (inr != INR_TIME)<span class="comment">//判断是否时间服务号</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> SYSSTUSERR;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用真正时间服务函数</span></span><br><span class="line">  <span class="keyword">return</span> krlsve_time((<span class="type">time_t</span> *)stkparv-&gt;parmv1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// krlsvetabl_time 函数一定要放在系统服务表中才可以，系统服务表其实是个函数指针数组</span></span><br><span class="line"><span class="comment">// 将 kelsvetabl_time函数放入 osservicetab数组</span></span><br><span class="line">KRL_DEFGLOB_VARIABLE(<span class="type">syscall_t</span>, osservicetab)[INR_MAX] = &#123;</span><br><span class="line"><span class="literal">NULL</span>, krlsvetabl_mallocblk,<span class="comment">//内存分配服务接口</span></span><br><span class="line">krlsvetabl_mfreeblk, <span class="comment">//内存释放服务接口</span></span><br><span class="line">krlsvetabl_exel_thread,<span class="comment">//进程服务接口</span></span><br><span class="line">krlsvetabl_exit_thread,<span class="comment">//进程退出服务接口</span></span><br><span class="line">krlsvetabl_retn_threadhand,<span class="comment">//获取进程id服务接口</span></span><br><span class="line">krlsvetabl_retn_threadstats,<span class="comment">//获取进程状态服务接口</span></span><br><span class="line">krlsvetabl_set_threadstats,<span class="comment">//设置进程状态服务接口</span></span><br><span class="line">krlsvetabl_open, krlsvetabl_close,<span class="comment">//文件打开、关闭服务接口</span></span><br><span class="line">krlsvetabl_read, krlsvetabl_write,<span class="comment">//文件读、写服务接口</span></span><br><span class="line">krlsvetabl_ioctrl, krlsvetabl_lseek,<span class="comment">//文件随机读写和控制服务接口</span></span><br><span class="line">krlsvetabl_time&#125;;<span class="comment">//获取时间服务接口</span></span><br><span class="line"><span class="comment">// 获取时间服务接口占最后一个，第 0 个要保留,这样就能调用到 krlsvetabl_time 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 实现时间服务</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// cosmos/kernel/krltime.c文件中实现</span></span><br><span class="line"><span class="type">sysstus_t</span> <span class="title function_">krlsve_time</span><span class="params">(<span class="type">time_t</span> *time)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (time == <span class="literal">NULL</span>)<span class="comment">//对参数进行判断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> SYSSTUSERR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ktime_t</span> *initp = &amp;osktime;<span class="comment">//操作系统保存时间的结构</span></span><br><span class="line"><span class="type">cpuflg_t</span> cpufg;</span><br><span class="line">krlspinlock_cli(&amp;initp-&gt;kt_lock, &amp;cpufg);<span class="comment">//加锁</span></span><br><span class="line">time-&gt;year = initp-&gt;kt_year;</span><br><span class="line">time-&gt;mon = initp-&gt;kt_mon;</span><br><span class="line">time-&gt;day = initp-&gt;kt_day;</span><br><span class="line">time-&gt;date = initp-&gt;kt_date;</span><br><span class="line">time-&gt;hour = initp-&gt;kt_hour;</span><br><span class="line">time-&gt;min = initp-&gt;kt_min;</span><br><span class="line">time-&gt;sec = initp-&gt;kt_sec;<span class="comment">//把时间数据写入到参数指向的内存</span></span><br><span class="line">krlspinunlock_sti(&amp;initp-&gt;kt_lock, &amp;cpufg);<span class="comment">//解锁</span></span><br><span class="line"><span class="keyword">return</span> SYSSTUSOK;<span class="comment">//返回正确的状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// krlsve_time 函数，只是把系统的时间数据读取出来，写入用户应用程序传入缓冲区中，由于 osktime 这个结构实例会由其它代码自动更新，所以要加锁访问</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="112-如何实现系统api"><a class="markdownIt-Anchor" href="#112-如何实现系统api"></a> 11.2 如何实现系统API</h2>
<ul>
<li><strong>Linux内核API接口的架构</strong>
<ul>
<li>在Linux内核之上使用最广泛的C库是glibc，其中包括C标准库的实现,也包括所有和系统API对应的库接口函数</li>
<li>glibc是Linux内核上C程序运行的基础</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-20-22-25.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-20-22-25.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="LinuxAPI框架" /></p>
<ul>
<li><strong>Linux内核有多少API接口</strong>
<ul>
<li>对Linux代码进行编译，在编译的过程中根据 syscall_32.tbl 和 syscall_64.tbl 生成自己的 syscalls_32.h 和 syscall_64.h 文件</li>
<li>生成方式在 arch/x86/entry/syscalls/Makefile文件中,使用两个脚本 <a target="_blank" rel="noopener" href="http://syscallhdr.sh">syscallhdr.sh</a>，<a target="_blank" rel="noopener" href="http://syscalltbl.sh">syscalltbl.sh</a>，最终生成的 syscalls_32.h 和 syscalls_64.h 两个文件中就保存了系统调用号和系统调用实现函数之间的对应关系,可以看到Linux内核的系统调用号(API号)</li>
</ul>
</li>
<li><strong>Linux系统调用表</strong>
<ul>
<li>Linux内核有400多个系统调用，使用了一个函数指针数组,存放所有的系统调用函数的地址,通过数组下表就能索引到相应的系统调用
<ul>
<li><mark>该数组为 sys_call_table，即Linux系统调用表</mark></li>
</ul>
</li>
<li>__SYSCALL_COMMON 首先会替换成 __SYSCALL_64，因为编译的 Linux 内核是 x86_64 架构的</li>
<li>sys_call_table 数组，第一次全部初始化为默认系统调用函数 sys_ni_syscall，该函数无实际工作是为了防止数组有些元素中没有函数地址，从而导致调用失败</li>
</ul>
</li>
<li><strong>下载 Linux 源码</strong>
<ul>
<li>可从github上获得</li>
</ul>
<blockquote>
<p>git clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/</p>
</blockquote>
</li>
<li><strong>申明系统调用</strong>
<ul>
<li>Linux内核的系统调用的申明文件和信息的具体实现:由一个 makefile 在编译 Linux 系统内核时调用了一个脚本，脚本会读取另一个叫 syscall_64.tbl 文件，根据其中信息生成相应的文件 syscall_64.h</li>
</ul>
</li>
<li><strong>定义系统调用</strong>
<ul>
<li>定义一个系统调用函数需要使用专门的宏</li>
<li>对于无参数的系统调用函数,应使用SYSCALL_DEFINE0宏来定义</li>
</ul>
</li>
<li><strong>编译Linux内核</strong>
<ul>
<li>源代码目录下执行make menuconfig指令</li>
<li>可以选择加载一个已经存在的配置文件，这个配置文件可以加载你机器上 boot 目录下的 config 开头的文件，加载之后选择 Save，就能保存配置</li>
<li>然后输入 make -j8 bzImage &amp;&amp; make -j8 modules 就可自行完成编译(j8表示开启8线程并行编译)</li>
<li>使用  sudo make modules_install &amp;&amp; sudo make install 安装内核模块,然后再安装内核,最后调用 update-grub，自动生成启动选项,重启计算机即可选择修改的Linux内核</li>
</ul>
</li>
<li><strong>编写应用测试</strong>
<ul>
<li>使用 gcc main.c -o cpus 指令进行编译，运行之后就可以看到结果了，但是没有写库代码，而是直接使用 syscall 函数
<ul>
<li>这个函数可以根据系统调用号触发系统调用，根据上面定义，441 正是对应咱们的 sys_get_cpus 系统调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以open库函数为例</span></span><br><span class="line"><span class="comment">//glibc/intl/loadmsgcat.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> open(name, flags) __open_nocancel (name, flags)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> close(fd) __close_nocancel_nostatus (fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//glibc/sysdeps/unix/sysv/linux/open_nocancel.c</span></span><br><span class="line"><span class="type">int</span> __open_nocancel (<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> oflag, ...)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (__OPEN_NEEDS_MODE (oflag))</span><br><span class="line">&#123;</span><br><span class="line">va_list arg;</span><br><span class="line">va_start (arg, oflag);<span class="comment">//解决可变参数</span></span><br><span class="line">mode = va_arg (arg, <span class="type">int</span>);</span><br><span class="line">va_end (arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag, mode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//glibc/sysdeps/unix/sysdep.h</span></span><br><span class="line"><span class="comment">//这是为了解决不同参数数量的问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL0(name) \</span></span><br><span class="line"><span class="meta">INLINE_SYSCALL (name, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL1(name, a1) \</span></span><br><span class="line"><span class="meta">INLINE_SYSCALL (name, 1, a1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL2(name, a1, a2) \</span></span><br><span class="line"><span class="meta">INLINE_SYSCALL (name, 2, a1, a2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL3(name, a1, a2, a3) \</span></span><br><span class="line"><span class="meta">INLINE_SYSCALL (name, 3, a1, a2, a3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL_NARGS(...) \</span></span><br><span class="line"><span class="meta">__INLINE_SYSCALL_NARGS_X (__VA_ARGS__,7,6,5,4,3,2,1,0,)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE_SYSCALL_DISP(b,...) \</span></span><br><span class="line"><span class="meta">__SYSCALL_CONCAT (b,__INLINE_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INLINE_SYSCALL_CALL(...) \</span></span><br><span class="line"><span class="meta">__INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)</span></span><br><span class="line"><span class="comment">//glibc/sysdeps/unix/sysv/linux/sysdep.h</span></span><br><span class="line"><span class="comment">//关键是这个宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INLINE_SYSCALL(name, nr, args...) \</span></span><br><span class="line"><span class="meta">(&#123; \</span></span><br><span class="line"><span class="meta">long int sc_ret = INTERNAL_SYSCALL (name, nr, args); \</span></span><br><span class="line"><span class="meta">__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (sc_ret)) \</span></span><br><span class="line"><span class="meta">? SYSCALL_ERROR_LABEL (INTERNAL_SYSCALL_ERRNO (sc_ret)) \</span></span><br><span class="line"><span class="meta">: sc_ret; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SYSCALL(name, nr, args...) \</span></span><br><span class="line"><span class="meta">internal_syscall##nr (SYS_ify (name), args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SYSCALL_NCS(number, nr, args...) \</span></span><br><span class="line"><span class="meta">internal_syscall##nr (number, args)</span></span><br><span class="line"><span class="comment">//这是需要6个参数的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> internal_syscall6(number, arg1, arg2, arg3, arg4, arg5, arg6) \</span></span><br><span class="line"><span class="meta">(&#123; \</span></span><br><span class="line"><span class="meta">unsigned long int resultvar; \</span></span><br><span class="line"><span class="meta">TYPEFY (arg6, __arg6) = ARGIFY (arg6); \</span></span><br><span class="line"><span class="meta">TYPEFY (arg5, __arg5) = ARGIFY (arg5); \</span></span><br><span class="line"><span class="meta">TYPEFY (arg4, __arg4) = ARGIFY (arg4); \</span></span><br><span class="line"><span class="meta">TYPEFY (arg3, __arg3) = ARGIFY (arg3); \</span></span><br><span class="line"><span class="meta">TYPEFY (arg2, __arg2) = ARGIFY (arg2); \</span></span><br><span class="line"><span class="meta">TYPEFY (arg1, __arg1) = ARGIFY (arg1); \</span></span><br><span class="line"><span class="meta">register TYPEFY (arg6, _a6) asm (<span class="string">&quot;r9&quot;</span>) = __arg6; \</span></span><br><span class="line"><span class="meta">register TYPEFY (arg5, _a5) asm (<span class="string">&quot;r8&quot;</span>) = __arg5; \</span></span><br><span class="line"><span class="meta">register TYPEFY (arg4, _a4) asm (<span class="string">&quot;r10&quot;</span>) = __arg4; \</span></span><br><span class="line"><span class="meta">register TYPEFY (arg3, _a3) asm (<span class="string">&quot;rdx&quot;</span>) = __arg3; \</span></span><br><span class="line"><span class="meta">register TYPEFY (arg2, _a2) asm (<span class="string">&quot;rsi&quot;</span>) = __arg2; \</span></span><br><span class="line"><span class="meta">register TYPEFY (arg1, _a1) asm (<span class="string">&quot;rdi&quot;</span>) = __arg1; \</span></span><br><span class="line"><span class="meta">asm volatile ( \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;syscall\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;=a&quot;</span> (resultvar) \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;0&quot;</span> (number), <span class="string">&quot;r&quot;</span> (_a1), <span class="string">&quot;r&quot;</span> (_a2), <span class="string">&quot;r&quot;</span> (_a3), <span class="string">&quot;r&quot;</span> (_a4), \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;r&quot;</span> (_a5), <span class="string">&quot;r&quot;</span> (_a6) \</span></span><br><span class="line"><span class="meta">: <span class="string">&quot;memory&quot;</span>, REGISTERS_CLOBBERED_BY_SYSCALL); \</span></span><br><span class="line"><span class="meta">(long int) resultvar; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// open 只是宏，实际工作的是 __open_nocancel 函数，其中会用 INLINE_SYSCALL_CALL 宏经过一系列替换，最终根据参数的个数替换成相应的 internal_syscall##nr 宏</span></span><br><span class="line"><span class="comment">// 其中 number 是系统调用号，参数通过寄存器传递的。但是这里没有发现 int 指令，这是因为这里用到的指令是最新处理器为其设计的系统调用指令 syscall。这个指令和 int 指令一样，都可以让 CPU 跳转到特定的地址上，只不过不经过中断门，系统调用返回时要用 sysexit 指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------</span></span><br><span class="line"><span class="comment">// Linux内核有多少API接口</span></span><br><span class="line"><span class="comment">// ---------------------</span></span><br><span class="line"><span class="comment">//linux/arch/x86/include/generated/asm/syscalls_64.h</span></span><br><span class="line">__SYSCALL_COMMON(<span class="number">0</span>, sys_read)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">1</span>, sys_write)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">2</span>, sys_open)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">3</span>, sys_close)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">4</span>, sys_newstat)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">5</span>, sys_newfstat)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">6</span>, sys_newlstat)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">7</span>, sys_poll)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">8</span>, sys_lseek)</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">__SYSCALL_COMMON(<span class="number">435</span>, sys_clone3)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">436</span>, sys_close_range)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">437</span>, sys_openat2)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">438</span>, sys_pidfd_getfd)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">439</span>, sys_faccessat2)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">440</span>, sys_process_madvise)</span><br><span class="line"><span class="comment">//linux/arch/x86/include/generated/uapi/asm/unistd_64.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clone3 435</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close_range 436</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_openat2 437</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pidfd_getfd 438</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_faccessat2 439</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_madvise 440</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __KERNEL__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syscall_max 440</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 定义了 __NR_syscall_max 为 440，这说明 Linux 内核一共有 441 个系统调用，而系统调用号从 0 开始到 440 结束，所以最后一个系统调用是sys_process_madvise</span></span><br><span class="line"><span class="comment">// __SYSCALL_COMMON 除了表示系统调用号和系统调用函数之间的关系，还会在Linux 内核的系统调用表中进行相应的展开,Linux内核的系统调用表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="comment">// Linux系统调用表</span></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_COMMON(nr, sym) __SYSCALL_64(nr, sym)</span></span><br><span class="line"><span class="comment">//第一次定义__SYSCALL_64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_64(nr, sym) extern asmlinkage long sym(unsigned long, unsign</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/syscalls_64.h&gt;</span><span class="comment">//第一次包含syscalls_64.h文件，其中的宏会被展开一次，例如</span></span></span><br><span class="line"><span class="keyword">extern</span> asmlinkage <span class="type">long</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, u</span></span><br><span class="line"><span class="params">这表示申明</span></span><br><span class="line"><span class="params"><span class="comment">//取消__SYSCALL_64定义</span></span></span><br><span class="line"><span class="params">#undef __SYSCALL_64</span></span><br><span class="line"><span class="params"><span class="comment">//第二次重新定义__SYSCALL_64</span></span></span><br><span class="line"><span class="params">#define __SYSCALL_64(nr, sym) [ nr ] = sym,</span></span><br><span class="line"><span class="params"><span class="keyword">extern</span> asmlinkage <span class="type">long</span> sys_ni_syscall(<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> l</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">sys_call_ptr_t</span> sys_call_table[] ____cacheline_aligned = &#123;</span></span><br><span class="line"><span class="params">[<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,<span class="comment">//默认系统调用函数，什么都不干</span></span></span><br><span class="line"><span class="params">#include &lt;<span class="keyword">asm</span>/syscalls_64.h&gt;<span class="comment">//包含前面生成文件</span></span></span><br><span class="line"><span class="params"><span class="comment">//第二次包含syscalls_64.h文件，其中的宏会被再展开一次，例如__SYSCALL_COMMON(2, sys_ope</span></span></span><br><span class="line"><span class="params">[<span class="number">2</span>] = sys_open, 用于初始化这个数组，即表示数组的第二个元素填入sys_open</span></span><br><span class="line"><span class="params">&#125;;</span></span><br><span class="line"><span class="params"><span class="type">int</span> syscall_table_size = <span class="keyword">sizeof</span>(sys_call_table);<span class="comment">//系统调用表的大小</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// -----------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 申明系统调用</span></span></span><br><span class="line"><span class="params"><span class="comment">// -----------</span></span></span><br><span class="line"><span class="params"><span class="comment">//linux-5.10.13/arch/x86/entry/syscalls/syscall_64.tbl</span></span></span><br><span class="line"><span class="params"><span class="number">0</span> common read sys_read</span></span><br><span class="line"><span class="params"><span class="number">1</span> common write sys_write</span></span><br><span class="line"><span class="params"><span class="number">2</span> common open sys_open</span></span><br><span class="line"><span class="params"><span class="number">3</span> common close sys_close</span></span><br><span class="line"><span class="params"><span class="number">4</span> common stat sys_newstat</span></span><br><span class="line"><span class="params"><span class="number">5</span> common fstat sys_newfstat</span></span><br><span class="line"><span class="params"><span class="number">6</span> common lstat sys_newlstat</span></span><br><span class="line"><span class="params"><span class="number">7</span> common poll sys_poll</span></span><br><span class="line"><span class="params"><span class="number">8</span> common lseek sys_lseek</span></span><br><span class="line"><span class="params"><span class="number">9</span> common mmap sys_mmap</span></span><br><span class="line"><span class="params"><span class="number">10</span> common mprotect sys_mprotect</span></span><br><span class="line"><span class="params"><span class="number">11</span> common munmap sys_munmap</span></span><br><span class="line"><span class="params"><span class="number">12</span> common brk sys_brk</span></span><br><span class="line"><span class="params"><span class="comment">//……</span></span></span><br><span class="line"><span class="params"><span class="number">435</span> common clone3 sys_clone3</span></span><br><span class="line"><span class="params"><span class="number">436</span> common close_range sys_close_range</span></span><br><span class="line"><span class="params"><span class="number">437</span> common openat2 sys_openat2</span></span><br><span class="line"><span class="params"><span class="number">438</span> common pidfd_getfd sys_pidfd_getfd</span></span><br><span class="line"><span class="params"><span class="number">439</span> common faccessat2 sys_faccessat2</span></span><br><span class="line"><span class="params"><span class="number">440</span> common process_madvise sys_process_madvise</span></span><br><span class="line"><span class="params"><span class="comment">// 上述代码分为四列:系统调用号、架构、服务名，以及其相对应的服务入口函数</span></span></span><br><span class="line"><span class="params"><span class="comment">// 申明自己的系统调用</span></span></span><br><span class="line"><span class="params"><span class="comment">// 第一步在syscall_64.tbl文件中增加一项</span></span></span><br><span class="line"><span class="params"> <span class="number">441</span> common get_cpus sys_get_cpus</span></span><br><span class="line"><span class="params"><span class="comment">//  还需要把 sys-get_cpus函数在syscall.h文件中声明</span></span></span><br><span class="line"><span class="params"><span class="comment">//linux-5.10.13/include/linux/syscalls.h</span></span></span><br><span class="line"><span class="params">asmlinkage <span class="type">long</span> sys_get_cpus(<span class="type">void</span>)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// -----------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 定义系统调用</span></span></span><br><span class="line"><span class="params"><span class="comment">// -----------</span></span></span><br><span class="line"><span class="params"><span class="comment">//linux-5.10.13/include/linux/syscalls.h</span></span></span><br><span class="line"><span class="params">#ifndef SYSCALL_DEFINE0</span></span><br><span class="line"><span class="params">#define SYSCALL_DEFINE0(sname) \</span></span><br><span class="line"><span class="params">SYSCALL_METADATA(_##sname, <span class="number">0</span>); \</span></span><br><span class="line"><span class="params">asmlinkage <span class="type">long</span> sys_##sname(<span class="type">void</span>); \</span></span><br><span class="line"><span class="params">ALLOW_ERROR_INJECTION(sys_##sname, ERRNO); \</span></span><br><span class="line"><span class="params">asmlinkage <span class="type">long</span> sys_##sname(<span class="type">void</span>)</span></span><br><span class="line"><span class="params">#endif <span class="comment">/* SYSCALL_DEFINE0 */</span></span></span><br><span class="line"><span class="params"><span class="comment">//linux-5.10.13/kernel/sys.c</span></span></span><br><span class="line"><span class="params">SYSCALL_DEFINE0(get_cpus)</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="keyword">return</span> num_present_cpus();<span class="comment">//获取系统中有多少CPU</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="comment">// SYSCALL_DEFINE0 会将 get_cpus 转换成 sys_get_cpus 函数，调用了一个 Linux 内核中另一个函数 num_present_cpus，负责返回系统 CPU 的数量</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// -----------</span></span></span><br><span class="line"><span class="params"><span class="comment">// 编写应用测试</span></span></span><br><span class="line"><span class="params"><span class="comment">// -----------</span></span></span><br><span class="line"><span class="params">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="params">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="params">#include &lt;sys/syscall.h&gt;</span></span><br><span class="line"><span class="params"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params"><span class="comment">//syscall就是根据系统调用号调用相应的系统调用</span></span></span><br><span class="line"><span class="params"><span class="type">long</span> cpus = syscall(<span class="number">441</span>);</span></span><br><span class="line"><span class="params"><span class="built_in">printf</span>(<span class="string">&quot;cpu num is:%d\n&quot;</span>, cpus);<span class="comment">//输出结果</span></span></span><br><span class="line"><span class="params"><span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>
<hr />
<h1 id="12-虚化的世界"><a class="markdownIt-Anchor" href="#12-虚化的世界"></a> 12 虚化的世界</h1>
</div><div class="story post-story"><h2 id="121-kvm是什么"><a class="markdownIt-Anchor" href="#121-kvm是什么"></a> 12.1 KVM是什么</h2>
<ul>
<li><strong>理解虚拟化的定义</strong>
<ul>
<li>虚拟化的本质是一种资源管理技术,可通过各种技术手段把计算机的实体资源进行<strong>转换和抽象</strong>,让资源可以重新分割,排列与组合，实现<strong>最大化使用物理资源的目的</strong></li>
</ul>
</li>
<li><strong>虚拟化的核心思想</strong>
<ul>
<li><strong>可以抽象出一个新的层次来解决资源复用的问题</strong></li>
<li>引入Hypervisor/Virtual Machine Monitor层,向下统一管理和调度真实的物理资源,让每个虚拟机都以为自己独享独立的资源</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-21-33-41.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-21-33-41.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="虚拟化架构简图" /></p>
<ul>
<li><strong>KVM架构梳理</strong>
<ul>
<li>计算机最重要的资源为:CPU,RAM,ROM,以及连接各种设备抽象出的IO资源</li>
<li>Intel设计了VT-x指令集,VT-d指令集,VT-c指令集等技术实现硬件虚拟化</li>
<li>首先客户机看到的硬件资源基本都是有 Hypervisor模拟出来的,客户机对模拟设备进行操作时,命令会被截获并转发给实际设备/内核模块进行处理</li>
<li>通过该架构设计Hypervisor层,最终实现了把一个客户机映射到宿主机OS系统的一个进程,而一个客户机的vCPU映射到这个进程下的独立的线程中,同理IO也映射到同一个线程组内的独立线程中</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-21-37-18.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-21-37-18.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="KVM架构图" /></p>
<ul>
<li><strong>CPU虚拟化原理</strong>
<ul>
<li>Intel定义了VMX处理器特性,即VT-x指令集,开启该特性后存在两种操作模式,根操作和非根操作</li>
<li>Hypervisor/VMM就是运行在根操作模式下,对处理器和平台硬件具有完全的控制权限</li>
<li>客户软件包括虚拟机在内的操作系统和应用程序,则运行在非根操作模式下;当客户软件执行特殊的敏感指令或异常指令,会触发VM-Exit指令切换会根操作模式，从而让 Hypervisor/VMM完全接管控制权限</li>
<li>两种模式间进行切换需要通过 VM-Entry和VM-Exit实现进入和退出</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-21-44-31.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-21-44-31.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="VMM和Guest切换过程" /></p>
<ul>
<li><strong>内存虚拟化原理</strong>
<ul>
<li>早期主要基于影子页表进行地址转换(性能有损耗),后来Intel设计了EPT机制(内存地址转换效率高)</li>
<li>内存从原先的虚拟地址,物理地址转换为4种内存地址
<ul>
<li>客户机虚拟地址 GVA（Guest Virtual Address）</li>
<li>客户机物理地址 GPA（Guest Physical Address）</li>
<li>宿主机虚拟地址 HVA（Host Virtual Address）</li>
<li>宿主机物理地址 HPA（Host Physical Address）</li>
</ul>
</li>
</ul>
</li>
<li><strong>IO虚拟化原理</strong>
<ul>
<li>I/O 虚拟化是基于 Intel 的 VT-d 指令集来实现的是基于 North Bridge 北桥芯片（或 MCH）的硬件辅助虚拟化技术</li>
<li>运用 VT-d 技术，虚拟机得以使用基于直接 I/O 设备分配方式，或者用 I/O 设备共享方式来代替传统的设备模拟 / 额外设备接口方式，不需要硬件改动，还省去了中间通道和VMM 的开销，从而大大提升了虚拟化的 I/O 性能，让虚拟机性能更接近于真实主机</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KVM关键代码走读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 创建虚拟机</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 虚拟机初始化的入口部分</span></span><br><span class="line">virt/kvm/kvm_main.c:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kvm_dev_ioctl_create_vm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm</span> *<span class="title">kvm</span>;</span></span><br><span class="line">kvm = kvm_create_vm(type);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(kvm))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(kvm);</span><br><span class="line">r = kvm_coalesced_mmio_init(kvm);</span><br><span class="line">r = get_unused_fd_flags(O_CLOEXEC);</span><br><span class="line"><span class="comment">/*生成kvm-vm控制文件*/</span></span><br><span class="line">file = anon_inode_getfile(<span class="string">&quot;kvm-vm&quot;</span>, &amp;kvm_vm_fops, kvm, O_RDWR);</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建KVM中内存,IO等资源相关的数据结构并进行初始化</span></span><br><span class="line">virt/kvm/kvm_main.c:</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> kvm *<span class="title function_">kvm_create_vm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r, i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm</span> *<span class="title">kvm</span> =</span> kvm_arch_create_vm();</span><br><span class="line"><span class="comment">/*设置kvm的mm结构为当前进程的mm,然后引用计数为1*/</span></span><br><span class="line">kvm-&gt;mm = current-&gt;mm;</span><br><span class="line">kvm_eventfd_init(kvm);</span><br><span class="line">mutex_init(&amp;kvm-&gt;lock);</span><br><span class="line">mutex_init(&amp;kvm-&gt;irq_lock);</span><br><span class="line">mutex_init(&amp;kvm-&gt;slots_lock);</span><br><span class="line">refcount_set(&amp;kvm-&gt;users_count, <span class="number">1</span>);</span><br><span class="line">INIT_LIST_HEAD(&amp;kvm-&gt;devices);</span><br><span class="line">INIT_HLIST_HEAD(&amp;kvm-&gt;irq_ack_notifier_list);</span><br><span class="line">r = kvm_arch_init_vm(kvm, type);</span><br><span class="line">r = hardware_enable_all()</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KVM_NR_BUSES; i++) &#123;</span><br><span class="line">rcu_assign_pointer(kvm-&gt;buses[i],</span><br><span class="line">kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kvm_io_bus), GFP_KERNEL));</span><br><span class="line">&#125;</span><br><span class="line">kvm_init_mmu_notifier(kvm);</span><br><span class="line"><span class="comment">/*把kvm链表加入总链表*/</span></span><br><span class="line">list_add(&amp;kvm-&gt;vm_list, &amp;vm_list);</span><br><span class="line"><span class="keyword">return</span> kvm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化完毕后会将 KVM 加入到一个全局链表头，可以通过这个链表头，遍历所有的 VM 虚拟机了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// 创建vCPU</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line">virt/kvm/kvm_main.c:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kvm_vm_ioctl_create_vcpu</span><span class="params">(<span class="keyword">struct</span> kvm *kvm, u32 id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span>, *<span class="title">v</span>;</span></span><br><span class="line"><span class="comment">/*调用相关cpu的vcpu_create 通过arch/x86/x86.c 进入vmx.c*/</span></span><br><span class="line">vcpu = kvm_arch_vcpu_create(kvm, id);</span><br><span class="line"><span class="comment">/*调用相关cpu的vcpu_setup*/</span></span><br><span class="line">r = kvm_arch_vcpu_setup(vcpu);</span><br><span class="line"><span class="comment">/*判断是否达到最大cpu个数*/</span></span><br><span class="line">mutex_lock(&amp;kvm-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;kvm-&gt;online_vcpus) == KVM_MAX_VCPUS) &#123;</span><br><span class="line">r = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> vcpu_destroy;</span><br><span class="line">&#125;</span><br><span class="line">kvm-&gt;created_vcpus++;</span><br><span class="line">mutex_unlock(&amp;kvm-&gt;lock);</span><br><span class="line"><span class="comment">/*生成kvm-vcpu控制文件*/</span></span><br><span class="line"><span class="comment">/* Now it&#x27;s all set up, let userspace reach it */</span></span><br><span class="line">kvm_get_kvm(kvm);</span><br><span class="line">r = create_vcpu_fd(vcpu);</span><br><span class="line">kvm_get_kvm(kvm);</span><br><span class="line">r = create_vcpu_fd(vcpu);</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">kvm_put_kvm(kvm);</span><br><span class="line"><span class="keyword">goto</span> unlock_vcpu_destroy;</span><br><span class="line">&#125;</span><br><span class="line">kvm-&gt;vcpus[<span class="type">atomic_read</span>(&amp;kvm-&gt;online_vcpus)] = vcpu;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Pairs with smp_rmb() in kvm_get_vcpu. Write kvm-&gt;vcpus</span></span><br><span class="line"><span class="comment">* before kvm-&gt;online_vcpu&#x27;s incremented value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">smp_wmb();</span><br><span class="line"><span class="type">atomic_inc</span>(&amp;kvm-&gt;online_vcpus);</span><br><span class="line">mutex_unlock(&amp;kvm-&gt;lock);</span><br><span class="line">kvm_arch_vcpu_postcreate(vcpu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先在第 7 行的 kvm_arch_vcpu_create() 函数内进行 vcpu_vmx 结构的申请操作，然后还对 vcpu_vmx 进行了初始化。在这个函数的执行过程中，同时还会设置 CPU 模式寄存器（MSR 寄存器）。</span></span><br><span class="line"><span class="comment">// 接下来分别为 guest 和 host 申请页面，并在页面里保存 MSR 寄存器的信息。最后，还会申请一个 vmcs 结构，并调用 vmx_vcpu_setup 设置 vCPU 的工作模式，这里就是实模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line"><span class="comment">// vCPU运行</span></span><br><span class="line"><span class="comment">// --------</span></span><br><span class="line">arch/x86/kvm/x86.c:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vcpu_run</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm</span> *<span class="title">kvm</span> =</span> vcpu-&gt;kvm;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*vcpu进入guest模式*/</span></span><br><span class="line"><span class="keyword">if</span> (kvm_vcpu_running(vcpu)) &#123;</span><br><span class="line">r = vcpu_enter_guest(vcpu);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = vcpu_block(kvm, vcpu);</span><br><span class="line">&#125;</span><br><span class="line">kvm_clear_request(KVM_REQ_PENDING_TIMER, vcpu);</span><br><span class="line"><span class="comment">/*检查是否有阻塞的时钟timer*/</span></span><br><span class="line"><span class="keyword">if</span> (kvm_cpu_has_pending_timer(vcpu))</span><br><span class="line">kvm_inject_pending_timer_irqs(vcpu);</span><br><span class="line"><span class="comment">/*检查是否有用户空间的中断注入*/</span></span><br><span class="line"><span class="keyword">if</span> (dm_request_for_irq_injection(vcpu) &amp;&amp;</span><br><span class="line">kvm_vcpu_ready_for_interrupt_injection(vcpu)) &#123;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line">vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;</span><br><span class="line">++vcpu-&gt;stat.request_irq_exits;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">kvm_check_async_pf_completion(vcpu);</span><br><span class="line"><span class="comment">/*是否有阻塞的signal*/</span></span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">r = -EINTR;</span><br><span class="line">vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_INTR;</span><br><span class="line">++vcpu-&gt;stat.signal_exits;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*执行一个调度*/</span></span><br><span class="line"><span class="keyword">if</span> (need_resched()) &#123;</span><br><span class="line">cond_resched();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 vcpu_enter_guest 进入 / 退出 vCPU，在根模式之间来回切换、反复横跳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 内存虚拟化</span></span><br><span class="line"><span class="comment">// ---------</span></span><br><span class="line"><span class="comment">// 在 vcpu 初始化的时候，会调用 kvm_init_mmu 来设置虚拟内存初始化，一种是基于 EPT 的方式，另一种是基于影子页表实现的 soft mmu 方式</span></span><br><span class="line">arch/x86/kvm/mmu/mmu.c</span><br><span class="line"><span class="type">void</span> <span class="title function_">kvm_init_mmu</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">bool</span> reset_roots)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*嵌套虚拟化，我们暂不考虑了 */</span></span><br><span class="line"><span class="keyword">if</span> (mmu_is_nested(vcpu))</span><br><span class="line">init_kvm_nested_mmu(vcpu);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tdp_enabled)</span><br><span class="line">init_kvm_tdp_mmu(vcpu);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">init_kvm_softmmu(vcpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// IO虚拟化</span></span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line"><span class="comment">// 一种是全虚拟化方案，一种是半虚拟化方案</span></span><br><span class="line"><span class="comment">// 全虚拟化会在 VM-exit 退出之后把 IO 交给 QEMU 处理</span></span><br><span class="line"><span class="comment">// 半虚拟化则是把 I/O 变成了消息处理，从客户机（guest）机器发消息出来，宿主机（由 host）机器来处理</span></span><br><span class="line">arch/x86/kvm/vmx.c:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_io</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> exit_qualification;</span><br><span class="line"><span class="type">int</span> size, in, <span class="built_in">string</span>;</span><br><span class="line"><span class="type">unsigned</span> port;</span><br><span class="line">exit_qualification = vmcs_readl(EXIT_QUALIFICATION);</span><br><span class="line"><span class="built_in">string</span> = (exit_qualification &amp; <span class="number">16</span>) != <span class="number">0</span>;</span><br><span class="line">++vcpu-&gt;stat.io_exits;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">string</span>)</span><br><span class="line"><span class="keyword">return</span> kvm_emulate_instruction(vcpu, <span class="number">0</span>) == EMULATE_DONE;</span><br><span class="line">port = exit_qualification &gt;&gt; <span class="number">16</span>;</span><br><span class="line">size = (exit_qualification &amp; <span class="number">7</span>) + <span class="number">1</span>;</span><br><span class="line">in = (exit_qualification &amp; <span class="number">8</span>) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> kvm_fast_pio(vcpu, size, port, in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-21-52-26.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-25-21-52-26.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="KVM虚拟化技术" /></p>
</div><div class="story post-story"><h2 id="122-如何理解容器的实现机制"><a class="markdownIt-Anchor" href="#122-如何理解容器的实现机制"></a> 12.2 如何理解容器的实现机制</h2>
<ul>
<li><strong>什么是容器</strong>
<ul>
<li>容器是一种工作模式:轻量,拥有一个模具(镜像),既可以规模生产出多个相同的集装箱(运行实例),又可以和外部环境(宿主机)隔离,最终实现对&quot;内容&quot;的打包隔离,方便其运输传送</li>
<li>容器目的就是提供一个独立的运行环境</li>
</ul>
</li>
<li><strong>和虚拟机的对比</strong>
<ul>
<li>传统的虚拟化技术通过硬件模拟实现，也可以通过操作系统软件实现
<ul>
<li>为了让虚拟的应用程序达到和物理机相似的效果,使用Hypervisor/VM虚拟机,允许多个操作系统共享一个或多个CPU,但是开销较大</li>
</ul>
</li>
<li>容器是一种更加轻量级的操作系统虚拟化技术,将应用程序,依赖包,库文件等依赖环境打包到标准的镜像中,通过容器引擎提供进程隔离,资源可限制的运行环境,实现应用与os平台及底层硬件的解耦</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-26-09-44-46.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-26-09-44-46.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="容器和传统虚拟机的比较" /></p>
<ul>
<li><strong>容器的基础架构</strong>
<ul>
<li>Docker是最经典,使用最广泛的容器技术，采用C/S架构，包括3个核心部分</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-26-09-45-28.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-26-09-45-28.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Docker架构示意图" /></p>
<ul>
<li><strong>容器客户端(Client)</strong>
<ul>
<li>主要任务是接受并解析用户的操作指令和执行参数,收集所需要的配置信息,根据相应的Docker命令通过HTTP或REST API等方式与Docker daemon(守护进程)进行交互,并将处理结果返回给用户,实现Docker服务使用与管理</li>
</ul>
</li>
<li><strong>容器镜像仓库(Registry)</strong>
<ul>
<li>Registry是存储容器的仓库,在容器的运行过程中,Client在接受到用户的指令后转发给Host下的Daemon,会通过网络与Registry进行通信</li>
<li>镜像仓库可以部署在公网环境,也可以私有化部署在内网,通过局域网对镜像进行管理</li>
</ul>
</li>
<li><strong>容器管理引擎进程(Host)</strong>
<ul>
<li>容器引擎进程是Docker架构的核心，包括Docker Daemon(守护进程), Image(镜像),Driver(驱动),Libcontainer(容器管理)等</li>
</ul>
</li>
<li><strong>Docker Daemon详解</strong>
<ul>
<li>为一个常驻后台的系统进程,负责监听客户端请求,然后执行后续的对应逻辑,还能管理DOcker对象(容器,镜像,网络,磁盘等)</li>
<li>可以把 Daemon 分为三大部分，分别是 Server、Job、Engine
<ul>
<li>Server 负责接收客户端发来的请求（由 Daemon 在后台启动 Server）。接受请求以后Server 通过路由与分发调度找到相应的 Handler 执行请求，然后与容器镜像仓库交互（查询、拉取、推送）镜像并将结果返回给 Docker Client</li>
<li>Engine 是 Daemon 架构中的运行引擎，同时也是 Docker 运行的核心模块。Engine 扮演了 Docker container 存储仓库的角色。Engine 执行的每一项工作，都可以拆解成多个最小动作——Job，这是 Engine 最基本的工作执行单元</li>
<li>Job 不光能用在 Engine 内部，Docker 内部每一步操作，都可以抽象为一个 Job。Job 负责执行各项操作时，如储存拉取的镜像，配置容器网络环境等，会使用下层的Driver（驱动）来完成</li>
</ul>
</li>
</ul>
</li>
<li><strong>Docker Driver</strong>
<ul>
<li>Driver是Docker中的驱动,依旧是解耦,将容器管理的镜像,网络和隔离执行逻辑从Docker Daemon的逻辑中剥离</li>
<li>可分为三类驱动
<ul>
<li>graphdriver 负责容器镜像的管理，主要就是镜像的存储和获取，当镜像下载的时候，会将镜像持久化存储到本地的指定目录</li>
<li>networkdriver 主要负责 Docker 容器网络环境的配置，如 Docker 运行时进行 IP 分配端口映射以及启动时创建网桥和虚拟网卡</li>
<li>execdriver 是Docker 的执行驱动，通过操作 Lxc 或者 libcontainer 实现资源隔离。它负责创建管理容器运行命名空间、管理分配资源和容器内部真实进程的运行</li>
</ul>
</li>
</ul>
</li>
<li><strong>libcontainer</strong>
<ul>
<li>通过调用 libcontainer 来完成对容器的操作，加载容器配置container，继而创建真正的 Docker 容器。libcontainer 提供了访问内核中和容器相关的API，负责对容器进行具体操作</li>
<li>容器可以创建一个相对隔离的环境,就容器技术本身而言,其核心部分利用了内核的虚拟化技术</li>
</ul>
</li>
<li><strong>容器基础技术</strong>
<ul>
<li>Docker是一个给予Linux操作系统下Namespace和Cgroups和UnionFS的虚拟化工具</li>
</ul>
</li>
<li><strong>Linux NameSpace</strong>
<ul>
<li>实现各种资源隔离功能的技术为Linux Namespace，可以隔离一系列的系统资源</li>
<li>Namespace在基于chroot扩展升级的基础上,可以分别将一些资源隔离起来,限制每个进程能够访问的资源
<ul>
<li>PID Namespace：保障进程隔离，每个容器都以 PID=1 的 init 进程来启动</li>
<li>User Namespace：用于隔离容器中 UID、GID 以及根目录等</li>
<li>UTS Namespace：保障每个容器都有独立的主机名或域名</li>
<li>Mount Namespace: 保障每个容器都有独立的目录挂载路径</li>
<li>NET Namespace：保障每个容器有独立的网络栈、socket 和网卡设备</li>
<li>IPC Namespace：保障每个容器进程 IPC 通信隔离</li>
<li>Cgroup Namespace：保障容器容器中看到的 cgroup 视图，像宿主机一样以根形式来呈现，同时让容器内使用 cgroup 变得更安全</li>
</ul>
</li>
<li>7类Namespace主要使用3种系统调用函数,就是和进程有关的调用函数
<ul>
<li>clone：创建新进程，根据传入上面的不同 NameSpace 类型，来创建不同的NameSpace 进行隔离，同样的，对应的子进程也会被包含到这些 Namespace 中</li>
</ul>
<blockquote>
<p>int clone(int (*child_func)(void *), void *child_stac, int flags, void *arg);<br />
flags就是标志用来描述你需要从父进程继承哪些资源，这里flags参数为将要创建的NameSpace类型</p>
</blockquote>
<ul>
<li>unshare：将进程移出某个指定类型的 Namespace，并加入到新创建的 NameSpace中， 容器中 NameSpace 也是通过 unshare 系统调用创建的</li>
</ul>
<blockquote>
<p>int unshare(int flags);<br />
flags同上</p>
</blockquote>
<ul>
<li>setns：将进程加入到 Namespace 中</li>
</ul>
<blockquote>
<p>int setns(int fd, int nstype);<br />
fd： 加入的NameSpace，指向/proc/[pid]/ns/目录里相应NameSpace对应的文件,nstype：NameSpace类型</p>
</blockquote>
</li>
<li>几种Namespace 都是为了隔离容器的运行环境，此外，NameSpace 是和进程息息相关的，NameSpace 将全局共享的资源划分为多组进程间共享的资源，当一个NameSpace 下的进程全部退出，NameSpace 也会被销毁</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-26-10-14-15.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-26-10-14-15.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Namespace隔离资源和" /></p>
<ul>
<li><strong>Linux Cgroups</strong>
<ul>
<li>Linux Cgroups（Control Groups）主要负责对指定的一组进程做资源限制，同时可以统计其资源使用。具体包括 CPU、内存、存储、I/O、网络等资源</li>
<li>Cgrpups 的核心概念，分别是 Task (任务)、Control Groups（控制组 ）、subsystem（子系统）、hierarchy（层级数）
<ul>
<li>Task: 任务，在 Cgroup 中，任务同样是一个进程</li>
<li>Control Groups：控制组，Cgroups 的一组进程，并可以在这个 Cgroups 通过参数，将一组进程和一组 linux subsystem 关联起来</li>
<li>subsystem：子系统，是一组资源控制模块，subsystem 作用于 hierarchy 的 Cgroup 节点，并控制节点中进程的资源占用</li>
<li>hierarchy：层级树 Cgroups，将 Cgroup 通过树状结构串起来，通过虚拟文件系统的方式暴露给用户</li>
</ul>
</li>
<li>容器中常用的 Cgroup 驱动
<ul>
<li>Cgroupfs 驱动：需要限制 CPU 或内存使用时，直接把容器进程的 PID 写入相应的 CPU 或内存的 cgroup</li>
<li>systemdcgroup 驱动：提供 cgroup 管理，所有的 cgroup 写操作需要通过 systemd 的接口来完成，不能手动修改</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-26-10-24-14.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-26-10-24-14.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cgroup示意图" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-26-10-24-32.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-05-26-10-24-32.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="cgroup subsystem参数" /></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实验</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建cgroup挂载文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个 Cgroup，名为 cgroup-cosmos，先创建一个 hierarchy，再进行挂载代码</span></span><br><span class="line">mkdir cgroup-cosmos</span><br><span class="line">sudo mount -t cgroup -o none,name=cgroup-cosmos cgroup-cosmos cgroup-cosmos/</span><br><span class="line">ll ./cgroup-cosmos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建子group(名为cgroup-cosmos-a)</span></span><br><span class="line">cd cgroup-cosmos</span><br><span class="line">mkdir cgroup-cosmos-a</span><br><span class="line">tree</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Cgroup 中添加、移动进程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前的进程 ID 写入对应的cgroup 文件即可</span></span><br><span class="line">echo $$ // 583</span><br><span class="line">cat /proc/583/cgroup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将终端进程移动到 cgroup-cosmos-a</span></span><br><span class="line">cd cgroup-cosmos-a</span><br><span class="line">sh -c &quot;echo $$ &gt;&gt; tasks&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">限制 Cgroup 中进程的资源</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看hierarchy的subsystem，为/sys/fs/cgroup/memory/</span></span><br><span class="line">mount | grep memory</span><br><span class="line">cd /sys/fs/cgroup/memory/</span><br><span class="line">sudo mkdir cosmos-limit-memory</span><br><span class="line">cd cosmos-limit-memory</span><br><span class="line">ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先启动一个未限制的进程</span></span><br><span class="line">stress --vm-bytes 200m --vm-keep -m 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置最大内存，并且将进程移动到当前 Cgroup 中，在此运行一个进程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">操作以后，就可以通过 top 命令看到已经将 stress 的最大内存限制到 100m 了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置最大内存占用</span></span><br><span class="line">sh -c &quot;echo &quot;100m&quot; &gt; memory.limit_in_bytes&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移动到这个cgroup内</span></span><br><span class="line">sh -c &quot;echo $$ &gt;&gt; tasks&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再启动一个机型</span></span><br><span class="line">stress --vm-bytes 200m --vm-keep -m 1</span><br><span class="line">top</span><br></pre></td></tr></table></figure>

</div>
  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateModified" datetime="2023-05-07T00:12:59+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2023年5月7日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Basic/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>Basic</p></a></div>
  <span hidden itemprop="keywords">Basic</span>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://jay1060950003.github.io/2022/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统 - CodingStudio&summary= 引言

《极客时间操作系统45讲》学习笔记
"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://jay1060950003.github.io/2022/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统 - CodingStudio&summary= 引言

《极客时间操作系统45讲》学习笔记
"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://jay1060950003.github.io/2022/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&title=操作系统 - CodingStudio&summary= 引言

《极客时间操作系统45讲》学习笔记
"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2022/05/07/%E6%9D%82%E9%A1%B9%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i>杂项知识记录</p>
          <p class='content'> 深度学习
 TensorRT介绍

TensorRT采用C++开发, 能使深度学习模型在GPU上进行低延迟、高吞吐量的部署
Pytorch的支持需要先转换成中间模型ONNX格式
工作流程

首...</p>
        </a>
      
      
        <a class='next' href='/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++Primer/'>
          <p class='title'>C++Primer<i class="fa-solid fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'> 引言

C++ Primer的学习笔记


 1 开始
 1.2 初始输入输出

iostream库为IO库,其中包含两个基本类型istream和ostream,分别表示输入流和输出流

一个...</p>
        </a>
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  


  <article class="post white-box shadow floatable blur" id="comments">
    <span hidden>
      <meta itemprop="discussionUrl" content="/2022/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html#comments">
    </span>
    <p ct><i class='fa-solid fa-comments'></i> 评论</p>
    

    <div id="layoutHelper-comments"></div>

  </article>






</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky pjax">

  
  


  <section class="widget toc-wrapper desktop mobile " id="toc-div" >
    
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text"> 引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%8Ehello%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AAhello"><span class="toc-number">2.</span> <span class="toc-text"> 1 从hello到另一个hello</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E6%9C%BA%E5%99%A8%E8%BF%90%E8%A1%8C"><span class="toc-number">2.1.</span> <span class="toc-text"> 1.1 程序的运行过程:从代码到机器运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 程序编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 程序装载执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%BD%A2%E8%B1%A1%E5%9C%B0%E5%B0%86helloworld%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E5%8E%9F%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 更形象地将HelloWorld程序装入原型计算机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8"><span class="toc-number">2.2.</span> <span class="toc-text"> 1.2 实现一个最简单的内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pc%E6%9C%BA%E7%9A%84%E5%BC%95%E5%AF%BC%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text"> PC机的引导流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hello-os%E5%BC%95%E5%AF%BC%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.2.</span> <span class="toc-text"> Hello OS引导汇编代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hello-os%E7%9A%84%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text"> Hello OS的主函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B1%8F%E5%B9%95"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 控制计算机屏幕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85hello-os"><span class="toc-number">2.2.5.</span> <span class="toc-text"> 编译和安装Hello OS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.6.</span> <span class="toc-text"> make工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">2.2.7.</span> <span class="toc-text"> 编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85hello-os"><span class="toc-number">2.2.8.</span> <span class="toc-text"> 安装Hello OS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text"> 2 设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text"> 2.1 内核结构与设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E4%B8%9A%E7%95%8C%E6%88%90%E7%86%9F%E7%9A%84%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text"> 2.2 业界成熟的内核架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%A1%AC%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text"> 3 硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text"> 3.1 执行程序的三种模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#311-%E5%AE%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 3.1.1 实模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#312-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 3.1.2 保护模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#313-%E9%95%BF%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 3.1.3 长模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text"> 3.2 程序中的地址如何转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-cache%E4%B8%8E%E5%86%85%E5%AD%98%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%9C%A8%E5%93%AA%E5%84%BF"><span class="toc-number">4.3.</span> <span class="toc-text"> 3.3 Cache与内存:程序放在哪儿</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%9F%BA%E6%9C%AC%E6%B3%95%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD"><span class="toc-number">5.</span> <span class="toc-text"> 4 基本法:同步原语</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E9%94%81%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E4%B8%AD%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text"> 4.1 锁:并发操作中,解决数据同步的四种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#411-%E6%96%B9%E6%B3%951%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-%E6%8B%BF%E4%B8%8B%E5%8D%95%E4%BD%93%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 4.1.1 方法1:原子操作 拿下单体变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#412-%E6%96%B9%E6%B3%952%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6-%E6%90%9E%E5%AE%9A%E5%A4%8D%E6%9D%82%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text"> 4.1.2 方法2:中断控制 搞定复杂变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#413-%E6%96%B9%E6%B3%953%E8%87%AA%E6%97%8B%E9%94%81%E5%8D%8F%E8%B0%83%E5%A4%9A%E6%A0%B8%E5%BF%83cpu"><span class="toc-number">5.1.3.</span> <span class="toc-text"> 4.1.3 方法3:自旋锁,协调多核心CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#414-%E6%96%B9%E6%B3%954%E4%BF%A1%E5%8F%B7%E9%87%8F-cpu%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%A4%A7%E5%B8%88"><span class="toc-number">5.1.4.</span> <span class="toc-text"> 4.1.4 方法4:信号量 CPU时间管理大师</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-linux%E7%9A%84%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.</span> <span class="toc-text"> 4.2 Linux的自旋锁和信号量如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#421-linux%E7%9A%84%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 4.2.1 Linux的原子变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#422-linux%E6%8E%A7%E5%88%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">5.2.2.</span> <span class="toc-text"> 4.2.2 Linux控制中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#423-linux%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">5.2.3.</span> <span class="toc-text"> 4.2.3 Linux自旋锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text"> 5 启动初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%BB%BA%E7%AB%8B%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">6.1.</span> <span class="toc-text"> 5.1 建立计算机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E5%BB%BA%E9%80%A0%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8"><span class="toc-number">6.2.</span> <span class="toc-text"> 5.2 建造二级引导器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%8E%A2%E6%9F%A5%E5%92%8C%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF"><span class="toc-number">6.3.</span> <span class="toc-text"> 5.3 探查和收集信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E7%AC%AC%E4%B8%80%E4%B8%AAc%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9D%BF%E7%BA%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.4.</span> <span class="toc-text"> 5.4 第一个C函数:如何实现板级初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-linux%E5%88%9D%E5%A7%8B%E5%8C%96grub%E4%B8%8Evmlinuz%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">6.5.</span> <span class="toc-text"> 5.5 Linux初始化:GRUB与vmlinuz的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-linux%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%8E_start%E5%88%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">6.6.</span> <span class="toc-text"> 5.6 Linux初始化:从_start到第一个进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98"><span class="toc-number">7.</span> <span class="toc-text"> 6 内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E4%B8%8E%E7%BB%84%E7%BB%87%E5%86%85%E5%AD%98"><span class="toc-number">7.1.</span> <span class="toc-text"> 6.1 如何划分与组织内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E9%A1%B5%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">7.2.</span> <span class="toc-text"> 6.2 如何实现内存页的分配与释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E9%A1%B5%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">7.3.</span> <span class="toc-text"> 6.3 如何实现内存页的分配与释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.4.</span> <span class="toc-text"> 6.4 如何管理内存对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">7.5.</span> <span class="toc-text"> 6.5 如何表示虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">7.6.</span> <span class="toc-text"> 6.6 如何分配和释放虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E7%9E%A7%E4%B8%80%E7%9E%A7linux%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">7.7.</span> <span class="toc-text"> 6.7 瞧一瞧Linux:伙伴系统如何分配内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E7%9E%A7%E4%B8%80%E7%9E%A7linuxslab%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">7.8.</span> <span class="toc-text"> 6.8 瞧一瞧Linux:SLAB如何分配内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text"> 7 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text"> 7.1 到底什么是进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E8%B0%83%E5%BA%A6"><span class="toc-number">8.2.</span> <span class="toc-text"> 7.2 多进程如何调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="toc-number">8.3.</span> <span class="toc-text"> 7.3 如何实现进程的等待与唤醒机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-linux%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">8.4.</span> <span class="toc-text"> 7.4 Linux如何实现进程与进程调度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E8%AE%BE%E5%A4%87io"><span class="toc-number">9.</span> <span class="toc-text"> 8 设备IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="toc-number">9.1.</span> <span class="toc-text"> 8.1 如何表示设备类型与设备驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E6%B3%A8%E5%86%8C%E8%AE%BE%E5%A4%87"><span class="toc-number">9.2.</span> <span class="toc-text"> 8.2 如何在内核中注册设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E8%AE%BE%E5%A4%87%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%86%85%E6%A0%B8io%E5%8C%85"><span class="toc-number">9.3.</span> <span class="toc-text"> 8.3 设备如何处理内核IO包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E7%9E%A7%E4%B8%80%E7%9E%A7linux%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF"><span class="toc-number">9.4.</span> <span class="toc-text"> 8.4 瞧一瞧Linux:如何获取所有设备信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.</span> <span class="toc-text"> 9 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E6%96%87%E4%BB%B6"><span class="toc-number">10.1.</span> <span class="toc-text"> 9.1 如何组织文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.</span> <span class="toc-text"> 9.2 文件系统的格式化操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%AD%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">10.3.</span> <span class="toc-text"> 9.3 如何实现文件的六大基础操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E7%9E%A7%E4%B8%80%E7%9E%A7linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6"><span class="toc-number">10.4.</span> <span class="toc-text"> 9.4 瞧一瞧Linux:虚拟文件系统如何管理文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E7%BD%91%E7%BB%9C"><span class="toc-number">11.</span> <span class="toc-text"> 10 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%A6%82%E4%BD%95%E5%85%A8%E5%B1%80%E8%A7%82%E5%AF%9F%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8"><span class="toc-number">11.1.</span> <span class="toc-text"> 10.1 如何全局观察网络数据流动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC"><span class="toc-number">11.2.</span> <span class="toc-text"> 10.2 网络数据在内核中如何流转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103-%E8%AF%A6%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%8F%E8%A7%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84"><span class="toc-number">11.3.</span> <span class="toc-text"> 10.3 详解操作系统的宏观网络架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E8%AF%A6%E8%A7%A3socket%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.4.</span> <span class="toc-text"> 10.4 详解socket实现与网络编程接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E8%AF%A6%E8%A7%A3socket%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.5.</span> <span class="toc-text"> 10.5 详解socket的接口实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.</span> <span class="toc-text"> 11 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E6%B2%9F%E9%80%9A%E6%A1%A5%E6%A2%81"><span class="toc-number">12.1.</span> <span class="toc-text"> 11.1 如何搭建沟通桥梁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9Fapi"><span class="toc-number">12.2.</span> <span class="toc-text"> 11.2 如何实现系统API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E8%99%9A%E5%8C%96%E7%9A%84%E4%B8%96%E7%95%8C"><span class="toc-number">13.</span> <span class="toc-text"> 12 虚化的世界</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121-kvm%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">13.1.</span> <span class="toc-text"> 12.1 KVM是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">13.2.</span> <span class="toc-text"> 12.2 如何理解容器的实现机制</span></a></li></ol></li></ol>
    </div>
  </section>

  

</div>


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.remove("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="half";
      cover_wrapper.style.display="";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.4'
      loop='all'
      order='random'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5062959861'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
              <a href="mailto:jay1060950003@gmail.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
            
              <a href="https://github.com/jay1060950003/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
        </div>
      
    
      
        <p>本站使用 <a target="_blank" rel="noopener" href="https://github.com/volantis-x/hexo-theme-volantis/#5.8.0">Volantis</a> 作为主题，您可以在 GitHub 找到<a target="_blank" rel="noopener" href="https://github.com/volantis-x/volantis-docs">本站源码</a>。</p>

      
    
      
        <div class='copyright'>
        <p>Copyright © Since 2017</p>

        </div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fortawesome/fontawesome-pro/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="/js/app.js"></script>





  













<div id="rightmenu-wrapper">
  <ul class="list-v rightmenu" id="rightmenu-content">
    
  <li class='navigation menuNavigation-Content'>


    <a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa-duotone fa-arrow-left PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa-duotone fa-arrow-right PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa-duotone fa-redo PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" href="/"><i class="fa-duotone fa-home PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)"><i class="fa-duotone fa-arrow-up PETERRIVE fa-fw"></i></a>


  </li>


    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyPaste" data-event="copyPaste" data-group="inputBox">
      <i class="fa-duotone PETERRIVE fa-paste fa-fw"></i>
      粘贴文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyAll" data-event="copyAll" data-group="inputBox">
      <i class="fa-duotone PETERRIVE fa-object-ungroup fa-fw"></i>
      全选文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyCut" data-event="copyCut" data-group="inputBox">
      <i class="fa-duotone PETERRIVE fa-cut fa-fw"></i>
      剪切文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyText" data-event="copyText" data-group="seletctText">
      <i class="fa-duotone PETERRIVE fa-copy fa-fw"></i>
      复制文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="searchWord" data-event="OpenSearch(__text__)" data-group="seletctText">
      <i class="fa-duotone PETERRIVE fa-search fa-fw"></i>
      站内搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="bingSearch" data-event="window.open(`https://cn.bing.com/search?q=${__text__}`)" data-group="seletctText">
      <i class="fa-duotone PETERRIVE fa-search fa-fw"></i>
      必应搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="openTab" data-event="window.open(__link__)" data-group="elementCheck">
      <i class="fa-duotone PETERRIVE fa-external-link-square-alt fa-fw"></i>
      新标签页打开
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyLink" data-event="copyLink" data-group="elementCheck">
      <i class="fa-duotone PETERRIVE fa-link fa-fw"></i>
      复制链接地址
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyImg" data-event="copyImg" data-group="elementImage">
      <i class="fa-duotone PETERRIVE fa-image fa-fw"></i>
      复制图片
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="googleImg" data-event="window.open(`https://www.google.com/searchbyimage?image_url=${__link__}`)" data-group="elementImage">
      <i class="fa-duotone PETERRIVE fa-images fa-fw"></i>
      谷歌识图
    </span>
  </li>



    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="darkMode" data-event="volantis.dark.toggle()" data-group="darkMode">
      <i class="fa-duotone fa-eclipse-alt WISTERIA fa-fw"></i>
      暗黑模式
    </span>
  </li>



    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="printMode" data-event="printMode" data-group="articlePage">
      <i class="fa-duotone fa-print TURQUOISE fa-fw"></i>
      打印页面
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="readMode" data-event="readMode" data-group="articlePage">
      <i class="fa-duotone fa-book-open EMERALD fa-fw"></i>
      阅读模式
    </span>
  </li>



    <hr class="menuLoad-Content" >


<div id="menuMusic">
  <li class='music name menuOption-Content'>
    <p class='nav music-title fix-cursor-default'></p>
  </li>
  <li class='music ctrl'>
    <a class='nav icon-only backward fix-cursor-default' href="/" onclick="return false;" title="backward">
      <i class='fa-duotone PETERRIVE fa-step-backward fa-fw'></i>
    </a>
    <a class='nav icon-only toggle fix-cursor-default' href="/" onclick="return false;" title="toggle">
      <i class='fa-duotone PETERRIVE fa-play fa-fw'></i>
    </a>
    <a class='nav icon-only forward fix-cursor-default' href="/" onclick="return false;" title="forward">
      <i class='fa-duotone PETERRIVE fa-step-forward fa-fw'></i>
    </a>
  </li>
  <li class='music volume'>
    <div class='nav volume'>
      <div class="aplayer-volume-bar-wrap">
        <div class="aplayer-volume-bar fix-cursor-pointer">
          <div class="aplayer-volume"></div>
          <i class='left fa-duotone PETERRIVE fa-volume-off fa-fw'></i>
          <i class='right fa-duotone PETERRIVE fa-volume-up fa-fw'></i>
        </div>
      </div>
    </div>
  </li>
</div>

  </ul>
</div>
<script src="/js/plugins/rightMenus.js"></script>
<script>
  const RightMenusFunction = {};
  














  //RightMenusFunction['copyPaste'] = (fun) => {fun()}





  //RightMenusFunction['copyAll'] = (fun) => {fun()}





  //RightMenusFunction['copyCut'] = (fun) => {fun()}





  //RightMenusFunction['copyText'] = (fun) => {fun()}





  RightMenusFunction['searchWord'] = (__text__) => {OpenSearch(__text__)}





  RightMenusFunction['bingSearch'] = (__text__) => {window.open(`https://cn.bing.com/search?q=${__text__}`)}





  RightMenusFunction['openTab'] = (__link__) => {window.open(__link__)}





  //RightMenusFunction['copyLink'] = (fun) => {fun()}





  //RightMenusFunction['copyImg'] = (fun) => {fun()}





  RightMenusFunction['googleImg'] = (__link__) => {window.open(`https://www.google.com/searchbyimage?image_url=${__link__}`)}







  RightMenusFunction['darkMode'] = () => {volantis.dark.toggle()}







  //RightMenusFunction['printMode'] = (fun) => {fun()}





  //RightMenusFunction['readMode'] = (fun) => {fun()}







</script>



<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->

  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "color-scheme";
const rootElementDarkModeAttributeName = "color-scheme";
const setLS = (k, v) => {
    localStorage.setItem(k, v);
};
const removeLS = (k) => {
    localStorage.removeItem(k);
};
const getLS = (k) => {
    return localStorage.getItem(k);
};
const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};
const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};
const validColorModeKeys = {
  dark: true,
  light: true,
};
const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);
  getCustomDarkMode();
  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};
const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};
/**
 * get target mode
 */
 const getCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  if(currentSetting=="dark"){
    volantis.dark.mode="light";
  }else{
    volantis.dark.mode="dark";
  }
  // console.log(volantis.dark.mode)
};
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};
/**
 * 暗黑模式触发器
 */
volantis.dark.toggle=()=>{
  const mode = toggleCustomDarkMode();
  applyCustomDarkModeSettings(mode);
  // 使用 volantis.dark.push 方法传入volantis.dark.toggle回调函数 参见layout/_partial/scripts/global.ejs
  volantis.dark.method.toggle.start();
}
/**
 * bind event for toggle button
 */

function bindToggleButton() {
  var btn= document.querySelectorAll("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn")
  btn.forEach(function (e) {
    volantis.dom.$(e).on('click',volantis.dark.toggle);
  })
}
applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", ()=>{
  volantis.requestAnimationFrame(bindToggleButton)
});
volantis.pjax.push(bindToggleButton);

const darkModelListeners={
  dark:(mediaQueryList )=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "dark";
    }
    volantis.dark.method.toggle.start();
  },
  light:(mediaQueryList)=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "light";
    }
    volantis.dark.method.toggle.start();
  }
}
window.matchMedia('(prefers-color-scheme: dark)').addListener(darkModelListeners.dark)
window.matchMedia('(prefers-color-scheme: light)').addListener(darkModelListeners.light)
</script>




<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/js/plugins/tags/sites.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/js/plugins/tags/friends.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/js/plugins/tags/contributors.js")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/flying-pages/flying-pages.min.js"></script>





   <script type="text/javascript">
  function pjax_scrollrebeal() {
    ScrollReveal().reveal("#l_main .reveal", {
      distance: "32px",
      duration: "800",
      interval: "20",
      scale: "1",
      easing: "ease-out",
    });
  }
  function init_scrollrebeal() {
    if (typeof ScrollReveal == "undefined") {
      volantis.requestAnimationFrame(init_scrollrebeal);
    } else {
      pjax_scrollrebeal();
    }
  }
  volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/scrollreveal/dist/scrollreveal.min.js");
  document.addEventListener("DOMContentLoaded", init_scrollrebeal);
  volantis.pjax.push(
    pjax_scrollrebeal,
    "pjax_scrollrebeal",
    (setRequestAnimationFrame = false)
  );
</script>




  <script>
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/aplayer/dist/APlayer.min.css");
  (async () => {
    // APlayer 需要在  MetingJS 之前加载
    await volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/aplayer/dist/APlayer.min.js")
    await volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/meting/dist/Meting.min.js")
  
    // 右键 music 需要在 APlayer  MetingJS 之后加载
    await volantis.js('/js/plugins/aplayer.js')
  
  })();

  function SetAPlayerPlugin(){
    let Metings = document.querySelectorAll('meting-js');
    if (Metings.length === 0) {return;};
    if (Metings[0].aplayer && Metings[0].aplayer.on) {
      // improve the accessibility https://web.dev/button-name/
      document.querySelectorAll(".aplayer-icon-menu").forEach(e=>{
        e.setAttribute("aria-label","Aplayer Menu")
      })
      // message see: /layout/_plugins/message/script.ejs
      
        try {
          setTimeout(() => {
            Metings.forEach((item, index) => {
              const aplayerItem = item.aplayer; if(!aplayerItem) return;
              const rightAplayerCheck = 'true' === 'true'
                && item.meta.id === '5062959861';
              if(rightAplayerCheck && typeof RightMenuAplayer !="undefined") RightMenuAplayer.checkAPlayer();
              if(aplayerItem.events.events.play.every(item => {return item.name !== 'messagePlay'})) {
                aplayerItem.on('play', function messagePlay() {
                  let index = aplayerItem.list.index;
                  let title = aplayerItem.list.audios[index].title;
                  let artist = aplayerItem.list.audios[index].artist;
                  setTimeout(() => {
                    VolantisApp.message('音乐通知', title + ' - ' + artist, {
                      icon: 'fa-light fa-play light-blue',
                      transitionIn: 'flipInX',
                      transitionOut: 'flipOutX'
                    });
                  }, 100)
                });
              }
              if(aplayerItem.events.events.pause.every(item => {return item.name !== 'messagePause'})) {
                aplayerItem.on('pause', function messagePause() {
                  let index = aplayerItem.list.index;
                  let title = aplayerItem.list.audios[index].title;
                  let artist = aplayerItem.list.audios[index].artist;
                  setTimeout(() => {
                    // 歌曲播放结束也会触发 pause 事件，为了避免错误提示，等待一会儿
                    if(aplayerItem.paused) {
                      VolantisApp.message('音乐通知', title + ' - ' + artist, {
                        icon: 'fa-light fa-pause light-blue',
                        transitionIn: 'flipInX',
                        transitionOut: 'flipOutX'
                      });
                    }
                  }, 100)
                });
              }
            });
          }, 500)
        } catch (error) { console.error(error); }
      
    }else{
      volantis.requestAnimationFrame(SetAPlayerPlugin)
    }
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    SetAPlayerPlugin();
  });
  volantis.pjax.push(SetAPlayerPlugin);
</script>




      <script>
  volantis.layoutHelper("comments",`<div id="giscus_container"></div>`)

  volantis.giscus = {};

  function check_giscus() {
    if (volantis.dark.mode === "dark") {
      volantis.giscus.Theme = 'dark';
    } else {
      volantis.giscus.Theme = 'light';
    }

    return document.getElementById("giscus_container");
  }

  function pjax_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;
    let cfg = Object.assign({"theme":{"light":"light","dark":"dark"},"repo":"jay1060950003/comments","repo-id":"R_kgDOJfmU6A","category":"Announcements","category-id":"DIC_kwDOJfmU6M4CWTdE","mapping":"pathname","reactions-enabled":"1","emit-metadata":"0","lang":"zh-CN"},pdata.commentConfig)
    const script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    Object.keys(cfg).forEach(k=>{
      if (k != "theme") {
        script.setAttribute('data-'+k, cfg[k]);
      }
    })
    script.setAttribute('data-theme', volantis.giscus.Theme);
    script.setAttribute('crossorigin', "anonymous");
    HEAD.appendChild(script);
  }

  function dark_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;

    const message = {
      setConfig: {
        theme: volantis.giscus.Theme
      }
    };
    const giscusIframe = document.querySelector('iframe.giscus-frame');
    giscusIframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  pjax_giscus();
  volantis.pjax.push(pjax_giscus);
  volantis.dark.push(dark_giscus);
</script>

    




  <script defer src="https://gcore.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>


<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/") ?
    "/" || "/" :
    "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("/js/search/hexo.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>







  <script>



  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>










  <script>
  let imgs = ["https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/019.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/042.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/006.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/056.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/034.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/033.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/039.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/051.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/035.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/046.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/025.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/012.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/003.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/052.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/004.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/005.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/054.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/001.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/002.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/038.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/016.webp"];
  let index = 0;
  let IntervalParallax = null;

  function parallax(){
    let ParallaxWindow = document.querySelector("#parallax-window");
    
    Parallax.window = ParallaxWindow;
    Parallax.options.fade = 1500;
    Parallax.cache = 1;
    next_parallax();
    Parallax.init();
    if (imgs.length>1) {
      IntervalParallax = setInterval(function () {
        next_parallax();
      }, '10000');
    }
  }

  function next_parallax() {
    if (typeof Parallax == "undefined") {
      return
    }
    
      if (!document.querySelector("#full")&&!document.querySelector("#half")) {
        return
      }
    
    if (imgs.length>=1) {
      Parallax.options.src = imgs[index % imgs.length];
      Parallax.start();
      index++;
      if (Parallax.cache) {
        fetch(imgs[index % imgs.length] +"?t=" + new Date().getTime());
        if (index == imgs.length) {
          Parallax.cache = 0;
        }
      }
    }
  }
  var runningOnBrowser = typeof window !== "undefined";
  var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
  if (!isBot) {
    volantis.js('/js/plugins/parallax.js').then(()=>{
      parallax()
    })
    volantis.pjax.send(()=>{
      clearInterval(IntervalParallax)
    },"clearIntervalParallax");
    volantis.pjax.push(parallax);
  }
</script>




  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    let targets = []
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:true})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex=0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    volantis.scroll.push(()=>{
      if (targets[0].getBoundingClientRect().top >= 0) {
        volantis.activateNavIndex = 0
      }else if (targets[targets.length-1].getBoundingClientRect().top < 0) {
        volantis.activateNavIndex = targets.length-1
      } else {
        for (let index = 0; index < targets.length; index++) {
          const target0 = targets[index];
          const target1 = targets[(index+1)%targets.length];
          if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) {
            volantis.activateNavIndex=index
            break;
          }
        }
      }
      activateNavByIndex(navItems[volantis.activateNavIndex])
    })

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>


  <script>
  try {
    // https://web.dev/content-visibility/
    // https://www.caniuse.com/?search=content-visibility
    // https://infrequently.org/2020/12/content-visibility-scroll-fix/
    // https://infrequently.org/2020/12/resize-resilient-deferred-rendering/

    // 备注 目前已知的问题:
    // 动态修改导致的内容高度变化(例如评论框异步渲染的外部盒子高度变化) 无法提前获知, 进而导致的首次滚动条跳动无法去除 (wontfix) 事实上不使用 content-visibility 也会有跳动, 不过是比使用 content-visibility 跳动提前
    // scrollreveal 插件潜在问题 目前尚不明确

    let eqIsh = (a, b, fuzz = 2) => {
      return Math.abs(a - b) <= fuzz;
    };

    let rectNotEQ = (a, b) => {
      return !eqIsh(a.width, b.width) || !eqIsh(a.height, b.height);
    };

    // Keep a map of elements and the dimensions of
    // their place-holders, re-setting the element's
    // intrinsic size when we get updated measurements
    // from observers.
    let spaced = new WeakMap();

    // Only call this when known cheap, post layout
    let reserveSpace = (el, rect = el.getClientBoundingRect()) => {
      let old = spaced.get(el);
      // Set intrinsic size to prevent jumping on un-painting:
      //    https://drafts.csswg.org/css-sizing-4/#intrinsic-size-override
      if (!old || rectNotEQ(old, rect)) {
        spaced.set(el, rect);
        el.style["contain-intrinsic-size"] = `${rect.width}px ${rect.height}px`;
      }
    };

    let iObs = new IntersectionObserver(
      (entries, o) => {
        entries.forEach((entry) => {
          // We don't care if the element is intersecting or
          // has been laid out as our page structure ensures
          // they'll get the right width.
          reserveSpace(entry.target, entry.boundingClientRect);
        });
      },
      { rootMargin: "500px 0px 500px 0px" }
    );

    let rObs = new ResizeObserver((entries, o) => {
      entries.forEach((entry) => {
        reserveSpace(entry.target, entry.contentRect);
      });
    });

    let resizeResilientDeferredRendering = (Selector) => {
      let articles = document.querySelectorAll(Selector);

      if (articles.length) {
        articles.forEach((el) => {
          iObs.observe(el);
          rObs.observe(el);
        });

        // Workaround for Chrome bug, part 2.
        //
        // Re-enable browser management of rendering for the
        // first article after the first paint. Double-rAF
        // to ensure we get called after a layout.
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            articles[0].style["content-visibility"] = "auto";
          });
        });
      }
    };

    let contentVisibilityScrollFix = () => {
      if (!("content-visibility" in document.documentElement.style)) {
        return;
      }
      resizeResilientDeferredRendering(".post-story");
    };
    contentVisibilityScrollFix();
    volantis.pjax.push(contentVisibilityScrollFix);
  } catch (error) {
    console.log(error);
  }
</script>



<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"CodingStudio","url":"http://jay1060950003.github.io/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"jay1060950003","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://jay1060950003.github.io/","sameAs":["https://github.com/volantis-x"],"description":"自己的创作及学习空间"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"http://jay1060950003.github.io/","name":"CodingStudio"}},{"@type":"ListItem","position":2,"item":{"@id":"http://jay1060950003.github.io/categories/Basic/","name":"Basic"}},{"@type":"ListItem","position":3,"item":{"@id":"http://jay1060950003.github.io/2022/05/05/计算机基础知识/操作系统/","name":"操作系统"}}]},{"@context":"http://schema.org","@type":"WebSite","name":"CodingStudio","url":"http://jay1060950003.github.io/","keywords":"C++,Java,Qt,OpenCV,后端,开发者,程序猿,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder, 摄影","description":"自己的创作及学习空间","author":{"@type":"Person","name":"jay1060950003","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://jay1060950003.github.io/","description":"自己的创作及学习空间"},"publisher":{"@type":"Organization","name":"CodingStudio","url":"http://jay1060950003.github.io/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"http://jay1060950003.github.io?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"http://schema.org","@type":"BlogPosting","headline":"操作系统","description":" 引言\n\n《极客时间操作系统45讲》学习笔记\n","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http://jay1060950003.github.io/2022/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},"author":{"@type":"Person","name":"jay1060950003","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://jay1060950003.github.io/"},"publisher":{"@type":"Organization","name":"CodingStudio","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"http://jay1060950003.github.io/2022/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","wordCount":23,"datePublished":"2022-05-05T07:53:37.000Z","dateModified":"2023-05-06T16:12:59.036Z","articleSection":"Basic","keywords":"Basic","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>



      
        <!--
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name=keywords]",
          "head meta[name=description]",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
    <!-- import body_end begin-->
    <!-- import body_end end-->
    <!-- Custom Files bodyEnd begin-->
    
    <!-- Custom Files bodyEnd end-->
    <!-- front-matter body_end begin -->
    <!-- front-matter body_end end -->
  </body>
</html>
