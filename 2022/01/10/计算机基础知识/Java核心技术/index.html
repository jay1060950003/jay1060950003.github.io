<!DOCTYPE html>
<html lang="zh-CN">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#5.8.0'>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="Volantis" content="5.8.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="http://jay1060950003.github.io/2022/01/10/计算机基础知识/java核心技术/"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  <link rel="stylesheet" href="https://unpkg.com/katex@0.16.0/dist/katex.css" integrity="sha384-1IGr2Yb8xuHjwTG+WoGjj2+I/a/N6z0gDD5YIGCQxywPROOKc3+orbn/R7arWQxD" crossorigin="anonymous">
<script src="https://unpkg.com/katex@0.16.0/dist/katex.js" integrity="sha384-I2b1Pcl48X93GxEkGkaMo1hrd6n+IX8H2wgSsMimGbkZoGTve/87h1FjaDNvlpQi" crossorigin="anonymous"></script>
  <!-- Custom Files headBegin end-->
  <!-- front-matter head_begin begin -->
  <!-- front-matter head_begin end -->
    <link rel="shortcut icon" type='image/x-icon' href="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed//favicon.ico">
  <link rel="preload" href="/css/style.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
  <!-- 页面元数据 -->
  <title>Java核心技术 - CodingStudio</title>
  <meta name="keywords" content="Java,C++,Java,Qt,OpenCV,后端,开发者,程序猿,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder, 摄影">
  <meta desc name="description" content=" 引言

Java核心思想的学习笔记
包含第一卷除swing章节，并包含第二卷的文件流部分
 - jay1060950003 - CodingStudio">
  
<meta property="og:type" content="article">
<meta property="og:title" content="Java核心技术">
<meta property="og:url" content="http://jay1060950003.github.io/2022/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="CodingStudio">
<meta property="og:description" content="引言  Java核心思想的学习笔记 包含第一卷除swing章节，并包含第二卷的文件流部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2022-01-10T07:22:12.000Z">
<meta property="article:modified_time" content="2023-04-16T12:15:50.274Z">
<meta property="article:author" content="jay1060950003">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
.post-story + .post-story {
  content-visibility: auto;
  contain-intrinsic-size: 10px 500px;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #30ad91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #2092ec;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-bg {
  position: absolute;
  width: 100%;
  height: 100%;
  background-position: center;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
}
.cover-wrapper .cover-bg.lazyload:not(.loaded) {
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
}
.cover-wrapper .cover-bg.lazyload.loaded {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
.cover-wrapper #parallax-window {
  position: absolute;
  width: 100%;
  height: 100%;
  background: transparent;
}
.parallax-mirror {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media (prefers-color-scheme: dark) {
  :root {
    --color-mode: 'dark';
  }
  :root:not([color-scheme]) {
    --color-site-body: #121212;
    --color-read-bkg: #1f1f1f;
    --color-read-post: #262626;
    --color-site-bg: #1f1f1f;
    --color-site-inner: rgba(238,238,238,0.871);
    --color-site-footer: rgba(170,170,170,0.871);
    --color-card: #262626;
    --color-text: rgba(238,238,238,0.871);
    --color-block: #434343;
    --color-codeblock: #1f1f1f;
    --color-inlinecode: #d56d28;
    --color-h1: rgba(255,255,255,0.871);
    --color-h2: rgba(255,255,255,0.871);
    --color-h3: rgba(255,255,255,0.6);
    --color-h4: rgba(255,255,255,0.6);
    --color-h5: rgba(255,255,255,0.6);
    --color-h6: rgba(255,255,255,0.6);
    --color-p: rgba(217,217,217,0.871);
    --color-list: rgba(217,217,217,0.871);
    --color-list-hl: #63e0c4;
    --color-meta: rgba(191,191,191,0.871);
    --color-link: rgba(191,191,191,0.871);
    --color-copyright-bkg: #21252b;
  }
  :root:not([color-scheme]) img {
    filter: brightness(70%) !important;
  }
  :root:not([color-scheme]) .blur {
    background: rgba(31,31,31,0.9) !important;
  }
  :root:not([color-scheme]) .white-box.blur {
    background: rgba(38,38,38,0.9) !important;
  }
  :root:not([color-scheme]) .nav-main .u-search-input {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a:hover {
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) .article blockquote {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .article-title a {
    color: var(--color-h1) !important;
  }
  :root:not([color-scheme]) details>summary {
    color: var(--color-p) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) details {
    border: 1px solid var(--color-site-bg) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) #u-search .modal,
  :root:not([color-scheme]) #u-search .modal-header,
  :root:not([color-scheme]) #u-search .modal-body {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #u-search .modal-body .modal-results .result:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:focus {
    background: var(--color-site-body) !important;
  }
}
[color-scheme='dark'] {
  --color-site-body: #121212;
  --color-read-bkg: #1f1f1f;
  --color-read-post: #262626;
  --color-site-bg: #1f1f1f;
  --color-site-inner: rgba(238,238,238,0.871);
  --color-site-footer: rgba(170,170,170,0.871);
  --color-card: #262626;
  --color-text: rgba(238,238,238,0.871);
  --color-block: #434343;
  --color-codeblock: #1f1f1f;
  --color-inlinecode: #d56d28;
  --color-h1: rgba(255,255,255,0.871);
  --color-h2: rgba(255,255,255,0.871);
  --color-h3: rgba(255,255,255,0.6);
  --color-h4: rgba(255,255,255,0.6);
  --color-h5: rgba(255,255,255,0.6);
  --color-h6: rgba(255,255,255,0.6);
  --color-p: rgba(217,217,217,0.871);
  --color-list: rgba(217,217,217,0.871);
  --color-list-hl: #63e0c4;
  --color-meta: rgba(191,191,191,0.871);
  --color-link: rgba(191,191,191,0.871);
  --color-copyright-bkg: #21252b;
}
[color-scheme='dark'] img {
  filter: brightness(70%) !important;
}
[color-scheme='dark'] .blur {
  background: rgba(31,31,31,0.9) !important;
}
[color-scheme='dark'] .white-box.blur {
  background: rgba(38,38,38,0.9) !important;
}
[color-scheme='dark'] .nav-main .u-search-input {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a {
  background: var(--color-block) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a:hover {
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] .article blockquote {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .article-title a {
  color: var(--color-h1) !important;
}
[color-scheme='dark'] details>summary {
  color: var(--color-p) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] details {
  border: 1px solid var(--color-site-bg) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] #u-search .modal,
[color-scheme='dark'] #u-search .modal-header,
[color-scheme='dark'] #u-search .modal-body {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #u-search .modal-body .modal-results .result:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:focus {
  background: var(--color-site-body) !important;
}
@media screen and (max-width: 500px) {
  [color-scheme='dark'] .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1080px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #3dd9b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #3dd9b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #3dd9b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1080px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1112px;
    left: calc((100% - 1112px) * 0.5);
  }
}
@media screen and (max-width: 1112px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}
@media screen and (prefers-color-scheme: dark) and (max-width: 500px) {
  .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
    <script>
      let userColorScheme=localStorage.getItem("color-scheme")
      if(userColorScheme){
        document.documentElement.setAttribute("color-scheme", userColorScheme);
      }
    </script>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>`+
        `<span class="kill-c">微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>了解详情 ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>
        <span class="kill-c">本页面需要浏览器支持（启用）JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = "false"; // 调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    debug: false,
    cdn: {"js":{"app":"/js/app.js","parallax":"/js/plugins/parallax.js","rightMenu":"/js/plugins/rightMenu.js","rightMenus":"/js/plugins/rightMenus.js","sites":"/js/plugins/tags/sites.js","friends":"/js/plugins/tags/friends.js","contributors":"/js/plugins/tags/contributors.js","search":"/js/search/hexo.js"},"css":{"style":"/css/style.css"}},
    default: {"avatar":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg","link":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/link/8f277b4ee0ecd.svg","cover":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg","image":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/image/2659360.svg"},
    lastupdate: new Date(1684466732700),
    sidebar: {
      for_page: ["blogger","category","tagcloud","webinfo","lastupdate","donate"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2021/09/20",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js","icon":{"default":"fa-light fa-info-circle light-blue","quection":"fa-light fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"fa-brands fa-creative-commons light-blue"},"aplayer":{"enable":true,"play":"fa-light fa-play light-blue","pause":"fa-light fa-pause light-blue","error":"fa-light fa-exclamation-square red"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      
      aplayer: {
        id: 5062959861,
        enable:true
      },
      
      
      
      rightmenus: {"enable":true,"order":["plugins.navigation","hr","plugins.inputBox","plugins.seletctText","plugins.elementCheck","plugins.elementImage","hr","menus.darkMode","hr","plugins.articlePage","hr","music"],"options":{"iconPrefix":"fa-duotone PETERRIVE","articleShowLink":true,"musicAlwaysShow":true},"plugins":{"navigation":[{"id":"left","name":"转到上一页","icon":"fa-duotone fa-arrow-left PETERRIVE","event":"history.back()","group":"navigation"},{"id":"right","name":"转到下一页","icon":"fa-duotone fa-arrow-right PETERRIVE","event":"history.forward()","group":"navigation"},{"id":"redo","name":"刷新当前页面","icon":"fa-duotone fa-redo PETERRIVE","event":"window.location.reload()","group":"navigation"},{"id":"home","name":"回到首页","icon":"fa-duotone fa-home PETERRIVE","link":"/","group":"navigation"},{"id":"up","name":"回到顶部","icon":"fa-duotone fa-arrow-up PETERRIVE","event":"VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)","group":"navigation"}],"inputBox":[{"id":"copyPaste","name":"粘贴文本","icon":"fa-duotone PETERRIVE fa-paste","event":"copyPaste","group":"inputBox"},{"id":"copyAll","name":"全选文本","icon":"fa-duotone PETERRIVE fa-object-ungroup","event":"copyAll","group":"inputBox"},{"id":"copyCut","name":"剪切文本","icon":"fa-duotone PETERRIVE fa-cut","event":"copyCut","group":"inputBox"}],"seletctText":[{"id":"copyText","name":"复制文本","icon":"fa-duotone PETERRIVE fa-copy","event":"copyText","group":"seletctText"},{"id":"searchWord","name":"站内搜索","icon":"fa-duotone PETERRIVE fa-search","event":"OpenSearch(__text__)","group":"seletctText"},{"id":"bingSearch","name":"必应搜索","icon":"fa-duotone PETERRIVE fa-search","event":"window.open(`https://cn.bing.com/search?q=${__text__}`)","group":"seletctText"}],"elementCheck":[{"id":"openTab","name":"新标签页打开","icon":"fa-duotone PETERRIVE fa-external-link-square-alt","event":"window.open(__link__)","group":"elementCheck"},{"id":"copyLink","name":"复制链接地址","icon":"fa-duotone PETERRIVE fa-link","event":"copyLink","group":"elementCheck"}],"elementImage":[{"id":"copyImg","name":"复制图片","icon":"fa-duotone PETERRIVE fa-image","event":"copyImg","group":"elementImage"},{"id":"googleImg","name":"谷歌识图","icon":"fa-duotone PETERRIVE fa-images","event":"window.open(`https://www.google.com/searchbyimage?image_url=${__link__}`)","group":"elementImage"}],"articlePage":[{"id":"printMode","name":"打印页面","icon":"fa-duotone fa-print TURQUOISE","event":"printMode","group":"articlePage"},{"id":"readMode","name":"阅读模式","icon":"fa-duotone fa-book-open EMERALD","event":"readMode","group":"articlePage"}]},"menus":{"link":[{"id":"help","name":"常见问题","icon":"fa-solid fa-question","link":"https://volantis.js.org/faqs/","group":"link"},{"id":"examples","name":"示例博客","icon":"fa-solid fa-rss","link":"https://volantis.js.org/examples/","group":"link"},{"id":"contributors","name":"加入社区","icon":"fa-solid fa-fan","link":"https://volantis.js.org/contributors/","group":"link"},"hr",{"id":"source_docs","name":"本站源码","icon":"fa-solid fa-code-branch","link":"https://github.com/volantis-x/volantis-docs/","group":"link"},{"id":"source_theme","name":"主题源码","icon":"fa-solid fa-code-branch","link":"https://github.com/volantis-x/hexo-theme-volantis/","group":"link"}],"darkMode":[{"id":"darkMode","name":"暗黑模式","icon":"fa-duotone fa-eclipse-alt WISTERIA","event":"volantis.dark.toggle()","group":"darkMode"}]}}
      
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = Object.assign(volantis.pjax, {
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  });
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list=[]
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  volantis.scroll.ele = null;
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) => {
    if (!ele) return;
    volantis.scroll.ele = ele;
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(() => {
        if (volantis.scroll.ele != ele) {
          return
        }
        volantis.scroll.unengine.push(() => {
          let me = ele.getBoundingClientRect().top
          if(!(me >= -option.observerDic && me <= option.observerDic)){
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        },"unengineObserver")
      },1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = ()=>{
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e=>{
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
  <!-- front-matter head_end begin -->
  <!-- front-matter head_end end -->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <!-- import body_begin begin-->
    <!-- import body_begin end-->
    <!-- Custom Files bodyBegin begin-->
    
    <!-- Custom Files bodyBegin end-->
    <!-- front-matter body_begin begin -->
    <!-- front-matter body_begin end -->
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto shadow floatable blur " style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            CodingStudio <sup style="color:#ff9800">alpha</sup>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="文档"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-duotone fa-book faa-tada fa-fw'></i>文档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-duotone fa-play-circle faa-tada fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-duotone fa-question-circle faa-tada fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-duotone fa-heart fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="更多"
                  
                  
                  >
                  <i class='fa-duotone fa-ellipsis-v fa-fw'></i>更多
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-solid fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
                    
                      
            
              
                <li>
                  <a class="menuitem flat-box">
                    <i class='fa-solid fa-compact-disc fa-fw music'></i>背景音乐
                  </a>
                  <ul class="list-v">
                    <li>
                      <div class="aplayer-container">
                        

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.4'
      loop='all'
      order='random'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5062959861'
      list-folded='true'>
    </meting-js>
  


                      </div>
                    </li>
                  </ul>
                <li>
              
            
          
                    
                  </ul>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="文档"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-duotone fa-book faa-tada fa-fw'></i>文档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-duotone fa-play-circle faa-tada fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-duotone fa-question-circle faa-tada fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-duotone fa-heart fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="更多"
                  
                  
                  >
                  <i class='fa-duotone fa-ellipsis-v fa-fw'></i>更多
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-solid fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
                    
                      
            
              
            
          
                    
                  </ul>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="half" class='cover-wrapper post search' style="display: ;">
        
  <div id="parallax-window"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">CodingStudio</p>
    
    
      <p class="subtitle">努力进步</p>
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="搜一下" />
          <i class="icon fa-solid fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow floatable blur article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="http://jay1060950003.github.io/2022/01/10/计算机基础知识/Java核心技术/">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="CodingStudio">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="CodingStudio">
    <meta itemprop="description" content="自己的创作及学习空间">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title" itemprop="name headline">
        Java核心技术
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author' itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a itemprop="url" class='author' target="_blank" href="https://github.com/jay1060950003" rel="nofollow noopener">
    <img itemprop="image" src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/apple-touch-icon.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/apple-touch-icon.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
    <p itemprop="name">jay1060950003</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <i class="fa-solid fa-folder-open fa-fw" aria-hidden="true"></i>
    <a class="category-link" href="/categories/Java/">Java</a>
    
      <span hidden itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/Java/" itemprop="url"><span itemprop="name">Java</span></a>
      </span>
    
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateCreated datePublished" datetime="2022-01-10T15:22:12+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2022年1月10日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fa-solid fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>字数：76.1k 字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fa-solid fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>时长：282 分钟</p>
    </a>
  </div>


          
        
          
            


<div class="new-meta-item browse">
  <a class='notlink'>
    <p>
      <i class="fa-solid fa-eye fa-fw" aria-hidden="true"></i>
      
      <span id="busuanzi_value_page_pv"><i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i></span>
      
      <span>次浏览</span>
    </p>
  </a>
</div>


          
        
        <!-- Custom Files topMeta begin-->
        
        <!-- Custom Files topMeta end-->
      </div>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<ul>
<li>Java核心思想的学习笔记</li>
<li>包含第一卷除swing章节，并包含第二卷的文件流部分</li>
</ul>
<span id="more"></span>
<hr />
<h1 id="1-java程序设计概述"><a class="markdownIt-Anchor" href="#1-java程序设计概述"></a> 1 Java程序设计概述</h1>
<div class="story post-story"><h2 id="12-java白皮书的关键术语"><a class="markdownIt-Anchor" href="#12-java白皮书的关键术语"></a> 1.2 Java“白皮书”的关键术语</h2>
<ul>
<li>11个关键术语：
<ol>
<li>简单性</li>
<li>面向对象</li>
<li>分布式</li>
<li><strong>健壮性</strong>：
<ul>
<li>Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性</li>
<li>Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性</li>
</ul>
</li>
<li><strong>安全性</strong>：
<ul>
<li>Java代码不论来自哪里，都不能脱离<mark>沙箱</mark></li>
<li>编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，这些编译后的代码可以在许多处理器上运行</li>
<li>解释虚拟机指令肯定会比全速运行机器指令慢很多</li>
<li><mark>即时编译</mark>：虚拟机的一个选项，可以<mark>将执行最频繁的字节码序列翻译成机器码</mark></li>
</ul>
</li>
<li><strong>可移植性</strong>：
<ul>
<li>数据类型具有固定的大小</li>
<li>消除了代码移植时的问题</li>
<li>二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰</li>
<li>字符串是用标准的Unicode格式存储的</li>
<li>除了与用户界面有关的部分外，所有其他Java库都能很好地支持平台独立性。可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，而不用操心底层操作系统。<mark>不仅程序是可移植的，Java API往往也比原生API质量更高</mark></li>
</ul>
</li>
<li>解释型</li>
<li>高性能</li>
<li>多线程</li>
<li>动态性</li>
</ol>
</li>
</ul>
<hr />
<h1 id="3-java的基本程序设计结构"><a class="markdownIt-Anchor" href="#3-java的基本程序设计结构"></a> 3 Java的基本程序设计结构</h1>
</div><div class="story post-story"><h2 id="31-一个简单的java应用程序"><a class="markdownIt-Anchor" href="#31-一个简单的java应用程序"></a> 3.1 一个简单的Java应用程序</h2>
<ul>
<li>关键字class：
<ul>
<li>关键字class后面紧跟类名,表明Java程序中的全部内容都包含在类中</li>
<li>类作为加载程序逻辑的容器，程序逻辑定义了应用程序的行为。</li>
<li><mark>源代码的<strong>文件名必须与公共类的名字相同</strong>，并用.java作为扩展名</mark></li>
<li>运行已编译的程序时，JVM将<mark>从指定类中的main方法开始执行</mark>，<mark>main方法必须声明为public，且必须为静态static的</mark></li>
</ul>
</li>
<li><strong>Java的类与C++的类很相似，但Java中的所有函数都属于某个类的方法。因此，Java中的main方法必须有一个外壳类</strong></li>
</ul>
<!-- more -->
</div><div class="story post-story"><h2 id="32-注释"><a class="markdownIt-Anchor" href="#32-注释"></a> 3.2 注释</h2>
<ul>
<li>使用 //，其注释容从 // 开始到本行结尾。内</li>
<li>使用/*和 */  ：使用较长篇幅的注释</li>
<li>以 /** 开始，以 */ 结束：可以用来自动地生成文档</li>
<li><mark>在Java中，/**/注释不能嵌套</mark></li>
</ul>
</div><div class="story post-story"><h2 id="33-数据结构"><a class="markdownIt-Anchor" href="#33-数据结构"></a> 3.3 数据结构</h2>
<ul>
<li><mark>Java是一种强类型语言，意味着必须为每一个变量声明一种类型</mark></li>
<li>8种基本类型:
<ul>
<li>4种整型     <a href="#331-%E6%95%B4%E5%9E%8B">跳转至整型</a></li>
<li>2种浮点类型     <a href="#332-%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B">跳转至浮点</a></li>
<li>1种用于表示Unicode编码的字符单元的字符类型char      <a href="#333-char%E7%B1%BB%E5%9E%8B">跳转至char</a></li>
<li>1种用于表示真值的boolean类型</li>
</ul>
</li>
<li>另：Java有一个能够<strong>表示任意精度的算术包</strong>，通常称为“大数值”（为<mark>Java对象</mark>）      <a href="#39-%E5%A4%A7%E6%95%B0%E5%80%BC">跳转至大数据类</a></li>
</ul>
<h3 id="331-整型"><a class="markdownIt-Anchor" href="#331-整型"></a> 3.3.1 整型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求(字节)</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><mark>int</mark></td>
<td>4</td>
<td>-2147483~2147483647(正好超过20亿)</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>-9223372036854775808~9223372036854775807</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
<td>-128~127</td>
</tr>
</tbody>
</table>
<ul>
<li><mark>在Java中，整型的范围与运行Java代码的机器无关</mark></li>
<li><strong>Java没有任何无符号(unsigned)形式的int、long、short或byte类型</strong>
<ul>
<li>长整型数值有一个后缀L或l</li>
<li>十六进制数值有一个前缀0x或0X</li>
<li>八进制有一个前缀0</li>
<li>加上前缀0b或0B就可以写二进制数</li>
</ul>
</li>
<li>可以为数字字面量加下划线(如用1_000_000(或0b1111_0100_0010_0100_0000)表示一百万)</li>
</ul>
<h3 id="332-浮点类型"><a class="markdownIt-Anchor" href="#332-浮点类型"></a> 3.3.2 浮点类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求(字节)</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4</td>
<td>±3.40282347E+38F(有效位数6~7位)</td>
</tr>
<tr>
<td><mark>double</mark></td>
<td>8</td>
<td>±1.79769313486231570+308F(有效位数15位)</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>浮点数值存在舍入误差</p>
<ul>
<li>若不允许任何舍入误差，就应该使用BigDecimal类      <a href="#39-%E5%A4%A7%E6%95%B0%E5%80%BC">跳转至大数据类</a></li>
</ul>
</li>
<li>
<p>double（绝大多数程序使用）表示这种类型的数值精度是float类型的两倍。</p>
<ul>
<li>float类型的数值有一个<mark>后缀F或f</mark></li>
<li>没有后缀F的浮点数值，<mark>默认为double类型</mark></li>
</ul>
</li>
<li>
<p>使用十六进制表示浮点数值</p>
<ul>
<li>例如，0.125=1.0*2^(-3)可以表示成0x1.0p-3(尾数十六进制，指数十进制)</li>
<li>在十六进制表示法中，<mark>使用p表示指数，而不是e</mark></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示溢出和出错情况的三个特殊的浮点数值：</span></span><br><span class="line"><span class="comment">//不可用于比较大小</span></span><br><span class="line">Double.POSITIVE_INFINITY <span class="comment">//正无穷大</span></span><br><span class="line">Double.NEGATIVE_INFINITY <span class="comment">//负无穷大</span></span><br><span class="line">Double.NaN     <span class="comment">//NaN(不是一个数字) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Double.isNaN(x))  <span class="comment">//需要使用该方法检测非数值</span></span><br></pre></td></tr></table></figure>
<h3 id="333-char类型"><a class="markdownIt-Anchor" href="#333-char类型"></a> 3.3.3 char类型</h3>
<ul>
<li>转义序列\u可以出现在加引号的字符常量或字符串之外(而其他所有转义序列不可以)</li>
</ul>
<table>
<thead>
<tr>
<th>转义序列</th>
<th>名称</th>
<th>unicode值</th>
</tr>
</thead>
<tbody>
<tr>
<td>\b</td>
<td>退格</td>
<td>\u0008</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
<td>\u0009</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
<td>\u000a</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td>\u000d</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
<td>\u0022</td>
</tr>
<tr>
<td>'</td>
<td>单引号</td>
<td>\u0027</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
<td>\u005c</td>
</tr>
</tbody>
</table>
<ul>
<li>一定要当心注释中的\u</li>
</ul>
<h3 id="334-unicode和char类型"><a class="markdownIt-Anchor" href="#334-unicode和char类型"></a> 3.3.4 Unicode和char类型</h3>
<ul>
<li>
<p>在Java中，char类型描述了UTF-16编码中的一个代码单元</p>
</li>
<li>
<p><mark>强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元</mark></p>
</li>
<li>
<p>设计Unicode编码的目的</p>
<ul>
<li>对于任意给定的代码值，在不同的编码方案下有可能对应不同的字母</li>
<li>采用大字符集的语言其编码长度有可能不同。</li>
</ul>
</li>
<li>
<p>码点是指与一个编码表中的某个字符对应的代码值。</p>
<ul>
<li>在Unicode标准中，码点采用十六进制书写，并加上前缀U+</li>
<li>Unicode的码点可以分成17个代码级别
<ul>
<li>第一个代码级别称为基本的多语言级别(basic multilingual plane)，码点从U+0000到U+FFFF，其中包括经典的Unicode代码</li>
<li>其余的16个级别码点从U+10000到U+10FFFF，其中包括一些辅助字符(supplementary character)。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>UTF-16编码采用不同长度的编码表示所有Unicode码点</p>
</li>
<li>
<p>在基本的多语言级别中，每个字符用16位表示，通常被称为代码单元</p>
</li>
<li>
<p>而辅助字符采用一对连续的代码单元进行编码</p>
</li>
<li>
<p>这样构成的编码值落入基本的多语言级别中空闲的2048字节内，通常被称为替代区域</p>
</li>
<li>
<p>可以从中迅速地知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。</p>
</li>
</ul>
<h3 id="335-boolean类型"><a class="markdownIt-Anchor" href="#335-boolean类型"></a> 3.3.5 boolean类型</h3>
<ul>
<li>boolean类型有两个值：false,true <mark>用来判定逻辑条件</mark></li>
<li><mark>整型值和布尔值之间不能进行相互转换</mark></li>
</ul>
</div><div class="story post-story"><h2 id="34-变量"><a class="markdownIt-Anchor" href="#34-变量"></a> 3.4 变量</h2>
<ul>
<li>声明变量时，变量的类型位于变量名之前</li>
<li>在Java中，不区分变量的声明与定义</li>
<li><mark>声明一个变量之后，必须用赋值语句对变量进行显式初始化，<strong>不要使用未初始化的变量</strong></mark></li>
</ul>
<h3 id="342-常量"><a class="markdownIt-Anchor" href="#342-常量"></a> 3.4.2 常量</h3>
<ul>
<li>利用<mark>关键字final指示常量,常量名一般都是全大写</mark></li>
<li>关键字final表示这个变量只能被赋值一次。<mark>一旦被赋值之后，就不能够再更改了</mark></li>
<li>类常量：某个常量可以在一个类中的多个方法中使用。
<ul>
<li>使用关键字static final设置一个类常量</li>
<li>类常量的定义位于main方法的外部
<ul>
<li>同一个类的其他方法中也可以使用这个常量</li>
<li>一个常量被声明为public，其他类的方法也可以使用这个常量</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="35-运算符"><a class="markdownIt-Anchor" href="#35-运算符"></a> 3.5 运算符</h2>
<p>除号/：</p>
<ul>
<li>
<p>两个操作数都是整数时，表示整数除法</p>
</li>
<li>
<p>否则，表示浮点除法</p>
<ul>
<li><strong>整数被0除将产生一个异常</strong></li>
<li><strong>浮点数被0除将会得到无穷大或NaN结果</strong></li>
</ul>
</li>
<li>
<p>默认情况下，虚拟机设计者允许对中间计算结果采用扩展的精度</p>
</li>
<li>
<p>对于使用<mark>strictfp关键字标记的方法</mark>必须使用<mark>严格的浮点计算来生成可再生的结果</mark></p>
<ul>
<li>如果将一个类标记为strictfp，这个类中的所有方法都要使用严格的浮点计算</li>
<li>采用默认的方式不会产生溢出，而采用严格的计算有可能产生溢出</li>
</ul>
</li>
</ul>
<h3 id="351-数学函数与常量"><a class="markdownIt-Anchor" href="#351-数学函数与常量"></a> 3.5.1 数学函数与常量</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> Math.sqrt(x);  <span class="comment">//计算数值平方根</span></span><br><span class="line"><span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> Math.pow(x,<span class="number">4</span>);  <span class="comment">//计算幂运算</span></span><br><span class="line">System.out.println(y);</span><br></pre></td></tr></table></figure>
<p>Math类提供的各种各样的数学函数：</p>
<ul>
<li>
<p>平方根 sqrt</p>
</li>
<li>
<p>幂 pow</p>
</li>
<li>
<p>取余 floorMod</p>
</li>
<li>
<p>三角函数</p>
<ul>
<li>Math.sin</li>
<li>Math.cos</li>
<li>Math.tan</li>
<li>Math.atan</li>
<li>Math.atan2</li>
</ul>
</li>
<li>
<p>自然对数运算</p>
<ul>
<li>Math.exp</li>
<li>Math.log</li>
<li>Mtah.log10</li>
</ul>
</li>
<li>
<p>结果比运行速度更重要，<mark>应该使用StrictMath类</mark></p>
</li>
<li>
<p>println方法和sqrt方法存在微小的差异</p>
<ul>
<li>println方法处理System.out对象</li>
<li>Math类中的sqrt方法为<mark>静态方法</mark>，处理的不是对象</li>
</ul>
</li>
</ul>
<h3 id="352-数值类型之间的类型转换"><a class="markdownIt-Anchor" href="#352-数值类型之间的类型转换"></a> 3.5.2 数值类型之间的类型转换</h3>
<p><img src="Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%5Cimage1.png" class="lazyload" data-srcset="Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%5Cimage1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="数值转换" /><br />
6个实心箭头，表示无信息丢失的转换；3个虚箭头，表示可能有精度损失的转换</p>
<h3 id="353-强制类型转换"><a class="markdownIt-Anchor" href="#353-强制类型转换"></a> 3.5.3 强制类型转换</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">9.997</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) x;  </span><br><span class="line"><span class="comment">//在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将一个数值从一种类型强制转换为另一种类型，而又<mark>超出了目标类型的表示范围，结果就会截断成一个完全不同的值</mark></li>
<li>不要在boolean类型与任何数值类型之间进行强制类型转换
<ul>
<li><strong>极少数的情况</strong>才需要将布尔类型转换为数值类型,使用<mark>条件表达式 b?1:0</mark></li>
</ul>
</li>
<li>对浮点数进行舍入运算，<mark>使用Math.round方法</mark></li>
</ul>
<h3 id="355-自增与自减运算符"><a class="markdownIt-Anchor" href="#355-自增与自减运算符"></a> 3.5.5 自增与自减运算符</h3>
<p>后缀 i++ : 表示先使用当前值，在完成加一<br />
前缀 ++i : 表示先完成加一，在使用变量值</p>
<h3 id="356-关系和boolean变量"><a class="markdownIt-Anchor" href="#356-关系和boolean变量"></a> 3.5.6 关系和boolean变量</h3>
<ul>
<li>== 检测相等性</li>
<li>\ != 检测不相等</li>
<li>&amp;&amp; || ! 与或非运算符</li>
<li>三元操作符 ? :</li>
</ul>
<h3 id="357-位运算符"><a class="markdownIt-Anchor" href="#357-位运算符"></a> 3.5.7 位运算符</h3>
<ul>
<li>&amp; | ^ ~</li>
<li>&gt;&gt; 左移运算符</li>
<li>&lt;&lt; 右移运算符</li>
<li>&gt;&gt;&gt; 左移 使用0填充最高位</li>
<li>&lt;&lt;&lt; 右移 使用0填充最低位
<ul>
<li>移位运算符的右操作数要完成模32的运算(除非左操作数是long类型</li>
</ul>
</li>
</ul>
<h3 id="359-枚举类型"><a class="markdownIt-Anchor" href="#359-枚举类型"></a> 3.5.9 枚举类型</h3>
<ul>
<li>需要定义枚举类，参考<a href="#56-%E6%9E%9A%E4%B8%BE%E7%B1%BB">枚举类</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以自定义枚举类型</span></span><br><span class="line"><span class="comment">// 枚举类型包括有限个命名的值</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123; SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;  <span class="comment">//声明枚举类型Size</span></span><br><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Size.MEDIUM;   <span class="comment">//声明枚举变量s</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="36-字符串"><a class="markdownIt-Anchor" href="#36-字符串"></a> 3.6 字符串</h2>
<p>Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类String</p>
<h3 id="361-子串"><a class="markdownIt-Anchor" href="#361-子串"></a> 3.6.1 子串</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String类的substring方法</span></span><br><span class="line"><span class="comment">// 可以从一个较大的字符串提取出一个子串</span></span><br><span class="line"><span class="comment">// 容易计算子串的长度。字符串s.substring(a,b)的长度为b-a</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> greeting.substring(<span class="number">0</span>,<span class="number">3</span>);  <span class="comment">//从位置0处开始提取到第 3 字符为止(0 1 2)</span></span><br></pre></td></tr></table></figure>
<h3 id="362-拼接"><a class="markdownIt-Anchor" href="#362-拼接"></a> 3.6.2 拼接</h3>
<ul>
<li>允许<mark>使用 + 进行拼接两个字符串</mark></li>
<li>当将一个字符串与一个非字符串的值进行拼接时，<mark>后者被转换成字符串</mark></li>
<li>把多个字符串拼接并用定界符分隔，可以<mark>使用静态join方法</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">all</span> <span class="operator">=</span> String.join(<span class="string">&quot;/&quot;</span> , <span class="string">&quot;S&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="363-不可变字符串"><a class="markdownIt-Anchor" href="#363-不可变字符串"></a> 3.6.3 不可变字符串</h3>
<ul>
<li>String类没有提供修改字符串的方法（Java文档中将String类对象称为不可变字符串）</li>
<li>修改步骤：<strong>首先提取需要的字符，然后再拼接上替换的字符串</strong></li>
<li>不可变字符串的优点：编译器可以让字符串共享
<ul>
<li>各种字符串存放在公共的存储池中</li>
<li>字符串变量指向存储池中相应的位置</li>
<li>如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符</li>
</ul>
</li>
<li>Java字符串大致类似于char*指针</li>
</ul>
<h3 id="364-检测字符串是否相等"><a class="markdownIt-Anchor" href="#364-检测字符串是否相等"></a> 3.6.4 检测字符串是否相等</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用equals方法检测字符串是否相等（相等则返回true，否则返回false）</span></span><br><span class="line">s.equals(t);  <span class="comment">//用于检测可变字符串s与可变字符串t是否相等</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.equals(greeting); <span class="comment">//检测字符串常量与字符串变量greeting是否相等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不区分大小写检测：使用equalsIgnoreCase方法</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.equalsIgnoreCase(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><mark>一定不要使用==运算符检测两个字符串是否相等</mark></li>
<li>该运算符只能够确定两个字符串是否放置在同一个位置上
<ul>
<li>若虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等</li>
<li>但实际上只有字符串常量是共享的，而+或substring等操作产生的结果并不是共享的</li>
</ul>
</li>
</ul>
<h3 id="365-空串和null串"><a class="markdownIt-Anchor" href="#365-空串和null串"></a> 3.6.5 空串和Null串</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空串是长度为0的字符串(一个Java对象,有自己的串长度(0)和内容(空))</span></span><br><span class="line"><span class="keyword">if</span> (str.length() ==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// String变量还可以存放一个特殊的值null</span></span><br><span class="line"><span class="comment">//这表示目前没有任何对象与该变量关联</span></span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() != <span class="number">0</span>)  <span class="comment">//检测既不是空串也不是null</span></span><br></pre></td></tr></table></figure>
<h3 id="366-码点与代码单元"><a class="markdownIt-Anchor" href="#366-码点与代码单元"></a> 3.6.6 码点与代码单元</h3>
<ul>
<li>char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元</li>
<li>length方法将返回采用UTF-16编码表示的给定字符串所需要的代码单元数量
<ul>
<li>调用s.charAt(n)将返回位置n的代码单元，n介于0~s.length()-1之间</li>
<li>使用codePoints方法，它会生成一个int值的“流”,每个int值对应一个码点</li>
</ul>
</li>
<li>将码点数组转换为字符串，可以使用构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要想得到实际的长度，即码点数量，可以调用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">cpCount</span> <span class="operator">=</span> greeting.codePointCount(<span class="number">0</span>,greeting.length());</span><br></pre></td></tr></table></figure>
<h3 id="369-构建字符串"><a class="markdownIt-Anchor" href="#369-构建字符串"></a> 3.6.9 构建字符串</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBulider</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBulider</span>(); <span class="comment">//构造空的字符串构造器</span></span><br><span class="line">builder.append(ch);  <span class="comment">//调用append方法添加内容</span></span><br><span class="line">builder.append(str);  </span><br><span class="line"><span class="type">String</span> <span class="variable">completedString</span> <span class="operator">=</span> builder.toString(); <span class="comment">//调用toString方法转换为字符串String</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用StringBuilder类适用于<mark>由较短的字符串构造较短的字符串</mark></li>
<li><mark>避免每次连接字符串，都会构建一个新的String对象，既耗时，又浪费空间</mark></li>
<li>StringBuilder类将所有的字符串在<mark>一个单线程中编辑</mark>
<ul>
<li><strong>StringBuffer效率较低，但可以使用多线程方式执行添加或删除字符串的操作</strong></li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="37-输入与输出"><a class="markdownIt-Anchor" href="#37-输入与输出"></a> 3.7 输入与输出</h2>
<h3 id="371-读取输入"><a class="markdownIt-Anchor" href="#371-读取输入"></a> 3.7.1 读取输入</h3>
<ul>
<li>读取“标准输入流”操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Scanner类实现（输入是可见的）</span></span><br><span class="line"><span class="comment">//Scanner类定义在java.util包中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*     <span class="comment">//导入包</span></span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//构造Scanner对象，并且与标准输入流System.in关联</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.nextline(); <span class="comment">//使用nextline输入一行(输入行可能有空格)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">firstname</span> <span class="operator">=</span> in.next(); <span class="comment">//读取一个单词输入(空格作为分隔符)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> in.nextInt();  <span class="comment">//读取一个整数</span></span><br><span class="line"><span class="type">Double</span> <span class="variable">times</span> <span class="operator">=</span> in.nextDouble();  <span class="comment">//读取一个浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入不可见，用于从控制台读取密码</span></span><br><span class="line"><span class="type">Console</span> <span class="variable">cons</span> <span class="operator">=</span> System.console();  <span class="comment">//Console实现</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> Cons.readLine( <span class="string">&quot;User name; &quot;</span>);</span><br><span class="line"><span class="type">char</span>[] passwc = cons.readPassword(<span class="string">&quot;Password: &quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>返回的密码存放在一维字符数组中</li>
<li>在对密码进行处理之后，应该马上用一个填充值覆盖数组元素.</li>
<li>采用Console对象处理输入不如采用Scanner方便（每次只能读取一行输入，而没有能够读取一个单词或一个数值的方法）</li>
</ul>
<h3 id="372-格式化输出"><a class="markdownIt-Anchor" href="#372-格式化输出"></a> 3.7.2 格式化输出</h3>
<ul>
<li>
<p>每一个以%字符开始的格式说明符都用相应的参数替换。</p>
<ul>
<li>用于print的转换符：<br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/image2.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/image2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="print转换符" /></li>
<li>用于print的标志：<br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/image3.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/image3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="print转换符" /></li>
</ul>
</li>
<li>
<p>可以使用s转换符格式化任意的对象</p>
</li>
<li>
<p>对于任意<mark>实现了Formattable接口的对象都将调用formatTo方法</mark></p>
</li>
<li>
<p><mark>否则将调用toString方法，它可以将对象转换为字符串</mark></p>
</li>
<li>
<p>可以使用静态的String.format方法创建一个格式化的字符串，而不打印输出：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;Hello, %s. Next year, you&#x27;ll be %d&quot;</span>, name, age); </span><br></pre></td></tr></table></figure>
<p>日期和时间：<br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/image4.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/image4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="print时间日期" /></p>
<ul>
<li>可以采用一个格式化的字符串指出要被格式化的参数索引</li>
<li>索引必须紧跟在%后面，并以$终止。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%1$s %2$tB %2$te, %2$tY&quot;</span>, <span class="string">&quot;Due date;&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">System.out.printf(<span class="string">&quot;%s %tB %&lt;te, %&lt;tY&quot;</span>, <span class="string">&quot;Due date:&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()); </span><br><span class="line"><span class="comment">//&lt;标志前面格式说明中的参数将被再次使用。</span></span><br><span class="line"><span class="comment">//参数索引值从1开始，而不是从0开始，%1$...对第1个参数格式化。这就避免了与0标志混淆。</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/image5.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/image5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="print总结" /></p>
<h3 id="373-文件输入与输出"><a class="markdownIt-Anchor" href="#373-文件输入与输出"></a> 3.7.3 文件输入与输出</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Paths.get(<span class="string">&quot;myfile.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//对文件进行读取，就需要一个用File对象构造一个Scanner对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scaner</span>(<span class="string">&quot;myfile.txt&quot;</span>); </span><br><span class="line"><span class="comment">//构造一个带有字符串参数的Scanner，但这个Scanner将字符串解释为数据，而不是文件名。</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&#x27; myfile.txt&quot;,&quot;UTF-8&quot;);</span></span><br><span class="line"><span class="string">//写入文件，就需要构造一个PrintWriter对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li><mark>如果用一个不存在的文件构造一个Scanner，或者用一个不能被创建的文件名构造一个PrintWriter，那么就会发生异常</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//告知编译器：已经知道有可能出现“输入/输出”异常</span></span><br><span class="line"><span class="comment">//需要在main方法中用throws子句标记</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Paths.get(<span class="string">&quot;myfi1e.txt&quot;</span>),<span class="string">&quot;UTF8&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="38-控制流程"><a class="markdownIt-Anchor" href="#38-控制流程"></a> 3.8 控制流程</h2>
<ul>
<li>Java的控制流程结构<mark>没有goto语句，但break语句可以带标签，可以利用它实现从内层循环跳出的目的</mark></li>
<li>不能在嵌套的两个块中声明同名的变量</li>
</ul>
<h3 id="384-确定循环"><a class="markdownIt-Anchor" href="#384-确定循环"></a> 3.8.4 确定循环</h3>
<ul>
<li>在循环中，检测两个浮点数是否相等需要格外小心
<ul>
<li>由于舍入的误差，最终可能得不到精确值</li>
<li>例如，因为0.1无法精确地用二进制表示，所以，x将从9.99999999999998跳到10.09999999999998</li>
</ul>
</li>
<li>如果在for语句<mark>内部定义一个变量，这个变量就不能在循环体之外使用</mark>
<ul>
<li>如果希望<mark>在for循环体之外使用循环计数器的最终值，就要确保这个变量在循环语句的前面且在外部声明</mark></li>
</ul>
</li>
<li>可以在各自独立的不同for循环中定义同名的变量。</li>
</ul>
<h3 id="385-多重选择switch语句"><a class="markdownIt-Anchor" href="#385-多重选择switch语句"></a> 3.8.5 多重选择：switch语句</h3>
<ul>
<li>switch语句将从与选项值相匹配的case标签处开始执行直到遇到break语句，或者执行到switch语句的结束处为止</li>
<li>有可能触发多个case分支。如果在case分支语句的末尾没有break语句，那么就会接着执行下一个case分支语句</li>
<li>编译代码时可以考虑加上==-Xlint:fallthrough选项，如果某个分支最后缺少一个break语句，编译器就会给出一个警告消息==</li>
<li>当在switch语句中使用枚举常量时，不必在每个标签中指明枚举名，可以由switch的表达式值确定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">SZ</span> <span class="operator">=</span>...;</span><br><span class="line"><span class="keyword">switch</span> (sz)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">case</span> SMALL: <span class="comment">// no need to use Size.SMALL</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="386-中断控制流程语句"><a class="markdownIt-Anchor" href="#386-中断控制流程语句"></a> 3.8.6 中断控制流程语句</h3>
<ul>
<li>标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号</li>
<li>continue语句越过了当前循环体的剩余部分，立刻跳到循环首部</li>
<li>continue语句用于for循环中，就可以跳到for循环的“更新”部分</li>
</ul>
</div><div class="story post-story"><h2 id="39-大数值"><a class="markdownIt-Anchor" href="#39-大数值"></a> 3.9 大数值</h2>
<ul>
<li>java.math包中的两个很有用的类：BigInteger和BigDecimal
<ul>
<li>可以处理包含任意长度数字序列的数值</li>
<li>BigInteger类实现了任意精度的整数运算</li>
<li>BigDecimal实现了任意精度的浮点数运算。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的valueOf方法可以将普通的数值转换为大数值</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> BigInteger.value0f(<span class="number">100</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">c</span> <span class="operator">=</span> a.add(b);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">d</span> <span class="operator">=</span> c.multiply(b.add(BigInteger.vale0f(<span class="number">2</span>)));</span><br><span class="line"><span class="comment">// 不可以使用+，*表示加法和乘法，只可以使用add和multiply方法进行</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="310-数组"><a class="markdownIt-Anchor" href="#310-数组"></a> 3.10 数组</h2>
<ul>
<li>声明数组变量时，需要指出数组类型(数据元素类型紧跟[])和数组变量的名字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用new运算符创建数组</span></span><br><span class="line"><span class="type">int</span> [] a;  <span class="comment">//声明数组变量</span></span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];  <span class="comment">//创建长度为100的数组</span></span><br><span class="line"><span class="comment">//创建一个数字数组时，所有元素都初始化为0</span></span><br><span class="line"><span class="comment">//boolean数组的元素会初始化为false</span></span><br><span class="line"><span class="comment">//对象数组的元素则初始化为一个特殊值null，这表示这些元素(还)未存放任何对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; a.length; i++) <span class="comment">//获得数组元素个数(length方法)</span></span><br><span class="line"> System.out.println(a[i]);</span><br></pre></td></tr></table></figure>
<ul>
<li><mark>一旦创建了数组，就不能再改变它的大小(尽管可以改变每一个数组元素)</mark></li>
<li>需要在运行过程中扩展数组的大小，使用<mark>数组列表(array list)</mark></li>
</ul>
<h3 id="3101-for-each循环"><a class="markdownIt-Anchor" href="#3101-for-each循环"></a> 3.10.1 for each循环</h3>
<ul>
<li>for each循环可以用来依次处理数组中的每个元素而不必指定下标值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//collection集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象</span></span><br><span class="line"><span class="keyword">for</span> (variable:collection) statement  语句格式</span><br></pre></td></tr></table></figure>
<ul>
<li>调用Arrays.toString(a)，返回一个包含数组元素的字符串，可以打印数组中的所有值</li>
</ul>
<h3 id="3102-数组初始化以及匿名数组"><a class="markdownIt-Anchor" href="#3102-数组初始化以及匿名数组"></a> 3.10.2 数组初始化以及匿名数组</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数组对象并同时赋予初始值的简化书写(不需要使用new)</span></span><br><span class="line"><span class="type">int</span>[] smallPrimes = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span> ]; </span><br><span class="line"><span class="comment">//匿名数组</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span> &#125;; </span><br><span class="line"><span class="comment">//在不创建新变量的情况下重新初始化一个数组</span></span><br><span class="line">smallPrimes = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span> &#125;;  </span><br><span class="line"><span class="comment">//简化写法</span></span><br><span class="line"><span class="type">int</span>[] anonynous = &#123; <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span> &#125;;  </span><br><span class="line">smaPrimes = anonynous;</span><br></pre></td></tr></table></figure>
<h3 id="3103-数组拷贝"><a class="markdownIt-Anchor" href="#3103-数组拷贝"></a> 3.10.3 数组拷贝</h3>
<ul>
<li>在Java中，允许将一个数组变量拷贝给另一个数组变量,<mark>两个变量将引用同一个数组</mark></li>
<li>将<mark>一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyOf方法</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] luckyNumbers = smallPrimes; <span class="comment">//数组拷贝</span></span><br><span class="line">luckyNunbers[<span class="number">5</span>] = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] copiedLuckyNunbers = Arrays.copyOf(luckyNumbers,luckyNumbers.length); </span><br><span class="line"><span class="comment">//第2个参数是新数组的长度</span></span><br><span class="line"><span class="comment">//可用来调整数组的大小</span></span><br><span class="line"><span class="comment">//如果长度小于原始数组的长度，则只拷贝最前面的数据元素</span></span><br></pre></td></tr></table></figure>
<h3 id="3104-命令行参数"><a class="markdownIt-Anchor" href="#3104-命令行参数"></a> 3.10.4 命令行参数</h3>
<ul>
<li>每一个Java应用程序都有一个带String arg[]参数的main方法</li>
<li>这个参数表明main方法将接收一个字符串数组，也就是命令行参数。</li>
</ul>
<h3 id="3105-数组排序"><a class="markdownIt-Anchor" href="#3105-数组排序"></a> 3.10.5 数组排序</h3>
<ul>
<li>对数值型数组进行排序，使用Arrays类中的sort方法</li>
</ul>
<h3 id="3106-多维数组"><a class="markdownIt-Anchor" href="#3106-多维数组"></a> 3.10.6 多维数组</h3>
<ul>
<li>与一维数组一样，在调用new对多维数组进行初始化之前不能使用它</li>
<li>若知道数组元素，就可以不调用new，而直接使用简化的书写形式对多维数组进行初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">balances = <span class="keyword">new</span> <span class="title class_">double</span>[NYEARS] [NRATES];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] magicSquare =</span><br><span class="line">&#123;</span><br><span class="line"> <span class="number">16</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">13</span>&#125;,</span><br><span class="line"> &#123;<span class="number">5</span>，<span class="number">10</span>，<span class="number">11</span>, B&#125;,</span><br><span class="line"> &#123;<span class="number">9</span>; <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>&#125;,</span><br><span class="line"> &#123;<span class="number">4</span>，<span class="number">15</span>，<span class="number">14</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out. println(Arrays.deepToString(a)); <span class="comment">//快速地打印一个二维数组的数据元素列表</span></span><br></pre></td></tr></table></figure>
<ul>
<li><mark>快速地打印一个二维数组的数据元素列表</mark>Arrays.deepToString方法</li>
<li>for each循环语句处理二维数组的每一个元素(需要使用两个嵌套的循环)</li>
<li>for each循环语句对二维数组按照行(一维数组)处理</li>
</ul>
<h3 id="3107-不规则数组"><a class="markdownIt-Anchor" href="#3107-不规则数组"></a> 3.10.7 不规则数组</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[] temp = balances[i];  <span class="comment">//数组两行交换</span></span><br><span class="line">balances[i] = balances[i + <span class="number">1</span>];</span><br><span class="line">balances[i + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造“不规则”数组，即数组的每一行有不同的长度。</span></span><br></pre></td></tr></table></figure>
<hr />
<h1 id="4-对象与类"><a class="markdownIt-Anchor" href="#4-对象与类"></a> 4 对象与类</h1>
</div><div class="story post-story"><h2 id="411-类"><a class="markdownIt-Anchor" href="#411-类"></a> 4.1.1 类</h2>
<ul>
<li>封装是与对象有关的一个重要概念
<ul>
<li>从形式上看，封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式</li>
<li><mark>对象中的数据称为实例域，操纵数据的过程称为方法</mark></li>
<li>对于每个特定的类实例(对象)都有一组特定的实例域值。这些值的集合就是这个对象的当前状态</li>
<li>无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。</li>
</ul>
</li>
</ul>
<h3 id="412-对象"><a class="markdownIt-Anchor" href="#412-对象"></a> 4.1.2 对象</h3>
<ul>
<li><mark>对象状态的改变必须通过调用方法实现</mark></li>
<li><strong>如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏</strong></li>
<li>需要注意，作为一个类的实例，每个对象的标识永远是不同的，状态常常也存在着差异</li>
</ul>
<h3 id="414-类之间的关系"><a class="markdownIt-Anchor" href="#414-类之间的关系"></a> 4.1.4 类之间的关系</h3>
<ul>
<li>依赖：如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。</li>
<li>聚合：意味着类A的对象包含类B的对象。</li>
<li>继承：是一种用于表示特殊与一般关系的。</li>
</ul>
</div><div class="story post-story"><h2 id="42-使用预定类"><a class="markdownIt-Anchor" href="#42-使用预定类"></a> 4.2 使用预定类</h2>
<ul>
<li>Math类只封装了功能，它不需要也不必隐藏数据</li>
<li>由于没有数据，因此也不必担心生成对象以及初始化实例域</li>
</ul>
<h3 id="421-对象与对象变量"><a class="markdownIt-Anchor" href="#421-对象与对象变量"></a> 4.2.1 对象与对象变量</h3>
<ul>
<li>在Java程序中，使用构造器构造新实例
<ul>
<li>构造器是一种特殊的方法，用来构造并初始化对象</li>
<li><mark>构造器的名字应该与类名相同</mark></li>
<li>在构造器前面加上new操作符,<mark>new操作符的返回值是一个引用</mark></li>
</ul>
</li>
<li>定义对象变量后必须初始化对象变量,所有的Java对象都<mark>存储在堆中</mark>
<ul>
<li><mark>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象</mark></li>
<li>任何对象变量的值都是<mark>对存储在另外一个地方的一个对象的引用</mark></li>
</ul>
</li>
<li>如果将一个方法应用于<mark>一个值为null的对象上</mark>，那么就会产生运行时错误</li>
<li><mark>局部变量不会自动地初始化为null</mark>，而必须<mark>通过调用new或将它们设置为null进行初始化</mark></li>
<li><mark>当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针</mark></li>
<li>在Java中，<mark>必须使用clone方法获得对象的完整拷贝</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date deadline;  <span class="comment">//定义对象变量</span></span><br><span class="line">deadline = <span class="keyword">new</span> <span class="title class_">Date</span>();  <span class="comment">//初始化对象变量</span></span><br><span class="line">deadline = birthday;  <span class="comment">//或者引用一个存在的对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">deadline</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();  <span class="comment">//定义并初始化对象</span></span><br></pre></td></tr></table></figure>
<h3 id="422-java类库中的localdate类"><a class="markdownIt-Anchor" href="#422-java类库中的localdate类"></a> 4.2.2 Java类库中的LocalDate类</h3>
<ul>
<li>Date类:表示时间点</li>
<li>LocalDate类:日历表示法
<ul>
<li>不要使用构造器来构造LocalDate类的对象</li>
<li><mark>使用静态工厂方法代表调用构造器</mark></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDate.now(); <span class="comment">//构造新对象，表示构造这个对象时的日期</span></span><br><span class="line">LOcalDate.of(<span class="number">1999</span>, <span class="number">12</span>, <span class="number">31</span>);  <span class="comment">//构造特定日期的对象</span></span><br><span class="line"><span class="comment">//不可以使用构造器方法构造LocalDate对象</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">newYearsEve</span> <span class="operator">=</span> LocalDate.of(<span class="number">1998</span>, <span class="number">12</span>, <span class="number">31</span>);  <span class="comment">//用静态工厂方法构造对象</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> newYearsEve.getYear();    <span class="comment">//返回年</span></span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> newYearsEve.getMonthVa1ue();  <span class="comment">//月</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> nenYearsEve.getDayOfMonth();   <span class="comment">//日</span></span><br><span class="line"><span class="comment">//返回一个新的LocalDate对象，为距当前对象之情天数的日期</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">aThousandDaysLater</span> <span class="operator">=</span> newYearsEve.plusDays(<span class="number">1000</span>);  </span><br></pre></td></tr></table></figure>
<h3 id="423-更改器方法与访问器方法"><a class="markdownIt-Anchor" href="#423-更改器方法与访问器方法"></a> 4.2.3 更改器方法与访问器方法</h3>
<ul>
<li><strong>访问器方法</strong>:只访问对象而不修改对象的方法,如LocalDate.getYear()</li>
<li><strong>更改器方法</strong>:访问对象并修改对象的方法,如GregorianCalendar.add()</li>
<li>在C++中，带有const后缀的方法是访问器方法;默认为更改器方法</li>
</ul>
</div><div class="story post-story"><h2 id="43-用户自定义类"><a class="markdownIt-Anchor" href="#43-用户自定义类"></a> 4.3 用户自定义类</h2>
<p>在Java中，最简单的类定义形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line"> field1</span><br><span class="line"> field2</span><br><span class="line"> ...</span><br><span class="line"> constructor1</span><br><span class="line"> constructor2</span><br><span class="line"> ...</span><br><span class="line"> method1</span><br><span class="line"> method2</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="432-多个源文件的使用"><a class="markdownIt-Anchor" href="#432-多个源文件的使用"></a> 4.3.2 多个源文件的使用</h3>
<ul>
<li>使用通配符调用Java编译器:java Employee*.java</li>
<li>或编译 java EmployeeTest.java</li>
</ul>
<h3 id="433-剖析employee类"><a class="markdownIt-Anchor" href="#433-剖析employee类"></a> 4.3.3 剖析Employee类</h3>
<ul>
<li><mark>关键字private确保只有Employee类自身的方法能够访问这些实例域，而其他类的方法不能够读写这些域</mark></li>
<li>可以用public标记实例域（<mark>一种极为不提倡的做法</mark>）
<ul>
<li>public数据域允许程序中的任何方法对其进行读取和修改（<mark>完全破坏了封装</mark>）</li>
</ul>
</li>
</ul>
<h3 id="434-从构造器开始"><a class="markdownIt-Anchor" href="#434-从构造器开始"></a> 4.3.4 从构造器开始</h3>
<ul>
<li>构造器与类同名,可以拥有0个、1个或多个参数，没有返回值</li>
<li>构造器<mark>总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的</mark></li>
<li>每个类可以有一个以上的构造器</li>
<li>不要在构造器中<mark>定义</mark>与实例域重名的局部变量</li>
<li><mark>必须注意在所有的方法中不要命名与实例域同名的变量</mark></li>
</ul>
<h3 id="435-隐式参数与显式参数"><a class="markdownIt-Anchor" href="#435-隐式参数与显式参数"></a> 4.3.5 隐式参数与显式参数</h3>
<ul>
<li>在每一个方法中，<mark>关键字this表示隐式参数</mark></li>
<li>在Java中，<mark>所有的方法都必须在类的内部定义，但并不表示它们是内联方法</mark></li>
</ul>
<h3 id="436-封装的优点"><a class="markdownIt-Anchor" href="#436-封装的优点"></a> 4.3.6 封装的优点</h3>
<ul>
<li>需要获得或设置实例域的值，应该提供下面三项内容：
<ul>
<li>一个私有的数据域</li>
<li>一个公有的域访问器方法</li>
<li>一个公有的域更改器方法</li>
</ul>
</li>
<li>更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理</li>
<li>注意<mark>不要编写返回引用可变对象的访问器方法</mark>
<ul>
<li>如果<mark>需要返回一个可变对象的引用，应该首先对它进行克隆(clone)</mark>
<ul>
<li>对象clone是指存放在另一个位置上的对象副本。</li>
<li>Date类存在更改器方法setTime,因此Date对象是可变的，破坏了封装性</li>
<li>如需要使用Date类，返回时返回Date类的clone对象（使用clone方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="437-基于类的访问权限"><a class="markdownIt-Anchor" href="#437-基于类的访问权限"></a> 4.3.7 基于类的访问权限</h3>
<ul>
<li>一个方法可以访问所属类的所有对象的私有数据</li>
</ul>
<h3 id="438-私有方法"><a class="markdownIt-Anchor" href="#438-私有方法"></a> 4.3.8 私有方法</h3>
<ul>
<li>在Java中，为了实现一个私有的方法，只需将关键字public改为private即可</li>
<li>对于私有方法，如果改用其他方法实现相应的操作，则不必保留原有的方法</li>
</ul>
<h3 id="439-final实例域"><a class="markdownIt-Anchor" href="#439-final实例域"></a> 4.3.9 final实例域</h3>
<ul>
<li>将实例域定义为final，<mark>构建对象时必须初始化这样的域</mark>
<ul>
<li>即必须确保在每一个构造器执行之后，这个域的值被设置，并且值不能改变</li>
</ul>
</li>
<li>final修饰符大都应用于基本类型域或不可变类的域</li>
<li>对于<mark>可变的类，使用final修饰符表示对象引用不会指向其他对象，但对象是可以改变的</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;  </span><br><span class="line">    <span class="comment">//instance fields  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;  </span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//final关键字只是表示存储在evaluations变量中的对象引用不会再指示其他StringBuilder对象</span></span><br><span class="line"><span class="comment">//不过这个对象可以更改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringBuilder evaluations; </span><br><span class="line">evaluations = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">//构造器中初始化操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveColdStar</span><span class="params">()</span>  <span class="comment">//但可以修改该对象的值</span></span><br><span class="line">&#123;</span><br><span class="line"> evaluations.append(LocalDate.nowO + <span class="string">&quot;: Cold star!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="44-静态域与静态方法"><a class="markdownIt-Anchor" href="#44-静态域与静态方法"></a> 4.4 静态域与静态方法</h2>
<h3 id="441-静态域"><a class="markdownIt-Anchor" href="#441-静态域"></a> 4.4.1 静态域</h3>
<ul>
<li><mark>如果将域定义为static，每个类中只有一个这样的域</mark></li>
<li>每一个对象对于所有的实例域却都有自己的一份拷贝</li>
<li><mark>静态域属于类而不属于任何独立的对象，所有该类的对象共享一个静态域</mark></li>
</ul>
<h3 id="442-静态常量"><a class="markdownIt-Anchor" href="#442-静态常量"></a> 4.4.2 静态常量</h3>
<ul>
<li>在常量的声明中,添加关键词static表示静态常量
<ul>
<li>如Math类，若<mark>关键字static被省略，PI就变成了Math类的一个实例域</mark></li>
<li>需要通过Math类的对象访问PI，并且每一个Math对象都有它自己的一份PI拷贝</li>
</ul>
</li>
<li>由于<mark>每个类对象都可以对公有域进行修改，所以，最好不要将域设计为public</mark>.然而，公有常量(即final域)却没问题
<ul>
<li>静态常量System.out,out被声明为final,故不允许再将其他打印流赋给它</li>
<li>System类有一个setOut方法可以将System.out设置为不同的流</li>
<li>==为什么这个方法可以修改final变量的值?
<ul>
<li><mark>原因在于，setOut方法是一个</mark>本地方法，而不是用Java语言实现的==,可以绕过Java语言的存取控制机制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="443-静态方法"><a class="markdownIt-Anchor" href="#443-静态方法"></a> 4.4.3 静态方法</h3>
<ul>
<li>静态方法是一种<mark>不能向对象实施操作的方法</mark>
<ul>
<li><mark>静态方法是没有this参数的方法</mark>(在一个非静态的方法中，this参数表示这个方法的隐式参数</li>
<li><mark>建议使用类名，而不是对象来调用静态方法</mark>,可以使用对象名进行调用静态方法</li>
</ul>
</li>
</ul>
<p>在下面两种情况下使用静态方法：</p>
<ul>
<li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供(例如：Math.pow)。</li>
<li>一个方法只需要访问类的静态域(例如：Employee.getNextId)</li>
</ul>
<h3 id="444-工厂方法"><a class="markdownIt-Anchor" href="#444-工厂方法"></a> 4.4.4 工厂方法</h3>
<ul>
<li>工厂方法用于生成不同风格的格式化对象(静态方法的另一种用途[静态工厂方法])</li>
<li>为什么NumberFormat类不利用构造器完成构建对象操作</li>
<li>原因：
<ul>
<li>无法命名构造器。构造器的名字必须与类名相同。但是，这里希望将得到的货币实例和百分比实例采用不用的名字</li>
<li>当使用构造器时，无法改变所构造的对象类型。而工厂方法将返回一个DecimalFormat类对象，这是NumberFormat的子类</li>
</ul>
</li>
</ul>
<h3 id="445-main方法"><a class="markdownIt-Anchor" href="#445-main方法"></a> 4.4.5 main方法</h3>
<ul>
<li>main方法不对任何对象进行操作
<ul>
<li>事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。</li>
</ul>
</li>
<li>每一个类可以有一个main方法(<mark>常用于对类进行单元测试</mark>)</li>
</ul>
</div><div class="story post-story"><h2 id="45-方法参数"><a class="markdownIt-Anchor" href="#45-方法参数"></a> 4.5 方法参数</h2>
<ul>
<li>Java程序设计语言总是采用<mark>按值调用</mark></li>
<li>方法得到的是所有参数值的一个拷贝,<mark>方法不能修改传递给它的任何参数变量的内容</mark></li>
<li>方法可以通过对象引用的拷贝修改所引用的对象状态</li>
</ul>
<p>总结一下Java中方法参数的使用情况：</p>
<ul>
<li>一个方法<mark>不能修改一个基本数据类型的参数(即数值型或布尔型)</mark></li>
<li>一个方法<mark>可以改变一个对象参数的状态</mark></li>
<li>一个方法<mark>不能让对象参数引用一个新的对象</mark></li>
</ul>
</div><div class="story post-story"><h2 id="46-对象构造"><a class="markdownIt-Anchor" href="#46-对象构造"></a> 4.6 对象构造</h2>
<h3 id="461-重载"><a class="markdownIt-Anchor" href="#461-重载"></a> 4.6.1 重载</h3>
<ul>
<li>如果多个方法有相同的名字、不同的参数，便产生了<mark>重载</mark>
<ul>
<li>重载解析:编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法;如果编译器找不到匹配的参数，就会产生编译时错误</li>
</ul>
</li>
<li>Java允许重载任何方法(包括构造器方法)</li>
<li>方法的签名:<mark>方法名以及参数类型</mark></li>
</ul>
<h3 id="462-默认域初始化"><a class="markdownIt-Anchor" href="#462-默认域初始化"></a> 4.6.2 默认域初始化</h3>
<ul>
<li>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值
<ul>
<li>数值为0</li>
<li>布尔值为false</li>
<li>对象引用为null</li>
</ul>
</li>
</ul>
<h3 id="463-无参数的构造器"><a class="markdownIt-Anchor" href="#463-无参数的构造器"></a> 4.6.3 无参数的构造器</h3>
<ul>
<li>对象由无参数构造函数创建时，其状态会设置为适当的默认值</li>
<li>如果类<mark>提供了至少一个构造器，但是没有提供无参数构造器</mark>，在构造对象时必须提供参数</li>
<li><mark>仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器</mark></li>
</ul>
<h3 id="464-显式域初始化"><a class="markdownIt-Anchor" href="#464-显式域初始化"></a> 4.6.4 显式域初始化</h3>
<ul>
<li>可以在类定义中，直接将一个值赋给任何域</li>
<li>初始值不一定是常量值</li>
</ul>
<h3 id="465-参数名"><a class="markdownIt-Anchor" href="#465-参数名"></a> 4.6.5 参数名</h3>
<ul>
<li><mark>参数变量用同样的名字将实例域屏蔽起来</mark>
<ul>
<li>例如，如果将参数命名为salary，salary将引用这个参数，而不是实例域</li>
<li>但是，可以采用this.salary的形式访问实例域</li>
</ul>
</li>
<li><mark>this指示隐式参数，也就是所构造的对象</mark></li>
</ul>
<h3 id="466-调用另一个构造器"><a class="markdownIt-Anchor" href="#466-调用另一个构造器"></a> 4.6.6 调用另一个构造器</h3>
<ul>
<li>如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span> <span class="params">(<span class="type">double</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// calls Employee(String, double)</span></span><br><span class="line"> <span class="built_in">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextId, s);  <span class="comment">//调用Employee(String, double) 构造器</span></span><br><span class="line"> nextId++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="467-初始化块"><a class="markdownIt-Anchor" href="#467-初始化块"></a> 4.6.7 初始化块</h3>
<p>初始化数据块的方法：</p>
<ul>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
<li>初始化代码块：只要构造类的对象，这些块就会执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> nextId;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//初始化代码块</span></span><br><span class="line"> &#123;</span><br><span class="line">  id = nextId;</span><br><span class="line">  nextId++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">double</span> s)</span></span><br><span class="line"> &#123;</span><br><span class="line">  name = n;</span><br><span class="line">  salary = s;</span><br><span class="line"> &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通常会直接将初始化代码放在构造器中</li>
<li>调用构造器的具体处理步骤：
<ol>
<li>所有数据域被初始化为默认值(0、false或null)</li>
<li>按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行这个构造器的主体</li>
</ol>
</li>
</ul>
<h3 id="468-对象析构与finalize方法"><a class="markdownIt-Anchor" href="#468-对象析构与finalize方法"></a> 4.6.8 对象析构与finalize方法</h3>
<ul>
<li>由于Java有自动的垃圾回收器，不需要人工回收内存，所以<mark>Java不支持析构器</mark></li>
<li>可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源
<ul>
<li>有个名为System.runFinalizersOnExit(true)的方法能够确保finalizer方法在Java关闭前被调用。不过，<mark>这个方法并不安全，也不鼓励使用</mark></li>
<li>有一种代替的方法是使用方法Runtime.addShutdownHook添加“关闭钩”(shutdown hook)</li>
</ul>
</li>
<li><mark>对象用完时，可以应用一个close方法来完成相应的清理操作</mark></li>
</ul>
</div><div class="story post-story"><h2 id="47-包"><a class="markdownIt-Anchor" href="#47-包"></a> 4.7 包</h2>
<ul>
<li><mark>使用包的主要原因是确保类名的唯一性</mark></li>
<li>一个类可以使用所属包中的所有类，以及其他包中的公有类</li>
<li>访问方法
<ol>
<li>在每个类名之前添加完整的包名</li>
<li>使用import语句：import语句应该位于源文件的顶部(但位于package语句的后面)</li>
</ol>
</li>
<li>import语句不仅可以导入类，还可以导入静态方法和静态域</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前</span></span><br><span class="line"><span class="keyword">package</span> com.horstmann.corejava;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><mark>编译器对文件(带有文件分隔符和扩展名.java的文件)进行操作</mark></li>
<li><mark>而Java解释器加载类(带有.分隔符)</mark></li>
</ul>
</div><div class="story post-story"><h2 id="48-类路径"><a class="markdownIt-Anchor" href="#48-类路径"></a> 4.8 类路径</h2>
<ul>
<li>类存储在文件系统的子目录中
<ul>
<li>类的路径必须与包名匹配</li>
</ul>
</li>
<li>类文件也可以存储在JAR(Java归档)文件中
<ul>
<li>在一个JAR文件中，可以包含多个压缩形式的类文件和子目录，这样既可以节省又可以改善性能</li>
<li>在程序中用到第三方(third-party)的库文件时，通常会给出一个或多个需要包含的JAR文件。</li>
</ul>
</li>
<li>为了使类能够被多个程序共享，需要做到下面几点
<ol>
<li>把类放到一个目录中，需要注意，<mark>这个目录是包树状结构的基目录</mark>
<ul>
<li>如果希望将com.horstmann.corejava.Employee类添加到其中，这个Employee.class类文件就必须位于子目录/home/user/classdir/com/horstmann/corejava中</li>
</ul>
</li>
<li>将JAR文件放在一个目录中</li>
<li>设置类路径(类路径是所有包含类文件的路径的集合)</li>
</ol>
</li>
<li>最好采用-classpath(或-cp)选项指定类路径</li>
</ul>
</div><div class="story post-story"><h2 id="49-文档注释"><a class="markdownIt-Anchor" href="#49-文档注释"></a> 4.9 文档注释</h2>
<ul>
<li>javadoc实用程序从下面几个特性中抽取信息，并编写注释
<ul>
<li>包</li>
<li>公有类与接口</li>
<li>公有的和受保护的构造器及方法</li>
<li>公有的和受保护的域</li>
</ul>
</li>
<li>注释应该放置在所描述特性的前面,以/**开始，并以*/结束</li>
<li>标记由@开始
<ul>
<li>用于强调的＜em＞…＜/em＞</li>
<li>用于着重强调的＜strong＞…＜/strong＞以及包含图像的＜img…＞</li>
<li>不过，一定不要使用＜h1＞或＜hr＞，因为它们会与文档的格式产生冲突;<mark>若要键入等宽代码，需使用{@code…}</mark></li>
</ul>
</li>
<li>如果文档中有<mark>到其他文件的链接</mark>，就应该将这些文件放到<mark>子目录doc-files中</mark></li>
<li>javadoc实用程序<mark>将从源目录拷贝这些目录及其中的文件到文档目录中</mark>。<mark>在链接中需要使用doc-files目录</mark>，例如：＜img src=“doc-files/uml.png”alt=“UML diagram”＞</li>
</ul>
<h3 id="493-方法注释"><a class="markdownIt-Anchor" href="#493-方法注释"></a> 4.9.3 方法注释</h3>
<ul>
<li>每一个方法注释必须放在所描述的方法之前</li>
<li>除了通用标记之外，还可以使用下面的标记：
<ul>
<li>@param变量描述：这个标记将对当前方法的“param”(参数)部分添加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有@param标记必须放在一起。</li>
<li>@return描述：这个标记将对当前方法添加“return”(返回)部分。这个描述可以跨越多行，并可以使用HTML标记。</li>
<li>@throws类描述：这个标记将添加一个注释，用于表示这个方法有可能抛出异常。</li>
</ul>
</li>
<li>@version文本：这个标记将产生一个“version”(版本)条目(通用注释)</li>
</ul>
<h3 id="496-包与概述注释"><a class="markdownIt-Anchor" href="#496-包与概述注释"></a> 4.9.6 包与概述注释</h3>
<ul>
<li>可以直接将类、方法和变量的注释放置在Java源文件中，只要用/**…*/文档注释界定就可以了</li>
<li><mark>要想产生包注释，就需要在每一个包目录中添加一个单独的文件</mark>
<ol>
<li>提供一个以package.html命名的HTML文件: 在标记＜body＞…＜/body＞之间的所有文本都会被抽取出来</li>
<li>提供一个以package-info.java命名的Java文件: 文件必须包含一个初始的以/**和*/界定的Javadoc注释，跟随在一个包语句之后。它不应该包含更多的代码或注释</li>
</ol>
</li>
</ul>
<h3 id="497-注释的抽取"><a class="markdownIt-Anchor" href="#497-注释的抽取"></a> 4.9.7 注释的抽取</h3>
<ul>
<li>注释的抽取步骤：
<ol>
<li>切换到包含想要生成文档的源文件目录
<ul>
<li>如果有嵌套的包要生成文档，例如com.horstmann.corejava，就必须切换到包含子目录com的目录(如果存在overview.html文件的话，这也是它的所在目录)</li>
</ul>
</li>
<li>如果是一个包，应该运行命令：javadoc -d docDirectory nameOfPackage;对于多个包生成文档，运行：javadoc -d docDirectory nameOfPackage1 nameOfPackage2 …;如果文件在默认包中，就应该运行：javadoc -d docDirectory *.java</li>
</ol>
</li>
</ul>
</div><div class="story post-story"><h2 id="410-类设计技巧"><a class="markdownIt-Anchor" href="#410-类设计技巧"></a> 4.10 类设计技巧</h2>
<ol>
<li>一定要保证数据私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本类型</li>
<li>不是所有的域都需要独立的域访问器和域更改器</li>
<li>将职责过多的类进行分解</li>
<li>类名和方法名要能够体现它们的职责</li>
<li>优先使用不可变的类</li>
</ol>
<hr />
<h1 id="5-继承"><a class="markdownIt-Anchor" href="#5-继承"></a> 5 继承</h1>
<ul>
<li><mark>继承已存在的类就是复用(继承)这些类的方法和域，在此基础上，还可以添加一些新的方法和域，以满足新的需求</mark></li>
<li>反射是指在程序运行期间发现更多的类及其属性的能力</li>
</ul>
</div><div class="story post-story"><h2 id="51-类-超类和子类"><a class="markdownIt-Anchor" href="#51-类-超类和子类"></a> 5.1 类、超类和子类</h2>
<h3 id="511-定义子类"><a class="markdownIt-Anchor" href="#511-定义子类"></a> 5.1.1 定义子类</h3>
<ul>
<li>关键字extends表示继承</li>
<li>关键字extends表明正在构造的新类派生于一个已存在的类</li>
<li>已存在的类称为超类、基类或父类;新类称为子类、派生类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Manager继承Employee类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line"> 添加方法和域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="513-子类构造器"><a class="markdownIt-Anchor" href="#513-子类构造器"></a> 5.1.3 子类构造器</h3>
<ul>
<li>覆盖方法：提供一个与超类方法同名的方法进行覆盖
<ul>
<li>在子类中可以增加域、增加方法或覆盖超类的方法，<mark>绝对不能删除继承的任何域和方法</mark></li>
</ul>
</li>
<li>可以使用<mark>super</mark>关键字调用超类
<ul>
<li><mark>super与this的区别</mark>
<ul>
<li>super只是指示编译器调用超类方法的特殊关键字,不是一个对象的引用,不能将super赋给另一个对象变量</li>
<li>this关键字有两个用途:(1)引用隐式参数 (2)调用该类其他的构造器</li>
<li>super关键字两个用途:(1)调用超类的方法 (2)调用超类的构造器</li>
</ul>
</li>
</ul>
</li>
<li><mark>调用构造器的语句只能作为另一个构造器的第一条语句出现</mark>,使用super调用超类构造器的语句必须是子类构造器的第一条语句
<ul>
<li>如果子类的构造器<mark>没有显式地调用超类的构造器</mark>，则将<mark>自动地调用超类默认(没有参数)的构造器</mark></li>
</ul>
</li>
<li>构造参数既可以传递给本类(this)的其他构造器,也可以传递给超类(super)的构造器</li>
<li>在Java中，虚拟机<mark>知道对象实际引用的对象类型，能够正确地调用相应的方法</mark>
<ul>
<li><mark>多态</mark>:一个对象变量可以指示多种实际类型的现象</li>
<li><mark>动态绑定</mark>:在运行时能够自动地选择调用哪个方法的现象</li>
</ul>
</li>
<li>在Java中，不需要将方法声明为虚拟方法,动态绑定是默认的处理方式.<mark>如果不希望让一个方法具有虚拟特征，可以将它标记为final</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Manager子类的构造器方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">double</span> salary, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//由于Manager类的构造器不能访问Employee类的私有域，所以必须利用Employee类的构造器对这部分私有域进行初始化</span></span><br><span class="line"> <span class="built_in">super</span>(name, salary, year, month, day);</span><br><span class="line"> bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="type">Manger</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manger</span>(<span class="string">&quot;Carl&quot;</span>, <span class="number">8000</span>, <span class="number">1987</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line">boss.setBonus(<span class="number">5000</span>);</span><br><span class="line">staff[<span class="number">0</span>] = boss;</span><br><span class="line">staff[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry&quot;</span>, <span class="number">5000</span>, <span class="number">1989</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">staff[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Tony&quot;</span>, <span class="number">4000</span>, <span class="number">1990</span>, <span class="number">3</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">for</span>(Employee e : staff)</span><br><span class="line"> System.out.println(e.getSalary());</span><br><span class="line"><span class="comment">//对staff[0]，其为Manger类对象，调用的为Manger类的getSalary方法</span></span><br><span class="line"><span class="comment">//对staff[1]，其为Employee类对象，调用的为Employee类的getSalary方法</span></span><br></pre></td></tr></table></figure>
<h3 id="514-继承层次"><a class="markdownIt-Anchor" href="#514-继承层次"></a> 5.1.4 继承层次</h3>
<ul>
<li><mark>继承层次</mark>：由一个公共超类派生出来的所有类的集合
<ul>
<li>继承并不仅限于一个层次，可以由子类再次派生出其他类</li>
</ul>
</li>
<li>在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链</li>
<li><mark>Java不支持多继承</mark>(但可以利用<a href="#61-%E6%8E%A5%E5%8F%A3">接口</a>实现)</li>
</ul>
<h3 id="515-多态"><a class="markdownIt-Anchor" href="#515-多态"></a> 5.1.5 多态</h3>
<ul>
<li><mark>不能将一个超类的引用赋给子类变量</mark></li>
<li>在Java中，<mark>子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换</mark>
<ul>
<li><mark>需要注意子类数组的引用与超类数组的引用，引用同一个对象时，调用子类的方法可能调用一个不存在的实例域</mark></li>
<li>为了确保不发生这类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中</li>
</ul>
</li>
<li>判断是否可以设计为继承关系的简单规则
<ul>
<li>“is-a”规则:<mark>表明子类的每个对象也是超类的对象</mark></li>
<li><mark>置换法则</mark>:程序中出现超类对象的任何地方都可以用子类对象置换</li>
</ul>
</li>
<li>在Java程序设计语言中，<mark>对象变量是<a href="#513-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8">多态</a>的</mark>
<ul>
<li>一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类的任何一个子类的对象</li>
</ul>
</li>
</ul>
<h3 id="516-理解方法调用"><a class="markdownIt-Anchor" href="#516-理解方法调用"></a> 5.1.6 理解方法调用</h3>
<ul>
<li>方法调用流程:
<ol>
<li>编译器查看对象的声明类型和方法名。编译器获得所有可能被调用的候选方法</li>
<li>编译器将查看调用方法时提供的参数类型。编译器已获得需要调用的方法名字和参数类型</li>
<li>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法(静态绑定)。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定</li>
<li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与所引用对象的实际类型最合适的那个类的方法</li>
</ol>
</li>
<li>在运行时，调用e.getSalary()的解析过程为：
<ol>
<li>虚拟机提取e的实际类型的方法表。既可能是Employee、Manager的方法表，也可能是Employee类的其他子类的方法表</li>
<li>虚拟机搜索定义getSalary签名的类,虚拟机已经知道应该调用哪个方法</li>
<li>虚拟机调用方法</li>
</ol>
</li>
<li>动态绑定有一个非常重要的特性：<mark>无需对现存的代码进行修改，就可以对程序进行扩展</mark>
<ul>
<li>假设增加一个新类Executive，并且变量e有可能引用这个类的对象，我们不需要对包含调用e.getSalary()的代码进行重新编译</li>
<li>如果e恰好引用一个Executive类的对象，就会自动地调用Executive.getSalary()方法</li>
</ul>
</li>
<li>在覆盖一个方法的时候，<mark>子类方法不能低于超类方法的可见性</mark>
<ul>
<li><mark>特别是，如果超类方法是public，子类方法一定要声明为public</mark></li>
</ul>
</li>
</ul>
<h3 id="517-组织继承final类和方法"><a class="markdownIt-Anchor" href="#517-组织继承final类和方法"></a> 5.1.7 组织继承:final类和方法</h3>
<ul>
<li><mark>不允许扩展的类被称为final类</mark>,用于阻止利用该类定义子类
<ul>
<li>在定义类的时候使用final修饰符就表明这个类是final类,该类不可以被继承</li>
</ul>
</li>
<li>类中的方法也可以被声明为final
<ul>
<li><mark>子类不能覆盖该方法</mark></li>
<li>final类，只有<mark>其中的方法自动转换为final,域不进行转换</mark></li>
<li>声明final域 (<a href="#439-final%E5%AE%9E%E4%BE%8B%E5%9F%9F">final域</a>在构造对象之后不允许被改变)</li>
</ul>
</li>
</ul>
<h3 id="518-强制类型转换"><a class="markdownIt-Anchor" href="#518-强制类型转换"></a> 5.1.8 强制类型转换</h3>
<p><a href="#353-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">跳转至强制类型转换</a></p>
<ul>
<li>将某个类的对象引用转换成另外一个类的对象引用
<ul>
<li>仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前(与数值类型转换类似)</li>
</ul>
</li>
<li>进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能</li>
<li>在Java中，<mark>每个对象变量都属于一个类型</mark>(类型描述了这个变量所引用的以及能够引用的对象类型)</li>
<li>将一个值存入变量时，编译器将检查是否允许该操作
<ul>
<li>子类的引用赋给超类变量，编译器允许</li>
<li>超类的引用赋给子类变量，必须进行类型转换(为通过运行时的检查)
<ul>
<li><mark>只能在继承层次内进行类型转换</mark></li>
<li>在<strong>超类转换成子类之前</strong>，<mark>使用instanceof操作符查看一下是否能够成功地转换</mark></li>
</ul>
</li>
</ul>
</li>
<li>实际上，通过类型转换调整对象类型并不是好的做法(因为<mark>多态性的动态绑定机制能够自动地找到相应的方法</mark>)
<ul>
<li>只有在使用Manager中特有的方法时才需要进行类型转换</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(staff[<span class="number">1</span>] <span class="keyword">instanceof</span> manager)</span><br><span class="line">&#123;</span><br><span class="line">   boss = (Manager) staff[<span class="number">1</span>];</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="519-抽象类"><a class="markdownIt-Anchor" href="#519-抽象类"></a> 5.1.9 抽象类</h3>
<ul>
<li>建议将通用的域和方法放在超类中</li>
<li>抽象方法充当着占位的角色，<mark>具体的实现在子类中</mark></li>
<li>扩展抽象类可以有两种选择：
<ul>
<li>一种是在抽象类中定义部分抽象类方法或不定义抽象类方法</li>
<li>另一种是定义全部的抽象方法</li>
</ul>
</li>
<li><mark>抽象类不能被实例化</mark>
<ul>
<li><mark>不能创建abstract类的对象</mark></li>
<li><mark>可以定义一个抽象类的对象变量，但是<strong>只能引用非抽象子类的对象</strong></mark></li>
</ul>
</li>
<li>在<mark>接口中大量使用抽象方法</mark></li>
<li>在抽象类定义的抽象方法
<ul>
<li>若在超类中不定义该方法，则<mark>不可以通过抽象类对象变量调用类的方法</mark></li>
<li>若超类定义了该方法，则<mark>可以通过抽象类的对象变量调用超类的方法</mark></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用abstract关键字不需要实现方法</span></span><br><span class="line"><span class="comment">//包含一个或多个抽象方法的类本身必须声明为抽象abstract的</span></span><br><span class="line"><span class="comment">//抽象类Person</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5110-受保护访问"><a class="markdownIt-Anchor" href="#5110-受保护访问"></a> 5.1.10 受保护访问</h3>
<ul>
<li>4个访问修饰符
<ul>
<li>仅对本类可见——private</li>
<li>对所有类可见——public</li>
<li>对本包和所有子类可见——protected</li>
<li>对本包可见——默认，不需要修饰符</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="52-object所有类的超类"><a class="markdownIt-Anchor" href="#52-object所有类的超类"></a> 5.2 Object：所有类的超类</h2>
<ul>
<li><mark>Object类是Java中所有类的始祖(每个类都是由它扩展而来的)</mark></li>
<li><mark>在Java中，只有基本类型不是对象</mark></li>
</ul>
<h3 id="521-2-equals方法_相等测试与继承"><a class="markdownIt-Anchor" href="#521-2-equals方法_相等测试与继承"></a> 5.2.1-2 equals方法_相等测试与继承</h3>
<ul>
<li>Object类中的equals方法用于检测一个对象是否等于另外一个对象</li>
<li>在Object类中，equals方法将判断两个对象是否具有相同的引用(如果两个对象具有相同的引用，它们一定是相等的),但该方法没有实际意义,需要在自己的类中重写该方法</li>
<li>getClass()方法将返回一个对象所属的类,其进行相等检测的思考
<ul>
<li>如果<mark>子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测</mark></li>
<li>如果<mark>由超类决定相等的概念，那么就可以使用instanceof进行检测</mark>，这样可以在不同子类的对象之间进行相等的比较</li>
</ul>
</li>
<li>隐式参数和显示参数不属于同一个类，如何进行比较？
<ul>
<li><mark>使用equals方法，类不匹配则不相同</mark></li>
<li><s>若使用instanceof进行检测(if(!(otherObject instanceof Employee)) return false;)<mark>不能解决otherObject是子类的问题，且还会带来新的麻烦</mark></s></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超类Employee的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.getClass() != otherObject.getClass())   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) otherObject;</span><br><span class="line">      <span class="keyword">return</span> Objects.equals(name,other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay,other.hireDay);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在子类中定义equals方法时，首先调用超类的equals==</span></span><br><span class="line"><span class="comment">//如果检测失败，对象就不可能相等</span></span><br><span class="line"><span class="comment">//如果超类中的域都相等，就需要比较子类中的实例域</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> bonus;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">super</span>.equals(otherObject)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="type">Manager</span> <span class="variable">other</span> <span class="operator">=</span> (Manager) otherObject;</span><br><span class="line">      <span class="keyword">return</span> bonus == other.bonus;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>语言规范要求equals方法应具有的特性
<ol>
<li><strong>自反性</strong>：对于任何非空引用x，x.equals(x)应该返回true</li>
<li><strong>对称性</strong>：对于任何引用x和y，当且仅当y.equals(x)返回true，x.equals(y)也应该返回true</li>
<li><strong>传递性</strong>：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true</li>
<li><strong>一致性</strong>：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果</li>
<li><strong>对于任意非空引用x，x.equals(null)应该返回false</strong></li>
</ol>
</li>
<li>完美equals方法的建议
<ol>
<li>显式参数命名为otherObject(稍后需要类型转换)</li>
<li>检测this与otherObject是否引用同一个对象:(if(this == otherObject) return true;)实际上，这是一种经常采用的形式。因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多</li>
<li><mark>检测otherObject是否为null，如果为null，返回false(必要)</mark></li>
<li>比较this与otherObject是否属于同一个类
<ul>
<li>如果equals的语义在每个子类中有所改变，就使用getClass检测</li>
<li>如果所有的子类都拥有统一的语义，就使用instanceof检测</li>
</ul>
</li>
<li><mark>将otherObject转换为相应的类类型变量</mark></li>
<li>现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true；否则返回false</li>
</ol>
</li>
</ul>
<h3 id="523-hashcode方法"><a class="markdownIt-Anchor" href="#523-hashcode方法"></a> 5.2.3 hashCode方法</h3>
<ul>
<li>散列码是由对象导出的一个整型值:
<ul>
<li>散列码没有规律(如果x和y是两个不同的对象,x.hashCode()与y.hashCode()基本上不会相同)</li>
<li>在<mark>String类中，可以使用hashCode()方法获取散列码</mark></li>
<li>hashCode方法<mark>定义在Object类</mark>中，<mark>每个对象都有一个默认的散列码，其值为对象的存储地址</mark></li>
</ul>
</li>
<li><mark>若重新定义equals方法，必须重新定义hashCode方法，以便将对象插入到散列表中</mark>
<ul>
<li><mark>Equals与hashCode的定义必须一致(如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()具有相同的值)</mark></li>
</ul>
</li>
<li>hashCode方法应该返回一个整型数值(也可以是负数)，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。</li>
<li>定义hashCode方法的注意事项：
<ul>
<li>最好使用null安全的方法Objects.hashCode
<ul>
<li>如果其参数为null，其结果为0</li>
</ul>
</li>
<li>使用静态的Double.hashCode方法类避免创建Double对象</li>
<li><mark>组合多个散列值，可以使用Objects.hash并提供多个参数</mark>
<ul>
<li>该方法会对各个参数调用Objects.hashCode，并组合这些散列值</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Employee类的hashCode方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">7</span>*name.hashCode()</span><br><span class="line">    + <span class="number">11</span>*<span class="keyword">new</span> <span class="title class_">Double</span>(salary).hashCode()</span><br><span class="line">    + <span class="number">13</span>*hireDay.hashCode();</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee类的优化hashCode方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> Object.hash(name, salary, hireDay);</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="524-tostring方法"><a class="markdownIt-Anchor" href="#524-tostring方法"></a> 5.2.4 toString方法</h3>
<ul>
<li>在Object中toString方法，用于返回表示对象值的字符串
<ul>
<li><mark>绝大多数的toString方法都采用的格式：类的名字，随后是一对方括号括起来的域值</mark></li>
<li><mark>Object类定义了toString方法，用来打印输出对象所属的类名和散列码</mark></li>
</ul>
</li>
<li>子类需要定义自己的toString方法，并将子类域的描述添加进去
<ul>
<li>如果超类使用了getClass().getName()，那么子类只要调用super.toString()</li>
<li>随处可见toString方法的主要原因（<mark>只要对象与一个字符串通过操作符“+”连接</mark>起来，Java编译就会<mark>自动地调用toString方法，以便获得这个对象的字符串描述</mark>）</li>
</ul>
</li>
<li>数组继承了object类的toString方法，数组按照旧的格式打印
<ul>
<li>使用<mark>静态方法Arrays.toString</mark>可以获得数组字符串
<ul>
<li><mark>多维数组使用Arrays.deepToString方法</mark></li>
</ul>
</li>
</ul>
</li>
<li>可以使用该toString方法进行调试信息输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Employee类的toString方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//使用getClass.getName方法获得类名的字符串</span></span><br><span class="line">  <span class="keyword">return</span> getClass.getName()</span><br><span class="line">      + <span class="string">&quot;[name=&quot;</span> + name</span><br><span class="line">      + <span class="string">&quot;,salary=&quot;</span> + salary</span><br><span class="line">      + <span class="string">&quot;hireDay=&quot;</span> + hireDay</span><br><span class="line">      + <span class="string">&quot;]&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出java.io.PrintStream@2f6684</span></span><br><span class="line"><span class="comment">//PrintStream类没有覆盖toString方法</span></span><br><span class="line">System.out.println(System.out);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印调试信息的方法:使用Logger.global.info方法</span></span><br><span class="line"><span class="comment">//需要结合日志使用</span></span><br><span class="line">Logger.global.info(<span class="string">&quot;Current position = &quot;</span> + position);</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="53-泛型数组列表"><a class="markdownIt-Anchor" href="#53-泛型数组列表"></a> 5.3 泛型数组列表</h2>
<ul>
<li>Java支持<mark>数组在运行时确定数组的大小</mark>，即将一个变量赋值给数组大小</li>
<li>Java具有ArrayList的类
<ul>
<li>类似数组，但在添加或删除元素时，具有自动调节数组容量的功能</li>
<li>ArrayList是一个<mark>采用类型参数的泛型类</mark></li>
<li>为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面(ArrayList&lt;Employee&gt;)</li>
</ul>
</li>
<li><mark>数组列表的容量与数组的大小有一个非常重要的区别</mark>
<ul>
<li>如果为数组分配100个元素的存储空间，数组就有100个空位置可以使用</li>
<li>容量为100个元素的数组列表只是拥有保存100个元素的潜力(实际上，重新分配空间的话，将会超过100)</li>
<li>但是在最初，甚至完成初始化构造之后，数组列表根本就不含有任何元素</li>
</ul>
</li>
<li><mark>一旦能够确认数组列表的大小不再发生变化，就可以调用trimToSize方法(将存储区域的大小调整为当前元素数量所需要的存储空间数目)</mark>
<ul>
<li><mark>一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块(<strong>应该在确认不会添加任何元素时，再调用trimToSize</strong>)</mark></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明和构造保存Employee对象的数组列表</span></span><br><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line"><span class="comment">//在JavaSE7中，可以省略右边的类型参数</span></span><br><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用add方法将元素添加到数组列表中</span></span><br><span class="line"><span class="comment">//如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中</span></span><br><span class="line">staff.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry&quot;</span>,...));</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果已经清楚或能够估计出数组可能存储的元素数量</span></span><br><span class="line"><span class="comment">//在填充数组之前调用ensureCapacity方法</span></span><br><span class="line">staff.ensureCapacity(<span class="number">100</span>);  <span class="comment">//分配100个对象的内部数组</span></span><br><span class="line"><span class="comment">//可以将初始容量传递至ArrayList构造器</span></span><br><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//size方法返回数组列表中包含的实际元素数目</span></span><br><span class="line">staff.size();</span><br><span class="line"><span class="comment">//在数组列表的中间插入元素使用带参数的add方法</span></span><br><span class="line"><span class="comment">//为了插入一个新元素，位于n之后的所有元素都要向后移动一个位置</span></span><br><span class="line"><span class="comment">//如果插入新元素后，数组列表的大小超过了容量，数组列表就会被重新分配存储空间</span></span><br><span class="line">staff.add(n,<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry&quot;</span>,...));</span><br><span class="line"><span class="comment">//可以从数组列表中删除一个元素</span></span><br><span class="line"><span class="comment">//位于这个位置之后的所有元素都向前移动一个位置，并且数组的大小减1</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> staff.remove(n);</span><br></pre></td></tr></table></figure>
<h3 id="531-访问数组列表元素"><a class="markdownIt-Anchor" href="#531-访问数组列表元素"></a> 5.3.1 访问数组列表元素</h3>
<ul>
<li><mark>使用get和set方法</mark>实现访问或改变数组元素的操作
<ul>
<li>不使用[]语法格式进行索引元素</li>
</ul>
</li>
<li><mark>使用add方法为数组添加新元素，而不要使用set方法</mark>
<ul>
<li><mark>set方法只能替换数组中已经存在的元素内容</mark></li>
</ul>
</li>
<li>get方法可获得数组列表的元素
<ul>
<li><s>没有泛型类时，原始的ArrayList类的get方法只能返回Object，因此还需要对返回值进行类型转换</s></li>
<li>add方法和set方法允许接受任何类型对象</li>
</ul>
</li>
<li>对数组实施插入和删除元素的操作其<mark>效率比较低</mark>
<ul>
<li>对于小型数组来说，这一点不必担心</li>
<li><mark>但如果数组存储的元素数比较多，又经常需要在中间位置插入、删除元素，就应该考虑使用链表了</mark></li>
</ul>
</li>
</ul>
<h3 id="532-类型化与原始数组列表的兼容性"><a class="markdownIt-Anchor" href="#532-类型化与原始数组列表的兼容性"></a> 5.3.2 类型化与原始数组列表的兼容性</h3>
<ul>
<li>只要在与遗留的代码进行交叉操作时，研究一下编译器的警告性提示，并确保这些警告不会造成太严重的后果就行了。</li>
<li>一旦能确保不会造成严重的后果，可以用@SuppressWarnings(“unchecked”)标注来标记这个变量能够接受类型转换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot; unchecked&quot;)</span> ArrayList&lt;Employee&gt; result =</span><br><span class="line">(ArrayList&lt;Employee&gt;) emoloyeeDB.find(query); </span><br><span class="line"><span class="comment">// yields another warning</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="54-对象包装器与自动装箱"><a class="markdownIt-Anchor" href="#54-对象包装器与自动装箱"></a> 5.4 对象包装器与自动装箱</h2>
<ul>
<li><mark>所有的基本类型都有一个与之对应的类，这些类称为包装器</mark>
<ul>
<li>Integer,Long,Float,Double,Short,Byte,Character,Void和Boolean(前6个类派生于公共的超类Number)</li>
<li><mark>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值</mark></li>
<li><mark>对象包装器类还是final，不能定义它们的子类</mark></li>
</ul>
</li>
<li>由于每个值分别包装在对象中，<mark>ArrayList&lt;Integer&gt;的效率远远低于int[]数组</mark></li>
<li>自动装箱:
<ul>
<li>便于添加int类型的元素到ArrayList&lt;Integer&gt;中</li>
<li>要求boolean、byte、char≤127，介于-128~127之间的short和int被包装到固定的对象中</li>
</ul>
</li>
<li><mark>在算术表达式中也能够自动地装箱和拆箱</mark>
<ul>
<li>在自增自减操作中，编译器将自动地插入一条对象拆箱的指令，然后进行自增(自减)计算，最后再将结果装箱</li>
</ul>
</li>
<li>基本类型与它们的对象包装器是一样的，只是它们的相等性不同
<ul>
<li><mark>==运算符也可以应用于<strong>对象包装器对象</strong>，只不过检测的是对象是否指向同一个存储区域</mark></li>
<li><strong><mark>在两个包装器对象比较时调用equals方法</mark></strong></li>
</ul>
</li>
<li>自动装箱的问题说明：
<ul>
<li>由于包装器类引用可以为null，所以自动装箱有可能会抛出一个NullPointerException异常</li>
<li>如果在一个条件表达式中混合使用Integer和Double类型，Integer值就会拆箱，提升为double，再装箱为Double</li>
<li>使用数值对象包装器还有另外一个好处。Java设计者发现，可以将某些基本方法放置在包装器中，例如，将一个数字字符串转换成数值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动转换(自动装箱)</span></span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line">list.add(Integer.valueOf(<span class="number">3</span>));</span><br><span class="line"><span class="comment">//当将一个Integer对象赋给一个int值时(自动拆箱)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i);</span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i).intValue();</span><br><span class="line"><span class="comment">//将字符串转换为整数</span></span><br><span class="line"><span class="comment">//与Integer对象没有任何关系，parseInt是一个静态方法</span></span><br><span class="line"><span class="comment">//Integer类是放置这个方法的一个好地方</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(s);</span><br></pre></td></tr></table></figure>
<ul>
<li><mark>Integer对象是不可变的：包含在包装器中的内容不会改变</mark>
<ul>
<li><mark>不能使用这些包装器类创建修改数值参数的方法</mark></li>
</ul>
</li>
<li>如果想编写一个修改数值参数值的方法，就需要使用在org.omg.CORBA包中定义的<mark>持有者(holder)类型，包括IntHolder、BooleanHolder等。每个持有者类型都包含一个公有(！)域值，通过它可以访问存储在其中的值</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值传递，故x不会发生改变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">triple</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  x = <span class="number">3</span>*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Integer对象不可变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">triple</span><span class="params">(Integer x)</span></span><br><span class="line">&#123;</span><br><span class="line">  x = <span class="number">3</span>*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用IntHolder改变对象中的内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">triple</span><span class="params">(IntHolder x)</span></span><br><span class="line">&#123;</span><br><span class="line">  x.value = <span class="number">3</span>*x.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="55-参数数量可变的方法"><a class="markdownIt-Anchor" href="#55-参数数量可变的方法"></a> 5.5 参数数量可变的方法</h2>
<ul>
<li><mark>提供了可以用可变的参数数量调用的方法(变参方法),利用…符号表示参数数量可变</mark></li>
<li><mark>省略号…是Java代码的一部分，它表明这个方法可以接收任意数量的对象</mark></li>
<li>printf方法接收两个参数，一个是格式字符串，另一个是Object[]数组，其中保存着所有的参数
<ul>
<li>对于printf的实现者来说，Object…参数类型与Object[]完全一样</li>
<li>编译器需要对printf的每次调用进行转换，以便将参数绑定到数组上，并在必要的时候进行自动装箱</li>
</ul>
</li>
<li><mark>可以定义可变参数的方法，并将参数指定为任意类型，甚至是基本类型</mark></li>
<li><mark>允许将一个数组传递给可变参数方法的最后一个参数</mark>
<ul>
<li>可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt,Object... args)</span></span><br><span class="line">    <span class="keyword">return</span> format(fmt,args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="56-枚举类"><a class="markdownIt-Anchor" href="#56-枚举类"></a> 5.6 枚举类</h2>
<ul>
<li>比较两个枚举类型的值，<mark>不需要调用equals，而直接使用“==”就可以了</mark></li>
<li>可以在枚举类型中添加一些构造器、方法和域(构造器只是在构造枚举常量的时候被调用)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span></span><br><span class="line">&#123;</span><br><span class="line">  SMALL(<span class="string">&quot;S&quot;</span>)，MEDIUM(<span class="string">&quot;W&quot;</span>), LARGE(<span class="string">&quot;L&quot;</span>)，EXTRA_ <span class="title function_">LARGE</span><span class="params">(<span class="string">&quot;XL&quot;</span>)</span>;</span><br><span class="line">  <span class="keyword">private</span> String abbreviation;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String abbreviation)</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">this</span>.abbreviation = abbreviation;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getAbbreviation</span><span class="params">()</span> </span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">return</span> abbreviation;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所有的枚举类型都是Enum类的子类
<ul>
<li>继承了Enum类的许多方法
<ul>
<li><mark>其中最有用的一个是toString，这个方法能够返回枚举常量名</mark></li>
<li>toString的逆方法是静态方法valueOf</li>
<li>每个枚举类型都有一个静态的values方法，它将<mark>返回一个包含全部枚举值的数组</mark></li>
</ul>
</li>
<li>ordinal方法返回enum声明中枚举常量的位置，位置从0开始计数</li>
</ul>
</li>
<li><mark>同Class类一样，鉴于简化的考虑，Enum类省略了一个类型参数</mark>(实际上，应该将枚举类型Size扩展为Enum&lt;Size&gt;</li>
<li><strong>类型参数在compareTo方法中使用</strong>(<a href="#622-Comparator%E6%8E%A5%E5%8F%A3">compareTo方法</a> <a href="#8-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">类型参数</a>)</li>
</ul>
</div><div class="story post-story"><h2 id="57-反射"><a class="markdownIt-Anchor" href="#57-反射"></a> 5.7 反射</h2>
<ul>
<li>反射库提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵Java代码的程序</li>
<li>能够分析类能力的程序称为反射，反射机制可以用来：
<ol>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象，例如，编写一个toString方法供所有类使用</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象，这个对象很像C++中的函数指针</li>
</ol>
</li>
</ul>
<h3 id="571-class类"><a class="markdownIt-Anchor" href="#571-class类"></a> 5.7.1 Class类</h3>
<ul>
<li>在程序运行期间，系统始终为<strong>所有的对象</strong>维护一个运行时的类型标识，该标识的信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行</li>
<li><mark>可以通过专门的Java类访问这些信息(保存这些信息的类被称为Class)</mark></li>
<li>一个Class对象实际上<mark>表示的是一个类型，而这个类型未必一定是一种类</mark>，<mark>且Class类实际上是一种泛型类</mark></li>
<li>相关方法:
<ul>
<li>利用Object类中的getClass()方法获得Class类型的实例(获得class对象)</li>
<li><mark>T.class可获得匹配的类对象(T为任意的java类型)</mark>(获得class对象)
<ul>
<li>Class类的forName()方法可以获得类名对应的Class对象(全路径名)</li>
<li>Class类的getName()方法获得返回类的名字</li>
<li><mark>newInstance()方法可以创建一个类的实例</mark>
<ul>
<li><mark>配合forName()和newInstance()方法可以根据储存在字符串中的类名动态创建一个对象</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个Class对象将表示一个特定类的属性</span></span><br><span class="line"><span class="comment">//Object类中的getClass()方法会返回一个Class类型的实例</span></span><br><span class="line">Employee e;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> e.getClass();</span><br><span class="line"><span class="comment">//最常用的方法时getName，该方法将返回类的名字</span></span><br><span class="line"><span class="comment">//如果类在一个包中，则包的名字也作为类名的一部分</span></span><br><span class="line">System.out.println(e.getClass.getName);</span><br><span class="line"><span class="comment">//可以使用静态的forName方法获得类名对应的Class对象</span></span><br><span class="line"><span class="comment">//该方法只有在className是类名或者接口名时才能够执行</span></span><br><span class="line"><span class="comment">//若类名保存在字符串中，可以在运行中改变</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="comment">//可以使用T.class获得匹配的类对象（T为任意的java类型）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cl1</span> = Random.class;</span><br><span class="line"><span class="comment">//newInstance方法调用默认的构造器初始化新创建的对象(若该类没有默认的构造器，就会抛出checked exception异常)</span></span><br><span class="line"><span class="comment">//该方法创建一个与e具有相同类型的实例</span></span><br><span class="line">e.getClass.newInstance();</span><br><span class="line"><span class="comment">//可以将forName和newInstance配合起来使用，可以根据储存在字符串中的类名创建一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> Class.forName(s).newInstance();</span><br></pre></td></tr></table></figure>
<h3 id="572-捕获异常"><a class="markdownIt-Anchor" href="#572-捕获异常"></a> 5.7.2 捕获异常</h3>
<ul>
<li>异常有两种类型：
<ol>
<li>未检查异常</li>
<li>已检查异常
<ul>
<li>对于已检查异常，编译器将会检查是否提供了处理器</li>
<li>使用try_catch语句</li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将可能抛出已检查异常的一个或多个办法调用代码放在try块中</span></span><br><span class="line"><span class="comment">//在catch子句中提供处理器代码</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ...<span class="comment">// get class name</span></span><br><span class="line">  <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(name); <span class="comment">// might throw exception</span></span><br><span class="line">  <span class="keyword">do</span> something with cl</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">  e. printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果类名不存在，则将跳过try块中的剩余代码，程序直接进入catch子句</span></span><br></pre></td></tr></table></figure>
<h3 id="573-利用反射分析类的能力"><a class="markdownIt-Anchor" href="#573-利用反射分析类的能力"></a> 5.7.3 利用反射分析类的能力</h3>
<ul>
<li><mark>Class类中的getFields,getMethods和getConstructors方法分别返回类提供的public域,方法和构造器数组(包括超类的公有成员)</mark></li>
<li><mark>Class类的getDeclareFields,getDeclareMethods和getDeclaredConstructors方法分别返回类中声明的全部域、方法和构造器(包括私有和受保护成员,但不包括超类的成员)</mark></li>
<li>在java.lang.reflect包中有<mark>三个类Field,Method和Constructor分别用于描述类的域、方法和构造器</mark>
<ul>
<li><mark>Method和Constructor类有能够报告参数类型的方法，Method类还有一个可以报告返回类型的方法</mark></li>
<li>三个类都有<mark>getName方法(返回项目的名称)</mark></li>
<li>三个类都有<mark>getModifiers方法(返回整型数值，用不同的位开关描述public和static这样的修饰符使用状况)</mark>
<ul>
<li>可利用java.lang.reflect包中的<mark>Modifier类的静态方法分析getModifiers返回的整型数值</mark></li>
</ul>
</li>
<li><mark>Field类有getType方法(返回描述域所属类型的Class对象)</mark></li>
</ul>
</li>
</ul>
<h3 id="574-在运行时使用反射分析对象"><a class="markdownIt-Anchor" href="#574-在运行时使用反射分析对象"></a> 5.7.4 在运行时使用反射分析对象</h3>
<ul>
<li><mark>查看对象域的关键方法是Field类中的get方法</mark></li>
<li><mark>只有利用get方法才能得到可访问域的值</mark>。<strong>除非拥有访问权限，否则Java安全机制只允许查看任意对象有哪些域，而不允许读取它们的值</strong></li>
<li>setAccessible方法是<mark>AccessibleObject类中的一个方法</mark>,是<mark>Field、Method和Constructor类的公共超类</mark>
<ul>
<li>该特性是为调试、持久存储和相似机制提供的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">harry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry Hacker&quot;</span>, <span class="number">35000</span>, <span class="number">10</span>，<span class="number">1</span>, <span class="number">1989</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> harry.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> f.get(harry);</span><br><span class="line"><span class="comment">//name是一个私有域，get方法将会抛出IllegalAccessException</span></span><br><span class="line"><span class="comment">//反射机制的默认行为受限于Java的访问控制</span></span><br><span class="line"><span class="comment">//然而，如果一个Java程序没有受到安全管理器的控制，就可以覆盖访问控制</span></span><br><span class="line"><span class="comment">//需要调用Field、Method或Constructor对象的setAccessible方法设置访问权限</span></span><br><span class="line">f.serAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//name域是一个String作为Object返回没有问题</span></span><br><span class="line"><span class="comment">//但是,假定查看salary域(double类型,不是对象)，使用Field类中的getDouble方法，也可以调用get方法</span></span><br><span class="line"><span class="comment">//反射机制将会自动地将这个域值打包到相应的对象包装器中，这里将打包成Double</span></span><br><span class="line"><span class="comment">//调用f.set(obj, value)可以将obj对象的f域设置成新值</span></span><br></pre></td></tr></table></figure>
<h3 id="575-使用反射编写泛型数组代码"><a class="markdownIt-Anchor" href="#575-使用反射编写泛型数组代码"></a> 5.7.5 使用反射编写泛型数组代码</h3>
<ul>
<li>java.lang.reflect包中的Array类允许动态地创建数组</li>
<li><mark>getLength()是Array类的方法，而getCOmponentType()是Class类的方法</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Employee[]数组转换为Object[]数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] badCopyOf(Object[] a, <span class="type">int</span> newLength) &#123;</span><br><span class="line">  Object[] newArray = <span class="keyword">new</span> <span class="title class_">Object</span>[newLength];</span><br><span class="line">  System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(a.length,newLength));</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该段代码,在实际使用时返回Object[]类型</span></span><br><span class="line">  <span class="comment">//一个对象数组不能转换为Employee[],会产生CLassCastException异常</span></span><br><span class="line">  <span class="comment">//将一个Employee[]临时地转换成Object[]数组，然后再把它转换回来是可以的，但一个从开始就是Object[]的数组却永远不能转换成Employee[]数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为解决该问题，编写通用的数组代码</span></span><br><span class="line">  <span class="comment">//Array类中的静态方法newInstance能够构造新数组。在调用它时必须提供两个参数，一个是数组的元素类型，一个是数组的长度</span></span><br><span class="line">  <span class="comment">//可以通过调用Array.getLength(a)获得数组的长度，也可以通过Array类的静态getLength方法的返回值得到任意数组的长度</span></span><br><span class="line"><span class="comment">//获得新数组元素类型，就需要进行以下工作：</span></span><br><span class="line">  <span class="comment">//1)首先获得a数组的类对象。</span></span><br><span class="line">  <span class="comment">//2)确认它是一个数组。</span></span><br><span class="line">  <span class="comment">//3)使用Class类(只能定义表示数组的类对象)的getComponentType方法确定数组对应的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">goodCopy0f</span><span class="params">(Object a, <span class="type">int</span> newLength)</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> a.getClass();</span><br><span class="line">  <span class="keyword">if</span> (!cl.isArray()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">Class</span> <span class="variable">componentType</span> <span class="operator">=</span> cl.getConponentType();</span><br><span class="line">  <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Array.getLength(a);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array. newInstance(componentType，newLength);</span><br><span class="line">  System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="576-调用任意方法"><a class="markdownIt-Anchor" href="#576-调用任意方法"></a> 5.7.6 调用任意方法</h3>
<ul>
<li><mark>反射机制允许调用任意方法</mark></li>
<li>在Method类中有一个invoke方法(允许调用包装在当前Method对象中的方法)
<ul>
<li><mark>invoke的参数和返回值必须是Object类型(必须进行多次的类型转换)</mark></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invoke方法签名</span></span><br><span class="line"><span class="comment">//第一个参数是隐式参数，其余的对象提供了显式参数</span></span><br><span class="line"><span class="comment">//对于静态方法，第一个参数可以被忽略，即可以将它设置为null</span></span><br><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line"><span class="comment">//假设用ml代表Employee类的getName方法</span></span><br><span class="line"><span class="comment">//如果返回类型是基本类型，invoke方法会返回其包装器类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> (String) ml.invoke(harry);</span><br><span class="line"><span class="comment">//如果返回类型是基本类型，invoke方法会返回其包装器类型</span></span><br><span class="line"><span class="comment">//假设m2表示Employee类的getSalary方法，那么返回的对象实际上是一个Double，必须相应地完成类型转换。可以使用自动拆箱将它转换为一个double：</span></span><br><span class="line"><span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> (Double) m2.invoke(harry);</span><br><span class="line"><span class="comment">//如何得到Method对象呢？</span></span><br><span class="line">  <span class="comment">//当然，可以通过调用getDeclareMethods方法，然后对返回的Method对象数组进行查找，直到发现想要的方法为止</span></span><br><span class="line">  <span class="comment">//也可以通过调用Class类中的getMethod方法得到想要的方法。它与getField方法类似(getField方法根据表示域名的字符串，返回一个Field对象)</span></span><br><span class="line">  <span class="comment">//然而，有可能存在若干个相同名字的方法，因此要格外小心，以确保能够准确地得到想要的那个方法。有鉴于此，还必须提供想要的方法的参数类型</span></span><br><span class="line"><span class="comment">//getMethods的签名</span></span><br><span class="line">Method <span class="title function_">getMethod</span><span class="params">(String name, Class... parameterTypes)</span></span><br><span class="line"><span class="comment">//获取Employee类的getName方法和raiseSalary方法指针</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> Employee.class.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> Employee.class.getMethod(<span class="string">&quot;raiseSalary&quot;</span>, <span class="type">double</span>, class);</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="58-继承的设计技巧"><a class="markdownIt-Anchor" href="#58-继承的设计技巧"></a> 5.8 继承的设计技巧</h2>
<ol>
<li><mark>将公共操作和域放在超类</mark></li>
<li><mark>不要使用受保护的域</mark>
<ul>
<li>protected机制并不能够带来更好的保护</li>
<li>1.子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的实例域，从而破坏了封装性。</li>
<li>2.在Java程序设计语言中，在同一个包中的所有类都可以访问proteced域，而不管它是否为这个类的子类</li>
<li>protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用</li>
</ul>
</li>
<li>使用继承实现“is-a”关系</li>
<li><mark>除非所有继承的方法都有意义，否则不要使用继承</mark>
<ul>
<li>如果扩展LocalDate就不会出现这个问题。由于这个类是不可变的，所以没有任何方法会把假日变成非假日</li>
</ul>
</li>
<li>在覆盖方法时，不要改变预期的行为</li>
<li>使用多态，而非类型信息
<ul>
<li>action1与action2表示的是相同的概念吗？如果是相同的概念，就应该为这个概念定义一个方法，并将其放置在两个类的超类或接口中</li>
<li>可以调用以便使用多态性提供的动态分派机制执行相应的动作</li>
</ul>
</li>
<li>不要过多地使用反射</li>
</ol>
<hr />
<h1 id="6-接口lambda表达式与内部类"><a class="markdownIt-Anchor" href="#6-接口lambda表达式与内部类"></a> 6 接口,Lambda表达式与内部类</h1>
<ul>
<li>接口技术，主要用来描述类具有什么功能，而并不给出每个功能的具体实现
<ul>
<li>一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象</li>
</ul>
</li>
<li>使用lambda表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码</li>
<li>内部类机制
<ul>
<li>内部类定义在另外一个类的内部，其中的方法可以访问包含它们的外部类的域</li>
<li>内部类技术主要用于设计具有相互协作关系的类集合</li>
</ul>
</li>
<li>代理(实现任意接口的对象),代理是一种非常专业的构造工具，可以用来构建系统级的工具</li>
</ul>
</div><div class="story post-story"><h2 id="61-接口"><a class="markdownIt-Anchor" href="#61-接口"></a> 6.1 接口</h2>
<h3 id="611-接口概念"><a class="markdownIt-Anchor" href="#611-接口概念"></a> 6.1.1 接口概念</h3>
<ul>
<li>
<p>在Java程序设计语言中，<mark>接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义</mark></p>
</li>
<li>
<p>一个具体的示例</p>
<ul>
<li>Arrays类的sort方法可以对对象数组进行排序
<ul>
<li><mark>但对象所属的类必须实现了Comparable接口</mark></li>
<li><mark>任何实现Comparable接口的类都需要包含compareTo方法</mark></li>
<li>在调用x.compareTo(y)的时候，compareTo方法必须比较两个对象的内容，并返回比较的结果
<ul>
<li>当x小于y时，返回一个负数</li>
<li>当x等于y时，返回0；否则返回一个正数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>接口可能<mark>包含多个方法</mark></p>
<ul>
<li><mark>接口中的所有方法默认为public(在声明方法时，不必提供关键字public)</mark></li>
<li>接口还可以定义常量</li>
</ul>
</li>
<li>
<p>提供实例域和方法实现的任务<mark>应该由实现接口的那个类来完成</mark></p>
<ul>
<li><strong>接口看成是没有实例域的抽象类</strong></li>
</ul>
</li>
<li>
<p><mark>让类实现接口，需要两个步骤</mark>：</p>
<ol>
<li>将类声明为实现给定的接口</li>
<li>对接口中的所有方法进行定义</li>
</ol>
</li>
<li>
<p><mark>使用implements关键字将类声明为实现某个接口</mark></p>
</li>
<li>
<p><mark>让一个类使用排序服务必须让它实现compareTo方法</mark></p>
</li>
<li>
<p><mark>两个整数利用减法操作进行大小比较</mark></p>
<ul>
<li>整数的范围不能过大，以避免造成减法运算的溢出</li>
<li>如果能够确信ID为非负整数，或者它们的绝对值不会超过(Integer.MAX_VALUE-1)/2，就不会出现问题</li>
<li>否则，调用静态Integer.compare方法</li>
<li>相减技巧<mark>不适用于浮点值</mark></li>
</ul>
</li>
<li>
<p><mark>为什么不能在类中直接提供一个compareTo方法，而必须使用接口</mark></p>
<ul>
<li>Java程序设计语言是一种强类型语言。在调用方法的时候，编译器将会检查这个方法是否存在</li>
<li>如果a是一个Comparable对象的数组，就可以确保拥有compareTo方法，因为每个实现Comparable接口的类都必须提供这个方法的定义</li>
<li><s>将Arrays类中的sort方法定义为接收一个Comparable[]数组就可以在使用元素类型没有实现Comparable接口的数组作为参数调用sort方法时，由编译器给出错误报告，但事实并非如此。在这种情况下，sort方法可以接收一个Object[]数组，并对其进行笨拙的类型转换</s></li>
</ul>
</li>
<li>
<p>语言标准规定</p>
<ul>
<li>对于任意的x和y，实现必须能够保证sgn(x.compareTo(y))=-sgn(y.compareTo(x))</li>
<li>即y.compareTo(x)抛出一个异常，x.compareTo(y)也应该抛出一个异常</li>
<li>这里的“sgn”是一个数值的符号：如果n是负值，sgn(n)等于-1；如果n是0，sgn(n)等于0；如果n是正值，sgn(n)等于1。简单地讲，如果调换compareTo的参数，结果的符号也应该调换(而不是实际值)</li>
</ul>
</li>
<li>
<p><mark>如果子类之间的比较含义不一样，那就属于不同类对象的非法比较</mark><a href="##521-2-equals%E6%96%B9%E6%B3%95_%E7%9B%B8%E7%AD%89%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%A7%E6%89%BF">参考第五章equals方法</a></p>
<ul>
<li>通用算法(能够对两个不同的子类对象进行比较)，应该在超类中提供一个final常量的compareTo方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Comparable接口的代码</span></span><br><span class="line">  <span class="comment">//任何实现Comparable接口的类都需要包含compareTo方法</span></span><br><span class="line">  <span class="comment">//并且这个方法的参数必须是一个Object对象，返回一个整型数值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">CompareTo</span><span class="params">(Object other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可使用泛型类型进行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">CompareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在实现Compareable&lt;Employee&gt;接口的类中，必须提供方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CompareTo</span><span class="params">(Employee other)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还可以使用不带类型参数的“原始”Comparable类型</span></span><br><span class="line"><span class="comment">//其CompareTo方法就有一个Object类型参数</span></span><br><span class="line"><span class="comment">//必须手动将CompareTo方法的参数强制转换至所需要的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将类声明为实现Comparable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//在实现接口时，必须把方法声明为public</span></span><br><span class="line">  <span class="comment">//否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性</span></span><br><span class="line">  <span class="comment">//之后编译器就会给出试图提供更严格的访问权限的警告信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) otherObject;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用泛型提供类型参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Employee&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Employee otherObject)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="612-接口的特性"><a class="markdownIt-Anchor" href="#612-接口的特性"></a> 6.1.2 接口的特性</h3>
<ul>
<li><mark>接口不是类，尤其不能使用new运算符实例化一个接口</mark></li>
<li>尽管不能构造接口的对象，却能声明接口的变量,<mark>接口变量必须引用实现了接口的类对象</mark></li>
<li>可以使用instance检查一个对象是否实现了某个特定的接口</li>
<li>接口中可以包含常量，但<mark>不可以包含实例域和静态方法</mark>
<ul>
<li>与接口中的方法都自动地被设置为public一样，<mark>接口中的域将被自动设为public static final</mark></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口变量</span></span><br><span class="line">Comparable x;</span><br><span class="line"><span class="comment">//接口变量必须引用实现了接口的类对象</span></span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">Employee</span>(...);</span><br><span class="line"><span class="comment">//可以使用instanceof检查一个对象是否实现了某个特定的接口</span></span><br><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> Comparable)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//允许存在多条从具有较高通用性的接口到较高专用性的接口的链</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Moveable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Powered</span> <span class="keyword">extends</span> <span class="title class_">Moveable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">milesPerCallon</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">double</span> <span class="variable">SPEED_LIMIT</span> <span class="operator">=</span> <span class="number">95</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了</span></span><br><span class="line"><span class="comment">//使用逗号将实现的各个接口分隔开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>,Comparable</span><br></pre></td></tr></table></figure>
<h3 id="613-接口与抽象类"><a class="markdownIt-Anchor" href="#613-接口与抽象类"></a> 6.1.3 接口与抽象类</h3>
<ul>
<li>使用抽象类表示通用属性存在这样一个问题
<ul>
<li>每个类只能扩展于一个类。假设Employee类已经扩展于一个类，例如Person，它就不能扩展第二个类了</li>
<li><mark>但每个类可以实现多个接口</mark></li>
<li><mark>Java的不支持多继承</mark>，其主要原因是多继承会让语言本身变得非常复杂(如同C++)，效率也会降低</li>
<li>接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性</li>
</ul>
</li>
</ul>
<h3 id="614-静态方法"><a class="markdownIt-Anchor" href="#614-静态方法"></a> 6.1.4 静态方法</h3>
<ul>
<li>通常静态方法放在伴随类中，例如Collection/Collections或Path/Paths</li>
<li>在Java SE 8中，允许在接口中增加静态方法</li>
<li><mark>实现自己的接口不再需要为实用工具方法另外提供一个伴随类</mark></li>
</ul>
<h3 id="615-默认方法"><a class="markdownIt-Anchor" href="#615-默认方法"></a> 6.1.5 默认方法</h3>
<ul>
<li>可以用<mark>default修饰符为接口方法提供一个默认方法</mark></li>
<li><mark>默认方法可以调用任何其他方法</mark></li>
<li><mark>默认方法的一个重要用法是“接口演化”</mark>
<ul>
<li>假设stream方法不是一个默认方法。那么Bag类将不能编译，因为它没有实现这个新方法。为接口增加一个非默认方法不能保证“源代码兼容”</li>
<li>不过，假设不重新编译这个类，而只是使用原先的一个包含这个类的JAR文件。这个类仍能正常加载，尽管没有这个新方法。程序仍然可以正常构造Bag实例，不会有意外发生。</li>
<li>如果程序在一个Bag实例上调用stream方法，就会出现一个AbstractMethodError</li>
<li>将方法实现为一个默认方法就可以解决这两个问题。Bag类又能正常编译了。另外如果没有重新编译而直接加载这个类，并在一个Bag实例上调用stream方法，将调用Collection.stream方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">  <span class="comment">//可以为接口方法提供一个默认实现。必须用default修饰符标记这样一个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="616-解决默认方法冲突"><a class="markdownIt-Anchor" href="#616-解决默认方法冲突"></a> 6.1.6 解决默认方法冲突</h3>
<ul>
<li>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况？
<ul>
<li>超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略</li>
<li><strong>一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法</strong>
<ul>
<li><mark>在这种情况下，只会考虑超类方法，接口的所有默认方法都会被忽略</mark>
<ul>
<li>“类优先”规则可以确保与Java SE 7的兼容性</li>
<li>如果为一个接口增加默认方法，这对于有这个默认方法之前能正常工作的代码不会有任何影响</li>
</ul>
</li>
<li><mark>千万不要让一个默认方法重新定义Object类中的某个方法</mark>
<ul>
<li>例如，不能为toString或equals定义默认方法，尽管对于List之类的接口这可能很有吸引力.由于“类优先”规则，这样的<mark>方法绝对无法超越Object.toString或Objects.equals</mark></li>
</ul>
</li>
</ul>
</li>
<li>接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，必须覆盖这个方法来解决冲突(解决二义性问题)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Named</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;_&quot;</span> + hashCode); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类会继承Person和Named接口提供的两个不一致的getName方法,出现二义性问题</span></span><br><span class="line"><span class="comment">//Java设计者更强调一致性</span></span><br><span class="line"><span class="comment">//两个接口如何冲突并不重要。如果至少有一个接口提供了一个实现，编译器就会报告错误，而程序员就必须解决这个二义性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Named</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Person.<span class="built_in">super</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果两个接口都没有为共享方法提供默认实现，那么就与Java SE 8之前的情况一样，这里不存在冲突</span></span><br><span class="line"><span class="comment">//实现类可以有两个选择：实现这个方法，或者干脆不实现。如果是后一种情况，这个类本身就是抽象的</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="62-接口示例"><a class="markdownIt-Anchor" href="#62-接口示例"></a> 6.2 接口示例</h2>
<h3 id="621-接口与回调"><a class="markdownIt-Anchor" href="#621-接口与回调"></a> 6.2.1 接口与回调</h3>
<ul>
<li>回调(是一种常见的程序设计模式)</li>
<li>在这种模式中，可以指出某个特定事件发生时应该采取的动作</li>
</ul>
<h3 id="622-comparator接口"><a class="markdownIt-Anchor" href="#622-comparator接口"></a> 6.2.2 Comparator接口</h3>
<ul>
<li>假设我们希望按长度递增的顺序对字符串进行排序，而不是按字典顺序进行排序</li>
<li>Arrays.sort方法还有第二个版本，<mark>有一个数组和一个比较器(comparator)作为参数，比较器是实现了Comparator接口的类的实例</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Comparator接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T first, T second)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现按长度比较字符串的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> first.length()-second.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立实例进行比较</span></span><br><span class="line"><span class="comment">//尽管LengthComparator对象没有状态，不过还是需要建立这个对象的一个实例</span></span><br><span class="line"><span class="comment">//需要这个实例来调用compare方法(不是一个静态方法)</span></span><br><span class="line">Comparator&lt;String&gt; comp = <span class="keyword">new</span> <span class="title class_">LengthComparator</span>();</span><br><span class="line"><span class="keyword">if</span>(comp.compare(words[i],words[j])&gt;<span class="number">0</span>)...</span><br><span class="line"><span class="comment">//对数组排序</span></span><br><span class="line"><span class="comment">//为Arrays.sort方法传入LengthComparator对象</span></span><br><span class="line">String[] friends = &#123;<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;Paul&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(friends,<span class="keyword">new</span> <span class="title class_">LengthComparator</span>());</span><br></pre></td></tr></table></figure>
<h3 id="623-对象克隆"><a class="markdownIt-Anchor" href="#623-对象克隆"></a> 6.2.3 对象克隆</h3>
<ul>
<li>Cloneable接口(指示一个类提供了一个安全的clone方法)
<ul>
<li>Cloneable接口是Java提供的一组<mark>标记接口(标记接口不包含任何方法,唯一的作用是允许在类型查询中使用instanceof)之一</mark></li>
<li>Comparable等接口的通常用途是确保一个类实现一个或一组特定的方法</li>
</ul>
</li>
<li>clone方法是Object的一个protected方法(不能直接调用anObject.clone())
<ul>
<li>只有Employee类可以克隆Employee对象</li>
<li>限制的原因：
<ul>
<li>如果对象中的所有数据域都是数值或其他基本类型，拷贝没有问题</li>
<li><mark>如果对象包含子对象的引用，拷贝域就会得到相同子对象的另一个引用，原对象和克隆的对象仍然会共享一些信息</mark></li>
</ul>
</li>
</ul>
</li>
<li>默认的克隆操作是“浅拷贝”，并没有克隆对象中引用的其他对象
<ul>
<li>浅拷贝的影响
<ul>
<li>如果原对象和浅克隆对象共享的子对象是不可变的，共享是安全的</li>
<li>如果子对象属于一个不可变的类，如String。或者在对象的生命期中，子对象一直包含不变的常量，没有更改器方法会改变它，也没有方法会生成它的引用，安全</li>
<li><mark>通常子对象是可变的，必须重新定义clone方法来建立深拷贝，同时克隆所有子对象</mark></li>
</ul>
</li>
</ul>
</li>
<li>对于每一个类，需要确定
<ol>
<li>默认的clone方法是否满足要求</li>
<li>是否可以在可变的子对象上调用clone来修补默认的clone方法</li>
<li>是否不该使用clone</li>
</ol>
</li>
<li><mark>第3个选项是默认选项;如果选择第1项或第2项，类必须</mark>：
<ol>
<li>实现Cloneable接口</li>
<li>重新定义clone方法，并指定public访问修饰符</li>
</ol>
</li>
<li>clone方法实现的注意事项：
<ul>
<li><mark>必须重新定义clone为public才能允许所有方法克隆对象</mark>(子类只能调用受保护的clone方法来克隆它自己的对象)</li>
</ul>
</li>
<li>Cloneable接口的出现与接口的正常使用并没有关系
<ul>
<li>具体来说，它没有指定clone方法，这个方法是从Object类继承的</li>
<li>Cloneable接口只是作为一个标记，指示类设计者了解克隆过程。对象对于克隆很“偏执”，如果一个对象请求克隆，但没有实现这个接口，就会生成一个受查异常</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即使clone的默认(浅拷贝)实现能够满足要求，还是需要实现Cloneable接口</span></span><br><span class="line"><span class="comment">//将clone重新定义为public，再调用super.clone()</span></span><br><span class="line"><span class="comment">//与Object.clone提供的浅拷贝相比，该clone方法并没有增加任何功能</span></span><br><span class="line"><span class="comment">//只是让clone方法是公有的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// raise visibility level to public, change return type</span></span><br><span class="line">  <span class="keyword">public</span> Employee <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">  <span class="title function_">return</span> <span class="params">(Employee)</span> <span class="built_in">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//声明了这个异常:如果在一个对象上调用clone，但这个对象的类并没有实现Cloneable接口，Object类的clone方法就会抛出一个CloneNotSupportedException</span></span><br><span class="line">  <span class="keyword">public</span> Employee <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">  <span class="type">Employee</span> <span class="variable">cloned</span> <span class="operator">=</span> (Employee) <span class="built_in">super</span>.clone();</span><br><span class="line">  cloned.hireDay = (Date) hireDay.clone();</span><br><span class="line">  <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用异常捕获,非常适用于final类</span></span><br><span class="line"><span class="comment">//否则，最好还是保留throws说明符(允许子类在不支持克隆时选择抛出一个CloneNotSupportedException)</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">Employee</span> <span class="variable">cloned</span> <span class="operator">=</span> (Employee) <span class="built_in">super</span>.clone();</span><br><span class="line">&#125;<span class="keyword">catch</span> (CloneNotSupportedException e) &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line"><span class="comment">//必须当心子类的克隆</span></span><br><span class="line"><span class="comment">//例如，一旦为Employee类定义了clone方法，任何人都可以用它来克隆Manager对象</span></span><br><span class="line"><span class="comment">//出于这个原因，在Object类中clone方法声明为protected</span></span><br><span class="line"><span class="comment">//不过，如果你希望类用户调用clone，就不能这样做。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有数组类型都有一个public的clone方法，而不是protected</span></span><br><span class="line"><span class="comment">//可以用这个方法建立一个新数组，包含原数组所有元素的副本</span></span><br><span class="line"><span class="type">int</span>[] luckyNumbers = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span> &#125;;</span><br><span class="line"><span class="type">int</span>[] cloned = luckyNumbers.clone(); </span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="63-lambda表达式"><a class="markdownIt-Anchor" href="#63-lambda表达式"></a> 6.3 Lambda表达式</h2>
<h3 id="631_2-引入lambda表达式及语法"><a class="markdownIt-Anchor" href="#631_2-引入lambda表达式及语法"></a> 6.3.1_2 引入Lambda表达式及语法</h3>
<ul>
<li>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次</li>
<li>语法：参数，箭头(-&gt;)以及一个表达式</li>
<li>如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显式的return语句
<ul>
<li>即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样</li>
<li>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型</li>
<li>无需指定lambda表达式的返回类型(返回类型会由上下文推导得出)</li>
<li>如果一个lambda表达式只在某些分支返回一个值，在另外一些分支不返回值(<mark>不合法</mark>)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="633-函数式接口"><a class="markdownIt-Anchor" href="#633-函数式接口"></a> 6.3.3 函数式接口</h3>
<ul>
<li>函数式接口：对于<mark>只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式</mark></li>
<li>为什么函数式接口必须有一个抽象方法：
<ul>
<li><mark>接口中的方法并不是完全抽象的</mark></li>
<li>接口完全有可能重新声明Object类的方法，如toString或clone，这些声明有可能会让方法不再是抽象的</li>
<li>在JavaSE8中，接口可以声明非抽象方法</li>
</ul>
</li>
<li>在Java中，对lambda表达式所能做的也只是能转换为函数式接口</li>
<li><mark>不能把lambda表达式赋给类型为Object的变量，Object不是一个函数式接口</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展示如何转化为函数式接口</span></span><br><span class="line"><span class="comment">//考虑Arrays.sort方法</span></span><br><span class="line"><span class="comment">//第二个参数需要一个Comparator实例，Comparator就是只有一个方法的接口，所以可以提供一个lambda表达式</span></span><br><span class="line">Arrays.sort(words,</span><br><span class="line">  (first,second) -&gt; first.length() - second.length());</span><br><span class="line"><span class="comment">//在底层，Arrays.sort方法会接收实现了Comparator＜String＞的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体</span></span><br></pre></td></tr></table></figure>
<h3 id="634-方法引用"><a class="markdownIt-Anchor" href="#634-方法引用"></a> 6.3.4 方法引用</h3>
<ul>
<li>表达式System.out::println是一个方法引用，等价于lambda表达式x-&gt;System.out.println(x)
<ul>
<li>要用::操作符分隔方法名与对象或类名。主要有3种情况:
<ul>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class::instanceMethod</li>
<li>前2种情况中，方法引用等价于提供方法参数的lambda表达式</li>
<li>对于第3种情况，第1个参数会成为方法的目标。例如，String::compareToIgnoreCase等同于(x，y)-&gt;x.compareToIgnoreCase(y)</li>
</ul>
</li>
</ul>
</li>
<li>如果有多个同名的重载方法，编译器就会尝试从上下文中找出你指的那一个方法</li>
<li>类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例</li>
<li>可以在方法引用中使用this参数。例如，this::equals等同于x-&gt;this.equals(x)
<ul>
<li>==使用super也是合法的,super::instanceMethod</li>
<li><mark>使用this作为目标，会调用给定方法的超类版本</mark></li>
</ul>
</li>
</ul>
<h3 id="635-构造器引用"><a class="markdownIt-Anchor" href="#635-构造器引用"></a> 6.3.5 构造器引用</h3>
<ul>
<li>构造器引用与方法引用很类似，只不过方法名为new
<ul>
<li>Person::new是Person构造器的一个引用</li>
</ul>
</li>
<li>可以用数组类型建立构造器引用
<ul>
<li>例如，int[]::new是一个构造器引用，它有一个参数:即数组的长度。这等价于lambda表达式x-&gt;new int[x]</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java有一个限制，无法构造泛型类型T的数组。数组构造器引用对于克服这个限制很有用</span></span><br><span class="line"><span class="comment">//表达式new T[n]会产生错误，因为这会改为new Object[n]</span></span><br><span class="line"><span class="comment">//假设我们需要一个Person对象数组。Stream接口有一个toArray方法可以返回Object数组</span></span><br><span class="line">Object[] people = stream.toArray();</span><br><span class="line"><span class="comment">//流库利用构造器引用解决了这个问题。可以把Person[]::new传入toArray方法</span></span><br><span class="line">Person[] people = stream.toArray(Person[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//toArray方法调用这个构造器来得到一个正确类型的数组。然后填充这个数组并返回</span></span><br></pre></td></tr></table></figure>
<h3 id="636变量作用域"><a class="markdownIt-Anchor" href="#636变量作用域"></a> 6.3.6变量作用域</h3>
<ul>
<li>lambda表达式有3个部分:
<ol>
<li>一个代码块</li>
<li>参数</li>
<li>自由变量的值(指非参数而且不在代码中定义的变量)</li>
</ol>
</li>
<li>关于代码块以及自由变量值有一个术语：<mark>闭包</mark></li>
<li><mark>lambda表达式可以捕获外围作用域中变量的值</mark></li>
<li>在Java中，要确保所捕获的值是明确定义的，<mark>在lambda表达式中，只能引用值不会改变的变量</mark>,如果在lambda表达式中引用变量，而这个变量可能在外部改变，这也是不合法的</li>
<li><mark>lambda表达式中捕获的变量必须实际上是最终变量</mark>
<ul>
<li>最终变量是指，<mark>这个变量初始化之后就不会再为它赋新值</mark></li>
<li>在lambda表达式中<mark>声明与一个局部变量同名的参数或局部变量是不合法的</mark></li>
<li>在方法中，不能有两个同名的局部变量，因此，lambda表达式中同样也不能有同名的局部变量</li>
<li>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表达式this.toString()会调用Application对象的toString方法，而不是ActionListener实例的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">  <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="built_in">this</span>, toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="637-处理lambda表达式"><a class="markdownIt-Anchor" href="#637-处理lambda表达式"></a> 6.3.7 处理lambda表达式</h3>
<ul>
<li>使用lambda表达式的重点是延迟执行</li>
<li>大多数标准函数式接口都提供了非抽象方法来生成或合并函数</li>
<li>已经提供了默认方法and、or和negate来合并谓词</li>
<li>如果设计你自己的接口，其中只有一个抽象方法，可以用@FunctionalInterface注解来标记这个接口
<ul>
<li>优点：
<ul>
<li>如果你无意中增加了另一个非抽象方法，编译器会产生一个错误消息</li>
<li>另外javadoc页里会指出你的接口是一个函数式接口</li>
</ul>
</li>
</ul>
</li>
<li>任何有一个抽象方法的接口都是函数式接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设重复一个动作n次</span></span><br><span class="line">repeat(<span class="number">10</span>，() -&gt; System.out.println(<span class="string">&quot;He11o, Wor1d!&quot;</span>));</span><br><span class="line"><span class="comment">//可以使用Runnable接口,调用action.run()时会执行这个lambda表达式的主体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeat</span><span class="params">(<span class="type">int</span> n, Runnable action)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; n; i++) action.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="64-内部类"><a class="markdownIt-Anchor" href="#64-内部类"></a> 6.4 内部类</h2>
<ul>
<li>内部类是定义在另一个类中的类
<ul>
<li>内部类方法可以访问该类定义所在的作用域中的数据，<mark>包括私有的数据</mark></li>
<li>内部类可以<mark>对同一个包中的其他类隐藏起来</mark></li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷</li>
</ul>
</li>
<li>相较于C++嵌套类的好处
<ul>
<li>内部类的对象有一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态</li>
</ul>
</li>
</ul>
<h3 id="641-使用内部类访问对象状态"><a class="markdownIt-Anchor" href="#641-使用内部类访问对象状态"></a> 6.4.1 使用内部类访问对象状态</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkingClock</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> interval;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> beep;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TalkingClock</span><span class="params">(<span class="type">int</span> interval, <span class="type">boolean</span> beep)</span> &#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">  <span class="comment">//定义一个内部类  </span></span><br><span class="line">  <span class="comment">//TimePrinter类位于TalkingClock类内部。这并不意味着每个TalkingClock都有一个TimePrinter实例域</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//TimePrinter类的详细内容</span></span><br><span class="line"><span class="comment">//需要注意一点，actionPerformed方法在发出铃声之前检查了beep标志</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimePrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;At the tone, the time is&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>TimePrinter类没有实例域或者名为beep的变量
<ul>
<li>取而代之的是<mark>beep引用了创建TimePrinter的TalkingClock对象的域</mark></li>
</ul>
</li>
<li>一个方法可以引用调用这个方法的对象数据域
<ul>
<li><mark>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域</mark></li>
</ul>
</li>
<li><mark>内部类的对象总有一个隐式引用，它指向了创建它的外部类对象</mark></li>
</ul>
<h3 id="642-内部类的特殊语法规则"><a class="markdownIt-Anchor" href="#642-内部类的特殊语法规则"></a> 6.4.2 内部类的特殊语法规则</h3>
<ul>
<li>内部类中声明的所有静态域都必须是final
<ul>
<li>原因:静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例(若不是final，它可能就不是唯一的)</li>
</ul>
</li>
<li>内部类不能有static方法,可以允许有静态方法，但只能访问外围类的静态域和方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外围类引用的表达式</span></span><br><span class="line">OuterClass.<span class="built_in">this</span></span><br><span class="line"><span class="comment">//TimePrinter内部类的actionPerformed方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (TalkingClock.<span class="built_in">this</span>.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写内部对象的构造器</span></span><br><span class="line">outerObject.<span class="keyword">new</span> <span class="title class_">InnerClass</span>(construction paraments)</span><br><span class="line"><span class="comment">//最新构建的TimePrinter对象的外围类引用被设置为创建内部类对象的方法中的this引用</span></span><br><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="built_in">this</span>.<span class="keyword">new</span> <span class="title class_">TimePrinter</span>();</span><br><span class="line"><span class="comment">//如果TimePrinter是一个公有内部类，对于任意的语音时钟都可以构造一个TimePrinter</span></span><br><span class="line"><span class="type">TalkingClock</span> <span class="variable">jabberer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TakingClock</span>(<span class="number">1000</span>, <span class="literal">true</span>);</span><br><span class="line">TalkingClock.<span class="type">TimePrinter</span> <span class="variable">listener</span> <span class="operator">=</span> jabberer.<span class="keyword">new</span> <span class="title class_">TimePrinter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在外围类的作用域之外，可以这样引用内部类</span></span><br><span class="line">OuterClass.InnerClass</span><br></pre></td></tr></table></figure>
<h3 id="643-内部类是否有用_必要和安全"><a class="markdownIt-Anchor" href="#643-内部类是否有用_必要和安全"></a> 6.4.3 内部类是否有用_必要和安全</h3>
<ul>
<li>内部类是一种编译器现象，与虚拟机无关</li>
<li>编译器将会把内部类翻译成用$(美元符号)分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知
<ul>
<li>如果内部类访问了私有数据域，就有可能通过附加在外围类所在包中的其他类访问它们，但做这些事情需要高超的技巧和极大的决心</li>
<li>程序员不可能无意之中就获得对类的访问权限，而必须刻意地构建或修改类文件才有可能达到这个目的</li>
</ul>
</li>
</ul>
<h3 id="644-局部内部类"><a class="markdownIt-Anchor" href="#644-局部内部类"></a> 6.4.4 局部内部类</h3>
<ul>
<li>可以<mark>在方法中定义局部类</mark>
<ul>
<li><mark>局部类不能用public或private访问说明符进行声明</mark></li>
<li>它的<mark>作用域被限定在声明这个局部类的块中</mark></li>
<li>局部类有一个优势，即<mark>对外部世界可以完全地隐藏起来</mark></li>
</ul>
</li>
</ul>
<h3 id="645-由外部方法访问变量"><a class="markdownIt-Anchor" href="#645-由外部方法访问变量"></a> 6.4.5 由外部方法访问变量</h3>
<ul>
<li>局部类还有一个优点。
<ul>
<li>它们不仅能够访问包含它们的外部类，还可以<mark>访问final局部变量</mark>
<ul>
<li>局部变量必须事实上为final(一旦赋值就绝不会改变)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="646-匿名内部类"><a class="markdownIt-Anchor" href="#646-匿名内部类"></a> 6.4.6 匿名内部类</h3>
<ul>
<li>匿名内部类：假如只创建这个类的一个对象，就不必命名了
<ul>
<li><mark>匿名类不能有构造器</mark>(构造器的名字必须与类名相同，匿名类没有类名)</li>
<li>将构造器参数传递给超类构造器。尤其是在内部类实现接口的时候，不能有任何构造参数</li>
</ul>
</li>
<li>Java程序员习惯的做法是用匿名内部类实现事件监听器和其他回调。如今最好还是使用lambda表达式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> interval, <span class="type">boolean</span> beep)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//匿名内部类</span></span><br><span class="line">  <span class="comment">//含义：创建一个实现ActionListener接口的类的新对象，需要实现的方法actionPerformed定义在括号&#123;&#125;内</span></span><br><span class="line">  <span class="type">Actionlistener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActionListener</span> ()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span> <span class="params">(ActionEvent event)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">if</span> (beep) Too1kit.getDefaultTookit().beep();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(interval, listener);</span><br><span class="line">  t.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名内部类的常见定义</span></span><br><span class="line"><span class="comment">//SuperType可以是ActionListener这样的接口，于是内部类就要实现这个接口</span></span><br><span class="line"><span class="comment">//SuperType也可以是一个类，于是内部类就要扩展它</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Super</span> Type(construction parameters)</span><br><span class="line">&#123;</span><br><span class="line">  inner <span class="keyword">class</span> <span class="title class_">methods</span> and data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="647-静态内部类"><a class="markdownIt-Anchor" href="#647-静态内部类"></a> 6.4.7 静态内部类</h3>
<ul>
<li>静态内部类：为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象</li>
<li>将内部类声明为static，以便取消产生的引用
<ul>
<li><mark>内部类在静态方法中构造，必须将内部类声明为静态内部类</mark></li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="65-代理"><a class="markdownIt-Anchor" href="#65-代理"></a> 6.5 代理</h2>
<ul>
<li>利用代理可以在运行时创建一个实现了一组给定接口的新类</li>
<li>这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用</li>
</ul>
<h3 id="651-何时使用代理"><a class="markdownIt-Anchor" href="#651-何时使用代理"></a> 6.5.1 何时使用代理</h3>
<ul>
<li>假设有一个表示接口的Class对象(有可能只包含一个接口)，它的确切类型在编译时无法知道
<ul>
<li>要想构造一个实现这些接口的类，就需要使用newInstance方法或反射找出这个类的构造器</li>
<li>但是，不能实例化一个接口，需要在程序处于运行状态时定义一个新类</li>
</ul>
</li>
<li>代理类可以在运行时创建全新的类，能够实现指定的接口</li>
<li>尤其是，它具有下列方法：
<ul>
<li>指定接口所需要的全部方法</li>
<li>Object类中的全部方法，例如，toString、equals等。</li>
</ul>
</li>
<li>不能在运行时定义这些方法的新代码，而是要<mark>提供一个调用处理器</mark>
<ul>
<li>调用处理器是实现了InvocationHandler接口的类对象</li>
<li><mark>调用处理器必须给出处理调用的方式</mark></li>
<li><mark>无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用，并向其传递Method对象和原始的调用参数</mark></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvocationHandler接口的唯一方法</span></span><br><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br></pre></td></tr></table></figure>
<h3 id="652-创建代理对象"><a class="markdownIt-Anchor" href="#652-创建代理对象"></a> 6.5.2 创建代理对象</h3>
<ul>
<li><mark>使用Proxy类的newProxyInstance方法</mark>创建代理对象</li>
<li>参数
<ul>
<li>一个类加载器</li>
<li>一个Class对象数组，每个元素都是需要实现的接口</li>
<li>一个调用处理器</li>
</ul>
</li>
</ul>
<h3 id="653-代理类的特性"><a class="markdownIt-Anchor" href="#653-代理类的特性"></a> 6.5.3 代理类的特性</h3>
<ul>
<li>代理类是在程序运行过程中创建的</li>
<li><mark>代理类一旦被创建，就变成了常规类，与虚拟机中的任何其他类没有什么区别</mark></li>
<li>所有的代理类都扩展于Proxy类,<mark>一个代理类只有一个实例域—(调用处理器，它定义在Proxy的超类中)</mark></li>
<li>所有的代理类都覆盖了Object类中的方法toString、equals和hashCode</li>
<li><mark>Object类中的其他方法(如clone和getClass)没有被重新定义</mark>=
<ul>
<li>没有定义代理类的名字，Sun虚拟机中的Proxy类将生成一个以字符串$Proxy开头的类名</li>
<li>对于特定的类加载器和预设的一组接口来说，只能有一个代理类（如果使用同一个类加载器和接口数组调用两次newProxyInstance方法的话，那么只能够得到同一个类的两个对象，也可以利用getProxyClass方法获得这个类）</li>
</ul>
</li>
<li><mark>代理类一定是public和final</mark>
<ul>
<li>如果代理类实现的所有接口都是public，代理类就不属于某个特定的包</li>
<li>否则，所有非公有的接口都必须属于同一个包，同时，代理类也属于这个包</li>
</ul>
</li>
<li>通过<mark>调用Proxy类isProxyClass方法检测一个特定的Class对象是否代表一个代理类</mark></li>
</ul>
<hr />
<h1 id="7-异常_断言和日志"><a class="markdownIt-Anchor" href="#7-异常_断言和日志"></a> 7 异常_断言和日志</h1>
</div><div class="story post-story"><h2 id="71-处理错误"><a class="markdownIt-Anchor" href="#71-处理错误"></a> 7.1 处理错误</h2>
<h3 id="711-异常分类"><a class="markdownIt-Anchor" href="#711-异常分类"></a> 7.1.1 异常分类</h3>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-22-15-41-48.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-22-15-41-48.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Java中的异常层次结构" /></p>
<ul>
<li>异常对象都是派生于Throwable类的一个实例
<ul>
<li>所有的异常都是Throwable继承下而来的,但分解为<mark>Error和Exception</mark>
<ul>
<li>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误(应用程序不应该抛出这种类型的对象)</li>
<li><strong>需要关注Exception层次</strong>该层次结构又分解为两个分支：一个分支派生于RuntimeException;另一个分支包含其他异常</li>
<li>划分两个分支的规则是：
<ul>
<li>程序错误导致的异常属于RuntimeException</li>
<li>程序本身没有问题,但由于像I/O错误这类问题导致的异常属于其他异常</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Java语言规范将<mark>派生于Error类或RuntimeException类的所有异常称为非受查异常</mark>，所有其他的异常称为受查异常
<ul>
<li>编译器将核查是否为所有的受查异常提供了异常处理器</li>
</ul>
</li>
</ul>
<h3 id="712-声明受查异常"><a class="markdownIt-Anchor" href="#712-声明受查异常"></a> 7.1.2 声明受查异常</h3>
<ul>
<li>方法应该在其<mark>首部声明所有可能抛出的异常</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="comment">//标准类库中提供的FileInputStream类的一个构造器的声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span> <span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundExpection</span><br><span class="line"><span class="comment">//这个声明表示这个构造器将根据给定的String参数产生一个FileInputStream对象，但也有可能抛出一个FileNotFoundException异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于那些可能被他人使用的Java方法</span></span><br><span class="line"><span class="comment">//应该根据异常规范，在方法的首部声明这个方法可能抛出的异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnimation</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个方法有可能抛出多个受查异常类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnimation</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> FileNotFoundException,EOFException</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>在自己写的方法中.需要抛出异常的4种情况：</p>
<ol>
<li>调用一个抛出受查异常的方法，例如，FileInputStream构造器</li>
<li>程序运行过程中发现错误，并且利用throw语句抛出一个受查异常</li>
<li>程序出现错误，例如，a[–1]=0会抛出一个ArrayIndexOutOfBoundsException这样的非受查异常</li>
<li>Java虚拟机和运行时库出现的内部错误</li>
</ol>
</li>
<li>
<p><mark>不需要声明Java的内部错误，即从Error继承的错误</mark></p>
</li>
<li>
<p>一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制(Error)，要么就应该避免发生(RuntimeException)</p>
</li>
<li>
<p>如果在子类中覆盖了超类的一个方法，<mark>子类方法中声明的受查异常不能比超类方法中声明的异常更通用</mark></p>
<ul>
<li>也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常</li>
</ul>
</li>
<li>
<p><mark>如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常</mark></p>
</li>
<li>
<p>如果类中的一个方法声明将会抛出一个异常，而这个异常是某个特定类的实例时，则这个方法就<mark>可能抛出一个这个类的异常，或者这个类的任意一个子类的异常</mark></p>
</li>
</ul>
<h3 id="713-如何抛出异常"><a class="markdownIt-Anchor" href="#713-如何抛出异常"></a> 7.1.3 如何抛出异常</h3>
<ul>
<li>对于一个<mark>已经存在的异常类</mark>,抛出方法：
<ul>
<li>找到一个合适的异常类</li>
<li>创建这个类的一个对象</li>
<li>将对象抛出</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EOFException异常描述的是“在输入过程中遇到了一个未预期的EOF后的信号”</span></span><br><span class="line"><span class="comment">//抛出异常的语句</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="type">EOFException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line"><span class="comment">//EOFException类还有一个含有一个字符串型参数的构造器</span></span><br><span class="line"><span class="comment">//这个构造器可以更加细致的描述异常出现的情况</span></span><br><span class="line"><span class="type">String</span> <span class="variable">gripe</span> <span class="operator">=</span> <span class="string">&quot;Content Length: &quot;</span> + len + <span class="string">&quot;, Received: &quot;</span> + n;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>(gripe);</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="714-创建异常类"><a class="markdownIt-Anchor" href="#714-创建异常类"></a> 7.1.4 创建异常类</h2>
<ul>
<li><mark>需要做的只是定义一个派生于Exception的类，或者派生于Exception子类的类</mark>
<ul>
<li>例如，定义一个派生于IOException的类</li>
<li>习惯上，定义的类应该包含两个构造器
<ul>
<li>一个是默认的构造器</li>
<li>另一个是带有详细描述信息的构造器(超类Throwable的toString方法将会打印出这些详细信息，这在调试中非常有用)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义自己的异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String gripe)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抛出</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileFormatException</span>();</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="72-捕获异常"><a class="markdownIt-Anchor" href="#72-捕获异常"></a> 7.2 捕获异常</h2>
<h3 id="721-捕获异常"><a class="markdownIt-Anchor" href="#721-捕获异常"></a> 7.2.1 捕获异常</h3>
<ul>
<li><mark>要想捕获一个异常，必须设置try/catch语句块</mark>
<ul>
<li>如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类
<ul>
<li>程序将跳过try语句块的其余代码</li>
<li>程序将执行catch子句中的处理器代码</li>
</ul>
</li>
<li>如果在try语句块中的代码没有抛出任何异常，那么程序将跳过catch子句</li>
<li>如果方法中的任何代码抛出了一个在catch子句中没有声明的异常类型，那么这个方法就会立刻退出</li>
</ul>
</li>
<li><mark>如果编写一个覆盖超类的方法，而这个方法又没有抛出异常，那么这个方法就必须捕获方法代码中出现的每一个受查异常</mark>
<ul>
<li>不允许在子类的throws说明符中出现超过超类方法所列出的异常类范围</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//try/catch语句</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    code</span><br><span class="line">    morecode</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="722-捕获多个异常"><a class="markdownIt-Anchor" href="#722-捕获多个异常"></a> 7.2.2 捕获多个异常</h3>
<ul>
<li><mark>捕获多个异常时，异常变量隐含为final变量</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//捕获多个异常类型，并对不同类型的异常做出不同的处理</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    code</span><br><span class="line">    morecode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException e) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnknownHostException e) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得异常对象的更多信息</span></span><br><span class="line">e.getMessage();</span><br><span class="line"><span class="comment">//获得更详细的错误信息</span></span><br><span class="line">e.getClass().getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Java SE 7中，同一个catch子句中可以捕获多个异常类型</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    code</span><br><span class="line">    morecode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="723-再次抛出异常与异常链"><a class="markdownIt-Anchor" href="#723-再次抛出异常与异常链"></a> 7.2.3 再次抛出异常与异常链</h3>
<ul>
<li>在catch子句中可以抛出一个异常，这样做的目的是<mark>改变异常的类型</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//捕获异常并将它再次抛出的基本方法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    code</span><br><span class="line">    morecode</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;database error: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更好的处理方式，并且将原始异常设置为新异常的原因</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    code</span><br><span class="line">    morecode</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">se</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;database erroe:&quot;</span>);</span><br><span class="line">    se.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当捕获到异常时，就可以使用下面这条语句重新得到原始异常</span></span><br><span class="line"><span class="type">Throwable</span> <span class="variable">e</span> <span class="operator">=</span> se.getCause();</span><br><span class="line"></span><br><span class="line"><span class="comment">//只想记录一个异常，再将它重新抛出，而不做任何改变</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    code</span><br><span class="line">    morecode</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.log(level,message, e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="724-finally子句"><a class="markdownIt-Anchor" href="#724-finally子句"></a> 7.2.4 finally子句</h3>
<ul>
<li><strong>如果方法获得了一些本地资源，并且只有这个方法自己知道，又如果这些资源在退出方法之前必须被回收，那么就会产生资源回收问题</strong>
<ul>
<li>一种解决方案是捕获并重新抛出所有的异常(需要在正常的代码中和异常代码中清除所分配的资源)</li>
<li>一种更好的解决方案，<mark>finally子句</mark>
<ul>
<li><mark>不管是否有异常被捕获，finally子句中的代码都被执行</mark></li>
</ul>
</li>
</ul>
</li>
<li><mark>finally中的代码总会执行</mark></li>
<li>当finally子句<mark>包含return语句时，将会出现错误的结果</mark>
<ul>
<li>假设利用return语句从try语句块中退出</li>
<li>在方法返回前，finally子句的内容将被执行</li>
<li>如果finally子句中也有一个return语句，这个返回值将会覆盖原始的返回值</li>
</ul>
</li>
<li><mark>清理资源的方法也有可能抛出异常</mark>
<ul>
<li>close方法本身也有可能抛出IOException异常。当出现这种情况时，原始的异常将会丢失，转而抛出close方法的异常</li>
<li><mark>可以使用带资源的try语句解决</mark></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//try语句可以只有finally子句,而没有catch子句</span></span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(...)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">      in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">//show error message</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//内层的try语句块只有一个职责，就是确保关闭输入流</span></span><br><span class="line"><span class="comment">//外层的try语句块也只有一个职责，就是确保报告出现的错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;   <span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">2</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果调用f(2)，那么try语句块的计算结果为r=4，并执行return语句</span></span><br><span class="line"><span class="comment">//然而，在方法真正返回前，还要执行finally子句。finally子句将使得方法返回0，这个返回值覆盖了原始的返回值4</span></span><br></pre></td></tr></table></figure>
<h3 id="725-带资源的try语句"><a class="markdownIt-Anchor" href="#725-带资源的try语句"></a> 7.2.5 带资源的try语句</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带资源的try语句的简单形式</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ...) &#123;</span><br><span class="line">    <span class="comment">//work with res    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//try块退出时，会自动调用res.close()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以指定多个资源</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user/share/dict/words&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;out.txt&quot;</span>)) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(in.hasNext())</span><br><span class="line">        out.println(in.next().toUpperCase());    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><mark>带资源的try语句可以很好地处理:try块抛出一个异常，而且close方法也抛出一个异常</mark>
<ul>
<li>原来的异常会重新抛出，而close方法抛出的异常会“被抑制”</li>
<li>这些异常将自动捕获，并由addSuppressed方法增加到原来的异常</li>
<li>如果对这些异常感兴趣，可以调用getSuppressed方法，它会得到从close方法抛出并被抑制的异常列表</li>
</ul>
</li>
<li><mark>只要需要关闭资源,就要尽可能使用带资源的try语句</mark>
<ul>
<li>带资源的try语句的<mark>catch子句和一个finally子句在关闭资源之后执行</mark></li>
</ul>
</li>
</ul>
<h3 id="726-分析堆栈轨迹元素"><a class="markdownIt-Anchor" href="#726-分析堆栈轨迹元素"></a> 7.2.6 分析堆栈轨迹元素</h3>
<ul>
<li>堆栈轨迹是一个<mark>方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置</mark></li>
<li>可以调用<mark>Throwable类的printStackTrace方法</mark>访问堆栈轨迹的文本描述信息
<ul>
<li><mark>使用getStackTrace方法得到StackTraceElement对象的一个数组，可以在程序中分析这个对象数组</mark>
<ul>
<li>StackTraceElement类含有能够获得文件名和当前执行的代码行号的方法;同时,还含有能够获得类名和方法名的方法</li>
<li>使用toString方法将产生一个格式化的字符串，其中包含所获得的信息</li>
</ul>
</li>
<li>静态的Thread.getAllStackTrace方法可以产生所有线程的堆栈轨迹</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line"><span class="type">StringWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">t.printStackTrace(<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(out));</span><br><span class="line"><span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> out.toString();</span><br><span class="line"></span><br><span class="line">StackTraceElement[] frams = t.getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement frame : frames)</span><br><span class="line">    <span class="comment">//analyze frame</span></span><br><span class="line"></span><br><span class="line">Map&lt;Tread, StackTraceElement[]&gt; map = Tread.getAllStackTrace();</span><br><span class="line"><span class="keyword">for</span> (Tread t :map.keySet())</span><br><span class="line">&#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    <span class="comment">//analyze frames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="73-使用异常的技巧"><a class="markdownIt-Anchor" href="#73-使用异常的技巧"></a> 7.3 使用异常的技巧</h2>
<ol>
<li>异常处理不能代替简单的测试：只在异常情况下使用异常机制</li>
<li>不要过分地细化异常</li>
<li>利用异常层次结构
<ol>
<li>不要只抛出RuntimeException异常。应该寻找更加适当的子类或创建自己的异常类</li>
<li>不要只捕获Thowable异常，否则，会使程序代码更难读、更难维护</li>
</ol>
</li>
<li>不要压制异常</li>
<li>在检测错误时，“苛刻”要比放任更好</li>
<li>不要羞于传递异常</li>
</ol>
</div><div class="story post-story"><h2 id="74-使用断言"><a class="markdownIt-Anchor" href="#74-使用断言"></a> 7.4 使用断言</h2>
<h3 id="741-断言的概念"><a class="markdownIt-Anchor" href="#741-断言的概念"></a> 7.4.1 断言的概念</h3>
<ul>
<li>断言机制允许在测试期间向代码中插入一些检查语句
<ul>
<li>当代码发布时，这些插入的检测语句将会被自动地移走</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种形式:</span></span><br><span class="line"><span class="keyword">assert</span> 条件</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">assert</span> 条件:表达式;</span><br><span class="line"><span class="comment">//这两种形式都会对条件进行检测，如果结果为false，则抛出一个AssertionError异常</span></span><br><span class="line"><span class="comment">//在第二种形式中，表达式将被传入AssertionError的构造器，并转换成一个消息字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="742-启用和禁用断言"><a class="markdownIt-Anchor" href="#742-启用和禁用断言"></a> 7.4.2 启用和禁用断言</h3>
<ul>
<li>默认情况下，断言被禁用
<ul>
<li>可以在运行程序时用-enableassertions或-ea选项启用</li>
<li>在启用或禁用断言时不必重新编译程序
<ul>
<li>启用或禁用断言是类加载器的功能。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度</li>
</ul>
</li>
<li>可以用选项-disableassertions或-da禁用某个特定类和包的断言</li>
</ul>
</li>
<li>启用和禁用所有断言的-ea和-da开关不能应用到那些没有类加载器的“系统类”上
<ul>
<li>对于这些系统类来说，需要使用-enablesystemassertions/-esa开关启用断言</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启用断言</span></span><br><span class="line">java -enableassertions MyApp</span><br><span class="line"><span class="comment">//在某个类或整个包中使用断言</span></span><br><span class="line">java -ea:MyClass -ea:com.mycompany.mylib...MyApp</span><br><span class="line"></span><br><span class="line"><span class="comment">//禁用断言</span></span><br><span class="line">java -ea:... -da:MyClass MyApp</span><br></pre></td></tr></table></figure>
<h3 id="743-使用断言完成参数检查"><a class="markdownIt-Anchor" href="#743-使用断言完成参数检查"></a> 7.4.3 使用断言完成参数检查</h3>
<p>使用断言的情况：</p>
<ul>
<li>断言失败是致命的、不可恢复的错误</li>
<li>断言检查只用于开发和测阶段</li>
</ul>
</div><div class="story post-story"><h2 id="75-记录日志"><a class="markdownIt-Anchor" href="#75-记录日志"></a> 7.5 记录日志</h2>
<ul>
<li>记录日志API的优点:
<ul>
<li>可以很容易地取消全部日志记录,或者仅仅取消某个级别的日志,而且打开和关闭这个操作也很容易</li>
<li>可以很简单地禁止日志记录的输出</li>
<li>日志记录可以被定向到不同的处理器.用于在控制台中显示,用于存储在文件中等</li>
<li>日志记录器和处理器都可以对记录进行过滤.过滤器可以根据过滤实现器制定的标准丢弃那些无用的记录项</li>
<li>日志记录可以采用不同的方式格式化</li>
<li>应用程序可以使用多个日志记录器，它们使用类似包名的这种具有层次结构的名字</li>
<li>在默认情况下，日志系统的配置由配置文件控制</li>
</ul>
</li>
</ul>
<h3 id="751-基本日志"><a class="markdownIt-Anchor" href="#751-基本日志"></a> 7.5.1 基本日志</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用全局日志记录器并调用其info方法,可以生成简单的日志记录</span></span><br><span class="line">Logger.getGlobal().info(<span class="string">&quot;File-&gt;Open menu item selected&quot;</span>);</span><br><span class="line"><span class="comment">//在适当的地方调用将会取消所有的日志</span></span><br><span class="line">Logger.getGlobal().setLevel(Level.OFF);</span><br></pre></td></tr></table></figure>
<h3 id="752-高级日志"><a class="markdownIt-Anchor" href="#752-高级日志"></a> 7.5.2 高级日志</h3>
<ul>
<li>使用getLOgger方法创建或获取记录器
<ul>
<li><mark>未被任何变量引用的日志记录可能会被垃圾回收,需要用静态变量存储日志记录器的一个引用</mark></li>
</ul>
</li>
<li>日志的七个等级：
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建或获取记录器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">myLogger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany.myapp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置日记等级只记录前三个等级</span></span><br><span class="line">Logger.setLevel(Level.FINE);</span><br><span class="line"><span class="comment">//可以使用Level.ALL开启所有级别的记录</span></span><br><span class="line">Logger.setLevel(Level.ALL);</span><br><span class="line"><span class="comment">//使用Level.OFF关闭所有级别的记录</span></span><br><span class="line">Logger.setLevel(Level.OFF);</span><br><span class="line"><span class="comment">//对于所有的级别有下面几种记录方法</span></span><br><span class="line">logger.warning(message);</span><br><span class="line">logger.fine(message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用logger指定等级</span></span><br><span class="line">logger.log(Level.FINE, message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的日志记录将显示包含日志调用的类名和方法名,如同堆栈所显示的那样</span></span><br><span class="line"><span class="comment">//如果虚拟机对执行过程进行了优化，就得不到准确的调用信息</span></span><br><span class="line"><span class="comment">//此时,可以调用logp方法获得调用类和方法的确切位置,这个方法的签名:</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">logp</span><span class="params">(Level <span class="number">1</span>, String className, String methodName, String message)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用来跟踪流程执行的方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">entering</span><span class="params">(String ClassName, String methodName)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">entering</span><span class="params">(String className, String methodName, 0bject param)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">entering</span><span class="params">(String className, String methodName, Object[] params)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">exiting</span><span class="params">(String className, String methodName)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">exiting</span><span class="params">(String classNare, String methodName, 0bject result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//未来，带Object[]参数的日志记录方法可能会被重写，以便支持变量参数列表(“varargs”)</span></span><br><span class="line"><span class="comment">//此后就可以用logger.entering(“com.mycompany.mylib.Reader”，“read”，file，pattern)格式调用这个方法了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录日志的常见用途是记录那些不可预料的异常</span></span><br><span class="line"><span class="comment">//可以使用下面两个方法提供日志记录中包含的异常描述内容</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">throwing</span><span class="params">(String classNare, String methodName, Throwable t)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level <span class="number">1</span>, String message, Throwable t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//典型用途</span></span><br><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">IOException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  logger.throwing(<span class="string">&#x27;com.mycompany.mylib.Reader&#x27;</span>, <span class="string">&quot;read&quot;</span>, exception);</span><br><span class="line">  <span class="keyword">throw</span> exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Logger.getLogger(<span class="string">&quot;com.mycompany.myapp&quot;</span>).log(Level.WARNING, <span class="string">&quot;Reading image&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用throwing可以记录一条FINER级别的记录和一条以THROW开始的信息</span></span><br></pre></td></tr></table></figure>
<h3 id="753-修改日志管理器配置"><a class="markdownIt-Anchor" href="#753-修改日志管理器配置"></a> 7.5.3 修改日志管理器配置</h3>
<ul>
<li>可以通过编辑配置文件来修改日志系统的各种属性</li>
<li>要想使用另一个配置文件，就要将java.util.logging.config.file特性设置为配置文件的存储位置</li>
<li>日志管理器在VM启动过程中初始化，在main执行之前完成
<ul>
<li>如果在main中调用System.setProperty(“java.util.logging.config.file”,file)</li>
<li>也会调用LogManager.readConfiguration()来重新初始化日志管理器</li>
</ul>
</li>
<li>修改默认的日志记录级别
<ul>
<li>编辑配置文件，并修改**.LEVEL=INFO**</li>
</ul>
</li>
<li>日志记录并不将消息发送到控制台上，这是处理器的任务,且处理器也有级别
<ul>
<li>java.util.logging.ConsoleHandler.level=FINE (在控制台上看到FINE级别的消息)</li>
<li>在日志管理器配置的属性设置不是系统属性，因此，用-Dcom.mycompany.myapp.level=FINE启动应用程序不会对日志记录器产生任何影响</li>
</ul>
</li>
<li>日志属性文件由java.util.logging.LogManager类处理
<ul>
<li>可以通过将java.util.logging.manager系统属性设置为某个子类的名字来指定一个不同的日志管理器
<ul>
<li>另外，在保存标准日志管理器的同时，还可以从日志属性文件跳过初始化</li>
</ul>
</li>
<li>还有一种方式是将java.util.logging.config.class系统属性设置为某个类名，该类再通过其他方式设定日志管理器属性</li>
</ul>
</li>
<li>在运行的程序中，使用jconsole程序也可以改变日志记录的级别</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下配置文件路径</span></span><br><span class="line">jre/lib/1ogging.properties</span><br><span class="line"><span class="comment">//使用其他配置文件</span></span><br><span class="line">java -Djava.util.logging.config.fi1e=configFile MainClass</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定自己的日志记录级别(在日志记录器名后面添加后缀.level)</span></span><br><span class="line">com.mycompany.myapp.level = FINE</span><br><span class="line"></span><br><span class="line"><span class="comment">//在控制台上看到FINE级别的消息，就需要进行下列设置</span></span><br><span class="line">java.util.logging.ConsoleHandler.level=FINE</span><br></pre></td></tr></table></figure>
<h3 id="754-本地化"><a class="markdownIt-Anchor" href="#754-本地化"></a> 7.5.4 本地化</h3>
<ul>
<li>本地化的应用程序包含资源包中的本地特定信息</li>
<li>一个程序可以包含多个资源包，一个用于菜单;其他用于日志消息</li>
<li>要想将映射添加到一个资源包中，需要为每个地区创建一个文件
<ul>
<li>英文消息映射位于com/mycompany/logmessages_en.properties文件中</li>
<li>德文消息映射位于com/mycompany/logmessages_de.properties文件中</li>
</ul>
</li>
<li>通常需要在本地化的消息中增加一些参数，因此，消息应该包括占位符{0}、{1}等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求日志记录器，指定资源包</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Lgger.getlogger(loggerName，<span class="string">&quot;com.mycompany.logmessages&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为日志消息指定资源包的关键字，而不是实际的日志消息字符串</span></span><br><span class="line">logger.info(<span class="string">&quot;readingFile&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在日志消息中包含文件名，就应该用下列方式包括占位符</span></span><br><span class="line">Reading file: &#123;<span class="number">0</span>&#125;.</span><br><span class="line">Achtung! Datei &#123;<span class="number">0</span>&#125; wird eingelesen.</span><br><span class="line"><span class="comment">//然后通过调用下面的一个方法向占位符传递具体的值</span></span><br><span class="line">logger.log(Level.INFO, <span class="string">&quot;readingFile&quot;</span>, fileName);</span><br><span class="line">lagger.log(Level.INF0, <span class="string">&quot;renamingFile&quot;</span>, <span class="keyword">new</span> 0bject[] &#123;oldNane, newName&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="755-处理器"><a class="markdownIt-Anchor" href="#755-处理器"></a> 7.5.5 处理器</h3>
<ul>
<li>在默认情况下，日志记录器<mark>将记录发送到ConsoleHandler中，并由它输出到System.err流中</mark></li>
<li>特别是，<mark>日志记录器还会将记录发送到父处理器中，而最终的处理器有一个ConsoleHandler</mark></li>
<li><mark>处理器也有日志记录级别</mark>
<ul>
<li><mark>对于一个要被记录的日志记录，它的日志记录级别必须高于日志记录器和处理器的阈值</mark></li>
</ul>
</li>
<li>修改文件处理器的默认行为<br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-24-19-39-43.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-24-19-39-43.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="文件处理器配置参数" /></li>
<li>日志记录文件名：例如%h/myapp.log<br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-24-19-41-31.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-24-19-41-31.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="日志记录文件模式变量" /></li>
<li>如果多个应用程序(或者同一个应用程序的多个副本)使用同一个日志文件，就应该<mark>开启append标志</mark></li>
<li><strong>另外，应该在文件名模式中使用%u，以便每个应用程序创建日志的唯一副本</strong></li>
<li>可以使用<strong>文件循环功能</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志管理器默认配置文件设置的默认控制台处理器的日志记录级别</span></span><br><span class="line">java.util.logging.ConsoleHandler.level = INFO</span><br><span class="line"></span><br><span class="line"><span class="comment">//绕过配置文件,安装自己的处理器</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;com.mycompany.myapp&quot;</span>);</span><br><span class="line">logger.setLevel(Level.FINE);</span><br><span class="line">loger.setUseParentHandlers(<span class="literal">false</span>);</span><br><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleHandler</span>();</span><br><span class="line">handler.setLevel(Level.FINE);</span><br><span class="line">logger.addHandler(handler);</span><br><span class="line">  <span class="comment">//默认情况下，日志记录器将记录发送到自己的处理器和父处理器</span></span><br><span class="line">  <span class="comment">//我们的日志记录器是原始日志记录器(命名为“”)的子类，而原始日志记录器将会把所有等于或高于INFO级别的记录发送到控制台</span></span><br><span class="line">  <span class="comment">//然而，并不想两次看到这些记录,故将useParentHandlers属性设置为false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要想将日志记录发送到其他地方,就要添加其他的处理器</span></span><br><span class="line"><span class="comment">//日志API为此提供了两个很有用的处理器</span></span><br><span class="line"><span class="comment">//一个是FileHandler;另一个是SocketHandler(SocketHandler将记录发送到特定的主机和端口)</span></span><br><span class="line"><span class="type">FileHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line">logger.addHander(handler);</span><br></pre></td></tr></table></figure>
<h3 id="756-过滤器"><a class="markdownIt-Anchor" href="#756-过滤器"></a> 7.5.6 过滤器</h3>
<ul>
<li>在默认情况下，过滤器根据日志记录的级别进行过滤</li>
<li>每个日志记录器和处理器都可以有一个可选的过滤器来完成附加的过滤
<ul>
<li>另外，可以通过实现Filter接口并定义下列方法来自定义过滤器</li>
</ul>
</li>
<li>要想将一个过滤器安装到一个日志记录器或处理器中，只需要调用setFilter方法就可以了
<ul>
<li><mark>同一时刻,最多只能有一个过滤器</mark></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Filter接口并定义自定义过滤器</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isLoggable</span><span class="params">(LogRecord record)</span></span><br><span class="line"><span class="comment">//在这个方法中，可以利用自己喜欢的标准，对日志记录进行分析，返回true表示这些记录应该包含在日志中</span></span><br></pre></td></tr></table></figure>
<h3 id="757-格式化器"><a class="markdownIt-Anchor" href="#757-格式化器"></a> 7.5.7 格式化器</h3>
<ul>
<li>ConsoleHandler类和FileHandler类可以生成文本和XML格式的日志记录</li>
<li><mark>扩展Formatter类可以实现自定义格式</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩展Formatter类并覆盖方法</span></span><br><span class="line">String <span class="title function_">format</span><span class="params">(LogRecord record)</span></span><br><span class="line"><span class="comment">//在format方法中,formatMessage方法对记录中的部分消息进行格式化、参数替换和本地化应用操作</span></span><br><span class="line">String <span class="title function_">formatMessage</span><span class="params">(LogRecord record)</span></span><br><span class="line"><span class="comment">//很多文件格式(如XML)需要在已格式化的记录的前后加上一个头部和尾部</span></span><br><span class="line"><span class="comment">//在已格式化的记录前后增加头部和尾部的覆盖方法</span></span><br><span class="line">String <span class="title function_">getHead</span><span class="params">(Handler h)</span></span><br><span class="line">String <span class="title function_">getTail</span><span class="params">(Handler h)</span></span><br><span class="line"><span class="comment">//最后，调用setFormatter方法将格式化器安装到处理器中</span></span><br></pre></td></tr></table></figure>
<h3 id="758-日志记录说明"><a class="markdownIt-Anchor" href="#758-日志记录说明"></a> 7.5.8 日志记录说明</h3>
<ol>
<li>为一个简单的应用程序，选择一个日志记录器，并把日志记录器命名为与主应用程序包一样的名字
<ul>
<li>为了方便起见，可能希望利用一些日志操作将静态域添加到类中</li>
</ul>
</li>
<li>默认的日志配置将级别等于或高于INFO级别的所有消息记录到控制台
<ul>
<li>用户可以覆盖默认的配置文件(最好在应用程序中安装一个更加适宜的默认配置)</li>
</ul>
</li>
<li>可以记录自己想要的内容
<ul>
<li>所有级别为INFO、WARNING和SEVERE的消息都将显示到控制台上</li>
<li><mark>最好只将对程序用户有意义的消息设置为这几个级别(设定为FINE是一个很好的选择)</mark></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列代码确保将所有的消息记录到应用程序特定的文件中</span></span><br><span class="line"><span class="comment">//可以将这段代码放置在应用程序的main方法中</span></span><br><span class="line"><span class="keyword">if</span> (System.getPropery(<span class="string">&quot;java.util.logging.config.class&quot;</span>) == <span class="literal">null</span></span><br><span class="line">&amp;&amp; System.getProperty(<span class="string">&quot;java.util.logging.confg.fine&quot;</span>) == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">   &#123;</span><br><span class="line">     Logger.getLogger(<span class="string">&quot;&quot;</span>).setlevel(Level.ALl);</span><br><span class="line">     <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOG_ROTATION_COUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">     <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileHandler</span>(<span class="string">&quot;%h/myapp.log&quot;</span>, <span class="number">0</span>, LOG_ROTATION_COUNT);</span><br><span class="line">     Logger.getLoggr(<span class="string">&quot;&quot;</span>).addHandler(handler);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">   logger.log(Level.SEVERE, <span class="string">&quot;Can&#x27;t create log file handler&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="76-调试技巧"><a class="markdownIt-Anchor" href="#76-调试技巧"></a> 7.6 调试技巧</h2>
<ol>
<li>可以用方法打印或记录任意变量的值</li>
<li>一个不太为人所知但却非常有效的技巧是在每一个类中放置一个单独的main方法</li>
<li>日志代理(logging proxy)是一个子类的对象，它可以截获方法调用，并进行日志记录，然后调用超类中的方法</li>
<li>利用Throwable类提供的printStackTrace方法，可以从任何一个异常对象中获得堆栈情况</li>
<li>一般来说，堆栈轨迹显示在System.err上。也可以利用printStackTrace(PrintWriter s)方法将它发送到一个文件中。如果想记录或显示堆栈轨迹，可以将它捕获到一个字符串中</li>
<li>通常，将一个程序中的错误信息保存在一个文件中是非常有用的。然而，错误信息被发送到System.err中，而不是System.out中。</li>
<li>让非捕获异常的堆栈轨迹出现在System.err中并不是一个很理想的方法。如果在客户端偶然看到这些消息，则会感到迷惑，并且在需要的时候也无法实现诊断目的。比较好的方式是将这些内容记录到一个文件中。可以调用静态的Thread.setDefaultUncaughtExceptionHandler方法改变非捕获异常的处理器</li>
<li>要想观察类的加载过程，可以用-verbose标志启动Java虚拟机</li>
<li>-Xlint选项告诉编译器对一些普遍容易出现的代码问题进行检查</li>
<li>Java虚拟机增加了对Java应用程序进行监控(monitoring)和管理(management)的支持;它允许利用虚拟机中的代理装置跟踪内存消耗、线程使用、类加载等情况</li>
<li>可以使用jmap实用工具获得一个堆的转储，其中显示了堆中的每个对象</li>
<li>如果使用-Xprof标志运行Java虚拟机，就会运行一个基本的剖析器来跟踪那些代码中经常被调用的方法;剖析信息将发送给System.out。输出结果中还会显示哪些方法是由即时编译器编译的</li>
</ol>
<hr />
<h1 id="8-泛型程序设计"><a class="markdownIt-Anchor" href="#8-泛型程序设计"></a> 8 泛型程序设计</h1>
</div><div class="story post-story"><h2 id="81-为什么要使用泛型程序设计"><a class="markdownIt-Anchor" href="#81-为什么要使用泛型程序设计"></a> 8.1 为什么要使用泛型程序设计</h2>
<h3 id="811-类型参数的好处"><a class="markdownIt-Anchor" href="#811-类型参数的好处"></a> 8.1.1 类型参数的好处</h3>
<ul>
<li><s>在Java中增加范型类之前，泛型程序设计是用继承实现的</s>
<ul>
<li><s>ArrayList类只维护一个Object引用的数组</s></li>
<li>具有两个问题:
<ul>
<li>获取一个值时必须进行强制类型转换</li>
<li>没有错误检查(可以向数组列表中添加任何类的对象)</li>
</ul>
</li>
</ul>
</li>
<li>使用类型参数可以很好的解决问题
<ul>
<li>再使用get方法时,<mark>不需要进行强制类型转换</mark></li>
</ul>
</li>
<li><strong>只能允许前一个调用，而不能允许后一个调用</strong>
<ul>
<li>ArrayList类有一个方法addAll用来添加另一个集合的全部元素。程序员可能想要将ArrayList&lt;Manager&gt;中的所有元素添加到ArrayList&lt;Employee&gt;中去。然而，反过来就不行了</li>
<li>可以<mark>使用通配符类型</mark>解决该问题</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList类只维护一个Object引用的数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object o)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList类有一个类型参数用来指示元素的类型</span></span><br><span class="line">ArrayList&lt;String&gt; files = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//JavaSE7之后可以省略泛型类型</span></span><br><span class="line">ArrayList&lt;String&gt; files = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="82-定义简单泛型类"><a class="markdownIt-Anchor" href="#82-定义简单泛型类"></a> 8.2 定义简单泛型类</h2>
<ul>
<li>一个泛型类就是具有一个或多个类型变量的类</li>
<li><mark>泛型类可以有多个类型变量</mark>,在尖括号内使用逗号隔开</li>
<li>类定义中的类型变量指定方法的返回类型以及域和局部变量的类型</li>
<li>类型变量使用大写形式,且比较短
<ul>
<li>使用变量E表示集合的元素类型</li>
<li>K和V分别表示表的关键字与值的类型</li>
<li>T (需要时还可以用临近的字母U和S)表示“任意类型”</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Pair类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt;    <span class="comment">//Pair类引入了一个类型变量T，用尖括号&lt;&gt;括起来，并放在类名的后面</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span>&#123;</span><br><span class="line">      first = <span class="literal">null</span>;second = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span> <span class="params">(T first, T second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;<span class="keyword">return</span> first;&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSecond</span><span class="params">()</span> &#123;<span class="keyword">return</span> second;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T newValue)</span>&#123;first = newValue;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(T newValue)</span>&#123;second = newValue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="83-泛型方法"><a class="markdownIt-Anchor" href="#83-泛型方法"></a> 8.3 泛型方法</h2>
<ul>
<li><mark>可以定义带有类型参数的简单方法,泛型方法</mark>
<ul>
<li>类型变量放在修饰符的后面，返回类型的前面</li>
<li>泛型方法<strong>可以定义在普通类中，也可以定义在泛型类中</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义泛型方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T...a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用方法,在方法名前面的尖括号内放入具体的类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> ArrayAlg.&lt;String&gt;getMiddle(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Q.&quot;</span>);</span><br><span class="line"><span class="comment">//在大多数情况下，方法调用中可以省略&lt;String&gt;类型参数</span></span><br><span class="line"><span class="comment">//编译器有足够的信息能够推断出所调用的方法。它用names的类型(即String[])与泛型类型T[]进行匹配并推断出T一定是String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> ArrayAlg.getMiddle(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Q.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">middle</span> <span class="operator">=</span> ArrayAlg.getMiddle(<span class="number">3.14</span>,<span class="number">1729</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//编译器将会自动打包参数为1个Double和2个Integer对象，而后寻找这些类的共同超类型。事实上，找到2个这样的超类型：Number和Comparable接口，其本身也是一个泛型类型5</span></span><br><span class="line"><span class="comment">//可以采取的补救措施是将所有的参数写为double值</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="84-类型变量的限定"><a class="markdownIt-Anchor" href="#84-类型变量的限定"></a> 8.4 类型变量的限定</h2>
<ul>
<li>类和方法需要对类型变量加以约束</li>
<li>解决办法:将T限制为实现了Comparable接口的类.可以通过对类型变量T设置限定实现</li>
<li>一个类型变量或通配符可以有多个限定
<ul>
<li>限定类型使用 &amp; 分隔，而逗号用来分隔类型变量</li>
</ul>
</li>
<li>在Java的继承中,可以根据需要拥有多个接口超类型,但限定中至多有一个类
<ul>
<li>如果用一个类作为限定,它必须是限定列表中的第一个</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对类型变量限制</span></span><br><span class="line"><span class="comment">//将T限制为实现了Comparable接口(只含一个方法compareTo的标准接口)的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span>...</span><br><span class="line"></span><br><span class="line"><span class="comment">//限定类型使用&amp;分隔，而逗号用来分隔类型变量</span></span><br><span class="line">T <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Serializable</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算数组中最小元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="literal">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">T</span> <span class="variable">smallest</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;a.length;i++)</span><br><span class="line">            <span class="keyword">if</span>(smallest.compareTo(a[i])&gt;<span class="number">0</span>) smallest = a[i];</span><br><span class="line">        <span class="keyword">return</span> smallest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="85-泛型代码和虚拟机"><a class="markdownIt-Anchor" href="#85-泛型代码和虚拟机"></a> 8.5 泛型代码和虚拟机</h2>
<ul>
<li><mark>虚拟机没有泛型类型对象,所有对象都属于普通类</mark></li>
</ul>
<h3 id="851-类型擦除"><a class="markdownIt-Anchor" href="#851-类型擦除"></a> 8.5.1 类型擦除</h3>
<ul>
<li><mark>无论何时定义一个泛型类型,都自动提供了一个相应的原始类型</mark>
<ul>
<li>原始类型的名字就是删去类型参数后的泛型类型名</li>
<li>擦除类型变量并替换为限定类型</li>
</ul>
</li>
<li><mark>为了提高效率，应该将标签接口(即没有方法的接口)放在边界列表的末尾</mark></li>
</ul>
<p><a href="#82-%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B%E7%B1%BB">Pair泛型类</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pair原始类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span>   &#123;first = <span class="literal">null</span>;second = <span class="literal">null</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object first, Object second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getFirst</span><span class="params">()</span> &#123;<span class="keyword">return</span> first;&#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSecond</span><span class="params">()</span> &#123;<span class="keyword">return</span> second;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(Object newValue)</span>&#123;first = newValue;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object newValue)</span>&#123;second = newValue;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于多个限定类型的泛型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interval</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Serializable</span> &amp; Comparable&gt;</span><br><span class="line"><span class="comment">//生成原始类型时用Serializable替换T</span></span><br><span class="line"><span class="comment">//编译器在必要时要向Comparable插入强制类型转换</span></span><br></pre></td></tr></table></figure>
<h3 id="852-翻译泛型表达式"><a class="markdownIt-Anchor" href="#852-翻译泛型表达式"></a> 8.5.2 翻译泛型表达式</h3>
<ul>
<li>当程序调用泛型方法时,如果擦除返回类型,编译器插入强制类型转换</li>
<li>擦除返回类型后,返回一个Object类型</li>
<li>编译器自动插入Employee的强制类型转换</li>
<li>编译器将这个方法翻译为两条虚拟机指令
<ul>
<li>对原始方法Pair.getFirst的调用</li>
<li>将返回的Object类型强制转换为Employee类型</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ...;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">buddy</span> <span class="operator">=</span> buddies.getFirst();</span><br></pre></td></tr></table></figure>
<h3 id="853-翻译泛型方法"><a class="markdownIt-Anchor" href="#853-翻译泛型方法"></a> 8.5.3 翻译泛型方法</h3>
<ul>
<li><mark>在泛型方法中也存在着类型擦除</mark>
<ul>
<li>完整的方法族,擦除类型后只剩下一个方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型方法(完整的方法簇)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span></span><br><span class="line"><span class="comment">//擦除之后只剩下一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title function_">min</span><span class="params">(Comparable[] a)</span></span><br><span class="line"><span class="comment">//类型擦除实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataInterval</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;LocalDate&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(LocalDate second)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(second.compareTo(getFirst()) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">super</span>.setSecond(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法擦除之后，带来两个问题</span></span><br><span class="line">  <span class="comment">//一个日期区间是一对LocalDate对象,并且需要覆盖这个方法来确保第二个值永远不小于第一个值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateInterval</span> <span class="keyword">extends</span> <span class="title class_">Pair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(LocalDate second)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但存在另一个从Pair继承的setSecond方法</span></span><br><span class="line"><span class="comment">//两个方法的签名不同,属于不同的方法.但其应该是相同的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object second)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//语言序列</span></span><br><span class="line"><span class="type">DateInterval</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateInterval</span>(...);</span><br><span class="line">Pair&lt;LocalDate&gt; pair = interval;</span><br><span class="line">pair.setSecond(aData);</span><br><span class="line"><span class="comment">//希望setSecond的调用具有多态性,由于pair引用DateInterval对象,所以应该调用DateInterval.setSecond</span></span><br><span class="line"><span class="comment">//问题在于类型擦除与多态发生了冲突,需要编译器在DateInterval类中生成一个桥方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object second)</span>&#123;setSecond((Date) second);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桥方法应用于方法覆盖时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> Employee <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Object.clone和Employee.clone方法被说成具有协变的返回类型</span></span><br><span class="line"><span class="comment">//合成的桥方法调用了新定义的方法</span></span><br><span class="line"><span class="comment">//实际上,Employee类有两个克隆方法:</span></span><br><span class="line">Employee <span class="title function_">clone</span><span class="params">()</span></span><br><span class="line">Object <span class="title function_">clone</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>桥方法的工作过程:
<ul>
<li>变量pair已经声明为类型Pair&lt;LocalDate&gt;,并且这个类型只有一个简单的方法叫setSecond,即setSecond(Object)</li>
<li>虚拟机用pair引用的对象调用这个方法.这个对象是DateInterval类型的,因而将会调用DateInterval.setSecond(Object)方法(合成的桥方法).</li>
<li>该方法调用DateInterval.setSecond(Date),正是所期望的操作效果</li>
</ul>
</li>
<li>桥方法不仅用于泛型类型
<ul>
<li>一个方法覆盖另一个方法时可以指定一个更严格的返回类型</li>
</ul>
</li>
<li>泛型转换的事实：
<ul>
<li><mark>虚拟机中没有泛型，只有普通的类和方法</mark></li>
<li><mark>所有的类型参数都用于他们的限定类型替换</mark></li>
<li><mark>桥方法被合成用来保持多态</mark></li>
<li><mark>为保持类型安全性，必要时插入强制类型转换</mark></li>
</ul>
</li>
</ul>
<h3 id="854-调用遗留代码"><a class="markdownIt-Anchor" href="#854-调用遗留代码"></a> 8.5.4 调用遗留代码</h3>
<ul>
<li>设计泛型的目的：<mark>允许泛型代码和遗留代码间能够相互操作</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1</span></span><br><span class="line"><span class="comment">//要想设置一个JSlider标签,可以使用方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setLabelTable</span><span class="params">(Dictionary table)</span></span><br><span class="line"><span class="comment">//Dictionary是一个原始类型,因为实现JSlider类时Java中还不存在泛型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//填充字典时,使用泛型类型</span></span><br><span class="line">Dictionary&lt;Integer, Component&gt; labelTable = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">labelTable.put(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">JLable</span>(<span class="keyword">new</span> <span class="title class_">ImageIcon</span>(<span class="string">&quot;nine.gif&quot;</span>)));</span><br><span class="line">labelTable.put(<span class="number">20</span>, <span class="keyword">new</span> <span class="title class_">JLable</span>(<span class="keyword">new</span> <span class="title class_">ImageIcon</span>(<span class="string">&quot;ten.gif&quot;</span>)));</span><br><span class="line">...</span><br><span class="line"><span class="comment">//将Dictionary&lt;Interger, Component&gt;对象传递给setLabelTable 时, 编译器会发出警告</span></span><br><span class="line">slider.setLable(labelTable);</span><br><span class="line"><span class="comment">//原因:</span></span><br><span class="line"><span class="comment">//编译器无法确定setLabelTable可能会对Dictionary对象做什么操作</span></span><br><span class="line"><span class="comment">//这个警告对操作并不会产生什么影响,最多考虑一下JSlider有可能用 Dictionary对象做什么就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2</span></span><br><span class="line"><span class="comment">//由一个遗留的类得到一个原始类型的对象,将它赋给一个参数化的类型变量</span></span><br><span class="line">Dictionary &lt;Integer, Components&gt; labelTable = slider.getLabelTable(); <span class="comment">// Warning</span></span><br><span class="line"><span class="comment">//可以利用注解使警告消失,注释必须放在生成这个警告的代码所在的方法之前</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Dictionary&lt;Integer, Components&gt; labelTable = slider.getLabelTable(); <span class="comment">// no warning</span></span><br><span class="line"><span class="comment">//或标注整个方法(关闭对方法中所有代码的检查)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureSlider</span><span class="params">()</span>&#123;......&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="86-约束与局限性"><a class="markdownIt-Anchor" href="#86-约束与局限性"></a> 8.6 约束与局限性</h2>
<ul>
<li><mark>泛型编程时,需要注意一些限制</mark>
<ul>
<li>大多数限制都是由于类型擦除引起的</li>
</ul>
</li>
</ul>
<h3 id="861-不能用基本类型实例化类型参数"><a class="markdownIt-Anchor" href="#861-不能用基本类型实例化类型参数"></a> 8.6.1 不能用基本类型实例化类型参数</h3>
<ul>
<li><mark>不能用类型参数代替基本类型</mark>
<ul>
<li>没有Pair&lt;double&gt;,只有Pair&lt;Double&gt;</li>
<li>原因：类型擦除后,Pair含有Object类型的域,而Object不能存储double值</li>
</ul>
</li>
<li><mark>当包装器类型不能接受替换时,可以使用独立的类和方法处理</mark></li>
</ul>
<h3 id="862-运行时类型查询只适用于原始类型"><a class="markdownIt-Anchor" href="#862-运行时类型查询只适用于原始类型"></a> 8.6.2 运行时类型查询只适用于原始类型</h3>
<ul>
<li>虚拟机中的对象<mark>总有一个特定的非泛型类型</mark>,因此所有的类型检查只产生原始类型
<ul>
<li>倘若使用instanceof会得到一个编译器错误,如果使用强制类型转换会得到一个警告</li>
<li>getClass方法总是返回原始类型</li>
</ul>
</li>
</ul>
<h3 id="863-不能创建参数化类型的数组"><a class="markdownIt-Anchor" href="#863-不能创建参数化类型的数组"></a> 8.6.3 不能创建参数化类型的数组</h3>
<ul>
<li>不允许创建参数类型化数组
<ul>
<li><mark>而声明类型为Pair&lt;String&gt;[]的变量仍是合法的</mark></li>
<li>不过不能用new Pair&lt;String&gt;[10]初始化这个变量</li>
<li><mark>可以声明通配类型的数组,然后进行类型转换</mark></li>
</ul>
</li>
<li>如果需要<mark>收集参数化类型对象,只有一种安全而有效的方法</mark>
<ul>
<li>使用ArrayList:ArrayList&lt;Pair&lt;String&gt;&gt;</li>
</ul>
</li>
</ul>
<h3 id="864-varargs警告"><a class="markdownIt-Anchor" href="#864-varargs警告"></a> 8.6.4 Varargs警告</h3>
<ul>
<li>向参数个数可变的方法传递一个泛型类型的实例</li>
<li>会得到一个警告(与<a href="#863-%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84">泛型类型数组</a>,不支持泛型类型数组冲突)</li>
<li>使用两种方法进行解决
<ul>
<li>一种方法是为包含addAll调用的方法增加注解@SuppressWarnings(“unchecked”)</li>
<li>或者在Java SE 7中，还可以用@SafeVarargs直接标注addAll方法</li>
</ul>
</li>
<li>可以使用@SafeVarargs标注来消除创建泛型数组的有关限制</li>
</ul>
<h3 id="865-不能实例化类型变量"><a class="markdownIt-Anchor" href="#865-不能实例化类型变量"></a> 8.6.5 不能实例化类型变量</h3>
<ul>
<li>不能使用像new T(…), new T[…]或T.class这样的表达式中的类型变量</li>
<li>原因:类型擦除将T改为Object,违背本意</li>
<li>最好的解决方法:调用者提供一个构造器表达式</li>
<li>传统解决方法:通过反射调用Class.newInstance方法构造泛型类型,较为复杂,Class类本身是泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//makePair方法接收一个Supplier&lt;T&gt;,这是一个函数式接口，表示一个无参数而且返回类型为T的函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Pair&lt;T&gt; <span class="title function_">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(constr.get(),constr.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="866-不能构造泛型数组"><a class="markdownIt-Anchor" href="#866-不能构造泛型数组"></a> 8.6.6 不能构造泛型数组</h3>
<ul>
<li>原因：数组本身也有类型,用来监控存储在虚拟机中的数组.(该类型会被擦除)</li>
<li>老式方法使用反射进行，调用Array.newInstance</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型擦除会让这个方法永远构造Comparable[2]数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T[] minmax(T[] z) &#123;T[] mm= <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">2</span>];,...,&#125; <span class="comment">// Error .</span></span><br><span class="line"><span class="comment">//如果数组仅仅作为一个类的私有实例域，就可以将这个数组声明为Object[]，并且在获取元素时进行类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子ArrayList类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> Object[] elements;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="keyword">return</span> (E) elements[n]; &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> n, E e)</span> &#123; elenents[r] = e; &#125; <span class="comment">// no cast needed</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> E[] elements;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;elements = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];&#125;</span><br><span class="line">  <span class="comment">//强制类型转换E[]是一个假象,而类型擦除使其无法察觉</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于minmax方法返回T[]数组使得这一技术无法施展,如果掩盖这个类型会有运行时错误结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T[] minmax(T... a)</span><br><span class="line">&#123;</span><br><span class="line">  Object[] mm = <span class="keyword">new</span> 0bject[<span class="number">2</span>];</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (T[]) mm; <span class="comment">// compiles with warning</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译时不会有任何警告。当Object[]引用赋给Comparable[]变量时，将会发生ClassCastException异常</span></span><br><span class="line">String[] ss = ArrayAlg.minmax(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;Dick&quot;</span>);</span><br><span class="line"><span class="comment">//解决方案，提供一个数组构造器</span></span><br><span class="line">String[] ss = ArrayAlg.minmax(String[]::<span class="keyword">new</span>,<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;Dick&quot;</span>);</span><br><span class="line"><span class="comment">//构造器表达式String：：new指示一个函数，给定所需的长度，会构造一个指定长度的String数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T[] minmax(IntFunction&lt;T[]&gt; constr, T...a)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="867-泛型类的静态上下文中类型变量无效"><a class="markdownIt-Anchor" href="#867-泛型类的静态上下文中类型变量无效"></a> 8.6.7 泛型类的静态上下文中类型变量无效</h3>
<ul>
<li><mark>不能在静态域或方法中引用类型变量</mark></li>
</ul>
<h3 id="868-不能抛出或捕捉泛型类的实例"><a class="markdownIt-Anchor" href="#868-不能抛出或捕捉泛型类的实例"></a> 8.6.8 不能抛出或捕捉泛型类的实例</h3>
<ul>
<li><mark>既不能抛出也不能捕获泛型类对象.实际上,甚至泛型类扩展Throwable都是不合法的</mark></li>
<li>catch子句中不能使用类型变量(在异常规范中使用类型变量是允许的)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//do work</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (T e) <span class="comment">// Error--can&#x27;t catch type vari able</span></span><br><span class="line">  &#123;</span><br><span class="line">    Logger.global.info.(..)</span><br><span class="line">    t.initCause(realCause);     <span class="comment">//允许</span></span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="869-可以消除对受查异常的检查"><a class="markdownIt-Anchor" href="#869-可以消除对受查异常的检查"></a> 8.6.9 可以消除对受查异常的检查</h3>
<ul>
<li>Java异常处理的一个基本原则,<mark>必须为所有受查异常提供一个处理器</mark></li>
<li>不过可以利用泛型消除这个限制</li>
<li><mark>通过使用泛型类,擦除和@SuppressWarnings注解,就能消除Java类型系统的部分基本限制</mark></li>
</ul>
<h3 id="8610-注意擦除后的冲突"><a class="markdownIt-Anchor" href="#8610-注意擦除后的冲突"></a> 8.6.10 注意擦除后的冲突</h3>
<ul>
<li>当泛型类型被擦除时,无法创建引发冲突的条件</li>
<li>要想支持擦除的转换,就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类,而这两个接口是同一接口的不同参数化</li>
</ul>
</div><div class="story post-story"><h2 id="87-泛型类型的继承规则"><a class="markdownIt-Anchor" href="#87-泛型类型的继承规则"></a> 8.7 泛型类型的继承规则</h2>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-26-20-21-23.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-26-20-21-23.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="泛型类型的继承" /></p>
<ul>
<li>Employee是Manager的超类
<ul>
<li><mark>Pair&lt;Employee&gt;与Pair&lt;Manager&gt;没有任何关系</mark></li>
</ul>
</li>
<li>注意泛型与Java数组之间的区别
<ul>
<li>可以将一个Manager[]数组赋给一个类型为Employee[]的变量,数组带有特别的保护</li>
<li>如果试图将一个低级别的雇员存储到employeeBuddies[0]，虚拟机将会抛出ArrayStoreException异常</li>
</ul>
</li>
<li>永远可以将参数化类型转换为一个原始类型
<ul>
<li>例如,Pair&lt;Employee&gt;是原始类型Pair的一个子类型.</li>
<li>在与遗留代码衔接时,这个转换非常必要</li>
</ul>
</li>
<li>转换成原始类型之后不会产生类型错误
<ul>
<li>当使用getFirst获得外来对象并赋给Manager变量时,与通常一样,会抛出ClassCastException异常</li>
<li>失去的只是泛型程序设计提供的附加安全性</li>
</ul>
</li>
<li><mark>泛型类可以扩展或实现其他的泛型类</mark></li>
</ul>
</div><div class="story post-story"><h2 id="88-通配符类型"><a class="markdownIt-Anchor" href="#88-通配符类型"></a> 8.8 通配符类型</h2>
<h3 id="881-通配符概念"><a class="markdownIt-Anchor" href="#881-通配符概念"></a> 8.8.1 通配符概念</h3>
<ul>
<li>通配符类型中，允许类型参数变化</li>
<li>引入有限定的通配符的关键之处,可以用来区分安全的访问器方法和不安全的更改器方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt;</span><br><span class="line"><span class="comment">//任何泛型Pair类型,它的类型参数是Employee的子类,如Pair&lt;Manager&gt;,但不是Pair&lt;String&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写打印雇员对的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">Employee</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">  <span class="type">Employee</span> <span class="variable">second</span> <span class="operator">=</span> p.getSecond();</span><br><span class="line">  System.out.println(first.getName() + <span class="string">&quot; and &quot;</span> + second.getName() + <span class="string">&quot; are buddies.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&lt;? extends Employee&gt;可以将Employee的子类Manager(Pair&lt;Manager&gt;)传入该方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用通配符不会通过Pair&lt;? extends Employee&gt;的引用破坏Pair&lt;Manager&gt;</span></span><br><span class="line">Pair&lt;Manager&gt; managerBuddies = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(ceo, cfo);</span><br><span class="line">Pair&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt; wildcardBuddies = managerBuddies；<span class="comment">// 0K</span></span><br><span class="line">wildcardBuddies.setFirst(lowlyEmployee); <span class="comment">//对setFirst的调用有一个类型错误</span></span><br><span class="line"><span class="comment">//编译器只知道需要某个Employee的子类型,但不知道具体是什么类型</span></span><br><span class="line"><span class="comment">//它拒绝传递任何特定的类型.毕竟?不能用来匹配</span></span><br><span class="line"><span class="comment">//使用getFirst就不存在这个问题:将getFirst的返回值赋给一个Employee的引用完全合法</span></span><br></pre></td></tr></table></figure>
<h3 id="882-通配符的超类型限定"><a class="markdownIt-Anchor" href="#882-通配符的超类型限定"></a> 8.8.2 通配符的超类型限定</h3>
<ul>
<li>通配符限定与类型变量限定十分类似
<ul>
<li>但是,还有一个附加的能力,即可以指定一个<mark>超类型限定</mark></li>
</ul>
</li>
<li>带有超类型限定的通配符<mark>可以为方法提供参数,但不能使用返回值</mark></li>
<li>带有超类型限定的通配符可以向泛型对象写入,带有子类型限定的通配符可以从泛型对象读取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pair&lt;? super Manager&gt;有方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(? <span class="built_in">super</span> Manager)</span></span><br><span class="line">? <span class="built_in">super</span> Manager <span class="title function_">getFirst</span><span class="params">()</span></span><br><span class="line"><span class="comment">//编译器无法知道setFirst方法的具体类型</span></span><br><span class="line"><span class="comment">//因此调用这个方法时不能接受类型为Employee或Object的参数</span></span><br><span class="line"><span class="comment">//只能传递Manager类型的对象,或者某个子类型(如Executive)对象</span></span><br><span class="line"><span class="comment">//另外,如果调用getFirst,不能保证返回对象的类型.只能把它赋给一个Object</span></span><br><span class="line"></span><br><span class="line">? <span class="built_in">super</span> Manager</span><br><span class="line"><span class="comment">//? 限制为Manager的所有超类型</span></span><br></pre></td></tr></table></figure>
<h3 id="883-无限定通配符"><a class="markdownIt-Anchor" href="#883-无限定通配符"></a> 8.8.3 无限定通配符</h3>
<ul>
<li>使用无限定的通配符,例如,Pair&lt;?&gt;</li>
<li>Pair&lt;?&gt;和Pair本质的不同在于
<ul>
<li>可以用任意Object对象调用原始Pair类的setObject方法</li>
<li>可以调用setFirst(null)</li>
</ul>
</li>
<li>该类型对简单的测试操作有用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="comment">//用来测试一个pair是否包含一个null引用,它不需要实际的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getSecond() == <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过将hasNulls转换成泛型方法,可以避免使用通配符类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">hasNulls</span><span class="params">(Pair&lt;T&gt; p)</span></span><br></pre></td></tr></table></figure>
<h3 id="884-通配符捕获"><a class="markdownIt-Anchor" href="#884-通配符捕获"></a> 8.8.4 通配符捕获</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个交换成对元素的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">  ? t = p.getFirst();</span><br><span class="line">  <span class="comment">//通配符不是类型变量（不能在编写代码中使用“?”作为一种类型)</span></span><br><span class="line">  p.setFirst(p.getSecond());</span><br><span class="line">  p.setSecond(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以编写辅助方法swapHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span>  <span class="title function_">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span> &#123;</span><br><span class="line">  <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">  p.setFirst(p.getSecond());</span><br><span class="line">  p.setSecond(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//swapHelper是一个泛型方法,而swap不是,它具有固定的Pair&lt;?&gt;类型的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以由swap调用swapHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">  swapHelper(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这种情况下，swapHelper方法的参数T捕获通配符</span></span><br><span class="line"><span class="comment">//它不知道是哪种类型的通配符</span></span><br><span class="line"><span class="comment">//但是,这是一个明确的类型,并且&lt;T&gt;swapHelper的定义只有在T指出类型时才有明确的含义</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通配符捕获只有<mark>在有许多限制的情况下才是合法的</mark></li>
<li><mark>编译器必须能够确信通配符表达的是单个,确定的类型</mark></li>
</ul>
</div><div class="story post-story"><h2 id="89-反射和泛型"><a class="markdownIt-Anchor" href="#89-反射和泛型"></a> 8.9 反射和泛型</h2>
<h3 id="891-泛型class类"><a class="markdownIt-Anchor" href="#891-泛型class类"></a> 8.9.1 泛型Class类</h3>
<ul>
<li>Class类是泛型的
<ul>
<li>String.class实际上是Class&lt;String&gt;类的唯一对象</li>
<li>类型参数十分有用，它允许Class&lt;T&gt;方法的返回类型更加具有针对性</li>
</ul>
</li>
</ul>
<h3 id="892-使用classt参数进行类型匹配"><a class="markdownIt-Anchor" href="#892-使用classt参数进行类型匹配"></a> 8.9.2 使用Class&lt;T&gt;参数进行类型匹配</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有时，匹配泛型方法中的Class&lt;T&gt;参数的类型变量很有实用价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">makePair</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> InstantiaticnException,</span><br><span class="line">IllegalAccessException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(c.newInstance(), c.newInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">makePair(Emplyee.class)</span><br><span class="line"><span class="comment">//Employee.class是类型Class&lt;Employee&gt;的一个对象</span></span><br><span class="line"><span class="comment">//makePair方法的类型参数T同Employee匹配，并且编译器可以推断出这个方法将返回一个Pair&lt;Employee&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="893-虚拟机中的泛型类型信息"><a class="markdownIt-Anchor" href="#893-虚拟机中的泛型类型信息"></a> 8.9.3 虚拟机中的泛型类型信息</h3>
<ul>
<li>Java泛型的卓越特性之一是<mark>在虚拟机中泛型类型的擦除</mark></li>
<li>但<mark>擦除的类仍然保留一些泛型祖先的微弱记忆</mark></li>
</ul>
<hr />
<h1 id="9-集合"><a class="markdownIt-Anchor" href="#9-集合"></a> 9 集合</h1>
</div><div class="story post-story"><h2 id="91-java集合框架"><a class="markdownIt-Anchor" href="#91-java集合框架"></a> 9.1 Java集合框架</h2>
<ul>
<li>使用标准库中的集合类</li>
<li>Java最初版本只为最常用的数据结构提供了一组类：Vector,Stack,Hashtable,BitSet与Enumeration接口
<ul>
<li>其中的Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制</li>
</ul>
</li>
</ul>
<h3 id="911-将集合的接口与实现分离"><a class="markdownIt-Anchor" href="#911-将集合的接口与实现分离"></a> 9.1.1 将集合的接口与实现分离</h3>
<ul>
<li><mark>Java集合类库将接口与实现分开</mark></li>
<li>以<mark>队列</mark>为例
<ul>
<li>队列接口指出可以在队列的尾部添加元素,在队列的头部删除元素,并且可以查找队列中元素的个数</li>
<li>当需要收集对象,并按照“先进先出”的规则检索对象时就应该使用队列</li>
<li>队列的实现形式一般由两种:<mark>循环数组,或者链表</mark>
<ul>
<li><strong>每一个实现都可以通过一个实现了Queue接口的类表示</strong><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-28-15-19-15.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-28-15-19-15.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="队列的实现方式" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列接口的最简单形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>(E) &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">  E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularArrayQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> head;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  CircularArrayQueue (<span class="type">int</span> capacity) &#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;..&#125;</span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">private</span> E[] elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用链表实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> Link head;</span><br><span class="line">  <span class="keyword">private</span> Link tail;</span><br><span class="line"></span><br><span class="line">  LinkedListQueue()&#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java类库并没有CircularArrayQueue和LinkedListQueue的类(示例)</span></span><br><span class="line"><span class="comment">//使用接口类型存放集合的引用</span></span><br><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> <span class="title class_">CircularArrayQueue</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">expressLane.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Harry&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用LinkedListQueue实现</span></span><br><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> <span class="title class_">LinkedListQueue</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">expressLane.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Harry));</span></span><br></pre></td></tr></table></figure>
<ul>
<li><mark>需要循环数组队列,使用ArrayDeque类</mark></li>
<li><mark>需要链表队列,使用LinkedList类,这个类实现了Queue接口</mark></li>
<li><mark>循环数组要比链表更高效</mark>
<ul>
<li>循环数组是一个有界集合，即容量有限</li>
<li><mark>如果程序中要收集的对象数量没有上限，就最好使用链表来实现</mark></li>
</ul>
</li>
<li>以Abstract开头的类,例如,AbstractQueue,是为类库实现者而设计的
<ul>
<li>如果要实现自己的队列类扩展AbstractQueue类要比实现Queue接口中的所有方法轻松得多</li>
</ul>
</li>
</ul>
<h3 id="912-collection接口"><a class="markdownIt-Anchor" href="#912-collection接口"></a> 9.1.2 Collection接口</h3>
<ul>
<li>在Java类库中，<mark>集合类的基本接口是Collection接口</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">  Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//add方法用于向集合中添加元素,如果添加元素改变了集合返回true</span></span><br><span class="line"><span class="comment">//iterator方法返回一个实现了Iterator接口的对象(可以使用迭代器对象依次访问集合中的元素)</span></span><br></pre></td></tr></table></figure>
<h3 id="913-迭代器"><a class="markdownIt-Anchor" href="#913-迭代器"></a> 9.1.3 迭代器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Iterator接口的四个方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反复调用next方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，next方法将抛出一个NoSuchElementException</span></span><br><span class="line"><span class="comment">//在调用next之前调用hasNext方法。如果迭代器对象还有多个供访问的元素，这个方法就返回true</span></span><br><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iter.next()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在JavaSE8中，可以使用lambda表达式进行</span></span><br><span class="line">iterator.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><mark>编译器简单的将“for each”循环翻译为带有迭代器的循环</mark></p>
</li>
<li>
<p><mark>“for each”循环可以与任何实现了Iterable接口的对象一起工作</mark></p>
</li>
<li>
<p><mark>Collection接口扩展了Iterable接口,对于标准类库中的任何集合都可以使用“for each”循环</mark></p>
</li>
<li>
<p>元素<mark>被访问的顺序取决于集合类型</mark></p>
<ul>
<li>如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1</li>
<li>如果访问HashSet中的元素，每个元素将会按照某种随机的次序出现。
<ul>
<li>虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序</li>
<li>这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说，并不是什么问题</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Iterator接口的next和hasNext方法与Enumeration接口的nextElement和hasMoreElements方法的作用一样</p>
</li>
<li>
<p>可以将Iterator.next与InputStream.read看作为等效的</p>
</li>
<li>
<p>从数据流中读取一个字节，就会自动地“消耗掉”这个字节。下一次调用read将会消耗并返回输入的下一个字节。用同样的方式，反复地调用next就可以读取集合中所有元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Iterator接口的remove方法将会删除上次调用next方法时返回的元素</span></span><br><span class="line"><span class="comment">//在删除之前，查看该元素是很具有实际意义的</span></span><br><span class="line">it.next();</span><br><span class="line">it.remove();</span><br><span class="line"><span class="comment">//对next方法和remove方法的调用具有互相依赖性</span></span><br><span class="line"><span class="comment">//如果调用remove之前没有调用next将是不合法的。如果这样做，将会抛出一个IllegalStateException异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除相邻的两个元素,必须先调用next</span></span><br><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove();</span><br></pre></td></tr></table></figure>
<h3 id="914-泛型实用方法"><a class="markdownIt-Anchor" href="#914-泛型实用方法"></a> 9.1.4 泛型实用方法</h3>
<ul>
<li>由于Collection与Iterator都是泛型接口，可以编写操作任何集合类型的实用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测任意集合是否包含指定元素的泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; <span class="type">boolean</span> <span class="title function_">constains</span><span class="params">(Collection&lt;E&gt; c, Object obj)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(E element : c)</span><br><span class="line">    <span class="keyword">if</span>(element.equals(obj))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java类库的设计者认为：这些实用方法中的某些方法非常有用，应该将它们提供给用户使用</span></span><br><span class="line"><span class="comment">//类库的使用者就不必自己重新构建这些方法</span></span><br><span class="line"><span class="comment">//contains就是这样一个实用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Collection接口声明的方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object other)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; from)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object obj)</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">Object[] toArray();</span><br><span class="line">&lt;T&gt; T[] toArray(T[] arrayToFill);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果实现Collection接口的每一个类都要提供如此多的例行方法将是一件很烦人的事情</span></span><br><span class="line"><span class="comment">//为了能够让实现者更容易地实现这个接口，Java类库提供了一个类AbstractCollection</span></span><br><span class="line"><span class="comment">//AbstractCollection将基础方法size和iterator抽象化了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于Java SE 8，这种方法有些过时了</span></span><br><span class="line"><span class="comment">//如果这些方法是Collection接口的默认方法会更好,但实际上并不是这样</span></span><br><span class="line"><span class="comment">//不过，确实已经增加了很多默认方法。其中大部分方法都与流的处理有关</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span></span><br><span class="line"><span class="comment">//该方法可以用来删除满足一定条件的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="915-集合框架中的接口"><a class="markdownIt-Anchor" href="#915-集合框架中的接口"></a> 9.1.5 集合框架中的接口</h3>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-28-20-10-51.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-28-20-10-51.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="集合框架的接口" /></p>
<ul>
<li>
<p>集合有两个基本接口</p>
<ul>
<li>Collection</li>
<li>Map</li>
</ul>
</li>
<li>
<p>List是一个有序集合,元素会增加到容器中的特定位置</p>
</li>
<li>
<p>可以采用两种方式访问元素：</p>
<ul>
<li>使用迭代器访问</li>
<li>或使用一个整数索引来访问(随机访问)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以使用add方法在集合中插入元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于映射包含键/值对，需要使用put方法进行插入</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从集合读取元素，使用迭代器访问元素</span></span><br><span class="line"><span class="comment">//从映射中读取值，使用get方法</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//List接口定义了多个用于随机访问的方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ListIterator接口是Iterator的一个子接口,该接口定义了一个方法用于在迭代器位置前面增加一个元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问</p>
</li>
<li>
<p>与之不同，链表尽管也是有序的，但是随机访问很慢，所以最好使用迭代器来遍历</p>
<ul>
<li>为了避免对链表完成随机访问操作，Java SE 1.4引入了一个标记接口<mark>RandomAccess</mark></li>
<li>这个接口不包含任何方法，不过可以用它来<mark>测试一个特定的集合是否支持高效的随机访问</mark></li>
</ul>
</li>
<li>
<p>Set接口等同于Collection接口</p>
<ul>
<li>集(set)的add方法不允许增加重复的元素。要适当地定义集的equals方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。</li>
<li>hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码</li>
</ul>
</li>
<li>
<p><mark>既然方法签名是一样的，为什么还要建立一个单独的接口呢？</mark></p>
<ul>
<li>从概念上讲，并不是所有集合都是集。建立一个Set接口可以让程序员编写只接受集的方法</li>
</ul>
</li>
<li>
<p>SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法</p>
</li>
<li>
<p>Java SE 6引入了接口NavigableSet和NavigableMap，其中包含一些用于搜索和遍历有序集和映射的方法</p>
</li>
<li>
<p>TreeSet和TreeMap类实现了这些接口</p>
<ul>
<li>理想情况下，这些方法本应当直接包含在SortedSet和SortedMap接口中</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="92-具体的集合"><a class="markdownIt-Anchor" href="#92-具体的集合"></a> 9.2 具体的集合</h2>
<ul>
<li>除了以Map结尾的类之外，<mark>其他类都实现了Collection接口</mark></li>
<li>以Map结尾的类，<mark>实现了Map接口</mark></li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-28-20-35-52.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-28-20-35-52.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Java库中的具体集合" /><br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-28-20-36-29.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-11-28-20-36-29.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="集合框架中的类" /></p>
<h3 id="921-链表"><a class="markdownIt-Anchor" href="#921-链表"></a> 9.2.1 链表</h3>
<ul>
<li>
<p>数组及动态ArrayList类，<mark>存在重大缺陷，在中间位置删除元素(或添加元素)困难</mark></p>
<ul>
<li>原因：数组中处于被删除元素之后的所有元素都要向数组的前端移动</li>
</ul>
</li>
<li>
<p>链表可以解决这个问题</p>
<ul>
<li>链表的每个对象存放在独立的结点上，每个结点上还存放着序列中下一个结点的引用</li>
<li><mark>Java中的链表为双向链表，每个结点还存放着指向前驱结点的引用</mark></li>
<li>删除一个元素即更新被删除元素附近的链接</li>
</ul>
</li>
<li>
<p>集合库中LinkedList类用于实现链表的操作</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先添加3个元素，然后将第2个元素删除</span></span><br><span class="line">List&lt;string&gt; staff = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//LinkedList implements List</span></span><br><span class="line">staff.add (<span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line">Iterator iter= staff.iterator();</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> iter.next();<span class="comment">//visit first element</span></span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> iter.next()<span class="comment">// visit second element</span></span><br><span class="line">iter.remove;  <span class="comment">// remove last visited element</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//集合类库提供了子接口ListIterator，其中包含add方法</span></span><br><span class="line"><span class="comment">//与Collection.add不同，该方法不返回boolean类型的值，它假定添加操作总会改变链表</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E elements)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ListIterator 反向遍历链表的方法</span></span><br><span class="line">E <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedList类 listIterator方法 返回一个实现了ListIterator接口的迭代器对象</span></span><br><span class="line">ListIterator&lt;String&gt; iter = staff.listIterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第二个元素之前添加元素</span></span><br><span class="line">List&lt;String&gt; staff =  <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line">ListIterator&lt;String&gt; iter =  staff.listlterator();</span><br><span class="line">iter.next();  <span class="comment">// skip past first element</span></span><br><span class="line">iter.add(<span class="string">&quot;Juliet&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果多次调用add方法，将按照提供的次序把元素添加到链表中。它们被依次添加到迭代器当前位置之前</span></span><br><span class="line"><span class="comment">//当用一个刚刚由Iterator方法返回，并且指向链表表头的迭代器调用add操作时，新添加的元素将变成列表的新表头</span></span><br><span class="line"><span class="comment">//当迭代器越过链表的最后一个元素时(即hasNext返回false)，添加的元素将变成列表的新表尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedList类还是提供了一个用来访问某个特定元素的get方法</span></span><br><span class="line"><span class="comment">//get方法做了微小的优化：如果索引大于size()/2就从列表尾端开始搜索元素</span></span><br><span class="line">LinkedList&lt;String&gt; list = ...;</span><br><span class="line"><span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(n);</span><br><span class="line"><span class="comment">//该方法的效率并不太高</span></span><br><span class="line"><span class="comment">//如果发现自己正在使用这个方法，说明有可能对于所要解决的问题使用了错误的数据结构</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>链表与泛型集合之间有一个重要的区别</p>
<ul>
<li><mark>链表是一个有序集合</mark>，每个对象的位置十分重要。LinkedList.add方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的，所以这种依赖于位置的add方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义</li>
<li>集(set)类型，其中的元素完全无序</li>
<li>在Iterator接口中就没有add方法。相反地，集合类库提供了子接口ListIterator，其中包含add方法</li>
</ul>
</li>
<li>
<p>add方法只依赖于迭代器的位置，而remove方法依赖于迭代器的状态</p>
</li>
<li>
<p>set方法用一个新元素取代调用next或previous方法返回的上一个元素</p>
</li>
<li>
<p>如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状况</p>
</li>
<li>
<p>例如，一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，并且不应该再使用。链表迭代器的设计使它能够检测到这种修改。如果迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个ConcurrentModificationException异常</p>
</li>
<li>
<p>可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器</p>
</li>
<li>
<p>有一种简单的方法可以检测到并发修改的问题。集合可以跟踪改写操作(诸如添加或删除元素)的次数。每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。如果不一致，抛出一个Concurrent ModificationException异常</p>
</li>
<li>
<p>链表只负责跟踪对列表的结构性修改，例如，添加元素、删除元素。set方法不被视为结构性修改</p>
</li>
<li>
<p>链表不支持快速地随机访问</p>
</li>
<li>
<p>LinkedList对象根本不做任何缓存位置信息的操作</p>
</li>
<li>
<p>列表迭代器接口还有一个方法，可以告之当前位置的索引</p>
</li>
<li>
<p>实际上，从概念上讲，由于Java迭代器指向两个元素之间的位置，所以可以同时产生两个索引：</p>
<ul>
<li>nextIndex方法返回下一次调用next方法时返回元素的整数索引</li>
<li>previousIndex方法返回下一次调用previous方法时返回元素的整数索引。当然，这个索引只比nextIndex返回的索引值小1</li>
</ul>
</li>
<li>
<p>list.listIterator(n)将返回一个迭代器，这个迭代器指向索引为n的元素前面的位置。也就是说，调用next与调用list.get(n)会产生同一个元素，只是获得这个迭代器的效率比较低</p>
</li>
<li>
<p>使用链表的唯一理由是尽可能地减少在列表中间插入或删除元素所付出的代价。如果列表只有少数几个元素，就完全可以使用ArrayList</p>
</li>
<li>
<p>免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就使用数组或ArrayList，而不要使用链表</p>
</li>
</ul>
<h3 id="922-数组列表"><a class="markdownIt-Anchor" href="#922-数组列表"></a> 9.2.2 数组列表</h3>
<ul>
<li>List接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用get和set方法随机地访问每个元素。后者不适用于链表，但对数组却很有用</li>
<li>ArrayList封装了一个动态再分配的对象数组</li>
<li>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象。但是，如果由一个线程访问Vector，代码要在同步操作上耗费大量的时间。这种情况还是很常见的。<mark>而ArrayList方法不是同步的，因此，建议在不需要同步时使用ArrayList，而不要使用Vector</mark></li>
</ul>
<h3 id="923-散列集"><a class="markdownIt-Anchor" href="#923-散列集"></a> 9.2.3 散列集</h3>
<ul>
<li>可以快速地查找所需要的对象，这就是散列表</li>
<li>散列表为每个对象计算一个整数，称为散列码。散列码是由对象的实例域产生的一个整数。更准确地说，具有不同数据域的对象将产生不同的散列码</li>
<li>最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关</li>
<li>在Java中，散列表用链表数组实现。每个列表被称为桶。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引</li>
<li>有时候会遇到桶被占满的情况，这也是不可避免的。这种现象被称为散列冲突
<ul>
<li>这时，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少</li>
</ul>
</li>
<li>如果想更多地控制散列表的运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能
<ul>
<li>通常，将桶数设置为预计元素个数的75%~150%</li>
<li>有些研究人员认为：尽管还没有确凿的证据，但最好将桶数设置为一个素数，以防键的集聚。标准类库使用的桶数是2的幂，默认值为16</li>
</ul>
</li>
<li>如果散列表太满，就需要再散列。如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。装填因子决定何时对散列表进行再散列
<ul>
<li>对于大多数应用程序来说，装填因子为0.75是比较合理的</li>
</ul>
</li>
<li>散列表可以用于实现几个重要的数据结构。其中最简单的是set类型。set是没有重复元素的元素集合。set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去</li>
<li>Java集合类库提供了一个HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains方法已经被重新定义，用来快速地查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素</li>
<li>只有不关心集合中元素的顺序时才应该使用HashSet</li>
</ul>
<h3 id="924-树集"><a class="markdownIt-Anchor" href="#924-树集"></a> 9.2.4 树集</h3>
<ul>
<li>树集是一个有序集合；可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现</li>
<li>正如TreeSet类名所示，排序是用树结构完成的(当前实现使用的是红黑树(red-black tree)
<ul>
<li>要使用树集，必须能够比较元素。这些元素必须实现Comparable接口，或者构造集时必须提供一个Comparator</li>
</ul>
</li>
<li>将一个元素添加到树中要比添加到散列表中慢。但是，与检查数组或链表中的重复元素相比还是快很多。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较</li>
<li>从Java SE 6起，TreeSet类实现了NavigableSet接口。这个接口增加了几个便于定位元素以及反向遍历的方法</li>
<li>树集和散列集的区别？
<ul>
<li>如果不需要对数据进行排序，就没有必要付出排序的开销。更重要的是，对于某些数据来说，对其排序要比散列函数更加困难。散列函数只是将对象适当地打乱存放，而比较却要精确地判别每个对象</li>
</ul>
</li>
</ul>
<h3 id="925-队列与双端队列"><a class="markdownIt-Anchor" href="#925-队列与双端队列"></a> 9.2.5 队列与双端队列</h3>
<p>Java SE 6中引入了Deque接口，并由ArrayDeque和LinkedList类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度</p>
<h3 id="926-优先级队列"><a class="markdownIt-Anchor" href="#926-优先级队列"></a> 9.2.6 优先级队列</h3>
<ul>
<li>优先级队列中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序</li>
<li>优先级队列使用了一个优雅且高效的数据结构，称为堆
<ul>
<li>堆是一个可以自我调整的二叉树，对树执行添加(add)和删除(remore)操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序</li>
</ul>
</li>
<li>与TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象</li>
<li>使用优先级队列的典型示例是任务调度。每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除(由于习惯上将1设为“最高”优先级，所以会将最小的元素删除)</li>
</ul>
</div><div class="story post-story"><h2 id="93-映射"><a class="markdownIt-Anchor" href="#93-映射"></a> 9.3 映射</h2>
<ul>
<li>集是一个集合，它可以快速地查找现有的元素。但是，要查看一个元素，需要有要查找元素的精确副本。这不是一种非常通用的查找方式</li>
<li>映射用来存放键/值对。如果提供了键，就能够查找到值</li>
</ul>
<h3 id="931-基本映射操作"><a class="markdownIt-Anchor" href="#931-基本映射操作"></a> 9.3.1 基本映射操作</h3>
<ul>
<li>
<p>Java类库为映射提供了两个通用的实现：</p>
<ul>
<li>HashMap和TreeMap</li>
<li>这两个类都实现了Map接口</li>
</ul>
</li>
<li>
<p>散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树</p>
</li>
<li>
<p>散列或比较函数只能作用于键。与键关联的值不能进行散列或比较</p>
</li>
<li>
<p>应该选择散列映射还是树映射呢？</p>
</li>
<li>
<p>与集一样，散列稍微快一些，如果不需要按照排列顺序访问键，就最好选择散列</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为存储的员工信息建立一个散列映射</span></span><br><span class="line">Map&lt;String, Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">Employee</span> <span class="variable">harry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry Hacker&quot;</span>);</span><br><span class="line">staff.put(<span class="string">&quot;987-98-9969&quot;</span>, harry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每当往映射中添加对象时，必须同时提供一个键</span></span><br><span class="line"><span class="comment">//在这里，键是一个字符串，对应的值是Employee对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要想检索一个对象，必须使用(因而，必须记住)一个键</span></span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;987-98-9996&quot;</span>;</span><br><span class="line">e = staff.get(id);</span><br><span class="line"><span class="comment">//使用getOrDefault方法，在映射中没有与给定键对应的信息，返回一个默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//键必须是唯一的。不能对同一个键存放两个值</span></span><br><span class="line"><span class="comment">//如果对同一个键两次调用put方法，第二个值就会取代第一个值。实际上，put将返回用这个键参数存储的上一个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//remove方法用于从映射中删除给定键对应的元素</span></span><br><span class="line"><span class="comment">//size方法用于返回映射中的元素数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要迭代处理映射的键和值，最容易的方法是使用forEach方法</span></span><br><span class="line"><span class="comment">//可以提供一个接收键和值的lambda表达式。映射中的每一项会依序调用这个表达式</span></span><br><span class="line">scores.forEach((k, v) -&gt; </span><br><span class="line">              System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot;, value=&quot;</span> + v));</span><br></pre></td></tr></table></figure>
<h3 id="932-更新映射项"><a class="markdownIt-Anchor" href="#932-更新映射项"></a> 9.3.2 更新映射项</h3>
<ul>
<li>处理映射时的一个难点就是<mark>更新映射项</mark></li>
<li>正常情况下，可以得到与一个键关联的原值，完成更新，再放回更新后的值</li>
<li><strong>考虑一个特殊情况，即键第一次出现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个映射统计一个单词在文件中出现的频度。看到一个单词(word)时，计数器增1</span></span><br><span class="line">counts.put(word, counts.get(word) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//就是第一次看到word时。在这种情况下，get会返回null，因此会出现一个NullPointerException异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法1</span></span><br><span class="line"><span class="comment">//getOrDefault方法</span></span><br><span class="line">counts.put(word, counts.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法2</span></span><br><span class="line"><span class="comment">//首先调用putIfAbsent方法。只有当键原先存在时才会放入一个值</span></span><br><span class="line">counts.putIfAbsent(word, <span class="number">0</span>);</span><br><span class="line">counts.put(word, counts.get(word) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法3</span></span><br><span class="line"><span class="comment">//merge方法可以简化这个常见的操作。如果键原先不存在，下面的调用</span></span><br><span class="line">counts.merge(word, <span class="number">1</span>, Integer::sum);</span><br><span class="line"><span class="comment">//将把word与1关联，否则使用Integer：：sum函数组合原值和1(也就是将原值与1求和)</span></span><br></pre></td></tr></table></figure>
<h3 id="933-映射视图"><a class="markdownIt-Anchor" href="#933-映射视图"></a> 9.3.3 映射视图</h3>
<ul>
<li>集合框架不认为映射本身是一个集合。(其他数据结构框架认为映射是一个键/值对集合，或者是由键索引的值集合。)</li>
<li>不过，可以得到映射的视图,这是实现了Collection接口或某个子接口的对象</li>
<li>有3种视图：键集、值集合(不是一个集)以及键/值对集</li>
<li>键和键/值对可以构成一个集，因为映射中一个键只能有一个副本</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别返回键集、值集合(不是一个集)以及键/值对集</span></span><br><span class="line"><span class="comment">//(条目集的元素是实现Map.Entry接口的类的对象。)</span></span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span></span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span></span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</span><br><span class="line"></span><br><span class="line"><span class="comment">//keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象</span></span><br><span class="line"><span class="comment">//Set接口扩展了Collection接口。因此，可以像使用集合一样使用keySet</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举一个映射的所有键</span></span><br><span class="line">Set&lt;string&gt; keys= map.keySet();</span><br><span class="line"><span class="keyword">for</span> (string key: keys)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span> something with key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时查看键和值，可以通过枚举条目来避免查找值</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Employee&gt; entry: staff, entrySet())</span><br><span class="line">&#123;</span><br><span class="line">  String k=entry.getKey();</span><br><span class="line">  Employee v= entry.getvalue();</span><br><span class="line">  <span class="keyword">do</span> something with k, v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如今可以使用forEach方法</span></span><br><span class="line">counts.forEach((k, v) -&gt; &#123;<span class="keyword">do</span> something with k, v&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在键集视图上调用迭代器的remove方法，实际上会从映射中删除这个键和与它关联的值。</span></span><br><span class="line"><span class="comment">//不过，不能向键集视图增加元素。</span></span><br><span class="line"><span class="comment">//另外，如果增加一个键而没有同时增加值也是没有意义的。</span></span><br><span class="line"><span class="comment">//如果试图调用add方法，它会抛出一个UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>
<h3 id="934-弱散列映射"><a class="markdownIt-Anchor" href="#934-弱散列映射"></a> 9.3.4 弱散列映射</h3>
<ul>
<li>设计WeakHashMap类是为了解决一个有趣的问题
<ul>
<li>如果有一个值，对应的键已经不再使用了，将会出现什么情况呢？假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现这个键，所以，这个键/值对无法从映射中删除</li>
</ul>
</li>
<li>垃圾回收器跟踪活动的对象。只要映射对象是活动的，其中的所有桶也是活动的，它们不能被回收</li>
<li>当对键的唯一引用来自散列条目时，这一数据结构将与垃圾回收器协同工作一起删除键/值对</li>
<li>WeakHashMap使用弱引用(weak references)保存键。WeakReference对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，WeakHashMap将删除对应的条目</li>
</ul>
<h3 id="935-链接散列集与映射"><a class="markdownIt-Anchor" href="#935-链接散列集与映射"></a> 9.3.5 链接散列集与映射</h3>
<ul>
<li>LinkedHashSet和LinkedHashMap类用来记住插入元素项的顺序。这样就可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中</li>
<li><mark>访问顺序对于实现高速缓存的“最近最少使用”原则十分重要</mark></li>
</ul>
<h3 id="936-枚举集与映射"><a class="markdownIt-Anchor" href="#936-枚举集与映射"></a> 9.3.6 枚举集与映射</h3>
<ul>
<li>EnumSet是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现。如果对应的值在集中，则相应的位被置为1</li>
<li>EnumMap是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EnumSet类没有公共的构造器。可以使用静态工厂方法构造这个集</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;monday, tuesday, wednesday, thursday, friday, saturday, sunday&#125;;</span><br><span class="line">EnumSet&lt;weekday&gt; always= EnumSet.allOf(Weekday.class);</span><br><span class="line">Enum Set&lt;weekday&gt; never= EnumSet.noneof (Weekday.class);</span><br><span class="line">EnunSet&lt;Weekday&gt; workday= EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY)</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);</span><br><span class="line"><span class="comment">//可以使用Set接口的常用方法来修改EnumSet。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//EnumMap在使用时，需要在构造器中指定键类型</span></span><br><span class="line">EnumMap&lt;Weekday, Employee&gt; personInCharge <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(weekday.class);</span><br></pre></td></tr></table></figure>
<h3 id="937-标识散列映射"><a class="markdownIt-Anchor" href="#937-标识散列映射"></a> 9.3.7 标识散列映射</h3>
<ul>
<li>类IdentityHashMap有特殊的作用</li>
<li>在这个类中，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的</li>
<li>这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。而且，在对两个对象进行比较时，IdentityHashMap类使用==，而不使用equals
<ul>
<li>也就是说，不同的键对象，即使内容相同，也被视为是不同的对象。在实现对象遍历算法(如对象串行化)时，这个类非常有用，可以用来跟踪每个对象的遍历状况</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="94-视图与包装器"><a class="markdownIt-Anchor" href="#94-视图与包装器"></a> 9.4 视图与包装器</h2>
<ul>
<li>通过使用视图可以获得其他的实现了Collection接口和Map接口的对象</li>
<li>keySet方法返回一个实现Set接口的类对象，这个类的方法对原映射进行操作。这种集合称为视图。</li>
</ul>
<h3 id="941-轻量级集合包装器"><a class="markdownIt-Anchor" href="#941-轻量级集合包装器"></a> 9.4.1 轻量级集合包装器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器</span></span><br><span class="line"><span class="comment">//这个方法可以将数组传递给一个期望得到列表或集合参数的方法</span></span><br><span class="line">Card[] cardDeck = <span class="keyword">new</span> <span class="title class_">Card</span>[<span class="number">52</span>];</span><br><span class="line">...</span><br><span class="line">List&lt;Card&gt; cradList = Array.asList(cardDeck);</span><br><span class="line"><span class="comment">//返回的对象不是ArrayList,而是一个视图对象，带有访问底层数组的get和set方法</span></span><br><span class="line"><span class="comment">//改变数组大小的所有方法都会抛出一个Unsupported OperationException异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//asList方法可以接收可变数目的参数</span></span><br><span class="line">List&lt;String&gt; names = Array.asList(<span class="string">&quot;Amy&quot;</span>,<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line"><span class="comment">//该方法实际调用Collection接口的npCopies方法，返回一个实现了List接口的不可修改的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意区分Collections类和Collection接口</span></span><br><span class="line">Collections.singleton(anObject);</span><br><span class="line"><span class="comment">//返回一个视图对象，该对象实现了Set接口</span></span><br><span class="line"><span class="comment">//返回的对象实现了一个不可修改的单元素集，而不需要付出建立数据结构的开销</span></span><br><span class="line"><span class="comment">//singletonList方法与singletonMap方法类似</span></span><br></pre></td></tr></table></figure>
<h3 id="942-子范围"><a class="markdownIt-Anchor" href="#942-子范围"></a> 9.4.2 子范围</h3>
<ul>
<li>可以为很多集合建立子范围视图</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设有一个列表staff，想从中取出第10个~第19个元素。可以使用subList方法来获得一个列表的子范围视图</span></span><br><span class="line"><span class="type">List</span> <span class="variable">group2</span> <span class="operator">=</span> staff.subList(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将任何操作应用于子范围，并且能够自动地反映整个列表的情况</span></span><br><span class="line"><span class="comment">//可以删除整个子范围</span></span><br><span class="line">group2.clear();</span><br><span class="line"><span class="comment">//元素自动地从staff列表中清除了，并且group2为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于有序集和映射，可以使用排序顺序而不是元素位置建立子范围</span></span><br><span class="line"><span class="comment">//SortedSet接口声明了3个方法</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E from, E to)</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E to)</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E from)</span></span><br><span class="line"><span class="comment">//这些方法将返回大于等于from且小于to的所有元素子集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有序映射类似的方法</span></span><br><span class="line"><span class="comment">//返回映射视图，该映射包含键落在指定范围内的所有元素</span></span><br><span class="line">SortedMap&lt;K, V&gt; <span class="title function_">subMap</span><span class="params">(K from, K to)</span></span><br><span class="line">SortedMap&lt;K, V&gt; <span class="title function_">headMap</span><span class="params">(K to)</span></span><br><span class="line">SortedMap&lt;K, V&gt; <span class="title function_">tailMap</span><span class="params">(K from)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Java SE 6引入的NavigableSet接口赋予子范围操作更多的控制能力。可以指定是否包括边界</span></span><br></pre></td></tr></table></figure>
<h3 id="943-不可修改的视图"><a class="markdownIt-Anchor" href="#943-不可修改的视图"></a> 9.4.3 不可修改的视图</h3>
<ul>
<li>
<p>Collections还有几个方法，用于产生集合的不可修改视图</p>
</li>
<li>
<p>这些视图对现有集合增加了一个运行时的检查。如果发现试图对集合进行修改，就抛出一个异常，同时这个集合将保持未修改的状态</p>
</li>
<li>
<p><mark>不可修改视图并不是集合本身不可修改</mark></p>
<ul>
<li>仍然可以通过集合的原始引用对集合进行修改。并且仍然可以让集合的元素调用更改器方法</li>
</ul>
</li>
<li>
<p><mark>由于视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法</mark></p>
<ul>
<li>例如，LinkedList类有一些非常方便的方法，addFirst和addLast，它们都不是List接口的方法，不能通过不可修改视图进行访问</li>
</ul>
</li>
<li>
<p>警告：unmodifiableCollection方法(与本节稍后讨论的synchronizedCollection和checked Collection方法一样)将返回一个集合，它的equals方法不调用底层集合的equals方法</p>
</li>
<li>
<p>相反，它继承了Object类的equals方法，这个方法只是检测两个对象是否是同一个对象。如果将集或列表转换成集合，就再也无法检测其内容是否相同了。视图就是以这种方式运行的，因为内容是否相等的检测在分层结构的这一层上没有定义妥当。视图将以同样的方式处理hashCode方法。</p>
</li>
<li>
<p>然而，unmodifiableSet类和unmodifiableList类却使用底层集合的equals方法和hashCode方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得不可修改的视图</span></span><br><span class="line">Collections.unmodifiableCollection</span><br><span class="line">Collections.unmodifiableList</span><br><span class="line">Collections.unmodifiableSet</span><br><span class="line">Collections.unmodifiableSortedSet</span><br><span class="line">Collections.unmodifiableNavigableSet</span><br><span class="line">Collections.unmodifiableMap</span><br><span class="line">Collections.unmodifiableSortedMap</span><br><span class="line">Collections.unmodifiableNavigableMap</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个方法都定义于一个接口</span></span><br><span class="line"><span class="comment">//例如，Collections.unmodifiableList与ArrayList、LinkedList或者任何实现了List接口的其他类一起协同工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如，假设想要查看某部分代码，但又不触及某个集合的内容</span></span><br><span class="line">List&lt;String&gt; staff= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">lookAt(Collections.unmodifiableList(staff));</span><br><span class="line"><span class="comment">//Collections.unmodifiableList方法将返回一个实现List接口的类对象</span></span><br><span class="line"><span class="comment">//其访问器方法将从staff集合中获取值。当然，lookAt方法可以调用List接口中的所有方法，而不只是访问器</span></span><br><span class="line"><span class="comment">//但是所有的更改器方法(例如，add)已经被重新定义为抛出一个UnsupportedOperationException异常，而不是将调用传递给底层集合</span></span><br></pre></td></tr></table></figure>
<h3 id="944-同步视图"><a class="markdownIt-Anchor" href="#944-同步视图"></a> 9.4.4 同步视图</h3>
<ul>
<li>如果由多个线程访问集合，就必须确保集不会被意外地破坏
<ul>
<li>例如，如果一个线程试图将元素添加到散列表中，同时另一个线程正在对散列表进行再散列，其结果将是灾难性的</li>
</ul>
</li>
<li>类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如，Collections类的静态synchronizedMap方法可以将任何一个映射表转换成具有同步访问方法的Map</span></span><br><span class="line">Map&lt;String, Employee&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Empl oyee&gt;());</span><br><span class="line"><span class="comment">//可以由多线程访问map对象了。像get和put这类方法都是同步操作的，即在另一个线程调用另一个方法之前，刚才的方法调用必须彻底完成</span></span><br></pre></td></tr></table></figure>
<h3 id="945-受查视图"><a class="markdownIt-Anchor" href="#945-受查视图"></a> 9.4.5 受查视图</h3>
<ul>
<li>“受查”视图用来对泛型类型发生问题时提供调试支持</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将错误类型的元素混入泛型集合中的问题极有可能发生</span></span><br><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&gt;();</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">rawList</span> <span class="operator">=</span> strings; </span><br><span class="line">rawList.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">//这个错误的add命令在运行时检测不到。相反，只有在稍后的另一部分代码中调用get方法，并将结果转化为String时，这个类才会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//受查视图可以探测到这类问题</span></span><br><span class="line"><span class="comment">//定义了一个安全列表,视图的add方法将检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个ClassCastException</span></span><br><span class="line">List&lt;String&gt; safeStrings = Collections.checkedList(strings, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//受查视图受限于虚拟机可以运行的运行时检查</span></span><br><span class="line"><span class="comment">//例如，对于ArrayList&lt;Pair&lt;String&gt;&gt;，由于虚拟机有一个单独的“原始”Pair类，所以，无法阻止插入Pair&lt;Date&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="946-关于可选操作的说明"><a class="markdownIt-Anchor" href="#946-关于可选操作的说明"></a> 9.4.6 关于可选操作的说明</h3>
<ul>
<li>通常，视图有一些局限性，即可能只可以读、无法改变大小、只支持删除而不支持插入，这些与映射的键视图情况相同</li>
<li>如果试图进行不恰当的操作，受限制的视图就会抛出一个UnsupportedOperationException</li>
<li>是否应该将“可选”方法这一技术扩展到用户的设计中呢？
<ul>
<li>我们认为不应该。尽管集合被频繁地使用，其实现代码的风格也未必适用于其他问题领域。集合类库的设计者必须解决一组特别严格且又相互冲突的需求。用户希望类库应该易于学习、使用方便，彻底泛型化，面向通用性，同时又与手写算法一样高效。要同时达到所有目标的要求，或者尽量兼顾所有目标完全是不可能的。但是，在自己的编程问题中，很少遇到这样极端的局限性。应该能够找到一种不必依靠极端衡量“可选的”接口操作来解决这类问题的方案</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="95-算法"><a class="markdownIt-Anchor" href="#95-算法"></a> 9.5 算法</h2>
<ul>
<li>泛型集合接口具有一个很大的优点：<mark>算法只需要实现一次</mark></li>
</ul>
<h3 id="951-排序与混排"><a class="markdownIt-Anchor" href="#951-排序与混排"></a> 9.5.1 排序与混排</h3>
<ul>
<li>Collections类中的sort方法可以对实现了List接口的集合进行排序</li>
<li>排序算法接收的列表，<mark>必须是可以修改的</mark>，但不必是可以改变大小的
<ul>
<li>如果列表支持set方法，则是可修改的</li>
<li>如果列表支持add和remove方法，则是可改变大小的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collections类中的sort方法排序,该假定列表元素实现了Comparable接口</span></span><br><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">fill collection</span><br><span class="line">Collections.sort(staff);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想采用其他方式对列表进行排序，可以使用List接口的sort方法并传入一个Comparator对象</span></span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));</span><br><span class="line"><span class="comment">//对工资进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按照降序对列表进行排序，可以使用一种非常方便的静态方法Collections.reverse-Order()</span></span><br><span class="line"><span class="comment">//该方法将返回一个比较器，比较器则返回b.compareTo(a)</span></span><br><span class="line">staff.sort(Comparator.reverseOrder());</span><br><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed());</span><br><span class="line"></span><br><span class="line"><span class="comment">//混排列表中的元素(Collections类有一个算法shuffle)</span></span><br><span class="line">ArrayList&lt;Card&gt; cards = ...;</span><br><span class="line">Collections.shuffle(cards);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java程序设计语言直接将所有元素转入一个数组，对数组进行排序，然后，再将排序后的序列复制回列表</span></span><br><span class="line"><span class="comment">//集合类库中使用的排序算法比快速排序要慢一些，快速排序是通用排序算法的传统选择。但是，归并排序有一个主要的优点：稳定，即不需要交换相同的元素。</span></span><br></pre></td></tr></table></figure>
<h3 id="952-二分查找"><a class="markdownIt-Anchor" href="#952-二分查找"></a> 9.5.2 二分查找</h3>
<ul>
<li>要想在数组中查找一个对象，通常要依次访问数组中的每个元素，直到找到匹配的元素为止</li>
<li>如果数组是有序的，就可以直接查看位于数组中间的元素，看一看是否大于要查找的元素
<ul>
<li>如果是，用同样的方法在数组的前半部分继续查找；</li>
<li>否则，用同样的方法在数组的后半部分继续查找。这样就可以将查找范围缩减一半</li>
</ul>
</li>
<li>Collections类的binarySearch方法实现了这个算法</li>
<li>注意，集合必须是排好序的，否则算法将返回错误的答案</li>
<li>要想查找某个元素，必须提供集合
<ul>
<li>(这个集合要实现List接口，如果集合没有采用Comparable接口的compareTo方法进行排序，就还要提供一个比较器对象)</li>
</ul>
</li>
<li>只有采用随机访问，二分查找才有意义
<ul>
<li>如果必须利用迭代方式一次次地遍历链表的一半元素来找到中间位置的元素，二分查找就完全失去了优势</li>
<li>因此，如果为binarySearch算法提供一个链表，它将自动地变为线性查找</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">i = Collections.binarySearch(c, element);</span><br><span class="line">i = Collections.binarySearch(c, element, comparator);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果binarySearch方法返回的数值大于等于0，则表示匹配对象的索引</span></span><br><span class="line"><span class="comment">//也就是说，c.get(i)等于在这个比较顺序下的element</span></span><br><span class="line"><span class="comment">//如果返回负值，则表示没有匹配的元素</span></span><br><span class="line"><span class="comment">//但是，可以利用返回值计算应该将element插入到集合的哪个位置，以保持集合的有序性</span></span><br><span class="line"><span class="comment">//插入的位置是</span></span><br><span class="line">insertionPoint =-i-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//这并不是简单的–i，因为0值是不确定的</span></span><br><span class="line"><span class="comment">//也就是说</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">  c.add(-i-<span class="number">1</span>, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将把元素插入到正确的位置上。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从有序列表中搜索一个键，如果元素扩展了AbstractSequentialList类，则采用线性查找，否则将采用二分查找。</li>
<li><mark>二分查找的时间复杂度</mark>为O(a(n)log n)，n是列表的长度，a(n)是访问一个元素的平均时间。这个方法将返回这个键在列表中的索引，如果在列表中不存在这个键将返回负值i。在这种情况下，应该将这个键插入到列表索引—i—1的位置上，以保持列表的有序性</li>
</ul>
<h3 id="953-简单算法"><a class="markdownIt-Anchor" href="#953-简单算法"></a> 9.5.3 简单算法</h3>
<ul>
<li>其他的简单算法：
<ul>
<li>将一个列表中的元素复制到另外一个列表中</li>
<li>用一个常量值填充容器</li>
<li>逆置一个列表的元素顺序</li>
</ul>
</li>
<li>Java SE 8增加了默认方法Collection.removeIf和List.replaceAll，这两个方法需要提供一个lambda表达式来测试或转换元素</li>
</ul>
<h3 id="954-批操作"><a class="markdownIt-Anchor" href="#954-批操作"></a> 9.5.4 批操作</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很多操作会成批复制或删除元素</span></span><br><span class="line">coll1.removeAll(coll2);</span><br><span class="line"><span class="comment">//将从coll1中删除coll2中出现的所有元素</span></span><br><span class="line">coll1.retainAll(coll2);</span><br><span class="line"><span class="comment">//从coll1中删除所有未在coll2中出现的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设有一个映射，将员工ID映射到员工对象，并且建立了一个将不再聘用的所有员工的ID</span></span><br><span class="line">Map&lt;String, Employee&gt; staffMap = ...;</span><br><span class="line">Set&lt;String&gt; terminatedIDs = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立一个链表，并删除种植聘用关系的所有员工ID</span></span><br><span class="line">staffMap.keySet().removeAll(terminatedIDs);</span><br><span class="line"><span class="comment">//由于键集是映射的一个视图，所以键和相关联的员工名会自动从映射中删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过使用一个子范围视图，可以把批操作限制在子列表和子集上。例如，假设希望把一个列表的前10个元素增加到另一个容器，可以建立一个子列表选出前10个元素：</span></span><br><span class="line">relocated.addAll(staff.sublist(<span class="number">0</span>,<span class="number">10</span>));</span><br><span class="line"><span class="comment">//这个子范围还可以完成更改操作</span></span><br><span class="line">staff.subList(<span class="number">0</span>,<span class="number">10</span>).clear();</span><br></pre></td></tr></table></figure>
<h3 id="955-集合与数组的转换"><a class="markdownIt-Anchor" href="#955-集合与数组的转换"></a> 9.5.5 集合与数组的转换</h3>
<ul>
<li>
<p>如果需要把一个数组转换为集合，Arrays.asList包装器可以达到这个目的</p>
</li>
<li>
<p>从集合得到数组会更困难一些。当然，可以使用toArray方法</p>
<ul>
<li>不过，这样做的结果是一个对象数组。</li>
<li><mark>尽管你知道集合中包含一个特定类型的对象，但不能使用强制类型转换</mark></li>
<li>toArray方法返回的数组是一个Object[]数组，不能改变它的类型。实际上，必须使用toArray方法的一个变体形式，提供一个所需类型而且长度为0的数组。这样一来，返回的数组就会创建为相同的数组类型</li>
</ul>
</li>
<li>
<p>为什么不能直接将一个Class对象(如String.class)传递到toArray方法</p>
<ul>
<li>原因是这个方法有“双重职责”，不仅要填充一个已有的数组，还要创建一个新数组</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组转换为集合</span></span><br><span class="line">String[] values=...;</span><br><span class="line">HashSet&lt;String&gt; staff = <span class="keyword">new</span> <span class="title class_">Hash</span>&lt;&gt;(Arrays.asList(values));</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合转换为数组</span></span><br><span class="line">Object[] values = staff.toArray();</span><br><span class="line"><span class="comment">//返回一个Object[]数组，不能改变其类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用toArray的变体形式，需要提供一个所需类型而且长度为0的数组，返回的数组就会创建为相同的数组类型</span></span><br><span class="line">String[] values = staff.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//可以构造一个指定大小的数组</span></span><br><span class="line">staff.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[staff.size()]);</span><br></pre></td></tr></table></figure>
<h3 id="956-编写自己的算法"><a class="markdownIt-Anchor" href="#956-编写自己的算法"></a> 9.5.6 编写自己的算法</h3>
<ul>
<li>编写自己的算法(实际上，是以集合作为参数的任何方法)，应该尽可能地使用接口，而不要使用具体的实现</li>
</ul>
</div><div class="story post-story"><h2 id="96-遗留的集合"><a class="markdownIt-Anchor" href="#96-遗留的集合"></a> 9.6 遗留的集合</h2>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-12-01-19-19-30.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-12-01-19-19-30.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="遗留的集合" /></p>
<h3 id="961-hashtable类"><a class="markdownIt-Anchor" href="#961-hashtable类"></a> 9.6.1 Hashtable类</h3>
<ul>
<li>Hashtable类与HashMap类的作用一样，实际上，它们拥有相同的接口。</li>
<li>与Vector类的方法一样。Hashtable的方法也是同步的。</li>
<li>如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用HashMap。</li>
<li>如果需要并发访问，则要使用ConcurrentHashMap</li>
</ul>
<h3 id="962-枚举"><a class="markdownIt-Anchor" href="#962-枚举"></a> 9.6.2 枚举</h3>
<ul>
<li>遗留集合使用Enumeration接口对元素序列进行遍历</li>
<li>Enumeration接口有两个方法，即hasMoreElements和nextElement
<ul>
<li>这两个方法与Iterator接口的hasNext方法和next方法十分类似</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hashtable类的elements方法将产生一个用于描述表中各个枚举值的对象</span></span><br><span class="line">Enumeration &lt;Employee&gt; e= staff.elements();</span><br><span class="line"><span class="keyword">while</span>(e.hasMoreElements())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> e.nextElement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有时还会遇到遗留的方法,其参数是枚举类型的</span></span><br><span class="line"><span class="comment">//静态方法Collections.enumeration将产生一个枚举对象，枚举集合中的元素</span></span><br><span class="line">List&lt;lnputStream&gt; streams = ...;</span><br><span class="line"><span class="type">SequenceInputstream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceInautStrean</span>(Collections.enumeration(streams));</span><br></pre></td></tr></table></figure>
<h3 id="963-属性映射"><a class="markdownIt-Anchor" href="#963-属性映射"></a> 9.6.3 属性映射</h3>
<ul>
<li>属性映射(property map)是一个类型非常特殊的映射结构</li>
<li>它有下面3个特性：
<ul>
<li>键与值都是字符串</li>
<li>表可以保存到一个文件中，也可以从文件中加载</li>
<li>使用一个默认的辅助表。</li>
</ul>
</li>
<li>实现属性映射的Java平台类称为Properties。</li>
<li>属性映射通常用于程序的特殊配置选项</li>
</ul>
<h3 id="964-栈"><a class="markdownIt-Anchor" href="#964-栈"></a> 9.6.4 栈</h3>
<ul>
<li>标准类库中就包含了Stack类，其中有大家熟悉的push方法和pop方法</li>
<li>但是，Stack类扩展为Vector类，从理论角度看，Vector类并不太令人满意，它可以让栈使用不属于栈操作的insert和remove方法，即可以在任何地方进行插入或删除操作，而不仅仅是在栈顶</li>
</ul>
<h3 id="965-位集"><a class="markdownIt-Anchor" href="#965-位集"></a> 9.6.5 位集</h3>
<ul>
<li>Java平台的BitSet类用于存放一个位序列(它不是数学上的集，称为位向量或位数组更为合适)</li>
<li><mark>如果需要高效地存储位序列(例如，标志)就可以使用位集</mark></li>
<li>由于位集将位包装在字节里，所以，使用位集要比使用Boolean对象的ArrayList更加高效</li>
<li>BitSet类提供了一个便于读取、设置或清除各个位的接口
<ul>
<li>使用这个接口可以避免屏蔽和其他麻烦的位操作</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//名为buckerOfBits的BitSet</span></span><br><span class="line">buckerOfBits.get(i);</span><br><span class="line"><span class="comment">//开为true,否则为false</span></span><br><span class="line">buckerOfBits.set(i);</span><br><span class="line"><span class="comment">//将第i位 置为开</span></span><br><span class="line">buckerOfBits.clear(i);</span><br><span class="line"><span class="comment">//将第i位 置为关</span></span><br></pre></td></tr></table></figure>
<hr />
<h1 id="13-部署java应用程序"><a class="markdownIt-Anchor" href="#13-部署java应用程序"></a> 13 部署Java应用程序</h1>
<ul>
<li>首先介绍打包应用的指令</li>
<li>然后展示应用如何存储配置信息和用户首选项</li>
<li>另外还会学习如何使用ServiceLoader类在应用中加载插件</li>
<li>讨论applet,介绍创建或维护applet时需要了解的有关知识(已过时,忽略)</li>
<li>讨论Java Web Start机制——这是一种基于Internet的应用发布方法,很多方面都与applet很类似,不过更适合不在Web页面中的程序</li>
</ul>
</div><div class="story post-story"><h2 id="131-jar文件"><a class="markdownIt-Anchor" href="#131-jar文件"></a> 13.1 JAR文件</h2>
<ul>
<li>一个JAR文件既可以包含类文件,也可以包含诸如图像和声音这些其他类型的文件</li>
<li>此外,JAR文件是压缩的,它使用了大家熟悉的ZIP压缩格式
<ul>
<li>pack200是一种较通常的ZIP压缩算法更加有效的压缩类文件的方式</li>
</ul>
</li>
</ul>
<h3 id="1311-创建jar文件"><a class="markdownIt-Anchor" href="#1311-创建jar文件"></a> 13.1.1 创建JAR文件</h3>
<ul>
<li>可以使用jar工具制作JAR文件(在默认的JDK安装中,位于jdk/bin目录下)</li>
<li>可以将应用程序、程序组件以及代码库打包在JAR文件中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新的JAR文件应该使用的常见命令格式为</span></span><br><span class="line">jar cvf JARFileName File1 File2...</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line">jar cvf CalculatorClasses.jar *.<span class="keyword">class</span> <span class="title class_">icon</span>.gif</span><br></pre></td></tr></table></figure>
<h3 id="1312-清单文件"><a class="markdownIt-Anchor" href="#1312-清单文件"></a> 13.1.2 清单文件</h3>
<ul>
<li>除了类文件、图像和其他资源外,每个JAR文件还包含一个用于描述归档特征的清单文件</li>
<li>清单文件被命名为MANIFEST.MF,它位于JAR文件的一个特殊METANF子目录中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个包含清单文件的Jar文件</span></span><br><span class="line">jar cfm JARFileName ManifestFileName...</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line">jar cfm MyArchive.jar manifest.mf com/mycompany/mypkg<span class="comment">/*.class</span></span><br><span class="line"><span class="comment">//要想更新一个已有的JAR文件的清单,则需要将增加的部分放置到一个文本文件中,然后执行下列命令</span></span><br><span class="line"><span class="comment">jar ufm MyArcnive.jar manifest-additions.mf</span></span><br></pre></td></tr></table></figure>
<h3 id="1313-可执行jar文件"><a class="markdownIt-Anchor" href="#1313-可执行jar文件"></a> 13.1.3 可执行JAR文件</h3>
<ul>
<li>可以使用jar命令中的e选项指定程序的入口点,即通常需要在调用java程序加载器时指定的类</li>
<li>或者,可以在清单中指定应用程序的主类
<ul>
<li>不要将扩展名.class添加到主类名中</li>
<li>清单文件的最后一行必须以换行符结束.否则,清单文件将无法被正确地读取</li>
<li>常见的错误是创建了一个只包含Main-Class而没有行结束符的文本文件</li>
</ul>
</li>
</ul>
<h3 id="1314-资源"><a class="markdownIt-Anchor" href="#1314-资源"></a> 13.1.4 资源</h3>
<ul>
<li>利用资源机制,对于非类文件也可以同样方便地进行操作.下面是必要的步骤
<ul>
<li>获得具有资源的Class对象,例如,AboutPanel.class</li>
<li>如果资源是一个图像或声音文件,那么就需要调用getresource(filename)获得作为URL的资源位置,然后利用getImage或getAudioClip方法进行读取</li>
<li>与图像或声音文件不同,其他资源可以使用getResourceAsStream方法读取文件中的数据.</li>
</ul>
</li>
<li>重点在于类加载器可以记住如何定位类,然后在同一位置查找关联的资源</li>
</ul>
<h3 id="1315-密封"><a class="markdownIt-Anchor" href="#1315-密封"></a> 13.1.5 密封</h3>
<ul>
<li>可以将Java包密封(seal)以保证不会有其他的类加入到其中
<ul>
<li>如果在代码中使用了包可见的类、方法和域,就可能希望密封包</li>
<li>如果不密封,其他类就有可能放在这个包中,进而访问包可见的特性</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="132-应用首选项的存储"><a class="markdownIt-Anchor" href="#132-应用首选项的存储"></a> 13.2 应用首选项的存储</h2>
<ul>
<li>应用用户通常希望能保存他们的首选项和定制信息,以后再次启动应用时再恢复这些配置</li>
</ul>
<h3 id="1321-属性映射"><a class="markdownIt-Anchor" href="#1321-属性映射"></a> 13.2.1 属性映射</h3>
<ul>
<li>属性映射是一种存储键/值对的数据结构
<ul>
<li>属性映射通常用来存储配置信息,它有3个特性：
<ul>
<li>键和值是字符串</li>
<li>映射可以很容易地存入文件以及从文件加载</li>
<li>有一个二级表保存默认值</li>
</ul>
</li>
</ul>
</li>
<li>实现属性映射的Java类名为Properties
<ul>
<li>属性映射对于指定程序的配置选项很有用</li>
<li>可以使用store方法将属性映射列表保存到一个文件中</li>
</ul>
</li>
<li>习惯上,会把程序属性存储在用户主目录的一个子目录中
<ul>
<li>目录名通常以一个点号开头(在UNIX系统中),这个约定说明这是一个对用户隐藏的系统目录</li>
</ul>
</li>
<li>要找出用户的主目录,可以调用System.getProperties方法,它恰好也使用一个Properties对象描述系统信息
<ul>
<li>主目录包含键“user.home”</li>
</ul>
</li>
</ul>
<h3 id="1322-首选项api"><a class="markdownIt-Anchor" href="#1322-首选项api"></a> 13.2.2 首选项API</h3>
<ul>
<li>使用属性文件有以下缺点：
<ul>
<li>有些操作系统没有主目录的概念,所以很难找到一个统一的配置文件位置</li>
<li>关于配置文件的命名没有标准约定,用户安装多个Java应用时,就更容易发生命名冲突</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="133-服务加载器"><a class="markdownIt-Anchor" href="#133-服务加载器"></a> 13.3 服务加载器</h2>
<ul>
<li>通常,提供一个插件时,程序希望插件设计者能有一些自由来确定如何实现插件的特性</li>
<li>另外还可以有多个实现以供选择.利用ServiceLoader类可以很容易地加载符合一个公共接口的插件</li>
</ul>
</div><div class="story post-story"><h2 id="135-java-web-start"><a class="markdownIt-Anchor" href="#135-java-web-start"></a> 13.5 Java Web Start</h2>
<ul>
<li>Java Web Start应用程序包含下列主要特性：
<ul>
<li>应用程序一般通过浏览器发布.只要Java Web Start应用程序下载到本地就可以启动它,而不需要浏览器</li>
<li>应用程序并不在浏览器窗口内.它将显示在浏览器外的一个属于自己的框架中</li>
<li>应用程序不使用浏览器的Java实现.浏览器只是在加载Java Web Start应用程序描述符时启动一个外部应用程序</li>
<li>数字签名应用程序可以被赋予访问本地机器的任意权限.未签名的应用程序只能运行在“沙箱”中,它可以阻止具有潜在危险的操作</li>
</ul>
</li>
</ul>
<h3 id="1351-发布java-web-start应用"><a class="markdownIt-Anchor" href="#1351-发布java-web-start应用"></a> 13.5.1 发布Java Web Start应用</h3>
<ul>
<li>要想准备一个通过Java Web Start发布的应用程序,应该将其打包到一个或多个JAR文件中</li>
<li>然后创建一个Java Network Launch Protocol(JNLP)格式的描述符文件.将这些文件放置在Web服务器上</li>
<li>还需要确保Web服务器对扩展名为.jnlp的文件报告一个application/x-java-jnlp-file的MIME类型(浏览器利用MIME类型确定启动哪一种辅助应用程序)</li>
<li>步骤：
<ol>
<li>编译程序</li>
<li>创建JAR文件：</li>
<li>准备启动文件Calculator.jnlp</li>
<li>如果使用Tomcat则在Tomcat安装的根目录上创建一个目录tomcat/webapps/calculator.创建子目录tomcat/webapps/calculator/WEBNF,并且将最小的web.xml文件放置在WEBNF子目录下</li>
<li>将JAR文件和启动文件放入tomcat/webapps/calculator目录</li>
<li>在Java控制面板中将URL增加到可信站点列表.或者,可以为JAR文件签名.</li>
<li>在tomcat/bin目录执行启动脚本来启动Tomcat.</li>
<li>将浏览器指向JNLP文件.如果你的浏览器不知道如何处理JNLP文件,可能会提供一个选项将它们与一个应用关联.如果是这样,请选择jdk/bin/javaws.否则,明确如何将MIME类型application/x-java-jnlp-file与javaws应用关联.还可以试着重新安装可以做到这一点的JDK.</li>
<li>稍后,计算器就会出现,所带的边框表明这是一个Java应用程序</li>
<li>当再次访问JNLP文件时,应用程序将从缓存中取出.可以利用Java插件控制面板查看缓存内容.在Windows系统的Windows控制面板中可以看到Java插件控制面板.在Linux下,可以运行jdk/jre/bin/ControlPanel</li>
</ol>
</li>
</ul>
<h3 id="1352-jnlp-api"><a class="markdownIt-Anchor" href="#1352-jnlp-api"></a> 13.5.2 JNLP API</h3>
<ul>
<li>JNLP API允许未签名的应用程序在沙箱中运行,同时通过一种安全的途径访问本地资源</li>
<li>API提供了下面的服务：
<ul>
<li>加载和保存文件</li>
<li>访问剪贴板</li>
<li>打印</li>
<li>下载文件</li>
<li>在默认的浏览器中显示一个文档</li>
<li>保存和获取持久性配置信息</li>
<li>确信只运行一个应用程序的实例</li>
</ul>
</li>
</ul>
<hr />
<h1 id="14-并发"><a class="markdownIt-Anchor" href="#14-并发"></a> 14 并发</h1>
<ul>
<li>进程与多线程有哪些区别呢</li>
<li><mark>本质的区别在于每个进程拥有自己的一整套变量，而线程则共享数据</mark></li>
</ul>
</div><div class="story post-story"><h2 id="141-什么是线程"><a class="markdownIt-Anchor" href="#141-什么是线程"></a> 14.1 什么是线程</h2>
<ul>
<li>调用Thread.sleep不会创建一个新线程</li>
<li>sleep是Thread类的静态方法，用于暂停当前线程的活动</li>
<li>sleep方法可以抛出一个InterruptedException异常</li>
</ul>
<h3 id="1411-使用进程给其他任务提供机会"><a class="markdownIt-Anchor" href="#1411-使用进程给其他任务提供机会"></a> 14.1.1 使用进程给其他任务提供机会</h3>
<ul>
<li>一个单独的线程中执行一个任务的简单过程
<ul>
<li>将任务代码移到实现了Runnable接口的类的run方法中</li>
<li>由Runnable创建一个Thread对象</li>
<li>启动线程</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runnable接口，只有一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于Runnable是一个函数式接口，可以用lambda表达式建立一个实例</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;task code&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由Runnable创建一个Thread对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//要想将弹跳球代码放在一个独立的线程中，只需要实现一个类BallRunnable，然后，将动画代码放在run方法中</span></span><br><span class="line">Runnable r= ()-&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=STEPS;i++&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        ball.move(comp.getBounds());</span><br><span class="line">        comp.repaint();</span><br><span class="line">        Tread.sleep(DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">t.start();</span><br><span class="line"><span class="comment">//需要捕获sleep方法可能抛出的异常InterruptedException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不要调用Thread类或Runnable对象的run方法</li>
<li>直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程</li>
<li><mark>应该调用Thread.start方法。这个方法将创建一个执行run方法的新线程</mark></li>
</ul>
</div><div class="story post-story"><h2 id="142-中断线程"><a class="markdownIt-Anchor" href="#142-中断线程"></a> 14.2 中断线程</h2>
<ul>
<li><mark>当线程的run方法执行方法体中最后一条语句后，并经由执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止</mark></li>
<li>在Java的早期版本中，还有一个<strong>stop方法</strong>，其他线程可以调用它终止线程，<strong>这个方法现在已经被弃用了</strong></li>
<li><mark>interrupt方法可以用来请求终止线程</mark>
<ul>
<li>当对一个线程调用interrupt方法时，线程的中断状态将被置位</li>
<li>这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断</li>
<li>要想弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用isInterrupted方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//isInterrupted方法</span></span><br><span class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果线程被阻塞，就无法检测中断状态,产生InterruptedException异常的地方</span></span><br><span class="line"><span class="comment">//当在一个被阻塞的线程(调用sleep或wait)上调用interrupt方法时，阻塞调用将会被Interrupted Exception异常中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程将简单地将中断作为一个终止的请求</span></span><br><span class="line"><span class="comment">//这种线程的run方法具有如下形式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep or wait</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        cleanup, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exiting the run rethod terminates the thread</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line"><span class="comment">//如果在每次工作迭代之后都调用sleep方法(或者其他的可中断方法)，isInterrupted检测既没有必要也没有用处</span></span><br><span class="line"><span class="comment">//如果在中断状态被置位时调用sleep方法，它不会休眠。相反，它将清除这一状态(！)并抛出InterruptedException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此，如果你的循环调用sleep，不会检测中断状态</span></span><br><span class="line"><span class="comment">//相反，要如下所示捕获InterruptedException异常</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep or wait</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        cleanup, <span class="keyword">if</span> required</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exiting the run rethod terminates the thread</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InterruptedException异常被抑制在很低的层次上</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mySubTask</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>&#123;sleep(delay);&#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterruptedException e)   &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不要这样做！</span></span><br><span class="line"><span class="comment">//如果不认为在catch子句中做这一处理有什么好处的话，仍然有两种合理的选择：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 在catch子句中调用Thread.currentThread().interrupt()来设置中断状态。于是，调用者可以对其进行检测</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mySubTask</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>&#123;sleep(delay);&#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterruptedException e)   &#123;Thread.currentThread().interrupt()&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更好的选择是，用throws InterruptedException标记你的方法，不采用try语句块捕获异常</span></span><br><span class="line"><span class="comment">//于是，调用者(或者，最终的run方法)可以捕获这一异常</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mySubTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有两个非常类似的方法，interrupted和isInterrupted</li>
<li>Interrupted方法是一个静态方法，它检测当前的线程是否被中断
<ul>
<li>而且，调用interrupted方法会清除该线程的中断状态</li>
</ul>
</li>
<li>isInterrupted方法是一个实例方法，可用来检验是否有线程被中断
<ul>
<li>调用这个方法不会改变中断状态</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="143-线程状态"><a class="markdownIt-Anchor" href="#143-线程状态"></a> 14.3 线程状态</h2>
<ul>
<li>线程有6种状态</li>
<li>New(新创建)</li>
<li>Runnable(可运行)</li>
<li>Blocked(被阻塞)</li>
<li>Waiting(等待)</li>
<li>Timed waiting(计时等待)</li>
<li>Terminated(被终止)</li>
</ul>
<h3 id="1431-新创建线程"><a class="markdownIt-Anchor" href="#1431-新创建线程"></a> 14.3.1 新创建线程</h3>
<ul>
<li>当用new操作符创建一个新线程时，如new Thread®，该线程还没有开始运行</li>
<li>这意味着它的状态是new</li>
<li>当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做</li>
</ul>
<h3 id="1432-可运行线程"><a class="markdownIt-Anchor" href="#1432-可运行线程"></a> 14.3.2 可运行线程</h3>
<ul>
<li>一旦调用start方法，线程处于runnable状态</li>
<li><mark>一个可运行的线程可能正在运行也可能没有运行</mark></li>
<li>一个正在运行中的线程仍然处于可运行状态</li>
<li>一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会</li>
<li>抢占式调度：每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会，当选择下一个线程时，操作系统考虑线程的优先级</li>
<li>协作式调度：一个线程只有在调用yield方法、或者被阻塞或等待时，线程才失去控制权</li>
</ul>
<h3 id="1433-被阻塞线程或等待线程"><a class="markdownIt-Anchor" href="#1433-被阻塞线程或等待线程"></a> 14.3.3 被阻塞线程或等待线程</h3>
<ul>
<li>当线程处于被阻塞或等待状态时，它暂时不活动，它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它</li>
<li>当一个线程试图获取一个内部的对象锁(而不是java.util.concurrent库中的锁)，而该锁被其他线程持有，则该线程进入阻塞状态</li>
<li>当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态</li>
<li>当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的</li>
<li>有几个方法有一个超时参数。调用它们导致线程进入计时等待(timed waiting)状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep和Object.wait、Thread.join、Lock.tryLock以及Condition.await的计时版</li>
</ul>
<h3 id="1434-被终止的线程"><a class="markdownIt-Anchor" href="#1434-被终止的线程"></a> 14.3.4 被终止的线程</h3>
<p>线程因如下两个原因之一而被终止：</p>
<ul>
<li>因为run方法正常退出而自然死亡</li>
<li>因为一个没有捕获的异常终止了run方法而意外死亡</li>
</ul>
</div><div class="story post-story"><h2 id="144-线程属性"><a class="markdownIt-Anchor" href="#144-线程属性"></a> 14.4 线程属性</h2>
<h3 id="1441-线程优先级"><a class="markdownIt-Anchor" href="#1441-线程优先级"></a> 14.4.1 线程优先级</h3>
<ul>
<li>在Java程序设计语言中，每一个线程有一个优先级</li>
<li>默认情况下，一个线程继承它的父线程的优先级</li>
<li>可以用setPriority方法提高或降低任何一个线程的优先级
<ul>
<li>可以将优先级设置为在MIN_PRIORITY(在Thread类中定义为1)与MAX_PRIORITY(定义为10)之间的任何值。NORM_PRIORITY被定义为5</li>
</ul>
</li>
<li>每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程</li>
<li>不要将程序构建为功能的正确性依赖于优先级
<ul>
<li>如果确实要使用优先级，应该避免初学者常犯的一个错误</li>
<li>如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行</li>
<li>每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，尽管这样会使低优先级的线程完全饿死</li>
</ul>
</li>
</ul>
<h3 id="1442-守护线程"><a class="markdownIt-Anchor" href="#1442-守护线程"></a> 14.4.2 守护线程</h3>
<ul>
<li>守护线程的唯一用途是为其他线程提供服务</li>
<li>当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了</li>
<li>守护线程有时会被初学者错误地使用，他们不打算考虑关机(shutdown)动作。但是，这是很危险的。守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//将线程转换为守护线程</span></span><br></pre></td></tr></table></figure>
<h3 id="1443-未捕获异常处理器"><a class="markdownIt-Anchor" href="#1443-未捕获异常处理器"></a> 14.4.3 未捕获异常处理器</h3>
<ul>
<li>线程的run方法不能抛出任何受查异常，但是，非受查异常会导致线程终止(线程死亡)</li>
<li>但是，不需要任何catch子句来处理可以被传播的异常</li>
<li>相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该处理器必须属于一个实现Thread.UncaughtExceptionHandler接口的类</span></span><br><span class="line"><span class="comment">//这个接口只有一个方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">UncaughtException</span><span class="params">(Thread t, Throwable e)</span></span><br><span class="line"><span class="comment">//可以用setUncaughtExceptionHandler方法为任何线程安装一个处理器</span></span><br><span class="line"><span class="comment">//可以用Thread类的静态方法setDefaultUncaughtExceptionHandler为所有线程安装一个默认的处理器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不安装默认的处理器，默认的处理器为空</span></span><br><span class="line"><span class="comment">//但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>线程组是一个可以统一管理的线程集合</p>
</li>
<li>
<p>默认情况下，创建的所有线程属于相同的线程组，但是，也可能会建立其他的组</p>
</li>
<li>
<p>现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组</p>
</li>
<li>
<p>ThreadGroup类实现Thread.UncaughtExceptionHandler接口</p>
</li>
</ul>
<p>它的uncaughtException方法做如下操作：</p>
<ol>
<li>如果该线程组有父线程组，那么父线程组的uncaughtException方法被调用。</li>
<li>否则，如果Thread.getDefaultExceptionHandler方法返回一个非空的处理器，则调用该处理器。</li>
<li>否则，如果Throwable是ThreadDeath的一个实例，什么都不做。</li>
<li>否则，线程的名字以及Throwable的栈轨迹被输出到System.err上</li>
</ol>
</div><div class="story post-story"><h2 id="145-同步"><a class="markdownIt-Anchor" href="#145-同步"></a> 14.5 同步</h2>
<h3 id="1452-竞争条件详解"><a class="markdownIt-Anchor" href="#1452-竞争条件详解"></a> 14.5.2 竞争条件详解</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假定两个线程同时执行指令</span></span><br><span class="line">accouts[to] += amount;</span><br><span class="line"><span class="comment">//问题在于这不是原子操作。该指令可能被处理如下：</span></span><br><span class="line"><span class="comment">//1)将accounts[to]加载到寄存器。</span></span><br><span class="line"><span class="comment">//2)增加amount。</span></span><br><span class="line"><span class="comment">//3)将结果写回accounts[to]。</span></span><br><span class="line"><span class="comment">//现在，假定第1个线程执行步骤1和2，然后，它被剥夺了运行权。假定第2个线程被唤醒并修改了accounts数组中的同一项。然后，第1个线程被唤醒并完成其第3步。</span></span><br><span class="line"><span class="comment">//这一动作擦去了第二个线程所做的更新。于是，总金额不再正确</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出现这一讹误的可能性有多大呢</span></span><br><span class="line"><span class="comment">//这里通过将打印语句和更新余额的语句交织在一起执行，增加了发生这种情况的机会。</span></span><br><span class="line"><span class="comment">//如果删除打印语句，讹误的风险会降低一点，因为每个线程在再次睡眠之前所做的工作很少，调度器在计算过程中剥夺线程的运行权可能性很小。但是，讹误的风险并没有完全消失。如果在负载很重的机器上运行许多线程，那么，即使删除了打印语句，程序依然会出错。这种错误可能会几分钟、几小时或几天出现一次</span></span><br><span class="line"><span class="comment">//真正的问题是transfer方法的执行过程中可能会被中断</span></span><br><span class="line"><span class="comment">//如果能够确保线程在失去控制之前方法运行完成，那么银行账户对象的状态永远不会出现讹误</span></span><br></pre></td></tr></table></figure>
<h3 id="1453-锁对象"><a class="markdownIt-Anchor" href="#1453-锁对象"></a> 14.5.3 锁对象</h3>
<ul>
<li>有两种机制防止代码块受并发访问的干扰</li>
<li>Java语言提供一个synchronized关键字达到这一目的，并且Java SE 5.0引入了ReentrantLock类。synchronized关键字自动提供一个锁以及相关的“条件”</li>
<li>java.util.concurrent框架为这些基础机制提供独立的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用ReentrantLock保护代码块的基本结构如下</span></span><br><span class="line">myLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    myLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这一结构确保任何时刻只有一个线程进入临界区</span></span><br><span class="line"><span class="comment">//一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句</span></span><br><span class="line"><span class="comment">//当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>把解锁操作括在finally子句之内是至关重要的</p>
</li>
<li>
<p>如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞</p>
</li>
<li>
<p>如果使用锁，就不能使用带资源的try语句</p>
</li>
<li>
<p>首先，解锁方法名不是close。不过，即使将它重命名，带资源的try语句也无法正常工作</p>
</li>
<li>
<p>它的首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享的那个变量(而不是新变量)</p>
</li>
<li>
<p>注意每一个Bank对象有自己的ReentrantLock对象</p>
<ul>
<li>如果两个线程试图访问同一个Bank对象，那么锁以串行方式提供服务。但是，如果两个线程访问不同的Bank对象，每一个线程得到不同的锁对象，两个线程都不会发生阻塞</li>
<li>本该如此，因为线程在操纵不同的Bank实例的时候，线程之间不会相互影响。</li>
</ul>
</li>
<li>
<p>锁是可重入的，因为线程可以重复地获得已经持有的锁</p>
<ul>
<li>锁保持一个持有计数(hold count)来跟踪对lock方法的嵌套调用</li>
<li>线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法</li>
</ul>
</li>
<li>
<p>通常，可能想要保护需若干个操作来更新或检查共享对象的代码块。要确保这些操作完成后，另一个线程才能使用相同对象</p>
</li>
<li>
<p>要留心临界区中的代码，不要因为异常的抛出而跳出临界区</p>
</li>
<li>
<p>如果在临界区代码结束之前抛出了异常，finally子句将释放锁，但会使对象可能处于一种受损状态</p>
</li>
</ul>
<hr />
<ul>
<li>听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多</li>
<li>只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候，才可以使用公平锁</li>
<li>即使使用公平锁，也无法确保线程调度器是公平的。如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁了</li>
</ul>
<h3 id="1454-条件对象"><a class="markdownIt-Anchor" href="#1454-条件对象"></a> 14.5.4 条件对象</h3>
<ul>
<li>线程进入临界区，却发现在某一条件满足之后它才能执行</li>
<li>要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//细化银行的模拟程序</span></span><br><span class="line"><span class="comment">//避免选择没有足够资金的账户作为转出账户</span></span><br><span class="line"><span class="keyword">if</span>(bank.getBalance(from) &gt;= amount)</span><br><span class="line"><span class="comment">//thread might be deactivated at this point</span></span><br><span class="line">    bank.transfer(from, to, amount);</span><br><span class="line"><span class="comment">//在线程再次运行前，账户余额可能已经低于提款金额</span></span><br><span class="line"><span class="comment">//必须确保没有其他线程在本检查余额与转账活动之间修改余额</span></span><br><span class="line"><span class="comment">//通过使用锁来保护检查与转账动作来做到这一点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    bankLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(accounts[from] &lt; amount)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//wait</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bankLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当账户中没有足够的余额时，应该做什么呢</span></span><br><span class="line"><span class="comment">//等待直到另一个线程向账户中注入了资金</span></span><br><span class="line"><span class="comment">//但是，这一线程刚刚获得了对bankLock的排它性访问，因此别的线程没有进行存款操作的机会</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个锁对象可以有一个或多个相关的条件对象</span></span><br><span class="line"><span class="comment">//你可以用newCondition方法获得一个条件对象</span></span><br><span class="line"><span class="comment">//习惯上给每一个条件对象命名为可以反映它所表达的条件的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一个条件对象来表达“余额充足”条件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bank</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Condition sufficientFunds;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">bank</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        sufficientFunds = bankLock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果transfer方法发现余额不足，它调用</span></span><br><span class="line">sufficientFunds.await();</span><br><span class="line"><span class="comment">//当前线程现在被阻塞了，并放弃了锁</span></span><br><span class="line"><span class="comment">//这样可以使得另一个线程可以进行增加账户余额的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等待获得锁的线程和调用await方法的线程存在本质上的不同</span></span><br><span class="line"><span class="comment">//一旦一个线程调用await方法，它进入该条件的等待集</span></span><br><span class="line"><span class="comment">//当锁可用时，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的signalAll方法时为止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当另一个线程转账时，它应该调用</span></span><br><span class="line">sufficientFunds.signalAll();</span><br><span class="line"><span class="comment">//这一调用重新激活因为这一条件而等待的所有线程</span></span><br><span class="line"><span class="comment">//当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们</span></span><br><span class="line"><span class="comment">//同时，它们将试图重新进入该对象。一旦锁成为可用的，它们中的某个将从await调用返回，获得该锁并从被阻塞的地方继续执行</span></span><br><span class="line"><span class="comment">//signalAll方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检测该条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通常，对await的调用应该在如下形式的循环体中</span></span><br><span class="line"><span class="keyword">while</span>(!(ok to proceed))</span><br><span class="line">    condition.await();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>至关重要的是最终需要某个其他线程调用signalAll方法</p>
<ul>
<li>当一个线程调用await时，它没有办法重新激活自身。它寄希望于其他线程</li>
<li>如果没有其他线程来重新激活等待的线程，它就永远不再运行了。这将导致令人不快的死锁(deadlock)现象</li>
<li>如果所有其他线程被阻塞，最后一个活动线程在解除其他线程的阻塞状态之前就调用await方法，那么它也被阻塞。没有任何线程可以解除其他线程的阻塞，那么该程序就挂起了。</li>
</ul>
</li>
<li>
<p>应该何时调用signalAll呢</p>
<ul>
<li>经验上讲，在对象的状态有利于等待线程的方向改变时调用signalAll</li>
</ul>
</li>
<li>
<p>注意调用signalAll不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问</p>
</li>
<li>
<p>另一个方法signal，则是随机解除等待集中某个线程的阻塞状态</p>
</li>
<li>
<p>这比解除所有线程的阻塞更加有效，但也存在危险。如果随机选择的线程发现自己仍然不能运行，那么它再次被阻塞。如果没有其他线程再次调用signal，那么系统就死锁了</p>
</li>
<li>
<p>当一个线程拥有某个条件的锁时，它仅仅可以在该条件上调用await、signalAll或signal方法</p>
</li>
</ul>
<h3 id="1455-synchronized关键字"><a class="markdownIt-Anchor" href="#1455-synchronized关键字"></a> 14.5.5 synchronized关键字</h3>
<p>锁和条件的关键之处：</p>
<ul>
<li>锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码</li>
<li>锁可以管理试图进入被保护代码段的线程</li>
<li>锁可以拥有一个或多个相关的条件对象</li>
<li>每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程</li>
</ul>
<hr />
<ul>
<li>Java中的每一个对象都有一个内部锁</li>
<li>如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法(要调用该方法，线程必须获得内部的对象锁)
<ul>
<li>由锁来管理那些试图进入synchronized方法的线程，由条件来管理那些调用wait的线程</li>
</ul>
</li>
<li>内部对象锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll/notify方法解除等待线程的阻塞状态
<ul>
<li>wait、notifyAll以及notify方法是Object类的final方法。Condition方法必须被命名为await、signalAll和signal以便它们不会与那些方法发生冲突</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    method body</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.intrinsicLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method body</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsicLock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部锁和条件存在一些局限。包括：</p>
<ul>
<li>不能中断一个正在试图获得锁的线程</li>
<li>试图获得锁时不能设定超时</li>
<li>每个锁仅有单一的条件，可能是不够的</li>
</ul>
<hr />
<p>Lock和Condition对象还是同步方法</p>
<ul>
<li>最好既不使用Lock/Condition也不使用synchronized关键字。在许多情况下你可以使用java.util.concurrent包中的一种机制，它会为你处理所有的加锁。例如，使用阻塞队列来同步完成一个共同任务的线程</li>
<li>如果synchronized关键字适合你的程序，那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率</li>
<li>如果特别需要Lock/Condition结构提供的独有特性时，才使用Lock/Condition</li>
</ul>
<h3 id="1456-同步阻塞"><a class="markdownIt-Anchor" href="#1456-同步阻塞"></a> 14.5.6 同步阻塞</h3>
<ul>
<li>线程可以通过调用同步方法获得锁</li>
<li>还可以<mark>通过进入一个同步阻塞</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当线程进入如下形式的阻塞</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj)</span><br><span class="line">&#123;</span><br><span class="line">    critical section</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得obj的锁</span></span><br></pre></td></tr></table></figure>
<h3 id="1457-监视器概念"><a class="markdownIt-Anchor" href="#1457-监视器概念"></a> 14.5.7 监视器概念</h3>
<ul>
<li>监视器可以在不需要程序员考虑如何加锁的情况下，就可以保证多线程的安全性</li>
<li>监视器的特征：
<ul>
<li>监视器是只包含私有域的类</li>
<li>每个监视器类的对象有一个相关的锁</li>
<li>使用该锁对所有的方法进行加锁
<ul>
<li>因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域</li>
</ul>
</li>
<li>该锁可以有任意多个相关条件
<ul>
<li>可以简单地调用await accounts[from]&gt;=balance而不使用任何显式的条件变量。然而，研究表明盲目地重新测试条件是低效的。显式的条件变量解决了这一问题。每一个条件变量管理一个独立的线程集</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>Java中的每一个对象有一个内部的锁和内部的条件</li>
<li>如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量</li>
<li>在3个方面Java对象不同于监视器，从而使得线程的安全性下降：
<ul>
<li>域不要求必须是private</li>
<li>方法不要求必须是synchronized</li>
<li>内部锁对客户是可用的</li>
</ul>
</li>
</ul>
<h3 id="1458-volatile域"><a class="markdownIt-Anchor" href="#1458-volatile域"></a> 14.5.8 Volatile域</h3>
<ul>
<li>多处理器的计算机能够暂时在寄存器或本地内存缓冲区中保存内存中的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值</li>
<li>编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变。然而，内存的值可以被另一个线程改变！</li>
<li>如果你使用锁来保护可以被多个线程访问的代码，那么可以不考虑这种问题。编译器被要求通过在必要的时候刷新本地缓存来保持锁的效应，并且不能不正当地重新排序指令</li>
</ul>
<hr />
<ul>
<li><mark>volatile关键字为实例域的同步访问提供了一种免锁机制</mark>
<ul>
<li>如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的</li>
</ul>
</li>
<li>Volatile变量不能提供原子性
<ul>
<li>不能确保翻转域中的值。不能保证读取、翻转和写入不被中断</li>
</ul>
</li>
</ul>
<h3 id="1459-final变量"><a class="markdownIt-Anchor" href="#1459-final变量"></a> 14.5.9 final变量</h3>
<ul>
<li>除非使用锁或volatile修饰符，否则无法从多个线程安全地读取一个域</li>
<li>还可以安全地访问一个共享域，<mark>即这个域声明为final</mark></li>
</ul>
<h3 id="14510-原子性"><a class="markdownIt-Anchor" href="#14510-原子性"></a> 14.5.10 原子性</h3>
<ul>
<li>假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为volatile</li>
<li>在Java SE 8中，可以使用一个lambda表达式更新变量</li>
<li>如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试
<ul>
<li>Java SE 8提供了LongAdder和LongAccumulator类来解决这个问题。LongAdder包括多个变量(加数)，其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下，只有当所有工作都完成之后才需要总和的值，对于这种情况，这种方法会很高效。性能会有显著的提升。</li>
<li>如果认为可能存在大量竞争，只需要使用LongAdder而不是AtomicLong。方法名稍有区别。调用increment让计数器自增，或者调用add来增加一个量，或者调用sum来获取总和</li>
</ul>
</li>
</ul>
<h3 id="14511-死锁"><a class="markdownIt-Anchor" href="#14511-死锁"></a> 14.5.11 死锁</h3>
<ul>
<li>有可能会因为每一个线程要等待更多的钱款存入而导致所有线程都被阻塞。这样的状态称为死锁
<ul>
<li>当程序挂起时，键入CTRL+\，将得到一个所有线程的列表。每一个线程有一个栈踪迹，告诉你线程被阻塞的位置</li>
</ul>
</li>
<li>导致死锁的另一种途径是让第i个线程负责向第i个账户存钱，而不是从第i个账户取钱。这样一来，有可能将所有的线程都集中到一个账户上，每一个线程都试图从这个账户中取出大于该账户余额的钱</li>
<li>还有一种很容易导致死锁的情况：在SynchBankTest程序中，将signalAll方法转换为signal，会发现该程序最终会挂起(将NACCOUNTS设为10可以更快地看到结果)。signalAll通知所有等待增加资金的线程，与此不同的是signal方法仅仅对一个线程解锁。如果该线程不能继续运行，所有的线程可能都被阻塞</li>
</ul>
<h3 id="14512-线程局部变量"><a class="markdownIt-Anchor" href="#14512-线程局部变量"></a> 14.5.12 线程局部变量</h3>
<ul>
<li>有时可能要避免共享变量，使用ThreadLocal辅助类为各个线程提供各自的实例
<ul>
<li>在多个线程中生成随机数，java.util.Random类是线程安全的。但是如果多个线程需要等待一个共享的随机数生成器，这会很低效</li>
<li>可以使用ThreadLocal辅助类为各个线程提供一个单独的生成器</li>
<li>Java SE 7还另外提供了一个便利类，ThreadLocalRandom.current()调用会返回特定于当前线程的Random类实例</li>
</ul>
</li>
</ul>
<h3 id="14513-锁测试域超时"><a class="markdownIt-Anchor" href="#14513-锁测试域超时"></a> 14.5.13 锁测试域超时</h3>
<ul>
<li>线程在调用lock方法来获得另一个线程所持有的锁的时候，很可能发生阻塞</li>
<li>tryLock方法试图申请一个锁，在成功获得锁后返回true，否则，立即返回false，而且线程可以立即离开去做其他事情</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (myLock.tryLock())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//now the thread owns the lock</span></span><br><span class="line">    <span class="keyword">try</span>&#123;...&#125;</span><br><span class="line">    finaly&#123;myLock.unlock()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//do something else</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以调用tryLock时，使用超时参数</span></span><br><span class="line"><span class="keyword">if</span> (myLock.tryLock(<span class="number">100</span>,TimeUnit.MILLISECONDS))...</span><br><span class="line"><span class="comment">//TimeUnit是一个枚举类型，可以取的值包括SECONDS、MILLISECONDS、MICROSECONDS和NANOSECONDS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lock方法不能被中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁，那么，lock方法就无法终止</span></span><br><span class="line"><span class="comment">//如果调用带有用超时参数的tryLock，那么如果线程在等待期间被中断，将抛出InterruptedException异常。这是一个非常有用的特性，因为允许程序打破死锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以调用lockInterruptibly方法。它就相当于一个超时设为无限的tryLock方法。</span></span><br><span class="line"><span class="comment">//在等待一个条件时，也可以提供一个超时</span></span><br><span class="line">myCondition.awit(<span class="number">100</span>,TimeUnit.MILLISECONDS)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一个线程被另一个线程通过调用signalAll或signal激活，或者超时时限已达到，或者线程被中断，那么await方法将返回</span></span><br><span class="line"><span class="comment">//如果等待的线程被中断，await方法将抛出一个InterruptedException异常。在你希望出现这种情况时线程继续等待(可能不太合理)，可以使用awaitUninterruptibly方法代替await</span></span><br></pre></td></tr></table></figure>
<h3 id="14514-读写锁"><a class="markdownIt-Anchor" href="#14514-读写锁"></a> 14.5.14 读/写锁</h3>
<ul>
<li>如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话，后者是十分有用的</li>
<li>在这种情况下，允许对读者线程共享访问是合适的。当然，写者线程依然必须是互斥访问的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用读/写锁的必要步骤</span></span><br><span class="line"><span class="comment">//1)构造一个ReentrantReadWriteLock对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="comment">//2)抽取读锁和写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"><span class="comment">//3)对所有的获取方法加读锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalBalance</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    readLock.lock()</span><br><span class="line">    <span class="keyword">try</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;readLock.unlock();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4)对所有的修改方法加写锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;writeLock.unlock();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14515-为什么弃用stop和suspend方法"><a class="markdownIt-Anchor" href="#14515-为什么弃用stop和suspend方法"></a> 14.5.15 为什么弃用stop和suspend方法</h3>
<ul>
<li>首先来看看stop方法，该方法终止所有未结束的方法，包括run方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态
<ul>
<li>例如，假定TransferThread在从一个账户向另一个账户转账的过程中被终止，钱款已经转出，却没有转入目标账户，现在银行对象就被破坏了。因为锁已经被释放，这种破坏会被其他尚未停止的线程观察到</li>
<li>当线程要终止另一个线程时，无法知道什么时候调用stop方法是安全的，什么时候导致对象被破坏。因此，该方法被弃用了。在希望停止线程的时候应该中断线程，被中断的线程会在安全的时候停止</li>
<li>因为它会导致对象被一个已停止的线程永久锁定。但是，这一说法是错误的。从技术上讲，被停止的线程通过抛出ThreadDeath异常退出所有它所调用的同步方法。结果是，该线程释放它持有的内部对象锁</li>
</ul>
</li>
<li>stop不同，suspend不会破坏对象。但是，如果用suspend挂起一个持有一个锁的线程，那么，该锁在恢复之前是不可用的。如果调用suspend方法的线程试图获得同一个锁，那么程序死锁：被挂起的线程等着被恢复，而将其挂起的线程等待获得锁</li>
</ul>
</div><div class="story post-story"><h2 id="146-阻塞队列"><a class="markdownIt-Anchor" href="#146-阻塞队列"></a> 14.6 阻塞队列</h2>
<ul>
<li>对于许多线程问题，可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生产者线程向队列插入元素，消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据</li>
<li>当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列(blocking queue)导致线程阻塞</li>
<li>在协调多个线程之间的合作时，阻塞队列是一个有用的工具。工作者线程可以周期性地将中间结果存储在阻塞队列中。其他的工作者线程移出中间结果并进一步加以修改。队列会自动地平衡负载</li>
<li>如果第一个线程集运行得比第二个慢，第二个线程集在等待结果时会阻塞。如果第一个线程集运行得快，它将等待第二个队列集赶上来</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-12-03-16-03-15.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-12-03-16-03-15.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="阻塞队列方法" /></p>
<ul>
<li>如果将队列当作线程管理工具来使用，将要用到put和take方法。当试图向满的队列中添加或从空的队列中移出元素时，add、remove和element操作抛出异常。当然，在一个多线程程序中，队列会在任何时候空或满，因此，一定要使用offer、poll和peek方法作为替代</li>
<li>poll和peek方法返回空来指示失败。因此，向这些队列中插入null值是非法的</li>
<li>还有带有超时的offer方法和poll方法的变体</li>
<li>java.util.concurrent包提供了阻塞队列的几个变种。默认情况下，LinkedBlockingQueue的容量是没有上边界的，但是，也可以选择指定最大容量。LinkedBlockingDeque是一个双端的版本</li>
<li>ArrayBlockingQueue在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数，则那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能，只有在确实非常需要时才使用它</li>
<li>PriorityBlockingQueue是一个带优先级的队列，而不是先进先出队列。元素按照它们的优先级顺序被移出。该队列是没有容量上限，但是，如果队列是空的，取元素的操作会阻塞</li>
<li>DelayQueue包含实现Delayed接口的对象</li>
<li>getDelay方法返回对象的残留延迟。负值表示延迟已经结束。元素只有在延迟用完的情况下才能从DelayQueue移除。还必须实现compareTo方法。DelayQueue使用该方法对元素进行排序</li>
<li>Java SE 7增加了一个TransferQueue接口，允许生产者线程等待，直到消费者准备就绪可以接收一个元素</li>
</ul>
</div><div class="story post-story"><h2 id="147-线程安全的集合"><a class="markdownIt-Anchor" href="#147-线程安全的集合"></a> 14.7 线程安全的集合</h2>
<ul>
<li>如果多线程要并发地修改一个数据结构，例如散列表，那么很容易会破坏这个数据结构</li>
<li>可以通过提供锁来保护共享数据结构，但是选择线程安全的实现作为替代可能更容易些</li>
</ul>
<h3 id="1471-高效的映射-集和队列"><a class="markdownIt-Anchor" href="#1471-高效的映射-集和队列"></a> 14.7.1 高效的映射、集和队列</h3>
<ul>
<li>java.util.concurrent包提供了映射、有序集和队列的高效实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet和ConcurrentLinkedQueue</li>
<li>这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化</li>
<li>与大多数集合不同，size方法不必在常量时间内操作。确定这样的集合当前的大小通常需要遍历</li>
<li>有些应用使用庞大的并发散列映射，这些映射太过庞大，以至于无法用size方法得到它的大小，因为这个方法只能返回int。对于一个包含超过20亿条目的映射该如何处理？Java SE 8引入了一个mappingCount方法可以把大小作为long返回</li>
<li>集合返回弱一致性(weakly consistent)的迭代器。这意味着迭代器不一定能反映出它们被构造之后的所有的修改，但是，它们不会将同一个值返回两次，也不会抛出Concurrent ModificationException异常</li>
<li>与之形成对照的是，集合如果在迭代器构造之后发生改变，java.util包中的迭代器将抛出一个ConcurrentModificationException异常</li>
<li>并发的散列映射表，可高效地支持大量的读者和一定数量的写者</li>
<li>散列映射将有相同散列码的所有条目放在同一个“桶”中。有些应用使用的散列函数不当，以至于所有条目最后都放在很少的桶中，这会严重降低性能。即使是一般意义上还算合理的散列函数，如String类的散列函数，也可能存在问题</li>
<li>在Java SE 8中，并发散列映射将桶组织为树，而不是列表，键类型实现了Comparable，从而可以保证性能为O(log(n))</li>
</ul>
<h3 id="1472-映射条目的原子更新"><a class="markdownIt-Anchor" href="#1472-映射条目的原子更新"></a> 14.7.2 映射条目的原子更新</h3>
<ul>
<li>ConcurrentHashMap原来的版本只有为数不多的方法可以实现原子更新</li>
<li>可以使用ConcurrentHashMap＜String，Long＞吗？考虑让计数自增的代码</li>
<li>为什么原本线程安全的数据结构会允许非线程安全的操作。不过有两种完全不同的情况。如果多个线程修改一个普通的HashMap，它们会破坏内部结构(一个链表数组)。有些链接可能丢失，或者甚至会构成循环，使得这个数据结构不再可用。对于ConcurrentHashMap绝对不会发生这种情况。在上面的例子中，get和put代码不会破坏数据结构。不过，由于操作序列不是原子的，所以结果不可预知
<ul>
<li>传统的做法是使用replace操作，它会以原子方式用一个新值替换原值，前提是之前没有其他线程把原值替换为其他值。必须一直这么做，直到replace成功</li>
<li>或者，可以使用一个ConcurrentHashMap＜String，AtomicLong＞，或者在Java SE 8中，还可以使用ConcurrentHashMap＜String，LongAdder＞</li>
<li>Java SE 8提供了一些可以更方便地完成原子更新的方法。调用compute方法时可以提供一个键和一个计算新值的函数。这个函数接收键和相关联的值(如果没有值，则为null)，它会计算新值</li>
</ul>
</li>
<li>ConcurrentHashMap中不允许有null值。有很多方法都使用null值来指示映射中某个给定的键不存在</li>
<li>另外还有computeIfPresent和computeIfAbsent方法，它们分别只在已经有原值的情况下计算新值，或者只有没有原值的情况下计算新值</li>
<li>首次增加一个键时通常需要做些特殊的处理。利用merge方法可以非常方便地做到这一点。这个方法有一个参数表示键不存在时使用的初始值。否则，就会调用你提供的函数来结合原值与初始值。(与compute不同，这个函数不处理键
<ul>
<li>如果传入compute或merge的函数返回null，将从映射中删除现有的条目</li>
<li>警告：使用compute或merge时，要记住你提供的函数不能做太多工作。这个函数运行时，可能会阻塞对映射的其他更新。当然，这个函数也不能更新映射的其他部分</li>
</ul>
</li>
</ul>
<h3 id="1473-对并发散列映射的批操作"><a class="markdownIt-Anchor" href="#1473-对并发散列映射的批操作"></a> 14.7.3 对并发散列映射的批操作</h3>
<ul>
<li>Java SE 8为并发散列映射提供了批操作，即使有其他线程在处理映射，这些操作也能安全地执行</li>
<li>3中不同的操作
<ul>
<li>搜索为每个键或值提供一个函数，直到函数生成一个非null的结果。然后搜索终止，返回这个函数的结果</li>
<li>归约组合所有键或值，这里要使用所提供的一个累加函数</li>
<li>forEach为所有键或值提供一个函数</li>
</ul>
</li>
<li>每个操作都有4个版本
<ul>
<li>operationKeys：处理键</li>
<li>operationValues：处理值</li>
<li>operation：处理键和值</li>
<li>operationEntries：处理Map.Entry对象</li>
</ul>
</li>
<li>需要指定一个参数化阈值(parallelism threshold)。如果映射包含的元素多于这个阈值，就会并行完成批操作。如果希望批操作在一个线程中运行，可以使用阈值Long.MAX_VALUE。如果希望用尽可能多的线程运行批操作，可以使用阈值1</li>
</ul>
<h3 id="1474-并发集视图"><a class="markdownIt-Anchor" href="#1474-并发集视图"></a> 14.7.4 并发集视图</h3>
<ul>
<li>假设你想要的是一个大的线程安全的集而不是映射。并没有一个ConcurrentHashSet类，而且你肯定不想自己创建这样一个类。当然，可以使用ConcurrentHashMap(包含“假”值)，不过这会得到一个映射而不是集，而且不能应用Set接口的操作</li>
<li>静态newKeySet方法会生成一个Set&lt;K&gt;，这实际上是ConcurrentHashMap&lt;K，Boolean&gt;的一个包装器。(所有映射值都为Boolean.TRUE，不过因为只是要把它用作一个集，所以并不关心具体的值</li>
<li>如果原来有一个映射，keySet方法可以生成这个映射的键集。这个集是可变的。如果删除这个集的元素，这个键(以及相应的值)会从映射中删除。不过，不能向键集增加元素，因为没有相应的值可以增加。Java SE 8为ConcurrentHashMap增加了第二个keySet方法，包含一个默认值</li>
</ul>
<h3 id="1475-写数组的拷贝"><a class="markdownIt-Anchor" href="#1475-写数组的拷贝"></a> 14.7.5 写数组的拷贝</h3>
<ul>
<li>CopyOnWriteArrayList和CopyOnWriteArraySet是线程安全的集合，其中所有的修改线程对底层数组进行复制</li>
<li>如果在集合上进行迭代的线程数超过修改线程数，这样的安排是很有用的。当构建一个迭代器的时候，它包含一个对当前数组的引用。如果数组后来被修改了，迭代器仍然引用旧数组，但是，集合的数组已经被替换了。因而，旧的迭代器拥有一致的(可能过时的)视图，访问它无须任何同步开销</li>
</ul>
<h3 id="1476-并行数组算法"><a class="markdownIt-Anchor" href="#1476-并行数组算法"></a> 14.7.6 并行数组算法</h3>
<ul>
<li>在Java SE 8中，Arrays类提供了大量并行化操作。静态Arrays.parallelSort方法可以对一个基本类型值或对象的数组排序</li>
<li>对对象排序时，可以提供一个Comparator</li>
<li>对于所有方法都可以提供一个范围的边界</li>
<li>parallelSetAll方法会用由一个函数计算得到的值填充一个数组。这个函数接收元素索引，然后计算相应位置上的值</li>
<li>parallelPrefix方法，它会用对应一个给定结合操作的前缀的累加结果替换各个数组元素</li>
</ul>
<h3 id="1477-较早的线程安全集合"><a class="markdownIt-Anchor" href="#1477-较早的线程安全集合"></a> 14.7.7 较早的线程安全集合</h3>
<ul>
<li>从Java的初始版本开始，Vector和Hashtable类就提供了线程安全的动态数组和散列表的实现。现在这些类被弃用了，取而代之的是ArrayList和HashMap类。这些类不是线程安全的，而集合库中提供了不同的机制。任何集合类都可以通过使用同步包装器(synchronization wrapper)变成线程安全的</li>
<li>确保没有任何线程通过原始的非同步方法访问数据结构。最便利的方法是确保不保存任何指向原始对象的引用，简单地构造一个集合并立即传递给包装器</li>
<li>在另一个线程可能进行修改时要对集合进行迭代，仍然需要使用“客户端”锁定</li>
<li>如果使用“for each”循环必须使用同样的代码，因为循环使用了迭代器。注意：如果在迭代过程中，别的线程修改集合，迭代器会失效，抛出ConcurrentModificationException异常。同步仍然是需要的，因此并发的修改可以被可靠地检测出来</li>
<li>最好使用java.util.concurrent包中定义的集合，不使用同步包装器中的。特别是，假如它们访问的是不同的桶，由于ConcurrentHashMap已经精心地实现了，多线程可以访问它而且不会彼此阻塞。有一个例外是经常被修改的数组列表。在那种情况下，同步的ArrayList可以胜过CopyOnWriteArrayList</li>
</ul>
</div><div class="story post-story"><h2 id="148-callable与future"><a class="markdownIt-Anchor" href="#148-callable与future"></a> 14.8 Callable与Future</h2>
<ul>
<li>Runnable封装一个异步运行的任务，可以把它想象成为一个没有参数和返回值的异步方法。Callable与Runnable类似，但是有返回值</li>
<li>Callable接口是一个参数化的类型，只有一个方法call</li>
<li>Future保存异步计算的结果。可以启动一个计算，将Future对象交给某个线程，然后忘掉它。Future对象的所有者在结果计算好之后就可以获得它</li>
</ul>
</div><div class="story post-story"><h2 id="149-执行器"><a class="markdownIt-Anchor" href="#149-执行器"></a> 14.9 执行器</h2>
<ul>
<li>如果程序中创建了大量的生命期很短的线程，应该使用线程池(thread pool)。一个线程池中包含许多准备运行的空闲线程。将Runnable对象交给线程池，就会有一个线程调用run方法。当run方法退出时，线程不会死亡，而是在池中准备为下一个请求提供服务</li>
<li>另一个使用线程池的理由是减少并发线程的数目。创建大量线程会大大降低性能甚至使虚拟机崩溃。如果有一个会创建许多线程的算法，应该使用一个线程数“固定的”线程池以限制并发线程的总数</li>
<li>执行器(Executor)类有许多静态工厂方法用来构建线程池</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-12-03-16-15-07.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2021-12-03-16-15-07.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="执行者工厂方法" /></p>
<h3 id="1491-线程池"><a class="markdownIt-Anchor" href="#1491-线程池"></a> 14.9.1 线程池</h3>
<ul>
<li>newCached-ThreadPool方法构建了一个线程池，对于每个任务，如果有空闲线程可用，立即让它执行任务，如果没有可用的空闲线程，则创建一个新线程</li>
<li>newFixedThreadPool方法构建一个具有固定大小的线程池。如果提交的任务数多于空闲的线程数，那么把得不到服务的任务放置到队列中。当其他任务完成以后再运行它们</li>
<li>newSingleThreadExecutor是一个退化了的大小为1的线程池：由一个线程执行提交的任务，一个接着一个</li>
<li>这3个方法返回实现了ExecutorService接口的ThreadPoolExecutor类的对象</li>
<li>在使用连接池时应该做的事
<ol>
<li>调用Executors类中静态的方法newCachedThreadPool或newFixedThreadPool。</li>
<li>调用submit提交Runnable或Callable对象。</li>
<li>如果想要取消一个任务，或如果提交Callable对象，那就要保存好返回的Future对象。</li>
<li>当不再提交任何任务时，调用shutdown</li>
</ol>
</li>
</ul>
<h3 id="1492-预定执行"><a class="markdownIt-Anchor" href="#1492-预定执行"></a> 14.9.2 预定执行</h3>
<ul>
<li>ScheduledExecutorService接口具有为预定执行(Scheduled Execution)或重复执行任务而设计的方法。它是一种允许使用线程池机制的java.util.Timer的泛化</li>
<li>Executors类的newScheduledThreadPool和newSingleThreadScheduledExecutor方法将返回实现了Scheduled-ExecutorService接口的对象</li>
<li>可以预定Runnable或Callable在初始的延迟之后只运行一次。也可以预定一个Runnable对象周期性地运行</li>
</ul>
<h3 id="1493-控制任务组"><a class="markdownIt-Anchor" href="#1493-控制任务组"></a> 14.9.3 控制任务组</h3>
<ul>
<li>将一个执行器服务作为线程池使用，以提高执行任务的效率</li>
<li>有时，使用执行器有更有实际意义的原因，控制一组相关任务</li>
</ul>
<hr />
<ul>
<li>invokeAny方法提交所有对象到一个Callable对象的集合中，并返回某个已经完成了的任务的结果。无法知道返回的究竟是哪个任务的结果，也许是最先完成的那个任务的结果。对于搜索问题，如果你愿意接受任何一种解决方案的话，你就可以使用这个方法</li>
<li>invokeAll方法提交所有对象到一个Callable对象的集合中，并返回一个Future对象的列表，代表所有任务的解决方案</li>
<li>缺点是如果第一个任务恰巧花去了很多时间，则可能不得不进行等待。将结果按可获得的顺序保存起来更有实际意义。可以用ExecutorCompletionService来进行排列</li>
<li>用常规的方法获得一个执行器。然后，构建一个ExecutorCompletionService，提交任务给完成服务(completion service)。该服务管理Future对象的阻塞队列，其中包含已经提交的任务的执行结果(当这些结果成为可用时)</li>
</ul>
<h3 id="1494-fork-join框架"><a class="markdownIt-Anchor" href="#1494-fork-join框架"></a> 14.9.4 Fork-Join框架</h3>
<ul>
<li>Java SE 7中新引入了fork-join框架，专门用来支持后一类应用。假设有一个处理任务，它可以很自然地分解为子任务</li>
<li>要采用框架可用的一种方式完成这种递归计算，需要提供一个扩展RecursiveTask＜T＞的类(如果计算会生成一个类型为T的结果)或者提供一个扩展RecursiveAction的类(如果不生成任何结果)。再覆盖compute方法来生成并调用子任务，然后合并其结果</li>
<li>在后台，fork-join框架使用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取(work stealing)。每个工作线程都有一个双端队列(deque)来完成任务。一个工作线程将子任务压入其双端队列的队头。(只有一个线程可以访问队头，所以不需要加锁。)一个工作线程空闲时，它会从另一个双端队列的队尾“密取”一个任务。由于大的子任务都在队尾，这种密取很少出现</li>
</ul>
<h3 id="1495-可完成future"><a class="markdownIt-Anchor" href="#1495-可完成future"></a> 14.9.5 可完成Future</h3>
<ul>
<li>处理非阻塞调用的传统方法是使用事件处理器，程序员为任务完成之后要出现的动作注册一个处理器</li>
<li>Java SE 8的CompletableFuture类提供了一种候选方法。与事件处理器不同，“可完成future”可以“组合”(composed)</li>
<li>利用可完成future，可以指定你希望做什么，以及希望以什么顺序执行这些工作。当然，这不会立即发生，不过重要的是所有代码都放在一处</li>
<li>从概念上讲，CompletableFuture是一个简单API，不过有很多不同方法来组合可完成future。下面先来看处理单个future的方法(如表14-3所示)。(对于这里所示的每个方法，还有两个Async形式，不过这里没有给出，其中一种形式使用一个共享ForkJoinPool，另一种形式有一个Executor参数)。在这个表中，我使用了简写记法来表示复杂的函数式接口，这里会把Function＜？super T，U＞写为T-＞U。当然这并不是真正的Java类型</li>
</ul>
</div><div class="story post-story"><h2 id="1410-同步器"><a class="markdownIt-Anchor" href="#1410-同步器"></a> 14.10 同步器</h2>
<ul>
<li>线程之间的共用集结点模式：如果有一个相互合作的线程集满足这些行为模式之一，那么应该直接重用合适的库类而不要试图提供手工的锁与条件的集合</li>
</ul>
<h3 id="14101-信号量"><a class="markdownIt-Anchor" href="#14101-信号量"></a> 14.10.1 信号量</h3>
<p>一个信号量管理许多的许可证(permit)。为了通过信号量，线程通过调用acquire请求许可。其实没有实际的许可对象，信号量仅维护一个计数。许可的数目是固定的，由此限制了通过的线程数量。其他线程可以通过调用release释放许可。而且，许可不是必须由获取它的线程释放。事实上，任何线程都可以释放任意数目的许可，这可能会增加许可数目以至于超出初始数目</p>
<h3 id="14102-倒计时门栓"><a class="markdownIt-Anchor" href="#14102-倒计时门栓"></a> 14.10.2 倒计时门栓</h3>
<ul>
<li>一个倒计时门栓(CountDownLatch)让一个线程集等待直到计数变为0。倒计时门栓是一次性的。一旦计数为0，就不能再重用了</li>
<li>一个有用的特例是计数值为1的门栓。实现一个只能通过一次的门。线程在门外等候直到另一个线程将计数器值置为0</li>
</ul>
<h3 id="14103-障栅"><a class="markdownIt-Anchor" href="#14103-障栅"></a> 14.10.3 障栅</h3>
<ul>
<li>CyclicBarrier类实现了一个集结点(rendezvous)称为障栅(barrier)。考虑大量线程运行在一次计算的不同部分的情形。当所有部分都准备好时，需要把结果组合在一起。当一个线程完成了它的那部分任务后，我们让它运行到障栅处。一旦所有的线程都到达了这个障栅，障栅就撤销，线程就可以继续运行</li>
<li>障栅被称为是循环的(cyclic)，因为可以在所有等待线程被释放后被重用。在这一点上，有别于CountDownLatch，CountDownLatch只能被使用一次</li>
<li>Phaser类增加了更大的灵活性，允许改变不同阶段中参与线程的个数</li>
</ul>
<h3 id="14104-交换器"><a class="markdownIt-Anchor" href="#14104-交换器"></a> 14.10.4 交换器</h3>
<p>当两个线程在同一个数据缓冲区的两个实例上工作的时候，就可以使用交换器(Exchanger)。典型的情况是，一个线程向缓冲区填入数据，另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区</p>
<h3 id="14105-同步队列"><a class="markdownIt-Anchor" href="#14105-同步队列"></a> 14.10.5 同步队列</h3>
<ul>
<li>同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用SynchronousQueue的put方法时，它会阻塞直到另一个线程调用take方法为止，反之亦然。与Exchanger的情况不同，数据仅仅沿一个方向传递，从生产者到消费者</li>
<li>即使SynchronousQueue类实现了BlockingQueue接口，概念上讲，它依然不是一个队列。它没有包含任何元素，它的size方法总是返回0</li>
</ul>
<hr />
<p>卷二部分</p>
<hr />
<h1 id="2-输入与输出"><a class="markdownIt-Anchor" href="#2-输入与输出"></a> 2 输入与输出</h1>
</div><div class="story post-story"><h2 id="21-输入输出"><a class="markdownIt-Anchor" href="#21-输入输出"></a> 2.1 输入/输出</h2>
<ul>
<li>在JavaAPI中，可以从其中读入一个字节序列的对象称为输入流</li>
<li>可以向其中写入一个字节序列的对象称为输出流</li>
<li><mark>抽象类InputStream和OutputStream构成了输入输出类层次结构的基础</mark>
<ul>
<li>这些类的读入和写出操作以基于二字节的char值(Unicode码元)为基础</li>
</ul>
</li>
</ul>
<h3 id="211-读写字节"><a class="markdownIt-Anchor" href="#211-读写字节"></a> 2.1.1 读写字节</h3>
<ul>
<li>InputStream类
<ul>
<li>抽象方法: abstract int read()
<ul>
<li>读入一个字节,并返回读入的字节或者在遇到输入源结尾时返回-1</li>
</ul>
</li>
</ul>
</li>
<li>OutputStream类
<ul>
<li>抽象方法：abstract void write(int b)
<ul>
<li>从某个位置输出一个字节</li>
</ul>
</li>
</ul>
</li>
<li><mark>read和write在执行时江北阻塞，直至字节确实被读入或写出</mark></li>
<li>available()方法——检查当前可读入的字节数量</li>
<li>close()方法——完成对输入/输出流的读写时，关闭流释放操作系统资源</li>
</ul>
<h3 id="212-完整的流家族"><a class="markdownIt-Anchor" href="#212-完整的流家族"></a> 2.1.2 完整的流家族</h3>
<ul>
<li>InputStream和OutputStream流构成层次结构的基础
<ul>
<li>读写单个字节或字节数组</li>
<li>子类包含很多有用的输入和输出流</li>
</ul>
</li>
<li>抽象类Reader和Writer子类,处理Unicode文本,基本方法为read()与write()方法</li>
<li>四个附加接口: Closeable Flushable Readable 和 Appendable
<ul>
<li>Closeable Flushable分别拥有close() flush()方法</li>
<li>Appendable接口有两个用于添加单个字符和字符序列的方法 append(char c) append(CharSequence s)</li>
<li>InputStream OutputStream Reader Writer 都实现了Closeable接口</li>
<li>OutputStream和Writer实现了Flushable接口<br />
<img src="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-03-02-15-59-36.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed/2022-03-02-15-59-36.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="流家族的接口" /></li>
</ul>
</li>
</ul>
<h3 id="213-组合输入输出流过滤器"><a class="markdownIt-Anchor" href="#213-组合输入输出流过滤器"></a> 2.1.3 组合输入/输出流过滤器</h3>
<ul>
<li>FileInputStream和FileOutputStream可以提供附着在一个磁盘文件上的输入流和输出流,只需向构造器提供文件名或文件的完整路径名
<ul>
<li>只支持在字节级别上的读写</li>
</ul>
</li>
<li>某些输入流(FileInputStream)可以从文件和其他外部位置获取字节;而其他的输入流(DataInputStream)可以将字节组装到更有用的数据类型中,<mark>对两者进行组合操作</mark></li>
<li><mark>输入流在默认情况下是不被缓冲区缓存的</mark>
<ul>
<li>每个对read的调用都会请求操作系统再分发一个字节，<strong>请求一个数据块，并将其置于缓冲区中会更加高效</strong></li>
</ul>
</li>
<li>当多个输入流链接在一起，跟踪个各个中介输入流：使用PushbackInputStream</li>
<li><mark>能预先浏览并且还可以读入数字</mark>，<mark>需要一个既是可回推输入流，又是一个数据输入流的引用</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了从文件中读入数字</span></span><br><span class="line"><span class="comment">//首先需要创建一个FileInputStream</span></span><br><span class="line"><span class="comment">//然后将其创建给DataInputStream的构造器</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;employee.dat&quot;</span>);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">din</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fin);</span><br><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> din.readDouble();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用缓冲机制</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">din</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;employee.dat&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟踪中介流</span></span><br><span class="line"><span class="type">PushbackInputStream</span> <span class="variable">pbin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PushbackInputStream</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;emoloyee.dat&quot;</span>)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"><span class="comment">//预读下一个字节</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> pbin.read();</span><br><span class="line"><span class="comment">// 退回流中</span></span><br><span class="line"><span class="keyword">if</span>(b != <span class="string">&#x27;&lt;&#x27;</span>) pbin.unread();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能预先浏览并且还可以读入数字</span></span><br><span class="line"><span class="comment">// 既是可回推输入流，又是一个数据输入流的引用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">din</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">  pbin = <span class="keyword">new</span> <span class="title class_">PushbackInputStream</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;employee.dat&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="22-文本输入与输出"><a class="markdownIt-Anchor" href="#22-文本输入与输出"></a> 2.2 文本输入与输出</h2>
<ul>
<li>Java内部使用UTF-16编码，字符串编码为16进制，<mark>许多应用程序使用UTF-8编码</mark></li>
<li><mark>OutputStreamWriter类将使用特定的字符编码方式，把Unicode码元的输出流转换为字节流</mark>=</li>
<li><mark>InputStreamReader类将包含字节的输入流转换为可以产生Unicode码元的读入器</mark></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个输入读入器从控制台读入键盘敲击信息，并转换为Unicode</span></span><br><span class="line"><span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line"><span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>),StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<h3 id="221-如何写出文本输出"><a class="markdownIt-Anchor" href="#221-如何写出文本输出"></a> 2.2.1 如何写出文本输出</h3>
<ul>
<li>对于文本输出,使用PrintWriter(存在可以链接到FileWriter的便捷写法)
<ul>
<li>为了输出到打印写出器，需要使用print,println,printf方法</li>
<li><mark>println方法在行中添加了对目标系统来说恰当的行结束符</mark>
<ul>
<li><mark>写出器设置为自动冲刷模式，那么只要println被调用，缓冲区中的所有字符都会被发送到它们的目的地</mark></li>
<li>默认情况下，自动冲刷机制是禁用的，你可以通过使用PrintWriter（Writer out，Boolean autoFlush）来启用或禁用自动冲刷机制</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrintWriter</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;employee.txt&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Harry Hacker&quot;</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> <span class="number">75000</span>;</span><br><span class="line">out.print(name);</span><br><span class="line">out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">out.println(salary);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用自动冲刷机制</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">  ),<span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="222-如何读入文本输入"><a class="markdownIt-Anchor" href="#222-如何读入文本输入"></a> 2.2.2 如何读入文本输入</h3>
<ul>
<li>使用Scanner对象
<ul>
<li>若文件太大，可以处理为Stream&lt;String&gt;对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Files.readAllBytes(path),charset);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path,charset);</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; lines = Files.lines(path,charset);</span><br></pre></td></tr></table></figure>
<h3 id="224-字符编码方法"><a class="markdownIt-Anchor" href="#224-字符编码方法"></a> 2.2.4 字符编码方法</h3>
<ul>
<li>Java针对字符使用的是Unicode标准，每个字符或编码点有21位整数
<ul>
<li>最常见的编码方式是UTF-8标准，将每个Unicode编码点编码为1到4个字节的序列
<ul>
<li>UTF-8的好处是传统的包含了英语中用到的所有字符的ASCII字符集中的每个字符都只会占用一个字节</li>
</ul>
</li>
<li>UTF-16，它会将每个Unicode编码点编码为1个或2个16位值</li>
</ul>
</li>
<li>StandardCharsets类具有类型为Charset的静态变量，用于表示每种Java虚拟机都必须支持的字符编码方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StandardCharsets.UTF_8</span><br><span class="line">StandardCharsets.UTF_16</span><br><span class="line">StandardCharsets.UTF_16BE</span><br><span class="line">StandardCharsets.UTF_16LE</span><br><span class="line">StandardCharsets.ISO_8859_1</span><br><span class="line">StandardCharsets.US_ASCII</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="23-读写二进制数据"><a class="markdownIt-Anchor" href="#23-读写二进制数据"></a> 2.3 读写二进制数据</h2>
<h3 id="231-datainput和dataoutput接口"><a class="markdownIt-Anchor" href="#231-datainput和dataoutput接口"></a> 2.3.1 DataInput和DataOutput接口</h3>
<ul>
<li>DataOutput接口定义了以二进制格式写数组、字符、boolean值和字符串的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">writeChars</span><br><span class="line">writeByte</span><br><span class="line"></span><br><span class="line"><span class="comment">// writeInt总是将一个整数写出为4字节的二进制数量值，而不管它有多少位</span></span><br><span class="line">writeInt</span><br><span class="line"></span><br><span class="line">writeShort</span><br><span class="line">writeLong</span><br><span class="line">writeFloat</span><br><span class="line"></span><br><span class="line"><span class="comment">// writeDouble总是将一个double值写出为8字节的二进制数量值</span></span><br><span class="line">writeDouble</span><br><span class="line">writeChar</span><br><span class="line">writeBoolean</span><br><span class="line"></span><br><span class="line"><span class="comment">// writeUTF方法使用修订版的8位Unicode转换格式写出字符串</span></span><br><span class="line">writeUTF</span><br></pre></td></tr></table></figure>
<ul>
<li>DataInput接口定义的方法，读回数据</li>
<li>DataInputStream类实现了DataInput接口
<ul>
<li>为了方便从文件中读入二进制数据，可以将DataInputStream与某个字节源相组合</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">readInt</span><br><span class="line">readShort</span><br><span class="line">readLong</span><br><span class="line">readFloat</span><br><span class="line">readDouble</span><br><span class="line">readChar</span><br><span class="line">readBoolean</span><br><span class="line">readUTF</span><br><span class="line"></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;employee.dat&quot;</span>));</span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOuputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.dat&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="232-随机访问文件"><a class="markdownIt-Anchor" href="#232-随机访问文件"></a> 2.3.2 随机访问文件</h3>
<ul>
<li>RandomAccessFile类可以在文件中的任何位置查找或写入数据
<ul>
<li>磁盘文件都是随机访问的，但是与网络套接字通信的输入/输出流却不是，可以打开一个随机访问文件，只用于读入或者同时用于读写</li>
<li>seek方法——将这个文件指针设置到文件中的任意字节位置——参数位一个long整数</li>
<li>getFilePointer方法——返回文件指针的位置</li>
<li>length方法——获得文件中的总字节数</li>
<li>writeFixedString方法——写出从字符串开头开始的指定数量的码元</li>
<li>readFixedString方法——从输入流中读入字符，直至读入size个码元，或者直至遇到具有0值得字符串
<ul>
<li>为了提高效率，使用StringBuilder类来读入字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;employee.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">inOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;employee.dat&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">in.seek((n-<span class="number">1</span>)*RECOED_SIZE);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">e.readData(in);</span><br><span class="line"></span><br><span class="line">e.writeData(out);</span><br></pre></td></tr></table></figure>
<h3 id="233-zip文档"><a class="markdownIt-Anchor" href="#233-zip文档"></a> 2.3.3 ZIP文档</h3>
<ul>
<li>ZIP文档都存在一个头，包含压缩文件的信息</li>
<li><mark>使用ZipInputStream来读入ZIP文档</mark>
<ul>
<li>getNextEntry方法——返回一个描述这些ZipEntry类型得对象</li>
<li>getInputStream方法——传递ZipEntry获得该项的输入流</li>
<li>closeEntry方法——读入下一项</li>
</ul>
</li>
<li><mark>使用ZipOutputStream写出到ZIP文件</mark>
<ul>
<li>对于希望放入到ZIP文件中的每一项，都应该创建一个ZipEntry对象，并将文件名传递给ZipEntry的构造器，它将设置其他诸如文件日期和解压缩方法等参数</li>
<li>putNextEntry方法——开始写出新文件，并将文件数据发送到ZIP输出流中</li>
<li>closeEntry方法——完成操作调用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZipInputStream</span> <span class="variable">zin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipname));</span><br><span class="line">ZipEntry entry;</span><br><span class="line"><span class="keyword">while</span>((entry = zin.getNextEntry()) != <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> zin.getInputStream(entry);</span><br><span class="line">  ...</span><br><span class="line">  zin.closeEntry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.zip&quot;</span>);</span><br><span class="line"><span class="type">ZipoutputStream</span> <span class="variable">zout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(fout);</span><br><span class="line"><span class="keyword">for</span> all files</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ZipEntry</span> <span class="variable">ze</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipEntry</span>(filename);</span><br><span class="line">  zout.putNextEntry(ze);</span><br><span class="line">  ...</span><br><span class="line">  zout.closeEntry();</span><br><span class="line">&#125;</span><br><span class="line">zout.close();</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="24-对象输入输出流与序列化"><a class="markdownIt-Anchor" href="#24-对象输入输出流与序列化"></a> 2.4 对象输入/输出流与序列化</h2>
<ul>
<li>对象序列化可以实现将任何对象写出到输出流中，并在之后将其读回</li>
</ul>
<h3 id="241-保存和加载序列化对象"><a class="markdownIt-Anchor" href="#241-保存和加载序列化对象"></a> 2.4.1 保存和加载序列化对象</h3>
<ul>
<li>为了保存对象数据，首先需要打开一个ObjectOutputStream对象
<ul>
<li>为了保存对象，可以直接使用ObjecyOutputStream的writeObject方法</li>
</ul>
</li>
<li>为了将对象读回，首先需要获得一个ObjectInputStream对象
<ul>
<li>用readObject方法将这些对象被写出时的顺序获得他们</li>
</ul>
</li>
<li><mark>在对象输出流中存储或从对象输入流中回复的所有类必须实现Serialzable接口</mark></li>
<li>每个对象都时用一个序列号保存（对象序列化的原因）
<ul>
<li>对遇到的每一个对象引用都关联一个序列号</li>
<li>对于每个对象，当第一次遇到时，保存其对象数据到输出流中</li>
<li>如果某个对象之前已经被保存过，那么只写出”与之前保存过的序列号x的对象相同“
<ul>
<li>对于对象输入流中的对象，在第一次遇到其序列号时，构建它，并使用流中数据来初始化它，然后记录这个顺序号和新对象之间的关联</li>
<li>当遇到“与之前保存过的序列号为x的对象相同”标记时，获取与这个顺序号相关联的对象引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">harry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry&quot;</span>, <span class="number">50000</span>, <span class="number">1989</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;Carl&quot;</span>, <span class="number">80000</span>, <span class="number">1989</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">out.writeObject(harry);</span><br><span class="line">out.writeObject(boss);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;employee.dat&quot;</span>));</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> (Employee) in.readObject();</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> (Employee) in.readObject();</span><br></pre></td></tr></table></figure>
<h3 id="242-理解对象序列化的文件格式"><a class="markdownIt-Anchor" href="#242-理解对象序列化的文件格式"></a> 2.4.2 理解对象序列化的文件格式</h3>
<ul>
<li>对象流输出中包含所有对象的类型和数据域</li>
<li>每个对象都被赋予一个序列号</li>
<li>相同对象的重复出现将被存储为对这个对象的序列号的引用</li>
</ul>
</div><div class="story post-story"><h2 id="25-操作文件"><a class="markdownIt-Anchor" href="#25-操作文件"></a> 2.5 操作文件</h2>
<ul>
<li>Path接口和Files类</li>
<li>Path和Files类封装了在用户机器上处理文件系统所需的所有功能</li>
</ul>
<h3 id="251-path"><a class="markdownIt-Anchor" href="#251-path"></a> 2.5.1 Path</h3>
<ul>
<li>Path表示是一个目录名序列，其后还可以跟着一个文件名
<ul>
<li>Paths.get方法——接受一个或多个字符串，并将它们用默认文件系统的路径分隔符连接起来，这个连接起来的结果就是一个Path对象</li>
</ul>
</li>
<li>p.resolve(q)——按照规则返回一个路径，如果q是绝对路径，则结果就是q；否则，根据文件系统的规则，将“p后面跟着q”作为结果
<ul>
<li>resolveSibling()——通过解析指定路径的父路径产生器兄弟路径</li>
</ul>
</li>
<li>p.relativize®——调用将产生路径q，而对q进行解析的结果正是r</li>
<li>normalize()——将移除所有冗余的.和…部件(或者文件系统认为冗余的所有部件)</li>
<li>toAbsolutePath()——将产生给定路径的绝对路径，该绝对路径从根部件开始</li>
</ul>
<h3 id="252-读写文件"><a class="markdownIt-Anchor" href="#252-读写文件"></a> 2.5.2 读写文件</h3>
<ul>
<li>Files类使操作普通文件更快捷</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件的所有内容</span></span><br><span class="line"><span class="type">byte</span>[] bytes = Files.readAllBytes(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当作字符串读入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, charset);</span><br><span class="line"><span class="comment">// 当作序列读入</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path,charset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写出一个字符串到文件中</span></span><br><span class="line">Files.write(path,content.getBytes(charset));</span><br><span class="line"><span class="comment">// 指定文件追加内容</span></span><br><span class="line">Files.write(path,content.getBytes(charset)， StandardOption.APPEND);</span><br><span class="line"><span class="comment">// 将一个行的集合写出到文件中</span></span><br><span class="line">Files.write(path, lines);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要处理的文件长度比较大，或者是二进制文件</span></span><br><span class="line"><span class="comment">// 那么还是应该使用所熟知的输入/输出流或者读入器/写出器</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Files.newInputStream(path);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> Files.newOutputStream(path);</span><br><span class="line"><span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> Files.newBufferedReader(path,charset);</span><br><span class="line"><span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> Files.newBufferedwriter(path,charset);</span><br></pre></td></tr></table></figure>
<h3 id="253-创建文件和目录"><a class="markdownIt-Anchor" href="#253-创建文件和目录"></a> 2.5.3 创建文件和目录</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新目录</span></span><br><span class="line">Files.createDirectory(path);</span><br><span class="line"><span class="comment">// 路径中除最后一个部件外，其他部分都必须是已经存在的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要创建路径中的中间目录</span></span><br><span class="line">Files.createDirectories(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建空文件</span></span><br><span class="line">Files.createFile(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些便捷方法可以用来在给定位置或者系统指定位置创建临时文件或临时目录</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> Files.createTempFile(dir,prefix,suffix);</span><br><span class="line"><span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> Files.createTempFile(prefix,suffix); </span><br><span class="line"><span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> Files.createTempDirectory(dir,prefix);</span><br><span class="line"><span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> Files.createTempDirectory(prefix);</span><br></pre></td></tr></table></figure>
<h3 id="254-复制移动和删除文件"><a class="markdownIt-Anchor" href="#254-复制移动和删除文件"></a> 2.5.4 复制,移动和删除文件</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line">Files.copy(fromPath, toPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动文件</span></span><br><span class="line">Files.move(fromPath, toPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想要覆盖已有的目标路径，可以使用REPLACE_EXISTING选项</span></span><br><span class="line"><span class="comment">// 如果想要复制所有的文件属性，可以使用COPY_ATTRIBUTES选项</span></span><br><span class="line">Files.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将移动操作定义为原子性的，这样就可以保证要么移动操作成功完成，要么源文件继续保持在原来位置</span></span><br><span class="line"><span class="comment">// 具体可以使用ATOMIC_MOVE选项来实现</span></span><br><span class="line">Files.copy(fromPath, toPath,StandardCopyOption.ATOMIC_MOVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入流复制，或将一个Path复制到输出流中</span></span><br><span class="line">Files.copy(inputStream,toPath);</span><br><span class="line">Files.copy(fromPath,outputStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件</span></span><br><span class="line">Files.delete(path);</span><br><span class="line">Files.deleteExists(path);</span><br></pre></td></tr></table></figure>
<h3 id="255-获取文件信息"><a class="markdownIt-Anchor" href="#255-获取文件信息"></a> 2.5.5 获取文件信息</h3>
<ul>
<li>所有的文件系统都会报告一个基本属性集，它们被封装在BasicFileAttributes接口中，这些属性与上述信息有部分重叠。基本文件属性包括：
<ul>
<li>创建文件、最后一次访问以及最后一次修改文件的时间，这些时间都表示成java.nio.file.attribute.FileTime</li>
<li>文件是常规文件、目录还是符号链接，抑或这三者都不是</li>
<li>文件尺寸</li>
<li>文件主键，这是某种类的对象，具体所属类与文件系统相关，有可能是文件的唯一标识符，也可能不是</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法将返回一个boolean值，表示检查路径的某个属性的结果</span></span><br><span class="line">- exists</span><br><span class="line">- isHidden</span><br><span class="line">- isReadable，isWritable，isExecutable</span><br><span class="line">- isRegularFile，isDirectory，isSymbolicLink</span><br><span class="line"></span><br><span class="line"><span class="comment">// size方法返回文件的字节数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> Files.size(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得文件属性</span></span><br><span class="line"><span class="type">BasicFileAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> Files.readAttributes(path,BasicFileAttributes.class);</span><br></pre></td></tr></table></figure>
<h3 id="256-访问目录中的项"><a class="markdownIt-Anchor" href="#256-访问目录中的项"></a> 2.5.6 访问目录中的项</h3>
<ul>
<li><mark>静态的Files.list方法会返回一个可以读取目录中各个项的Stream&lt;Path&gt;对象</mark>
<ul>
<li>目录是被惰性读取的，这使得处理具有大量项的目录可以变得更高效</li>
<li>读取目录涉及需要关闭的系统资源，所以应该使用try块</li>
</ul>
</li>
<li><mark>为了处理目录中的所有子目录，需要使用File.walk方法</mark>
<ul>
<li>可以通过调用File.walk（pathToRoot, depth）来限制想要访问的树的深度</li>
<li>两种walk方法都具有FileVisitOption…的可变长参数，但是你只能提供一种选项：FOLLOW_LINKS，即跟踪符号链接</li>
<li>如果要过滤walk返回的路径，并且你的过滤标准涉及与目录存储相关的文件属性，<mark>那么应该使用find方法来替代walk方法</mark>
<ul>
<li>可以用某个谓词函数来调用这个方法，该函数接受一个路径和一个BasicFileAttributes对象(效率高：因为路径总是会被读入，所以这些属性很容易获取)</li>
</ul>
</li>
</ul>
</li>
<li><mark>无法很容易地使用Files.walk方法来删除目录树，因为你需要在删除父目录之前必须先删除子目录</mark></li>
</ul>
<h3 id="257-使用目录流"><a class="markdownIt-Anchor" href="#257-使用目录流"></a> 2.5.7 使用目录流</h3>
<ul>
<li>对遍历过程进行更加细粒度的控制，<mark>应该使用File.newDirectoryStream对象，它会产生一个DirectoryStream</mark></li>
<li><mark>注意，它不是java.util.stream.Stream的子接口，而是专门用于目录遍历的接口</mark></li>
<li>是Iterable的子接口，因此你可以在增强的for循环中使用目录流</li>
<li><mark>如果想要访问某个目录的所有子孙成员，可以转而调用walkFileTree方法，并向其传递一个FileVisitor类型的对象</mark>
<ul>
<li>便捷类SimpleFileVisitor实现了FileVisitor接口，但是其除visitFileFailed方法之外的所有方法并不做任何处理而是直接继续访问，而visitFileFailed方法会抛出由失败导致的异常，并进而终止访问</li>
</ul>
</li>
</ul>
<h3 id="258-zip文件系统"><a class="markdownIt-Anchor" href="#258-zip文件系统"></a> 2.5.8 ZIP文件系统</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果zipname是某个ZIP文件的名字，建立一个文件系统，包含ZIP文档中的所有文件</span></span><br><span class="line">Files.copy(fs.getPath(sourceName),targetPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 知道文件名从ZIP文档中复制出文件</span></span><br><span class="line"><span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span> FileSystem.newFileSystem(Paths.get(zipname),<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// fs.getPath对于任意文件系统来说，都与Paths.get类似</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出ZIP文档中的所有文件，遍历文件树</span></span><br><span class="line"><span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span> FileSystems.newFileSystem(Paths.get(zipname),<span class="literal">null</span>);</span><br><span class="line">Files.walkFileTree(fs.getPath(<span class="string">&quot;/&quot;</span>),<span class="keyword">new</span> <span class="title class_">SimpleFilevisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">  <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file,BasicFileAttributes attrs)</span><span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    System.out.println(file);</span><br><span class="line">    <span class="keyword">return</span> FilevisitResult.CONTINVE;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>Java8实战</p>
<hr />
<h1 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> Lambda表达式</h1>
</div><div class="story post-story"><h2 id="行为参数化"><a class="markdownIt-Anchor" href="#行为参数化"></a> 行为参数化</h2>
<ul>
<li>一种软件开发模式，<mark>将代码块作为参数传递给另一个方法，稍后再去执行，方法的行为就基于那块代码被参数化了</mark></li>
</ul>
</div><div class="story post-story"><h2 id="lambda表达式的三个部分参数列表箭头lambda主体"><a class="markdownIt-Anchor" href="#lambda表达式的三个部分参数列表箭头lambda主体"></a> Lambda表达式的三个部分:参数列表,箭头,Lambda主体</h2>
<ul>
<li>在函数式接口中使用Lambda接口
<ul>
<li>函数式接口就是只定义了一个抽象方法的接口,在该接口中可以拥有默认方法(即在类没有对方法进行实现时，其主体为方法提供默认实现的方法)</li>
<li>Lambda表达式允许直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例</li>
<li><mark>@ FunctionalInterface 为函数式接口的标注, 抽象方法的签名称为函数描述符</mark></li>
</ul>
</li>
<li>常用的函数式接口:
<ul>
<li>Predicate&lt;T&gt;  boolean test(T t)</li>
<li>Consumer&lt;T&gt;   void accept(T t)</li>
<li>Function&lt;T,R&gt;  R apply(T t)</li>
<li>Supplier&lt;T&gt;</li>
</ul>
</li>
<li><mark>引用类型(Byte,Integer,Object,List),与原始类型(int,double,byte,char)类型，但是泛型只能绑定到引用类型</mark>
<ul>
<li><mark>Java中具有将原始类型转换为引用类型的机制(装箱),同时存在拆箱的机制</mark></li>
<li>装箱后的值本质上就是把原始类型包裹起来，并保存在堆</li>
</ul>
</li>
<li>若Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）</li>
</ul>
<!-- more -->
</div><div class="story post-story"><h2 id="使用局部变量"><a class="markdownIt-Anchor" href="#使用局部变量"></a> 使用局部变量</h2>
<ul>
<li><mark>Lambda表达式允许使用自由变量(不是参数,而是在外层作用域定义的变量),被称为捕获Lambda</mark></li>
<li>局部变量必须显式声明为final(Lambda表达式只能捕获派给它们的局部变量一次)
<ul>
<li>第一，实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</li>
<li>第二，这一限制不鼓励你使用改变外部变量的典型命令式编程模式（我们会在以后的各章中解释，这种模式会阻碍很容易做到的并行处理）。</li>
</ul>
</li>
<li>Java8的Lambda和匿名类对值封闭，而不是对变量封闭(原因在局部变量保存在栈上，并且隐式表示他们仅限于其所在线程)</li>
</ul>
</div><div class="story post-story"><h2 id="方法引用lambda的快捷写法"><a class="markdownIt-Anchor" href="#方法引用lambda的快捷写法"></a> 方法引用(Lambda的快捷写法)</h2>
<ul>
<li>方法引用的三类
<ul>
<li>指向静态方法的方法引用</li>
<li>指向任意类型实例方法的方法引用</li>
<li>指向现有对象的实例方法的方法引用</li>
</ul>
</li>
<li>构造函数引用
<ul>
<li>可以利用名称和关键字new来创建引用</li>
</ul>
</li>
<li>复合Lambda表达式
<ul>
<li>比较器复合: 1.逆序 2.比较器链</li>
<li>谓词复合: negate、and和or</li>
<li>函数复合: andThen 方法会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数；compose方法把给定的函数用作compose的参数里面给的那个函数，然后再把函数本身用于结果</li>
</ul>
</li>
</ul>
<h1 id="流简介"><a class="markdownIt-Anchor" href="#流简介"></a> 流简介</h1>
<ul>
<li>流允许以声明性方式处理数据集合(通过查询语句来表达,而不是临时编写一个实现)</li>
<li>优势：
<ul>
<li>声明性:说明想要完成什么而不是说明如何实现一个操作</li>
<li>可复合</li>
<li>可并行</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="流-从支持数据处理操作的源生成元素序列"><a class="markdownIt-Anchor" href="#流-从支持数据处理操作的源生成元素序列"></a> 流: 从支持数据处理操作的源生成元素序列</h2>
<ul>
<li><strong>元素序列</strong>——集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值，<mark>流的目的在于表达计算，集合为数据</mark></li>
<li><strong>源</strong>——流会使用一个提供数据的源，从有序集合生成流，从有序集合生成流时会保留原有的顺序</li>
<li><strong>数据处理操作</strong>——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作,
<ul>
<li>filter：接受Lambda，从流中排除某些元素</li>
<li>map：接受Lambda，将元素转换成其他形式或提取信息</li>
<li>limit：截断流，使元素不超过其他给定数量</li>
<li>collect：将流转换成其他元素（toList()将流转换为列表）</li>
<li><mark>流操作可以顺序执行，也可以并行执行</mark></li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="流与集合"><a class="markdownIt-Anchor" href="#流与集合"></a> 流与集合</h2>
<ul>
<li>集合是内存中的数据结构，包含数据结构中的所有值——集合中的每个元素都得先算出才能添加到集合中</li>
<li>流是在概念上固定得数据结构，<mark>元素是按需计算</mark>，流是延迟创建的集合(只有在消费者要求的时候才会计算值)</li>
<li><mark>集合和流的关键区别之一</mark>：遍历数据的方式，集合利用迭代器来访问for-each循环中的内部成员</li>
<li><mark>流只能遍历一次</mark></li>
<li>==外部迭代和内部迭代
<ul>
<li>使用Collection接口需要用户去做迭代，被称为外部迭代，(for-each循环,Iterator迭代器—外部迭代)</li>
<li>Streams库使用内部迭代——流将迭代做了，将得到的流值存在某个地方</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="流操作"><a class="markdownIt-Anchor" href="#流操作"></a> 流操作</h2>
<ul>
<li>中间操作：可以连接起来的流操作，中间操作会返回另一个流，可以使多个操作连接</li>
<li>终端操作：关闭流的操作，产生结果</li>
</ul>
</div><div class="story post-story"><h2 id="流的使用"><a class="markdownIt-Anchor" href="#流的使用"></a> 流的使用</h2>
<ul>
<li><strong>一个数据源：如集合，来执行一个查询</strong></li>
<li><strong>一个中间操作链：形成一条流的流水线</strong>
<ul>
<li>filter——操作类型Predicate&lt;T&gt;——函数描述符T-&gt;boolean</li>
<li>map——操作类型Function&lt;T,R&gt;——函数描述符T-&gt;R</li>
<li>limit</li>
<li>sorted——操作类型Comparator&lt;T&gt;——函数描述符(T, T)-&gt;R</li>
<li>distinct</li>
</ul>
</li>
<li><strong>一个终端操作</strong>：执行流水线，并能生成结果
<ul>
<li>forEach——消费流中的每个元素并对其应用Lambda。这一操作返回void</li>
<li>count——返回流中元素的个数。这一操作返回long</li>
<li>collection——把流归约成一个集合</li>
</ul>
</li>
</ul>
<h1 id="使用流"><a class="markdownIt-Anchor" href="#使用流"></a> 使用流</h1>
</div><div class="story post-story"><h2 id="筛选和切片"><a class="markdownIt-Anchor" href="#筛选和切片"></a> 筛选和切片</h2>
<ul>
<li>用谓词<mark>筛选</mark>：filter方法，接受一个谓词(一个返回boolean的函数)作为参数，并返回一个包括所有符合谓词的元素的流</li>
<li><mark>筛选各异的元素</mark>：distinct方法，返回一个元素各异(根据流所产生元素的hashCode和equals方法实现)的流</li>
<li><mark>截短流</mark>：limit(n)方法，该方法会返回一个不超过给定长度的流</li>
<li><mark>跳过元素</mark>：skip(n)方法，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流</li>
</ul>
</div><div class="story post-story"><h2 id="映射"><a class="markdownIt-Anchor" href="#映射"></a> 映射</h2>
<ul>
<li><mark>对流中每一个元素应用函数</mark>：map方法，接受一个函数作为参数。函数应用到每个元素上将其映射成新的元素</li>
<li><mark>流的扁平化</mark>：获得单词列表总各不相同的字符
<ul>
<li>使用map()与distinct()方法返回的为Stream&lt;String[]&gt;类型，而需要的为Stream&lt;String&gt;类型</li>
<li>使用map与Arrays .stream()(该方法可以接受一个数组并产生一个流)
<ul>
<li>words.stream().map(w-&gt;w.split(“”)).map(Arrays::stream).distinct().collect(Collectors.toList()) 返回Stream&lt;String&gt;的列表</li>
</ul>
</li>
<li><mark>使用flatMap解决</mark>：
<ul>
<li>words.stream().map(w-&gt;w.split(“”)).flatmap(Arrays::stream).distinct().collect(Collectors.toList()) 返回List&lt;String&gt;</li>
<li>flatmap方法把流中的每一个值都转换成另一个值，然后把所有的流连接起来成为一个流，创建扁平流</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="查找和匹配"><a class="markdownIt-Anchor" href="#查找和匹配"></a> 查找和匹配</h2>
<ul>
<li><mark>检查谓词是否至少匹配一个元素</mark>
<ul>
<li>anyMatch方法——流中是否有一个元素能匹配给定谓词</li>
</ul>
</li>
<li><mark>检查谓词是否匹配所有元素</mark>
<ul>
<li>allMatch方法——流中是否都能匹配给定谓词</li>
<li>noneMatch方法——流中没有任何元素与给定谓词匹配</li>
</ul>
</li>
<li><mark>findAny方法——将返回当前流中的任意元素</mark>
<ul>
<li>Optional&lt;T&gt;类使一个容器类，代表一个值存在或不存在</li>
<li>isPresent方法——将在Optional包含值得时候返回true</li>
<li>ifPresent(Consumer&lt;T&gt; block)方法——在值存在时执行给定的代码块</li>
<li>T get()方法——在值存在时返回值</li>
<li>T orElse(T other)方法——会在值存在时返回值，否则返回一个默认值</li>
</ul>
</li>
<li><mark>查找第一个元素——findFirst方法</mark></li>
</ul>
</div><div class="story post-story"><h2 id="归约"><a class="markdownIt-Anchor" href="#归约"></a> 归约</h2>
<ul>
<li>归约操作(折叠) ：将流中的元素组合起来，使用reduce操作来表达复杂的查询</li>
<li>元素求和：
<ul>
<li>使用reduce方法
<ul>
<li>reduce方法接受两个参数，一个参数为初始值，另一个参数为BinaryOperator&lt;T&gt;为Lambda表达式
<ul>
<li>Integer中具有sum方法可以使用进行求和</li>
<li>不接受初始值，返回Optional对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最大值和最小值
<ul>
<li>使用归约可以计算最大值和最小值
<ul>
<li>Integer中的max方法可以计算最大值，min方法计算最小值</li>
<li>可以使用并行处理，将strean()换成parallelStream()即可实现</li>
</ul>
</li>
</ul>
</li>
<li>流操作:
<ul>
<li>无状态和有状态：
<ul>
<li>无状态操作：没有内部状态，假设用户提供的Lambda或方法引用没有内部可变状态
<ul>
<li>如map或filter等操作会从输入流中获得每一个元素，并且在输出流中得到0或者1个结果</li>
</ul>
</li>
<li>有状态操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="数值流"><a class="markdownIt-Anchor" href="#数值流"></a> 数值流</h2>
<ul>
<li><strong>原始类型流特化，专门支持数值流的方法</strong></li>
<li>原始类型流特化
<ul>
<li>三个原始类型特化流接口：<strong>IntStream , DoubleStream , LongStream</strong> 分别将流中的元素特化为int , long  和long类型
<ul>
<li><mark><strong>避免了暗含的装箱操作成本</strong></mark></li>
</ul>
</li>
<li>映射到数值流：maoToInt mapToDouble mapToLong</li>
<li>转换回对象流：boxed()方法——可以将原始流转换为一般流(每个元素会自动装箱成为一个引用类型)</li>
<li>默认值OptionalInt：存在Optional原始类型特化版本 OptionalInt OptionalDouble OptionalLong
<ul>
<li>可以使用orElse方法，在不存在时设置一个默认值</li>
</ul>
</li>
</ul>
</li>
<li>数值范围
<ul>
<li>range()方法不包含结束值，rangeClosed()方法包含结束值</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="构建流"><a class="markdownIt-Anchor" href="#构建流"></a> 构建流</h2>
<ul>
<li>由值创建流：可以使用<strong>静态Steam.of方法显式创建一个流</strong>，使用Steam.empty()方法创建一个空流</li>
<li>由数组创建流：可以使用静态Arrays.steam方法从数组创建一个流</li>
<li>由文件创建流：
<ul>
<li>java.nio.file.Files中的很多静态方法都支持返回一个流</li>
<li>Files.lines返回一个由指定文件中各行构成的字符串流</li>
</ul>
</li>
<li>由函数生成流
<ul>
<li>无限流：不像从固定集合创建的流那样有固定大小的流</li>
<li>Stream.iterate和Stream.generate方法可以生成无限流
<ul>
<li>generate接受一个Supplier&lt;T&gt;类型的Lambda提供新的值</li>
<li><strong>使用iterate的方法则是纯粹不变的：它没有修改现有状态，但在每次迭代时会创建新的元组。而generate方法会使Supplier实例的状态产生变化</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="用流收集数据"><a class="markdownIt-Anchor" href="#用流收集数据"></a> 用流收集数据</h1>
</div><div class="story post-story"><h2 id="收集器简介"><a class="markdownIt-Anchor" href="#收集器简介"></a> 收集器简介</h2>
<ul>
<li><strong>收集器用作高级归纳</strong>——Collector会对元素应用一个转换函数，并且将结果累计在一个数据结构中，从而产生这一过程的最终输出</li>
<li>收集器的功能：将流元素归约和汇总为一个值，元素分组，元素分区</li>
</ul>
</div><div class="story post-story"><h2 id="归约和汇总"><a class="markdownIt-Anchor" href="#归约和汇总"></a> 归约和汇总</h2>
<ul>
<li>查找流中的最大值和最小值
<ul>
<li>两个收集器：Collectors.maxBy和Collectors.minBy来计算流中的最大值或最小值 接收器接收一个Comparator参数来比较流中的元素</li>
</ul>
</li>
<li>汇总
<ul>
<li>汇总的工厂方法：Collectors.summingInt 接受一个把对象映射为求和所需int的函数，并返回一个收集器，该收集器在传递给普通的collect方法后执行汇总操作
<ul>
<li>Collectors.summingLong Collectors.summingDouble ——求和 averagingLong averagingDouble 计算平均值</li>
<li><strong>summarizingInt summarizingLong summarizingLong方法 返回的收集器——可以得到元素个数，总和，平均值，最大值和最小值——返回IntSummaryStatistics类,LongSummaryStatistics类,DoubleSummaryStatistics类</strong></li>
</ul>
</li>
</ul>
</li>
<li>连接字符串
<ul>
<li>joining工厂方法——对流中每一个对象引用toString方法得到的所有字符串连接成一个字符串
<ul>
<li>重载版本可以设置元素之间的分界符</li>
<li>若类具有toString方法，则无需重新提取字符串</li>
</ul>
</li>
<li><strong>joining在内部使用了StringBuilder来把生成的字符串逐个追加起来</strong></li>
</ul>
</li>
<li>广义的归约汇总
<ul>
<li>Collectors.reducing方法使所有特殊情况的一般化</li>
<li>三个参数
<ul>
<li>第一个参数使归约操作的起始值，也是流中没有元素的返回值</li>
<li>第二个参数</li>
<li>第三个参数使BinaryOperator，将两个项目累积成一个同类型的值</li>
</ul>
</li>
<li>单参数形式
<ul>
<li>三个参数形式的特殊情况</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组</h2>
<ul>
<li><strong>Collectors.groupingBy工厂方法可以实现分类操作</strong>，其参数为一个分类函数，分组的结果保存在一个Map中</li>
<li>多级分类：
<ul>
<li><strong>双参数版本的Collectors.groupingBy可以实现多级分类</strong>
<ul>
<li><strong>其传入参数除了普通的分类函数之外，还可以接受Collectors类型的第二个参数，利用内层groupingBy传递给外层groupingBy，其类型为二级标准</strong></li>
</ul>
</li>
</ul>
</li>
<li>按子组收集数据：
<ul>
<li>Collectors.groupingBy的第二个参数可以使任意类型，如可以传递counting收集器作为参数统计数量</li>
<li>单参数的groupingBy(f)实际上使groupingBy(f,toList())的简便写法</li>
<li>将收集器的结果转换为另一种类型： Collectors.collectingAndThen工厂方法第一个参数为要转换的收集器，第二个参数为转换函数</li>
<li>Collectors.mapping——该方法接受两个参数，一个函数对流中的元素进行转换，另一个将变换的结果收集起来</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="分区"><a class="markdownIt-Anchor" href="#分区"></a> 分区</h2>
<ul>
<li>分组的特殊情况：由一个谓词作为分类函数，称为分区函数，分区函数返回一个布尔值，得到的Map的键为Boolean类型</li>
<li><strong>分区函数 partitioningBy——其传递的函数为分区函数</strong></li>
<li>分区的好处：保留了分区函数返回true或False的两套流元素列表
<ul>
<li>partitioningBy——重载版本，第一个参数为分区函数，第二个参数为收集器</li>
</ul>
</li>
<li>partitioningBy收集器也允许结合其他收集器使用，可以实现多级分区</li>
</ul>
</div><div class="story post-story"><h2 id="收集器接口"><a class="markdownIt-Anchor" href="#收集器接口"></a> 收集器接口</h2>
<ul>
<li>Collector接口：T是流中要收集的项目的泛型，A是累加器的类型(累加器是在收集过程中用于累计部分结果的对象)，R是收集操作得到的对象的类型
<ul>
<li>建立新的结果容器：supplier方法</li>
<li>将元素添加到结果容器：accumulator方法</li>
<li>对结果容器应用最终转换：finisher方法</li>
<li>合并两个结果容器：combiner方法</li>
<li>characteristics方法——返回一个不可变的Characteristics集合，它定义了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示，为三个项目的枚举
<ul>
<li>UNORDERED——归约结果不受流中项目的遍历和累积顺序的影响</li>
<li>CONCURRENT——accumulator函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为UNORDERED，那它仅在用于无序数据源时才可以并行归约</li>
<li>IDENTITY_FINISH——这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器A不加检查地转换为结果R是安全的</li>
</ul>
</li>
</ul>
</li>
<li><strong>调用自定义实现Collector接口的类时，需要使用new方法进行实例化(toList是工厂方法，故不需要new进行实例化)</strong></li>
<li><strong>可直接在重载的collect()方法中接受三个函数supplier,accumlator和combiner函数，实现上述操作</strong>
<ul>
<li><strong>第二个collect方法不能传递任何Characteristics，所以它永远都是一个IDENTITY_FINISH和CONCURRENT但并非UNORDERED的收集器</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collector</span>&lt;T,A R&gt;&#123;</span><br><span class="line">  Supplier&lt;A&gt;supplier();</span><br><span class="line">  BiConsumer&lt;A T&gt;accumulator();</span><br><span class="line">  Function&lt;A R&gt;finisher();</span><br><span class="line">  BinaryOperator&lt;A&gt;combiner();</span><br><span class="line">  Set &lt;Characteristics&gt;characteristics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并行数据处理与性能"><a class="markdownIt-Anchor" href="#并行数据处理与性能"></a> 并行数据处理与性能</h1>
</div><div class="story post-story"><h2 id="并行流"><a class="markdownIt-Anchor" href="#并行流"></a> 并行流</h2>
<ul>
<li>parallelStream 方法 ——将集合转换为并行流
<ul>
<li>并行流将内容分成多个数据块，并用不同的线程分别处理每个数据块的流</li>
</ul>
</li>
<li>将顺序流转换为并行流
<ul>
<li>对顺序流调用parallel方法转换为并行流——函数的归约过程并行运行</li>
<li>对并行流调用sequential方法转换为顺序流</li>
<li><strong>iterate产生的是装箱的对象，必须拆箱成数字才能求和</strong></li>
</ul>
</li>
<li>高效使用并行流
<ul>
<li>留意装箱</li>
<li>留意数据结构是否易于分解</li>
<li>ArrayList IntStream等 可分解性极佳 &gt; HashSet TreeSet 分解性较好 &gt; LinkedList 原生Stream</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="分支合并框架forkjoin框架"><a class="markdownIt-Anchor" href="#分支合并框架forkjoin框架"></a> 分支合并框架(Fork/Join框架)</h2>
<ul>
<li>以递归方式将可并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果，把子任务分配给- ForkJoinPool(线程池)中的工作线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// R是并行化任务产生的结果类型</span></span><br><span class="line"><span class="comment">// 其唯一抽象方法为compute方法</span></span><br><span class="line">RecursiveTask&lt;R&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">compute()&#123;</span><br><span class="line">  <span class="keyword">if</span>(任务足够小或不可分)&#123;</span><br><span class="line">       顶序计算该任务</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      将任务分成两个子任务</span><br><span class="line">       递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">        合并每个子任务的结果</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务不产生返回结果</span></span><br><span class="line">RecursiveAction</span><br></pre></td></tr></table></figure>
<ul>
<li>使用分支/合并框架的最佳做法
<ul>
<li>对一个任务调用join方法会阻塞调用方，直到该任务做出结果**(有必要在两个子任务的计算都开始之后再调用它。否则，你得到的版本会比原始的顺序算法更慢更复杂，因为每个子任务都必须等待另一个子任务完成才能启动)**；</li>
<li>不应该在RecursiveTask内部使用ForkJoinPool的invoke方法。相反，你应该始终直接调用compute或fork方法，只有顺序代码才应该用invoke来启动并行计算；</li>
<li>对子任务调用fork方法可以把它排进ForkJoinPool。同时对左边和右边的子任务调用它似乎很自然，但这样做的效率要比直接对其中一个调用compute低。这样做你可以为其中一个子任务重用同一线程，从而避免在线程池中多分配一个任务造成的开销；</li>
<li>和并行流一样，你不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计算快。我们已经说过，一个任务可以分解成多个独立的子任务，才能让性能在并行化时有所提升</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="spliterator"><a class="markdownIt-Anchor" href="#spliterator"></a> Spliterator</h2>
<ul>
<li>Java8中引入的一个新接口，为可分迭代器，用于遍历数据源中的元素，但其为了并行执行、</li>
<li>tryAdvance方法的行为类似于普通的Iterator，按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍历就返回true</li>
<li>trySplit是专为Spliterator接口设计的，可以把一些元素划出去分给第二个Spliterator（由该方法返回），两个并行处理</li>
<li>Spliterator还可通过estimateSize方法估计还剩下多少元素要遍历，因为即使不那么确切，能快速算出来是一个值也有助于让拆分均匀一点</li>
<li>Spliterator接口声明的最后一个抽象方法是characteristics，它将返回一个int，代表Spliterator本身特性集的编码</li>
<li>拆分过程：递归过程拆分直至调用trySplit方法返回null，受Spliterator本身特性影响，该特性通过characteristics方法声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Spliterator</span>&lt;T&gt;&#123;</span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">tryAdvance</span><span class="params">(Consumer&lt;?<span class="built_in">super</span> T&gt;action)</span>;</span><br><span class="line"> Spliterator&lt;T&gt;trySplit();</span><br><span class="line"> <span class="type">long</span> <span class="title function_">estimateSize</span><span class="params">()</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">charactenstics</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h1 id="默认方法"><a class="markdownIt-Anchor" href="#默认方法"></a> 默认方法</h1>
<ul>
<li>Java8允许在接口内声明静态方法，同时引入了<strong>默认方法</strong>，通过默认方法可以指定接口方法的默认实现</li>
<li>Java的类只能继承单一的类，但一个类可以实现多接口</li>
<li>可以使用代理有效地规避代码复用的复杂性，即创建一个方法通过该类的成员变量直接调用该类的方法
<ul>
<li><mark>为什么有的时候我们发现有些类被刻意地声明为final类型：</mark>
<ul>
<li>声明为final的类不能被其他的类继承，避免发生这样的反模式，防止核心代码的功能被污染</li>
</ul>
</li>
</ul>
</li>
<li><mark>解决默认方法签名相同时产生的冲突问题(一个类使用相同的函数签名从多个地方（比如另一个类或接口）继承了方法)：</mark>
<ul>
<li>类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级</li>
<li>如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体</li>
<li>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现</li>
</ul>
</li>
</ul>
<h1 id="用optional取代null"><a class="markdownIt-Anchor" href="#用optional取代null"></a> 用Optional取代null</h1>
<ul>
<li>避免遇到NullPointerException异常</li>
<li>Optional&lt;T&gt;
<ul>
<li>变量存在时，Optional类只是对类简单封装;</li>
<li>变量不存在时，缺失的值会被建模成一个“空”的Optional对象，由方法Optional.empty()返回</li>
</ul>
</li>
<li>创建Optional对象
<ul>
<li><strong>声明一个空的Optional</strong>：Optional.empty()静态方法——返回Optional类的特定单一实例</li>
<li><strong>依据一个非空值创建Optional</strong>：Optional.of()静态方法——依据非空值创建一个Optional对象</li>
<li><strong>可接受null的Optional</strong>：Optional.ofNullable()静态方法——创建一个允许null值得Optional对象</li>
</ul>
</li>
<li>函数方法
<ul>
<li>map方法——使用map从Optional对象中提取和转换值；map操作会将提供的函数引用于流的每个元素，可以把Optional对象堪称一种特殊的集合数据（如果Optional包含一个值，那函数就将该值作为参数传递给map，对该值进行转换。如果Optional为空，就什么也不做）</li>
<li>flatMap方法——将两层的Optional对象转换为单一Optional对象，使用flatMap链接Optional对象</li>
<li>get()——最简单但不安全，若变量存在返回封装的变量值，否则抛出NoSuchElementException异常</li>
<li>orElse(T other)——允许在Optional对象不包含值时提供一个默认值</li>
<li>orElseGet(Supplier&lt; ? extends T&gt; other)——Supplier方法只有在Optional对象不含值时才执行调用</li>
<li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)——遭遇Optional对象为空时都会抛出一个可定制的异常</li>
<li>ifPresent(Consumer&lt;? super T&gt;)——在变量值存在时执行一个作为参数传入的方法，否则就不进行任何操作</li>
<li>isPresent()——如果Optional对象包含值，该方法就返回true</li>
<li>filter()——方法接受一个谓词作为参数；如果Optional对象的值存在，并且它符合谓词的条件，filter方法就返回其值；否则它就返回一个空的Optional对象</li>
</ul>
</li>
</ul>
<h1 id="新的日期和时间api"><a class="markdownIt-Anchor" href="#新的日期和时间api"></a> 新的日期和时间API</h1>
<ul>
<li>LocalDate
<ul>
<li>LocalDate.of()——创建一个LocalDate实例</li>
<li>LocalDate.now()——从系统时钟中获取当前日期</li>
<li>get()——传递TemporalField参数获取某个字段的值(ChronoField枚举实现了TemporalField接口)</li>
<li>parse()静态方法——格式化一个日期或者时间对象</li>
</ul>
</li>
<li>LocalTime
<ul>
<li>LocalTime.of()——创建LocalTIme实例</li>
<li>getHour getMinute getSecond</li>
<li>parse()静态方法——格式化一个日期或者时间对象</li>
</ul>
</li>
<li>LocalDateTime
<ul>
<li>是LocalDate和LocalTime的合体，同时表示了日期和时间，但不带有时区信息</li>
<li>of方法</li>
<li>atTime()方法——传递日期对象或者时间对象创建</li>
<li>toLocalDate或toLocalTime方法——提取LocalDate或LocalTime组件</li>
</ul>
</li>
<li>Instant类
<ul>
<li>计算机角度的建模时间，表示一个持续时间段上某个点的单一大整型数</li>
<li>ofEpochSecond()——传递一个代表秒数的值创建该类的实例
<ul>
<li>重载版本，接受第二个以纳秒为单位的参数值，对传入作为秒数的参数进行调整</li>
</ul>
</li>
<li>now()——获取当前时刻的时间戳</li>
</ul>
</li>
<li>Duration类和Period
<ul>
<li>Duration类静态方法between——传递两个LocalTimes对象，LocalDateTimes对象，Instant对象，获得两个对象之间的时间长短(秒和纳秒)</li>
<li>Period类静态方法between——得到LocalDate之间的时长</li>
</ul>
</li>
<li>使用TemporalAdjuster：with()——传递一个提供定制化选择的TemporalAdjuster对象，更加灵活的处理日期</li>
<li>打印输出及解析日期-时间对象：
<ul>
<li>DateTimeFormatter类：创建格式器最简单的方法是通过静态方法和常量，BASIC_ISO_DATE和ISO_LOCAL_DATE- 为DateTimeFormatter类的预定义实例
<ul>
<li>parse()静态方法——使用同样的格式器解析字符串并重建该日期对象</li>
<li>ofPattern()方法——创建某了Local的格式器</li>
<li>DateTimeFormatterBuilder类提供更加复杂的格式器</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateModified" datetime="2023-04-16T20:15:50+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2023年4月16日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Java/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>Java</p></a></div>
  <span hidden itemprop="keywords">Java</span>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://jay1060950003.github.io/2022/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/&title=Java核心技术 - CodingStudio&summary= 引言

Java核心思想的学习笔记
包含第一卷除swing章节，并包含第二卷的文件流部分
"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://jay1060950003.github.io/2022/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/&title=Java核心技术 - CodingStudio&summary= 引言

Java核心思想的学习笔记
包含第一卷除swing章节，并包含第二卷的文件流部分
"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://jay1060950003.github.io/2022/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/&title=Java核心技术 - CodingStudio&summary= 引言

Java核心思想的学习笔记
包含第一卷除swing章节，并包含第二卷的文件流部分
"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i>数据结构与算法</p>
          <p class='content'> 引言

数据结构与算法的学习笔记
包含Leetcode刷题笔记



 1 数据结构绪论

数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合...</p>
        </a>
      
      
        <a class='next' href='/2021/12/01/%E5%B0%8F%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/MSVC%E9%85%8D%E7%BD%AE/'>
          <p class='title'>MSVC使用方法<i class="fa-solid fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'> 引言
Windows环境下MSVC的在vscode中配置方法


 1 MSVC的VsCode配置

向windows添加环境变量

1234567891011121314# 新建INCLUD...</p>
        </a>
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  


  <article class="post white-box shadow floatable blur" id="comments">
    <span hidden>
      <meta itemprop="discussionUrl" content="/2022/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/index.html#comments">
    </span>
    <p ct><i class='fa-solid fa-comments'></i> 评论</p>
    

    <div id="layoutHelper-comments"></div>

  </article>






</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky pjax">

  
  


  <section class="widget toc-wrapper desktop mobile " id="toc-div" >
    
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text"> 引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text"> 1 Java程序设计概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-java%E7%99%BD%E7%9A%AE%E4%B9%A6%E7%9A%84%E5%85%B3%E9%94%AE%E6%9C%AF%E8%AF%AD"><span class="toc-number">2.1.</span> <span class="toc-text"> 1.2 Java“白皮书”的关键术语</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text"> 3 Java的基本程序设计结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1 一个简单的Java应用程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%B3%A8%E9%87%8A"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2 注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#331-%E6%95%B4%E5%9E%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 3.3.1 整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#332-%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 3.3.2 浮点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#333-char%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text"> 3.3.3 char类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#334-unicode%E5%92%8Cchar%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.4.</span> <span class="toc-text"> 3.3.4 Unicode和char类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#335-boolean%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.5.</span> <span class="toc-text"> 3.3.5 boolean类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%8F%98%E9%87%8F"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#342-%E5%B8%B8%E9%87%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 3.4.2 常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.</span> <span class="toc-text"> 3.5 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#351-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text"> 3.5.1 数学函数与常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#352-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.5.2.</span> <span class="toc-text"> 3.5.2 数值类型之间的类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#353-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.5.3.</span> <span class="toc-text"> 3.5.3 强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#355-%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.4.</span> <span class="toc-text"> 3.5.5 自增与自减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#356-%E5%85%B3%E7%B3%BB%E5%92%8Cboolean%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.5.</span> <span class="toc-text"> 3.5.6 关系和boolean变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#357-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.6.</span> <span class="toc-text"> 3.5.7 位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#359-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.7.</span> <span class="toc-text"> 3.5.9 枚举类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.6.</span> <span class="toc-text"> 3.6 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#361-%E5%AD%90%E4%B8%B2"><span class="toc-number">3.6.1.</span> <span class="toc-text"> 3.6.1 子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#362-%E6%8B%BC%E6%8E%A5"><span class="toc-number">3.6.2.</span> <span class="toc-text"> 3.6.2 拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#363-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.6.3.</span> <span class="toc-text"> 3.6.3 不可变字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#364-%E6%A3%80%E6%B5%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-number">3.6.4.</span> <span class="toc-text"> 3.6.4 检测字符串是否相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#365-%E7%A9%BA%E4%B8%B2%E5%92%8Cnull%E4%B8%B2"><span class="toc-number">3.6.5.</span> <span class="toc-text"> 3.6.5 空串和Null串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#366-%E7%A0%81%E7%82%B9%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8D%95%E5%85%83"><span class="toc-number">3.6.6.</span> <span class="toc-text"> 3.6.6 码点与代码单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#369-%E6%9E%84%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.6.7.</span> <span class="toc-text"> 3.6.9 构建字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">3.7.</span> <span class="toc-text"> 3.7 输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#371-%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5"><span class="toc-number">3.7.1.</span> <span class="toc-text"> 3.7.1 读取输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#372-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">3.7.2.</span> <span class="toc-text"> 3.7.2 格式化输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#373-%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">3.7.3.</span> <span class="toc-text"> 3.7.3 文件输入与输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">3.8.</span> <span class="toc-text"> 3.8 控制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#384-%E7%A1%AE%E5%AE%9A%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.8.1.</span> <span class="toc-text"> 3.8.4 确定循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#385-%E5%A4%9A%E9%87%8D%E9%80%89%E6%8B%A9switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.8.2.</span> <span class="toc-text"> 3.8.5 多重选择：switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#386-%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.8.3.</span> <span class="toc-text"> 3.8.6 中断控制流程语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E5%A4%A7%E6%95%B0%E5%80%BC"><span class="toc-number">3.9.</span> <span class="toc-text"> 3.9 大数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#310-%E6%95%B0%E7%BB%84"><span class="toc-number">3.10.</span> <span class="toc-text"> 3.10 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3101-for-each%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.10.1.</span> <span class="toc-text"> 3.10.1 for each循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3102-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%8C%BF%E5%90%8D%E6%95%B0%E7%BB%84"><span class="toc-number">3.10.2.</span> <span class="toc-text"> 3.10.2 数组初始化以及匿名数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3103-%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.10.3.</span> <span class="toc-text"> 3.10.3 数组拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3104-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">3.10.4.</span> <span class="toc-text"> 3.10.4 命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3105-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">3.10.5.</span> <span class="toc-text"> 3.10.5 数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3106-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.10.6.</span> <span class="toc-text"> 3.10.6 多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3107-%E4%B8%8D%E8%A7%84%E5%88%99%E6%95%B0%E7%BB%84"><span class="toc-number">3.10.7.</span> <span class="toc-text"> 3.10.7 不规则数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text"> 4 对象与类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#411-%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1.1 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#412-%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 4.1.2 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#414-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 4.1.4 类之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2 使用预定类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#421-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 4.2.1 对象与对象变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#422-java%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84localdate%E7%B1%BB"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 4.2.2 Java类库中的LocalDate类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#423-%E6%9B%B4%E6%94%B9%E5%99%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 4.2.3 更改器方法与访问器方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">4.3.</span> <span class="toc-text"> 4.3 用户自定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#432-%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 4.3.2 多个源文件的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#433-%E5%89%96%E6%9E%90employee%E7%B1%BB"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 4.3.3 剖析Employee类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#434-%E4%BB%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%80%E5%A7%8B"><span class="toc-number">4.3.3.</span> <span class="toc-text"> 4.3.4 从构造器开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#435-%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E4%B8%8E%E6%98%BE%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">4.3.4.</span> <span class="toc-text"> 4.3.5 隐式参数与显式参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#436-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">4.3.5.</span> <span class="toc-text"> 4.3.6 封装的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#437-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">4.3.6.</span> <span class="toc-text"> 4.3.7 基于类的访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#438-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.7.</span> <span class="toc-text"> 4.3.8 私有方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#439-final%E5%AE%9E%E4%BE%8B%E5%9F%9F"><span class="toc-number">4.3.8.</span> <span class="toc-text"> 4.3.9 final实例域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E9%9D%99%E6%80%81%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text"> 4.4 静态域与静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#441-%E9%9D%99%E6%80%81%E5%9F%9F"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 4.4.1 静态域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#442-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 4.4.2 静态常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#443-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.3.</span> <span class="toc-text"> 4.4.3 静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#444-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.4.</span> <span class="toc-text"> 4.4.4 工厂方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#445-main%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.5.</span> <span class="toc-text"> 4.4.5 main方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text"> 4.5 方法参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="toc-number">4.6.</span> <span class="toc-text"> 4.6 对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#461-%E9%87%8D%E8%BD%BD"><span class="toc-number">4.6.1.</span> <span class="toc-text"> 4.6.1 重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#462-%E9%BB%98%E8%AE%A4%E5%9F%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.6.2.</span> <span class="toc-text"> 4.6.2 默认域初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#463-%E6%97%A0%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.6.3.</span> <span class="toc-text"> 4.6.3 无参数的构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#464-%E6%98%BE%E5%BC%8F%E5%9F%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.6.4.</span> <span class="toc-text"> 4.6.4 显式域初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#465-%E5%8F%82%E6%95%B0%E5%90%8D"><span class="toc-number">4.6.5.</span> <span class="toc-text"> 4.6.5 参数名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#466-%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.6.6.</span> <span class="toc-text"> 4.6.6 调用另一个构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#467-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="toc-number">4.6.7.</span> <span class="toc-text"> 4.6.7 初始化块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#468-%E5%AF%B9%E8%B1%A1%E6%9E%90%E6%9E%84%E4%B8%8Efinalize%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.8.</span> <span class="toc-text"> 4.6.8 对象析构与finalize方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E5%8C%85"><span class="toc-number">4.7.</span> <span class="toc-text"> 4.7 包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E7%B1%BB%E8%B7%AF%E5%BE%84"><span class="toc-number">4.8.</span> <span class="toc-text"> 4.8 类路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">4.9.</span> <span class="toc-text"> 4.9 文档注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#493-%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A"><span class="toc-number">4.9.1.</span> <span class="toc-text"> 4.9.3 方法注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#496-%E5%8C%85%E4%B8%8E%E6%A6%82%E8%BF%B0%E6%B3%A8%E9%87%8A"><span class="toc-number">4.9.2.</span> <span class="toc-text"> 4.9.6 包与概述注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#497-%E6%B3%A8%E9%87%8A%E7%9A%84%E6%8A%BD%E5%8F%96"><span class="toc-number">4.9.3.</span> <span class="toc-text"> 4.9.7 注释的抽取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#410-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7"><span class="toc-number">4.10.</span> <span class="toc-text"> 4.10 类设计技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%BB%A7%E6%89%BF"><span class="toc-number">5.</span> <span class="toc-text"> 5 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E7%B1%BB-%E8%B6%85%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1 类、超类和子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#511-%E5%AE%9A%E4%B9%89%E5%AD%90%E7%B1%BB"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 5.1.1 定义子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#513-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text"> 5.1.3 子类构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#514-%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1"><span class="toc-number">5.1.3.</span> <span class="toc-text"> 5.1.4 继承层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#515-%E5%A4%9A%E6%80%81"><span class="toc-number">5.1.4.</span> <span class="toc-text"> 5.1.5 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#516-%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">5.1.5.</span> <span class="toc-text"> 5.1.6 理解方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#517-%E7%BB%84%E7%BB%87%E7%BB%A7%E6%89%BFfinal%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.6.</span> <span class="toc-text"> 5.1.7 组织继承:final类和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#518-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.1.7.</span> <span class="toc-text"> 5.1.8 强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#519-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">5.1.8.</span> <span class="toc-text"> 5.1.9 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5110-%E5%8F%97%E4%BF%9D%E6%8A%A4%E8%AE%BF%E9%97%AE"><span class="toc-number">5.1.9.</span> <span class="toc-text"> 5.1.10 受保护访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-object%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2 Object：所有类的超类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#521-2-equals%E6%96%B9%E6%B3%95_%E7%9B%B8%E7%AD%89%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 5.2.1-2 equals方法_相等测试与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#523-hashcode%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text"> 5.2.3 hashCode方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#524-tostring%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.3.</span> <span class="toc-text"> 5.2.4 toString方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3 泛型数组列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#531-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 5.3.1 访问数组列表元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#532-%E7%B1%BB%E5%9E%8B%E5%8C%96%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 5.3.2 类型化与原始数组列表的兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-number">5.4.</span> <span class="toc-text"> 5.4 对象包装器与自动装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.5.</span> <span class="toc-text"> 5.5 参数数量可变的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">5.6.</span> <span class="toc-text"> 5.6 枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-%E5%8F%8D%E5%B0%84"><span class="toc-number">5.7.</span> <span class="toc-text"> 5.7 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#571-class%E7%B1%BB"><span class="toc-number">5.7.1.</span> <span class="toc-text"> 5.7.1 Class类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#572-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">5.7.2.</span> <span class="toc-text"> 5.7.2 捕获异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#573-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E7%B1%BB%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-number">5.7.3.</span> <span class="toc-text"> 5.7.3 利用反射分析类的能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#574-%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.7.4.</span> <span class="toc-text"> 5.7.4 在运行时使用反射分析对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#575-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%BC%96%E5%86%99%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81"><span class="toc-number">5.7.5.</span> <span class="toc-text"> 5.7.5 使用反射编写泛型数组代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#576-%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.6.</span> <span class="toc-text"> 5.7.6 调用任意方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7"><span class="toc-number">5.8.</span> <span class="toc-text"> 5.8 继承的设计技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%8E%A5%E5%8F%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text"> 6 接口,Lambda表达式与内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text"> 6.1 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#611-%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text"> 6.1.1 接口概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#612-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">6.1.2.</span> <span class="toc-text"> 6.1.2 接口的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#613-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.1.3.</span> <span class="toc-text"> 6.1.3 接口与抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#614-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.4.</span> <span class="toc-text"> 6.1.4 静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#615-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.5.</span> <span class="toc-text"> 6.1.5 默认方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#616-%E8%A7%A3%E5%86%B3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%86%B2%E7%AA%81"><span class="toc-number">6.1.6.</span> <span class="toc-text"> 6.1.6 解决默认方法冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.2.</span> <span class="toc-text"> 6.2 接口示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9B%9E%E8%B0%83"><span class="toc-number">6.2.1.</span> <span class="toc-text"> 6.2.1 接口与回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622-comparator%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.2.</span> <span class="toc-text"> 6.2.2 Comparator接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#623-%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="toc-number">6.2.3.</span> <span class="toc-text"> 6.2.3 对象克隆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text"> 6.3 Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#631_2-%E5%BC%95%E5%85%A5lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E8%AF%AD%E6%B3%95"><span class="toc-number">6.3.1.</span> <span class="toc-text"> 6.3.1_2 引入Lambda表达式及语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#633-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.3.2.</span> <span class="toc-text"> 6.3.3 函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#634-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">6.3.3.</span> <span class="toc-text"> 6.3.4 方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#635-%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-number">6.3.4.</span> <span class="toc-text"> 6.3.5 构造器引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#636%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.3.5.</span> <span class="toc-text"> 6.3.6变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#637-%E5%A4%84%E7%90%86lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.3.6.</span> <span class="toc-text"> 6.3.7 处理lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">6.4.</span> <span class="toc-text"> 6.4 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#641-%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81"><span class="toc-number">6.4.1.</span> <span class="toc-text"> 6.4.1 使用内部类访问对象状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#642-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">6.4.2.</span> <span class="toc-text"> 6.4.2 内部类的特殊语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#643-%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E6%9C%89%E7%94%A8_%E5%BF%85%E8%A6%81%E5%92%8C%E5%AE%89%E5%85%A8"><span class="toc-number">6.4.3.</span> <span class="toc-text"> 6.4.3 内部类是否有用_必要和安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#644-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">6.4.4.</span> <span class="toc-text"> 6.4.4 局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#645-%E7%94%B1%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F"><span class="toc-number">6.4.5.</span> <span class="toc-text"> 6.4.5 由外部方法访问变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#646-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">6.4.6.</span> <span class="toc-text"> 6.4.6 匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#647-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">6.4.7.</span> <span class="toc-text"> 6.4.7 静态内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E4%BB%A3%E7%90%86"><span class="toc-number">6.5.</span> <span class="toc-text"> 6.5 代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#651-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86"><span class="toc-number">6.5.1.</span> <span class="toc-text"> 6.5.1 何时使用代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#652-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.5.2.</span> <span class="toc-text"> 6.5.2 创建代理对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#653-%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">6.5.3.</span> <span class="toc-text"> 6.5.3 代理类的特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%BC%82%E5%B8%B8_%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97"><span class="toc-number">7.</span> <span class="toc-text"> 7 异常_断言和日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">7.1.</span> <span class="toc-text"> 7.1 处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#711-%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB"><span class="toc-number">7.1.1.</span> <span class="toc-text"> 7.1.1 异常分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#712-%E5%A3%B0%E6%98%8E%E5%8F%97%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="toc-number">7.1.2.</span> <span class="toc-text"> 7.1.2 声明受查异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#713-%E5%A6%82%E4%BD%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">7.1.3.</span> <span class="toc-text"> 7.1.3 如何抛出异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#714-%E5%88%9B%E5%BB%BA%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text"> 7.1.4 创建异常类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">7.3.</span> <span class="toc-text"> 7.2 捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#721-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">7.3.1.</span> <span class="toc-text"> 7.2.1 捕获异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#722-%E6%8D%95%E8%8E%B7%E5%A4%9A%E4%B8%AA%E5%BC%82%E5%B8%B8"><span class="toc-number">7.3.2.</span> <span class="toc-text"> 7.2.2 捕获多个异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#723-%E5%86%8D%E6%AC%A1%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="toc-number">7.3.3.</span> <span class="toc-text"> 7.2.3 再次抛出异常与异常链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#724-finally%E5%AD%90%E5%8F%A5"><span class="toc-number">7.3.4.</span> <span class="toc-text"> 7.2.4 finally子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#725-%E5%B8%A6%E8%B5%84%E6%BA%90%E7%9A%84try%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.3.5.</span> <span class="toc-text"> 7.2.5 带资源的try语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#726-%E5%88%86%E6%9E%90%E5%A0%86%E6%A0%88%E8%BD%A8%E8%BF%B9%E5%85%83%E7%B4%A0"><span class="toc-number">7.3.6.</span> <span class="toc-text"> 7.2.6 分析堆栈轨迹元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">7.4.</span> <span class="toc-text"> 7.3 使用异常的技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80"><span class="toc-number">7.5.</span> <span class="toc-text"> 7.4 使用断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#741-%E6%96%AD%E8%A8%80%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.5.1.</span> <span class="toc-text"> 7.4.1 断言的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#742-%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8%E6%96%AD%E8%A8%80"><span class="toc-number">7.5.2.</span> <span class="toc-text"> 7.4.2 启用和禁用断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#743-%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80%E5%AE%8C%E6%88%90%E5%8F%82%E6%95%B0%E6%A3%80%E6%9F%A5"><span class="toc-number">7.5.3.</span> <span class="toc-text"> 7.4.3 使用断言完成参数检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-number">7.6.</span> <span class="toc-text"> 7.5 记录日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#751-%E5%9F%BA%E6%9C%AC%E6%97%A5%E5%BF%97"><span class="toc-number">7.6.1.</span> <span class="toc-text"> 7.5.1 基本日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#752-%E9%AB%98%E7%BA%A7%E6%97%A5%E5%BF%97"><span class="toc-number">7.6.2.</span> <span class="toc-text"> 7.5.2 高级日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#753-%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">7.6.3.</span> <span class="toc-text"> 7.5.3 修改日志管理器配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#754-%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="toc-number">7.6.4.</span> <span class="toc-text"> 7.5.4 本地化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#755-%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">7.6.5.</span> <span class="toc-text"> 7.5.5 处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#756-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">7.6.6.</span> <span class="toc-text"> 7.5.6 过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#757-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%99%A8"><span class="toc-number">7.6.7.</span> <span class="toc-text"> 7.5.7 格式化器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#758-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E8%AF%B4%E6%98%8E"><span class="toc-number">7.6.8.</span> <span class="toc-text"> 7.5.8 日志记录说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="toc-number">7.7.</span> <span class="toc-text"> 7.6 调试技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.</span> <span class="toc-text"> 8 泛型程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.1.</span> <span class="toc-text"> 8.1 为什么要使用泛型程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#811-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">8.1.1.</span> <span class="toc-text"> 8.1.1 类型参数的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text"> 8.2 定义简单泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text"> 8.3 泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E9%99%90%E5%AE%9A"><span class="toc-number">8.4.</span> <span class="toc-text"> 8.4 类型变量的限定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-%E6%B3%9B%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">8.5.</span> <span class="toc-text"> 8.5 泛型代码和虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#851-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">8.5.1.</span> <span class="toc-text"> 8.5.1 类型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#852-%E7%BF%BB%E8%AF%91%E6%B3%9B%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">8.5.2.</span> <span class="toc-text"> 8.5.2 翻译泛型表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#853-%E7%BF%BB%E8%AF%91%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">8.5.3.</span> <span class="toc-text"> 8.5.3 翻译泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#854-%E8%B0%83%E7%94%A8%E9%81%97%E7%95%99%E4%BB%A3%E7%A0%81"><span class="toc-number">8.5.4.</span> <span class="toc-text"> 8.5.4 调用遗留代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-%E7%BA%A6%E6%9D%9F%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">8.6.</span> <span class="toc-text"> 8.6 约束与局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#861-%E4%B8%8D%E8%83%BD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">8.6.1.</span> <span class="toc-text"> 8.6.1 不能用基本类型实例化类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#862-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.6.2.</span> <span class="toc-text"> 8.6.2 运行时类型查询只适用于原始类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#863-%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">8.6.3.</span> <span class="toc-text"> 8.6.3 不能创建参数化类型的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#864-varargs%E8%AD%A6%E5%91%8A"><span class="toc-number">8.6.4.</span> <span class="toc-text"> 8.6.4 Varargs警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#865-%E4%B8%8D%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">8.6.5.</span> <span class="toc-text"> 8.6.5 不能实例化类型变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#866-%E4%B8%8D%E8%83%BD%E6%9E%84%E9%80%A0%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">8.6.6.</span> <span class="toc-text"> 8.6.6 不能构造泛型数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#867-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E6%97%A0%E6%95%88"><span class="toc-number">8.6.7.</span> <span class="toc-text"> 8.6.7 泛型类的静态上下文中类型变量无效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#868-%E4%B8%8D%E8%83%BD%E6%8A%9B%E5%87%BA%E6%88%96%E6%8D%95%E6%8D%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.6.8.</span> <span class="toc-text"> 8.6.8 不能抛出或捕捉泛型类的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#869-%E5%8F%AF%E4%BB%A5%E6%B6%88%E9%99%A4%E5%AF%B9%E5%8F%97%E6%9F%A5%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="toc-number">8.6.9.</span> <span class="toc-text"> 8.6.9 可以消除对受查异常的检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8610-%E6%B3%A8%E6%84%8F%E6%93%A6%E9%99%A4%E5%90%8E%E7%9A%84%E5%86%B2%E7%AA%81"><span class="toc-number">8.6.10.</span> <span class="toc-text"> 8.6.10 注意擦除后的冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99"><span class="toc-number">8.7.</span> <span class="toc-text"> 8.7 泛型类型的继承规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.8.</span> <span class="toc-text"> 8.8 通配符类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#881-%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A6%82%E5%BF%B5"><span class="toc-number">8.8.1.</span> <span class="toc-text"> 8.8.1 通配符概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#882-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E8%B6%85%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A"><span class="toc-number">8.8.2.</span> <span class="toc-text"> 8.8.2 通配符的超类型限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#883-%E6%97%A0%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">8.8.3.</span> <span class="toc-text"> 8.8.3 无限定通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#884-%E9%80%9A%E9%85%8D%E7%AC%A6%E6%8D%95%E8%8E%B7"><span class="toc-number">8.8.4.</span> <span class="toc-text"> 8.8.4 通配符捕获</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89-%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.9.</span> <span class="toc-text"> 8.9 反射和泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#891-%E6%B3%9B%E5%9E%8Bclass%E7%B1%BB"><span class="toc-number">8.9.1.</span> <span class="toc-text"> 8.9.1 泛型Class类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#892-%E4%BD%BF%E7%94%A8classt%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D"><span class="toc-number">8.9.2.</span> <span class="toc-text"> 8.9.2 使用Class&lt;T&gt;参数进行类型匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#893-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">8.9.3.</span> <span class="toc-text"> 8.9.3 虚拟机中的泛型类型信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E9%9B%86%E5%90%88"><span class="toc-number">9.</span> <span class="toc-text"> 9 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91-java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">9.1.</span> <span class="toc-text"> 9.1 Java集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#911-%E5%B0%86%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="toc-number">9.1.1.</span> <span class="toc-text"> 9.1.1 将集合的接口与实现分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#912-collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.1.2.</span> <span class="toc-text"> 9.1.2 Collection接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#913-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">9.1.3.</span> <span class="toc-text"> 9.1.3 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#914-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.4.</span> <span class="toc-text"> 9.1.4 泛型实用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#915-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.1.5.</span> <span class="toc-text"> 9.1.5 集合框架中的接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E5%85%B7%E4%BD%93%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">9.2.</span> <span class="toc-text"> 9.2 具体的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#921-%E9%93%BE%E8%A1%A8"><span class="toc-number">9.2.1.</span> <span class="toc-text"> 9.2.1 链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#922-%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8"><span class="toc-number">9.2.2.</span> <span class="toc-text"> 9.2.2 数组列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#923-%E6%95%A3%E5%88%97%E9%9B%86"><span class="toc-number">9.2.3.</span> <span class="toc-text"> 9.2.3 散列集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#924-%E6%A0%91%E9%9B%86"><span class="toc-number">9.2.4.</span> <span class="toc-text"> 9.2.4 树集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#925-%E9%98%9F%E5%88%97%E4%B8%8E%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">9.2.5.</span> <span class="toc-text"> 9.2.5 队列与双端队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#926-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">9.2.6.</span> <span class="toc-text"> 9.2.6 优先级队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E6%98%A0%E5%B0%84"><span class="toc-number">9.3.</span> <span class="toc-text"> 9.3 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#931-%E5%9F%BA%E6%9C%AC%E6%98%A0%E5%B0%84%E6%93%8D%E4%BD%9C"><span class="toc-number">9.3.1.</span> <span class="toc-text"> 9.3.1 基本映射操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#932-%E6%9B%B4%E6%96%B0%E6%98%A0%E5%B0%84%E9%A1%B9"><span class="toc-number">9.3.2.</span> <span class="toc-text"> 9.3.2 更新映射项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#933-%E6%98%A0%E5%B0%84%E8%A7%86%E5%9B%BE"><span class="toc-number">9.3.3.</span> <span class="toc-text"> 9.3.3 映射视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#934-%E5%BC%B1%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84"><span class="toc-number">9.3.4.</span> <span class="toc-text"> 9.3.4 弱散列映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#935-%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="toc-number">9.3.5.</span> <span class="toc-text"> 9.3.5 链接散列集与映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#936-%E6%9E%9A%E4%B8%BE%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="toc-number">9.3.6.</span> <span class="toc-text"> 9.3.6 枚举集与映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#937-%E6%A0%87%E8%AF%86%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84"><span class="toc-number">9.3.7.</span> <span class="toc-text"> 9.3.7 标识散列映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">9.4.</span> <span class="toc-text"> 9.4 视图与包装器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#941-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%9B%86%E5%90%88%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">9.4.1.</span> <span class="toc-text"> 9.4.1 轻量级集合包装器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#942-%E5%AD%90%E8%8C%83%E5%9B%B4"><span class="toc-number">9.4.2.</span> <span class="toc-text"> 9.4.2 子范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#943-%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E8%A7%86%E5%9B%BE"><span class="toc-number">9.4.3.</span> <span class="toc-text"> 9.4.3 不可修改的视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#944-%E5%90%8C%E6%AD%A5%E8%A7%86%E5%9B%BE"><span class="toc-number">9.4.4.</span> <span class="toc-text"> 9.4.4 同步视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#945-%E5%8F%97%E6%9F%A5%E8%A7%86%E5%9B%BE"><span class="toc-number">9.4.5.</span> <span class="toc-text"> 9.4.5 受查视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#946-%E5%85%B3%E4%BA%8E%E5%8F%AF%E9%80%89%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">9.4.6.</span> <span class="toc-text"> 9.4.6 关于可选操作的说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-%E7%AE%97%E6%B3%95"><span class="toc-number">9.5.</span> <span class="toc-text"> 9.5 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#951-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%B7%B7%E6%8E%92"><span class="toc-number">9.5.1.</span> <span class="toc-text"> 9.5.1 排序与混排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#952-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">9.5.2.</span> <span class="toc-text"> 9.5.2 二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#953-%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95"><span class="toc-number">9.5.3.</span> <span class="toc-text"> 9.5.3 简单算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#954-%E6%89%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">9.5.4.</span> <span class="toc-text"> 9.5.4 批操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#955-%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.5.5.</span> <span class="toc-text"> 9.5.5 集合与数组的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#956-%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">9.5.6.</span> <span class="toc-text"> 9.5.6 编写自己的算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E9%81%97%E7%95%99%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">9.6.</span> <span class="toc-text"> 9.6 遗留的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#961-hashtable%E7%B1%BB"><span class="toc-number">9.6.1.</span> <span class="toc-text"> 9.6.1 Hashtable类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#962-%E6%9E%9A%E4%B8%BE"><span class="toc-number">9.6.2.</span> <span class="toc-text"> 9.6.2 枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#963-%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84"><span class="toc-number">9.6.3.</span> <span class="toc-text"> 9.6.3 属性映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#964-%E6%A0%88"><span class="toc-number">9.6.4.</span> <span class="toc-text"> 9.6.4 栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#965-%E4%BD%8D%E9%9B%86"><span class="toc-number">9.6.5.</span> <span class="toc-text"> 9.6.5 位集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E9%83%A8%E7%BD%B2java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text"> 13 部署Java应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#131-jar%E6%96%87%E4%BB%B6"><span class="toc-number">10.1.</span> <span class="toc-text"> 13.1 JAR文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1311-%E5%88%9B%E5%BB%BAjar%E6%96%87%E4%BB%B6"><span class="toc-number">10.1.1.</span> <span class="toc-text"> 13.1.1 创建JAR文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1312-%E6%B8%85%E5%8D%95%E6%96%87%E4%BB%B6"><span class="toc-number">10.1.2.</span> <span class="toc-text"> 13.1.2 清单文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1313-%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E6%96%87%E4%BB%B6"><span class="toc-number">10.1.3.</span> <span class="toc-text"> 13.1.3 可执行JAR文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1314-%E8%B5%84%E6%BA%90"><span class="toc-number">10.1.4.</span> <span class="toc-text"> 13.1.4 资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1315-%E5%AF%86%E5%B0%81"><span class="toc-number">10.1.5.</span> <span class="toc-text"> 13.1.5 密封</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#132-%E5%BA%94%E7%94%A8%E9%A6%96%E9%80%89%E9%A1%B9%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">10.2.</span> <span class="toc-text"> 13.2 应用首选项的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1321-%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84"><span class="toc-number">10.2.1.</span> <span class="toc-text"> 13.2.1 属性映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1322-%E9%A6%96%E9%80%89%E9%A1%B9api"><span class="toc-number">10.2.2.</span> <span class="toc-text"> 13.2.2 首选项API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#133-%E6%9C%8D%E5%8A%A1%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">10.3.</span> <span class="toc-text"> 13.3 服务加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#135-java-web-start"><span class="toc-number">10.4.</span> <span class="toc-text"> 13.5 Java Web Start</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1351-%E5%8F%91%E5%B8%83java-web-start%E5%BA%94%E7%94%A8"><span class="toc-number">10.4.1.</span> <span class="toc-text"> 13.5.1 发布Java Web Start应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1352-jnlp-api"><span class="toc-number">10.4.2.</span> <span class="toc-text"> 13.5.2 JNLP API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E5%B9%B6%E5%8F%91"><span class="toc-number">11.</span> <span class="toc-text"> 14 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.1.</span> <span class="toc-text"> 14.1 什么是线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1411-%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%BB%99%E5%85%B6%E4%BB%96%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%9C%BA%E4%BC%9A"><span class="toc-number">11.1.1.</span> <span class="toc-text"> 14.1.1 使用进程给其他任务提供机会</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.2.</span> <span class="toc-text"> 14.2 中断线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#143-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">11.3.</span> <span class="toc-text"> 14.3 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1431-%E6%96%B0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.3.1.</span> <span class="toc-text"> 14.3.1 新创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1432-%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.3.2.</span> <span class="toc-text"> 14.3.2 可运行线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1433-%E8%A2%AB%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E6%88%96%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.3.3.</span> <span class="toc-text"> 14.3.3 被阻塞线程或等待线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1434-%E8%A2%AB%E7%BB%88%E6%AD%A2%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.3.4.</span> <span class="toc-text"> 14.3.4 被终止的线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">11.4.</span> <span class="toc-text"> 14.4 线程属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1441-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">11.4.1.</span> <span class="toc-text"> 14.4.1 线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1442-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.4.2.</span> <span class="toc-text"> 14.4.2 守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1443-%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">11.4.3.</span> <span class="toc-text"> 14.4.3 未捕获异常处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#145-%E5%90%8C%E6%AD%A5"><span class="toc-number">11.5.</span> <span class="toc-text"> 14.5 同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1452-%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">11.5.1.</span> <span class="toc-text"> 14.5.2 竞争条件详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1453-%E9%94%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.5.2.</span> <span class="toc-text"> 14.5.3 锁对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1454-%E6%9D%A1%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.5.3.</span> <span class="toc-text"> 14.5.4 条件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1455-synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">11.5.4.</span> <span class="toc-text"> 14.5.5 synchronized关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1456-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E"><span class="toc-number">11.5.5.</span> <span class="toc-text"> 14.5.6 同步阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1457-%E7%9B%91%E8%A7%86%E5%99%A8%E6%A6%82%E5%BF%B5"><span class="toc-number">11.5.6.</span> <span class="toc-text"> 14.5.7 监视器概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1458-volatile%E5%9F%9F"><span class="toc-number">11.5.7.</span> <span class="toc-text"> 14.5.8 Volatile域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1459-final%E5%8F%98%E9%87%8F"><span class="toc-number">11.5.8.</span> <span class="toc-text"> 14.5.9 final变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14510-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">11.5.9.</span> <span class="toc-text"> 14.5.10 原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14511-%E6%AD%BB%E9%94%81"><span class="toc-number">11.5.10.</span> <span class="toc-text"> 14.5.11 死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14512-%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">11.5.11.</span> <span class="toc-text"> 14.5.12 线程局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14513-%E9%94%81%E6%B5%8B%E8%AF%95%E5%9F%9F%E8%B6%85%E6%97%B6"><span class="toc-number">11.5.12.</span> <span class="toc-text"> 14.5.13 锁测试域超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14514-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">11.5.13.</span> <span class="toc-text"> 14.5.14 读&#x2F;写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14515-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%83%E7%94%A8stop%E5%92%8Csuspend%E6%96%B9%E6%B3%95"><span class="toc-number">11.5.14.</span> <span class="toc-text"> 14.5.15 为什么弃用stop和suspend方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">11.6.</span> <span class="toc-text"> 14.6 阻塞队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#147-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">11.7.</span> <span class="toc-text"> 14.7 线程安全的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1471-%E9%AB%98%E6%95%88%E7%9A%84%E6%98%A0%E5%B0%84-%E9%9B%86%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">11.7.1.</span> <span class="toc-text"> 14.7.1 高效的映射、集和队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1472-%E6%98%A0%E5%B0%84%E6%9D%A1%E7%9B%AE%E7%9A%84%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0"><span class="toc-number">11.7.2.</span> <span class="toc-text"> 14.7.2 映射条目的原子更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1473-%E5%AF%B9%E5%B9%B6%E5%8F%91%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84%E7%9A%84%E6%89%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">11.7.3.</span> <span class="toc-text"> 14.7.3 对并发散列映射的批操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1474-%E5%B9%B6%E5%8F%91%E9%9B%86%E8%A7%86%E5%9B%BE"><span class="toc-number">11.7.4.</span> <span class="toc-text"> 14.7.4 并发集视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1475-%E5%86%99%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">11.7.5.</span> <span class="toc-text"> 14.7.5 写数组的拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1476-%E5%B9%B6%E8%A1%8C%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95"><span class="toc-number">11.7.6.</span> <span class="toc-text"> 14.7.6 并行数组算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1477-%E8%BE%83%E6%97%A9%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88"><span class="toc-number">11.7.7.</span> <span class="toc-text"> 14.7.7 较早的线程安全集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-callable%E4%B8%8Efuture"><span class="toc-number">11.8.</span> <span class="toc-text"> 14.8 Callable与Future</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#149-%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">11.9.</span> <span class="toc-text"> 14.9 执行器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1491-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">11.9.1.</span> <span class="toc-text"> 14.9.1 线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1492-%E9%A2%84%E5%AE%9A%E6%89%A7%E8%A1%8C"><span class="toc-number">11.9.2.</span> <span class="toc-text"> 14.9.2 预定执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1493-%E6%8E%A7%E5%88%B6%E4%BB%BB%E5%8A%A1%E7%BB%84"><span class="toc-number">11.9.3.</span> <span class="toc-text"> 14.9.3 控制任务组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1494-fork-join%E6%A1%86%E6%9E%B6"><span class="toc-number">11.9.4.</span> <span class="toc-text"> 14.9.4 Fork-Join框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1495-%E5%8F%AF%E5%AE%8C%E6%88%90future"><span class="toc-number">11.9.5.</span> <span class="toc-text"> 14.9.5 可完成Future</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1410-%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">11.10.</span> <span class="toc-text"> 14.10 同步器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14101-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">11.10.1.</span> <span class="toc-text"> 14.10.1 信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14102-%E5%80%92%E8%AE%A1%E6%97%B6%E9%97%A8%E6%A0%93"><span class="toc-number">11.10.2.</span> <span class="toc-text"> 14.10.2 倒计时门栓</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14103-%E9%9A%9C%E6%A0%85"><span class="toc-number">11.10.3.</span> <span class="toc-text"> 14.10.3 障栅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14104-%E4%BA%A4%E6%8D%A2%E5%99%A8"><span class="toc-number">11.10.4.</span> <span class="toc-text"> 14.10.4 交换器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14105-%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">11.10.5.</span> <span class="toc-text"> 14.10.5 同步队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">12.</span> <span class="toc-text"> 2 输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">12.1.</span> <span class="toc-text"> 2.1 输入&#x2F;输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#211-%E8%AF%BB%E5%86%99%E5%AD%97%E8%8A%82"><span class="toc-number">12.1.1.</span> <span class="toc-text"> 2.1.1 读写字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#212-%E5%AE%8C%E6%95%B4%E7%9A%84%E6%B5%81%E5%AE%B6%E6%97%8F"><span class="toc-number">12.1.2.</span> <span class="toc-text"> 2.1.2 完整的流家族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213-%E7%BB%84%E5%90%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">12.1.3.</span> <span class="toc-text"> 2.1.3 组合输入&#x2F;输出流过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">12.2.</span> <span class="toc-text"> 2.2 文本输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#221-%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%96%87%E6%9C%AC%E8%BE%93%E5%87%BA"><span class="toc-number">12.2.1.</span> <span class="toc-text"> 2.2.1 如何写出文本输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222-%E5%A6%82%E4%BD%95%E8%AF%BB%E5%85%A5%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5"><span class="toc-number">12.2.2.</span> <span class="toc-text"> 2.2.2 如何读入文本输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#224-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.3.</span> <span class="toc-text"> 2.2.4 字符编码方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">12.3.</span> <span class="toc-text"> 2.3 读写二进制数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#231-datainput%E5%92%8Cdataoutput%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.3.1.</span> <span class="toc-text"> 2.3.1 DataInput和DataOutput接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6"><span class="toc-number">12.3.2.</span> <span class="toc-text"> 2.3.2 随机访问文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#233-zip%E6%96%87%E6%A1%A3"><span class="toc-number">12.3.3.</span> <span class="toc-text"> 2.3.3 ZIP文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">12.4.</span> <span class="toc-text"> 2.4 对象输入&#x2F;输出流与序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#241-%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.4.1.</span> <span class="toc-text"> 2.4.1 保存和加载序列化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">12.4.2.</span> <span class="toc-text"> 2.4.2 理解对象序列化的文件格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="toc-number">12.5.</span> <span class="toc-text"> 2.5 操作文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#251-path"><span class="toc-number">12.5.1.</span> <span class="toc-text"> 2.5.1 Path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#252-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">12.5.2.</span> <span class="toc-text"> 2.5.2 读写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#253-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">12.5.3.</span> <span class="toc-text"> 2.5.3 创建文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#254-%E5%A4%8D%E5%88%B6%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">12.5.4.</span> <span class="toc-text"> 2.5.4 复制,移动和删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#255-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">12.5.5.</span> <span class="toc-text"> 2.5.5 获取文件信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#256-%E8%AE%BF%E9%97%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E9%A1%B9"><span class="toc-number">12.5.6.</span> <span class="toc-text"> 2.5.6 访问目录中的项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#257-%E4%BD%BF%E7%94%A8%E7%9B%AE%E5%BD%95%E6%B5%81"><span class="toc-number">12.5.7.</span> <span class="toc-text"> 2.5.7 使用目录流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#258-zip%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">12.5.8.</span> <span class="toc-text"> 2.5.8 ZIP文件系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text"> Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">13.1.</span> <span class="toc-text"> 行为参数化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%AE%AD%E5%A4%B4lambda%E4%B8%BB%E4%BD%93"><span class="toc-number">13.2.</span> <span class="toc-text"> Lambda表达式的三个部分:参数列表,箭头,Lambda主体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">13.3.</span> <span class="toc-text"> 使用局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8lambda%E7%9A%84%E5%BF%AB%E6%8D%B7%E5%86%99%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text"> 方法引用(Lambda的快捷写法)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%AE%80%E4%BB%8B"><span class="toc-number">14.</span> <span class="toc-text"> 流简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81-%E4%BB%8E%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%9A%84%E6%BA%90%E7%94%9F%E6%88%90%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97"><span class="toc-number">14.1.</span> <span class="toc-text"> 流: 从支持数据处理操作的源生成元素序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E4%B8%8E%E9%9B%86%E5%90%88"><span class="toc-number">14.2.</span> <span class="toc-text"> 流与集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%93%8D%E4%BD%9C"><span class="toc-number">14.3.</span> <span class="toc-text"> 流操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">14.4.</span> <span class="toc-text"> 流的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81"><span class="toc-number">15.</span> <span class="toc-text"> 使用流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%9B%E9%80%89%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">15.1.</span> <span class="toc-text"> 筛选和切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84"><span class="toc-number">15.2.</span> <span class="toc-text"> 映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8C%B9%E9%85%8D"><span class="toc-number">15.3.</span> <span class="toc-text"> 查找和匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6"><span class="toc-number">15.4.</span> <span class="toc-text"> 归约</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E6%B5%81"><span class="toc-number">15.5.</span> <span class="toc-text"> 数值流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%B5%81"><span class="toc-number">15.6.</span> <span class="toc-text"> 构建流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE"><span class="toc-number">16.</span> <span class="toc-text"> 用流收集数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">16.1.</span> <span class="toc-text"> 收集器简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6%E5%92%8C%E6%B1%87%E6%80%BB"><span class="toc-number">16.2.</span> <span class="toc-text"> 归约和汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84"><span class="toc-number">16.3.</span> <span class="toc-text"> 分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">16.4.</span> <span class="toc-text"> 分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.5.</span> <span class="toc-text"> 收集器接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="toc-number">17.</span> <span class="toc-text"> 并行数据处理与性能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="toc-number">17.1.</span> <span class="toc-text"> 并行流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E6%A1%86%E6%9E%B6forkjoin%E6%A1%86%E6%9E%B6"><span class="toc-number">17.2.</span> <span class="toc-text"> 分支合并框架(Fork&#x2F;Join框架)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spliterator"><span class="toc-number">17.3.</span> <span class="toc-text"> Spliterator</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">18.</span> <span class="toc-text"> 默认方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8optional%E5%8F%96%E4%BB%A3null"><span class="toc-number">19.</span> <span class="toc-text"> 用Optional取代null</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api"><span class="toc-number">20.</span> <span class="toc-text"> 新的日期和时间API</span></a></li></ol>
    </div>
  </section>

  

</div>


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.remove("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="half";
      cover_wrapper.style.display="";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.4'
      loop='all'
      order='random'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5062959861'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
              <a href="mailto:jay1060950003@gmail.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
            
              <a href="https://github.com/jay1060950003/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
        </div>
      
    
      
        <p>本站使用 <a target="_blank" rel="noopener" href="https://github.com/volantis-x/hexo-theme-volantis/#5.8.0">Volantis</a> 作为主题，您可以在 GitHub 找到<a target="_blank" rel="noopener" href="https://github.com/volantis-x/volantis-docs">本站源码</a>。</p>

      
    
      
        <div class='copyright'>
        <p>Copyright © Since 2017</p>

        </div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fortawesome/fontawesome-pro/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="/js/app.js"></script>





  













<div id="rightmenu-wrapper">
  <ul class="list-v rightmenu" id="rightmenu-content">
    
  <li class='navigation menuNavigation-Content'>


    <a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa-duotone fa-arrow-left PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa-duotone fa-arrow-right PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa-duotone fa-redo PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" href="/"><i class="fa-duotone fa-home PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)"><i class="fa-duotone fa-arrow-up PETERRIVE fa-fw"></i></a>


  </li>


    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyPaste" data-event="copyPaste" data-group="inputBox">
      <i class="fa-duotone PETERRIVE fa-paste fa-fw"></i>
      粘贴文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyAll" data-event="copyAll" data-group="inputBox">
      <i class="fa-duotone PETERRIVE fa-object-ungroup fa-fw"></i>
      全选文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyCut" data-event="copyCut" data-group="inputBox">
      <i class="fa-duotone PETERRIVE fa-cut fa-fw"></i>
      剪切文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyText" data-event="copyText" data-group="seletctText">
      <i class="fa-duotone PETERRIVE fa-copy fa-fw"></i>
      复制文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="searchWord" data-event="OpenSearch(__text__)" data-group="seletctText">
      <i class="fa-duotone PETERRIVE fa-search fa-fw"></i>
      站内搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="bingSearch" data-event="window.open(`https://cn.bing.com/search?q=${__text__}`)" data-group="seletctText">
      <i class="fa-duotone PETERRIVE fa-search fa-fw"></i>
      必应搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="openTab" data-event="window.open(__link__)" data-group="elementCheck">
      <i class="fa-duotone PETERRIVE fa-external-link-square-alt fa-fw"></i>
      新标签页打开
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyLink" data-event="copyLink" data-group="elementCheck">
      <i class="fa-duotone PETERRIVE fa-link fa-fw"></i>
      复制链接地址
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyImg" data-event="copyImg" data-group="elementImage">
      <i class="fa-duotone PETERRIVE fa-image fa-fw"></i>
      复制图片
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="googleImg" data-event="window.open(`https://www.google.com/searchbyimage?image_url=${__link__}`)" data-group="elementImage">
      <i class="fa-duotone PETERRIVE fa-images fa-fw"></i>
      谷歌识图
    </span>
  </li>



    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="darkMode" data-event="volantis.dark.toggle()" data-group="darkMode">
      <i class="fa-duotone fa-eclipse-alt WISTERIA fa-fw"></i>
      暗黑模式
    </span>
  </li>



    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="printMode" data-event="printMode" data-group="articlePage">
      <i class="fa-duotone fa-print TURQUOISE fa-fw"></i>
      打印页面
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="readMode" data-event="readMode" data-group="articlePage">
      <i class="fa-duotone fa-book-open EMERALD fa-fw"></i>
      阅读模式
    </span>
  </li>



    <hr class="menuLoad-Content" >


<div id="menuMusic">
  <li class='music name menuOption-Content'>
    <p class='nav music-title fix-cursor-default'></p>
  </li>
  <li class='music ctrl'>
    <a class='nav icon-only backward fix-cursor-default' href="/" onclick="return false;" title="backward">
      <i class='fa-duotone PETERRIVE fa-step-backward fa-fw'></i>
    </a>
    <a class='nav icon-only toggle fix-cursor-default' href="/" onclick="return false;" title="toggle">
      <i class='fa-duotone PETERRIVE fa-play fa-fw'></i>
    </a>
    <a class='nav icon-only forward fix-cursor-default' href="/" onclick="return false;" title="forward">
      <i class='fa-duotone PETERRIVE fa-step-forward fa-fw'></i>
    </a>
  </li>
  <li class='music volume'>
    <div class='nav volume'>
      <div class="aplayer-volume-bar-wrap">
        <div class="aplayer-volume-bar fix-cursor-pointer">
          <div class="aplayer-volume"></div>
          <i class='left fa-duotone PETERRIVE fa-volume-off fa-fw'></i>
          <i class='right fa-duotone PETERRIVE fa-volume-up fa-fw'></i>
        </div>
      </div>
    </div>
  </li>
</div>

  </ul>
</div>
<script src="/js/plugins/rightMenus.js"></script>
<script>
  const RightMenusFunction = {};
  














  //RightMenusFunction['copyPaste'] = (fun) => {fun()}





  //RightMenusFunction['copyAll'] = (fun) => {fun()}





  //RightMenusFunction['copyCut'] = (fun) => {fun()}





  //RightMenusFunction['copyText'] = (fun) => {fun()}





  RightMenusFunction['searchWord'] = (__text__) => {OpenSearch(__text__)}





  RightMenusFunction['bingSearch'] = (__text__) => {window.open(`https://cn.bing.com/search?q=${__text__}`)}





  RightMenusFunction['openTab'] = (__link__) => {window.open(__link__)}





  //RightMenusFunction['copyLink'] = (fun) => {fun()}





  //RightMenusFunction['copyImg'] = (fun) => {fun()}





  RightMenusFunction['googleImg'] = (__link__) => {window.open(`https://www.google.com/searchbyimage?image_url=${__link__}`)}







  RightMenusFunction['darkMode'] = () => {volantis.dark.toggle()}







  //RightMenusFunction['printMode'] = (fun) => {fun()}





  //RightMenusFunction['readMode'] = (fun) => {fun()}







</script>



<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->

  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "color-scheme";
const rootElementDarkModeAttributeName = "color-scheme";
const setLS = (k, v) => {
    localStorage.setItem(k, v);
};
const removeLS = (k) => {
    localStorage.removeItem(k);
};
const getLS = (k) => {
    return localStorage.getItem(k);
};
const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};
const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};
const validColorModeKeys = {
  dark: true,
  light: true,
};
const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);
  getCustomDarkMode();
  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};
const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};
/**
 * get target mode
 */
 const getCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  if(currentSetting=="dark"){
    volantis.dark.mode="light";
  }else{
    volantis.dark.mode="dark";
  }
  // console.log(volantis.dark.mode)
};
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};
/**
 * 暗黑模式触发器
 */
volantis.dark.toggle=()=>{
  const mode = toggleCustomDarkMode();
  applyCustomDarkModeSettings(mode);
  // 使用 volantis.dark.push 方法传入volantis.dark.toggle回调函数 参见layout/_partial/scripts/global.ejs
  volantis.dark.method.toggle.start();
}
/**
 * bind event for toggle button
 */

function bindToggleButton() {
  var btn= document.querySelectorAll("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn")
  btn.forEach(function (e) {
    volantis.dom.$(e).on('click',volantis.dark.toggle);
  })
}
applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", ()=>{
  volantis.requestAnimationFrame(bindToggleButton)
});
volantis.pjax.push(bindToggleButton);

const darkModelListeners={
  dark:(mediaQueryList )=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "dark";
    }
    volantis.dark.method.toggle.start();
  },
  light:(mediaQueryList)=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "light";
    }
    volantis.dark.method.toggle.start();
  }
}
window.matchMedia('(prefers-color-scheme: dark)').addListener(darkModelListeners.dark)
window.matchMedia('(prefers-color-scheme: light)').addListener(darkModelListeners.light)
</script>




<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/js/plugins/tags/sites.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/js/plugins/tags/friends.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/js/plugins/tags/contributors.js")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/flying-pages/flying-pages.min.js"></script>





   <script type="text/javascript">
  function pjax_scrollrebeal() {
    ScrollReveal().reveal("#l_main .reveal", {
      distance: "32px",
      duration: "800",
      interval: "20",
      scale: "1",
      easing: "ease-out",
    });
  }
  function init_scrollrebeal() {
    if (typeof ScrollReveal == "undefined") {
      volantis.requestAnimationFrame(init_scrollrebeal);
    } else {
      pjax_scrollrebeal();
    }
  }
  volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/scrollreveal/dist/scrollreveal.min.js");
  document.addEventListener("DOMContentLoaded", init_scrollrebeal);
  volantis.pjax.push(
    pjax_scrollrebeal,
    "pjax_scrollrebeal",
    (setRequestAnimationFrame = false)
  );
</script>




  <script>
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/aplayer/dist/APlayer.min.css");
  (async () => {
    // APlayer 需要在  MetingJS 之前加载
    await volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/aplayer/dist/APlayer.min.js")
    await volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/meting/dist/Meting.min.js")
  
    // 右键 music 需要在 APlayer  MetingJS 之后加载
    await volantis.js('/js/plugins/aplayer.js')
  
  })();

  function SetAPlayerPlugin(){
    let Metings = document.querySelectorAll('meting-js');
    if (Metings.length === 0) {return;};
    if (Metings[0].aplayer && Metings[0].aplayer.on) {
      // improve the accessibility https://web.dev/button-name/
      document.querySelectorAll(".aplayer-icon-menu").forEach(e=>{
        e.setAttribute("aria-label","Aplayer Menu")
      })
      // message see: /layout/_plugins/message/script.ejs
      
        try {
          setTimeout(() => {
            Metings.forEach((item, index) => {
              const aplayerItem = item.aplayer; if(!aplayerItem) return;
              const rightAplayerCheck = 'true' === 'true'
                && item.meta.id === '5062959861';
              if(rightAplayerCheck && typeof RightMenuAplayer !="undefined") RightMenuAplayer.checkAPlayer();
              if(aplayerItem.events.events.play.every(item => {return item.name !== 'messagePlay'})) {
                aplayerItem.on('play', function messagePlay() {
                  let index = aplayerItem.list.index;
                  let title = aplayerItem.list.audios[index].title;
                  let artist = aplayerItem.list.audios[index].artist;
                  setTimeout(() => {
                    VolantisApp.message('音乐通知', title + ' - ' + artist, {
                      icon: 'fa-light fa-play light-blue',
                      transitionIn: 'flipInX',
                      transitionOut: 'flipOutX'
                    });
                  }, 100)
                });
              }
              if(aplayerItem.events.events.pause.every(item => {return item.name !== 'messagePause'})) {
                aplayerItem.on('pause', function messagePause() {
                  let index = aplayerItem.list.index;
                  let title = aplayerItem.list.audios[index].title;
                  let artist = aplayerItem.list.audios[index].artist;
                  setTimeout(() => {
                    // 歌曲播放结束也会触发 pause 事件，为了避免错误提示，等待一会儿
                    if(aplayerItem.paused) {
                      VolantisApp.message('音乐通知', title + ' - ' + artist, {
                        icon: 'fa-light fa-pause light-blue',
                        transitionIn: 'flipInX',
                        transitionOut: 'flipOutX'
                      });
                    }
                  }, 100)
                });
              }
            });
          }, 500)
        } catch (error) { console.error(error); }
      
    }else{
      volantis.requestAnimationFrame(SetAPlayerPlugin)
    }
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    SetAPlayerPlugin();
  });
  volantis.pjax.push(SetAPlayerPlugin);
</script>




      <script>
  volantis.layoutHelper("comments",`<div id="giscus_container"></div>`)

  volantis.giscus = {};

  function check_giscus() {
    if (volantis.dark.mode === "dark") {
      volantis.giscus.Theme = 'dark';
    } else {
      volantis.giscus.Theme = 'light';
    }

    return document.getElementById("giscus_container");
  }

  function pjax_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;
    let cfg = Object.assign({"theme":{"light":"light","dark":"dark"},"repo":"jay1060950003/comments","repo-id":"R_kgDOJfmU6A","category":"Announcements","category-id":"DIC_kwDOJfmU6M4CWTdE","mapping":"pathname","reactions-enabled":"1","emit-metadata":"0","lang":"zh-CN"},pdata.commentConfig)
    const script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    Object.keys(cfg).forEach(k=>{
      if (k != "theme") {
        script.setAttribute('data-'+k, cfg[k]);
      }
    })
    script.setAttribute('data-theme', volantis.giscus.Theme);
    script.setAttribute('crossorigin', "anonymous");
    HEAD.appendChild(script);
  }

  function dark_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;

    const message = {
      setConfig: {
        theme: volantis.giscus.Theme
      }
    };
    const giscusIframe = document.querySelector('iframe.giscus-frame');
    giscusIframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  pjax_giscus();
  volantis.pjax.push(pjax_giscus);
  volantis.dark.push(dark_giscus);
</script>

    




  <script defer src="https://gcore.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>


<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/") ?
    "/" || "/" :
    "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("/js/search/hexo.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>







  <script>



  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>










  <script>
  let imgs = ["https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/006.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/056.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/042.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/033.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/001.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/046.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/025.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/052.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/003.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/039.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/051.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/016.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/019.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/005.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/035.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/034.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/004.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/054.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/038.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/002.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/012.webp"];
  let index = 0;
  let IntervalParallax = null;

  function parallax(){
    let ParallaxWindow = document.querySelector("#parallax-window");
    
    Parallax.window = ParallaxWindow;
    Parallax.options.fade = 1500;
    Parallax.cache = 1;
    next_parallax();
    Parallax.init();
    if (imgs.length>1) {
      IntervalParallax = setInterval(function () {
        next_parallax();
      }, '10000');
    }
  }

  function next_parallax() {
    if (typeof Parallax == "undefined") {
      return
    }
    
      if (!document.querySelector("#full")&&!document.querySelector("#half")) {
        return
      }
    
    if (imgs.length>=1) {
      Parallax.options.src = imgs[index % imgs.length];
      Parallax.start();
      index++;
      if (Parallax.cache) {
        fetch(imgs[index % imgs.length] +"?t=" + new Date().getTime());
        if (index == imgs.length) {
          Parallax.cache = 0;
        }
      }
    }
  }
  var runningOnBrowser = typeof window !== "undefined";
  var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
  if (!isBot) {
    volantis.js('/js/plugins/parallax.js').then(()=>{
      parallax()
    })
    volantis.pjax.send(()=>{
      clearInterval(IntervalParallax)
    },"clearIntervalParallax");
    volantis.pjax.push(parallax);
  }
</script>




  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    let targets = []
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:true})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex=0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    volantis.scroll.push(()=>{
      if (targets[0].getBoundingClientRect().top >= 0) {
        volantis.activateNavIndex = 0
      }else if (targets[targets.length-1].getBoundingClientRect().top < 0) {
        volantis.activateNavIndex = targets.length-1
      } else {
        for (let index = 0; index < targets.length; index++) {
          const target0 = targets[index];
          const target1 = targets[(index+1)%targets.length];
          if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) {
            volantis.activateNavIndex=index
            break;
          }
        }
      }
      activateNavByIndex(navItems[volantis.activateNavIndex])
    })

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>


  <script>
  try {
    // https://web.dev/content-visibility/
    // https://www.caniuse.com/?search=content-visibility
    // https://infrequently.org/2020/12/content-visibility-scroll-fix/
    // https://infrequently.org/2020/12/resize-resilient-deferred-rendering/

    // 备注 目前已知的问题:
    // 动态修改导致的内容高度变化(例如评论框异步渲染的外部盒子高度变化) 无法提前获知, 进而导致的首次滚动条跳动无法去除 (wontfix) 事实上不使用 content-visibility 也会有跳动, 不过是比使用 content-visibility 跳动提前
    // scrollreveal 插件潜在问题 目前尚不明确

    let eqIsh = (a, b, fuzz = 2) => {
      return Math.abs(a - b) <= fuzz;
    };

    let rectNotEQ = (a, b) => {
      return !eqIsh(a.width, b.width) || !eqIsh(a.height, b.height);
    };

    // Keep a map of elements and the dimensions of
    // their place-holders, re-setting the element's
    // intrinsic size when we get updated measurements
    // from observers.
    let spaced = new WeakMap();

    // Only call this when known cheap, post layout
    let reserveSpace = (el, rect = el.getClientBoundingRect()) => {
      let old = spaced.get(el);
      // Set intrinsic size to prevent jumping on un-painting:
      //    https://drafts.csswg.org/css-sizing-4/#intrinsic-size-override
      if (!old || rectNotEQ(old, rect)) {
        spaced.set(el, rect);
        el.style["contain-intrinsic-size"] = `${rect.width}px ${rect.height}px`;
      }
    };

    let iObs = new IntersectionObserver(
      (entries, o) => {
        entries.forEach((entry) => {
          // We don't care if the element is intersecting or
          // has been laid out as our page structure ensures
          // they'll get the right width.
          reserveSpace(entry.target, entry.boundingClientRect);
        });
      },
      { rootMargin: "500px 0px 500px 0px" }
    );

    let rObs = new ResizeObserver((entries, o) => {
      entries.forEach((entry) => {
        reserveSpace(entry.target, entry.contentRect);
      });
    });

    let resizeResilientDeferredRendering = (Selector) => {
      let articles = document.querySelectorAll(Selector);

      if (articles.length) {
        articles.forEach((el) => {
          iObs.observe(el);
          rObs.observe(el);
        });

        // Workaround for Chrome bug, part 2.
        //
        // Re-enable browser management of rendering for the
        // first article after the first paint. Double-rAF
        // to ensure we get called after a layout.
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            articles[0].style["content-visibility"] = "auto";
          });
        });
      }
    };

    let contentVisibilityScrollFix = () => {
      if (!("content-visibility" in document.documentElement.style)) {
        return;
      }
      resizeResilientDeferredRendering(".post-story");
    };
    contentVisibilityScrollFix();
    volantis.pjax.push(contentVisibilityScrollFix);
  } catch (error) {
    console.log(error);
  }
</script>



<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"CodingStudio","url":"http://jay1060950003.github.io/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"jay1060950003","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://jay1060950003.github.io/","sameAs":["https://github.com/volantis-x"],"description":"自己的创作及学习空间"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"http://jay1060950003.github.io/","name":"CodingStudio"}},{"@type":"ListItem","position":2,"item":{"@id":"http://jay1060950003.github.io/categories/Java/","name":"Java"}},{"@type":"ListItem","position":3,"item":{"@id":"http://jay1060950003.github.io/2022/01/10/计算机基础知识/Java核心技术/","name":"Java核心技术"}}]},{"@context":"http://schema.org","@type":"WebSite","name":"CodingStudio","url":"http://jay1060950003.github.io/","keywords":"C++,Java,Qt,OpenCV,后端,开发者,程序猿,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder, 摄影","description":"自己的创作及学习空间","author":{"@type":"Person","name":"jay1060950003","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://jay1060950003.github.io/","description":"自己的创作及学习空间"},"publisher":{"@type":"Organization","name":"CodingStudio","url":"http://jay1060950003.github.io/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"http://jay1060950003.github.io?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"http://schema.org","@type":"BlogPosting","headline":"Java核心技术","description":" 引言\n\nJava核心思想的学习笔记\n包含第一卷除swing章节，并包含第二卷的文件流部分\n","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http://jay1060950003.github.io/2022/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},"author":{"@type":"Person","name":"jay1060950003","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://jay1060950003.github.io/"},"publisher":{"@type":"Organization","name":"CodingStudio","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"http://jay1060950003.github.io/2022/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/","wordCount":46,"datePublished":"2022-01-10T07:22:12.000Z","dateModified":"2023-04-16T12:15:50.274Z","articleSection":"Java","keywords":"Java","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>



      
        <!--
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name=keywords]",
          "head meta[name=description]",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
    <!-- import body_end begin-->
    <!-- import body_end end-->
    <!-- Custom Files bodyEnd begin-->
    
    <!-- Custom Files bodyEnd end-->
    <!-- front-matter body_end begin -->
    <!-- front-matter body_end end -->
  </body>
</html>
