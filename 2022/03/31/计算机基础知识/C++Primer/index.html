<!DOCTYPE html>
<html lang="zh-CN">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#5.8.0'>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="Volantis" content="5.8.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="http://jay1060950003.github.io/2022/03/31/计算机基础知识/c++primer/"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  <link rel="stylesheet" href="https://unpkg.com/katex@0.16.0/dist/katex.css" integrity="sha384-1IGr2Yb8xuHjwTG+WoGjj2+I/a/N6z0gDD5YIGCQxywPROOKc3+orbn/R7arWQxD" crossorigin="anonymous">
<script src="https://unpkg.com/katex@0.16.0/dist/katex.js" integrity="sha384-I2b1Pcl48X93GxEkGkaMo1hrd6n+IX8H2wgSsMimGbkZoGTve/87h1FjaDNvlpQi" crossorigin="anonymous"></script>
  <!-- Custom Files headBegin end-->
  <!-- front-matter head_begin begin -->
  <!-- front-matter head_begin end -->
    <link rel="shortcut icon" type='image/x-icon' href="https://gcore.jsdelivr.net/gh/jay1060950003/chartBed//favicon.ico">
  <link rel="preload" href="/css/style.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
  <!-- 页面元数据 -->
  <title>C++Primer - CodingStudio</title>
  <meta name="keywords" content="C++,C++,Java,Qt,OpenCV,后端,开发者,程序猿,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder, 摄影">
  <meta desc name="description" content=" 引言

C++ Primer的学习笔记
 - jay1060950003 - CodingStudio">
  
<meta property="og:type" content="article">
<meta property="og:title" content="C++Primer">
<meta property="og:url" content="http://jay1060950003.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++Primer/index.html">
<meta property="og:site_name" content="CodingStudio">
<meta property="og:description" content="引言  C++ Primer的学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2022-03-31T08:52:28.000Z">
<meta property="article:modified_time" content="2023-04-09T13:36:47.123Z">
<meta property="article:author" content="jay1060950003">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
.post-story + .post-story {
  content-visibility: auto;
  contain-intrinsic-size: 10px 500px;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #30ad91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #2092ec;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-bg {
  position: absolute;
  width: 100%;
  height: 100%;
  background-position: center;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
}
.cover-wrapper .cover-bg.lazyload:not(.loaded) {
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
}
.cover-wrapper .cover-bg.lazyload.loaded {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
.cover-wrapper #parallax-window {
  position: absolute;
  width: 100%;
  height: 100%;
  background: transparent;
}
.parallax-mirror {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media (prefers-color-scheme: dark) {
  :root {
    --color-mode: 'dark';
  }
  :root:not([color-scheme]) {
    --color-site-body: #121212;
    --color-read-bkg: #1f1f1f;
    --color-read-post: #262626;
    --color-site-bg: #1f1f1f;
    --color-site-inner: rgba(238,238,238,0.871);
    --color-site-footer: rgba(170,170,170,0.871);
    --color-card: #262626;
    --color-text: rgba(238,238,238,0.871);
    --color-block: #434343;
    --color-codeblock: #1f1f1f;
    --color-inlinecode: #d56d28;
    --color-h1: rgba(255,255,255,0.871);
    --color-h2: rgba(255,255,255,0.871);
    --color-h3: rgba(255,255,255,0.6);
    --color-h4: rgba(255,255,255,0.6);
    --color-h5: rgba(255,255,255,0.6);
    --color-h6: rgba(255,255,255,0.6);
    --color-p: rgba(217,217,217,0.871);
    --color-list: rgba(217,217,217,0.871);
    --color-list-hl: #63e0c4;
    --color-meta: rgba(191,191,191,0.871);
    --color-link: rgba(191,191,191,0.871);
    --color-copyright-bkg: #21252b;
  }
  :root:not([color-scheme]) img {
    filter: brightness(70%) !important;
  }
  :root:not([color-scheme]) .blur {
    background: rgba(31,31,31,0.9) !important;
  }
  :root:not([color-scheme]) .white-box.blur {
    background: rgba(38,38,38,0.9) !important;
  }
  :root:not([color-scheme]) .nav-main .u-search-input {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a:hover {
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) .article blockquote {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .article-title a {
    color: var(--color-h1) !important;
  }
  :root:not([color-scheme]) details>summary {
    color: var(--color-p) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) details {
    border: 1px solid var(--color-site-bg) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) #u-search .modal,
  :root:not([color-scheme]) #u-search .modal-header,
  :root:not([color-scheme]) #u-search .modal-body {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #u-search .modal-body .modal-results .result:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:focus {
    background: var(--color-site-body) !important;
  }
}
[color-scheme='dark'] {
  --color-site-body: #121212;
  --color-read-bkg: #1f1f1f;
  --color-read-post: #262626;
  --color-site-bg: #1f1f1f;
  --color-site-inner: rgba(238,238,238,0.871);
  --color-site-footer: rgba(170,170,170,0.871);
  --color-card: #262626;
  --color-text: rgba(238,238,238,0.871);
  --color-block: #434343;
  --color-codeblock: #1f1f1f;
  --color-inlinecode: #d56d28;
  --color-h1: rgba(255,255,255,0.871);
  --color-h2: rgba(255,255,255,0.871);
  --color-h3: rgba(255,255,255,0.6);
  --color-h4: rgba(255,255,255,0.6);
  --color-h5: rgba(255,255,255,0.6);
  --color-h6: rgba(255,255,255,0.6);
  --color-p: rgba(217,217,217,0.871);
  --color-list: rgba(217,217,217,0.871);
  --color-list-hl: #63e0c4;
  --color-meta: rgba(191,191,191,0.871);
  --color-link: rgba(191,191,191,0.871);
  --color-copyright-bkg: #21252b;
}
[color-scheme='dark'] img {
  filter: brightness(70%) !important;
}
[color-scheme='dark'] .blur {
  background: rgba(31,31,31,0.9) !important;
}
[color-scheme='dark'] .white-box.blur {
  background: rgba(38,38,38,0.9) !important;
}
[color-scheme='dark'] .nav-main .u-search-input {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a {
  background: var(--color-block) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a:hover {
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] .article blockquote {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .article-title a {
  color: var(--color-h1) !important;
}
[color-scheme='dark'] details>summary {
  color: var(--color-p) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] details {
  border: 1px solid var(--color-site-bg) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] #u-search .modal,
[color-scheme='dark'] #u-search .modal-header,
[color-scheme='dark'] #u-search .modal-body {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #u-search .modal-body .modal-results .result:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:focus {
  background: var(--color-site-body) !important;
}
@media screen and (max-width: 500px) {
  [color-scheme='dark'] .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1080px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #3dd9b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #3dd9b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #3dd9b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1080px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1112px;
    left: calc((100% - 1112px) * 0.5);
  }
}
@media screen and (max-width: 1112px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}
@media screen and (prefers-color-scheme: dark) and (max-width: 500px) {
  .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
    <script>
      let userColorScheme=localStorage.getItem("color-scheme")
      if(userColorScheme){
        document.documentElement.setAttribute("color-scheme", userColorScheme);
      }
    </script>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>`+
        `<span class="kill-c">微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>了解详情 ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>
        <span class="kill-c">本页面需要浏览器支持（启用）JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = "false"; // 调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    debug: false,
    cdn: {"js":{"app":"/js/app.js","parallax":"/js/plugins/parallax.js","rightMenu":"/js/plugins/rightMenu.js","rightMenus":"/js/plugins/rightMenus.js","sites":"/js/plugins/tags/sites.js","friends":"/js/plugins/tags/friends.js","contributors":"/js/plugins/tags/contributors.js","search":"/js/search/hexo.js"},"css":{"style":"/css/style.css"}},
    default: {"avatar":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg","link":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/link/8f277b4ee0ecd.svg","cover":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg","image":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/image/2659360.svg"},
    lastupdate: new Date(1684466732700),
    sidebar: {
      for_page: ["blogger","category","tagcloud","webinfo","lastupdate","donate"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2021/09/20",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js","icon":{"default":"fa-light fa-info-circle light-blue","quection":"fa-light fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"fa-brands fa-creative-commons light-blue"},"aplayer":{"enable":true,"play":"fa-light fa-play light-blue","pause":"fa-light fa-pause light-blue","error":"fa-light fa-exclamation-square red"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      
      aplayer: {
        id: 5062959861,
        enable:true
      },
      
      
      
      rightmenus: {"enable":true,"order":["plugins.navigation","hr","plugins.inputBox","plugins.seletctText","plugins.elementCheck","plugins.elementImage","hr","menus.darkMode","hr","plugins.articlePage","hr","music"],"options":{"iconPrefix":"fa-duotone PETERRIVE","articleShowLink":true,"musicAlwaysShow":true},"plugins":{"navigation":[{"id":"left","name":"转到上一页","icon":"fa-duotone fa-arrow-left PETERRIVE","event":"history.back()","group":"navigation"},{"id":"right","name":"转到下一页","icon":"fa-duotone fa-arrow-right PETERRIVE","event":"history.forward()","group":"navigation"},{"id":"redo","name":"刷新当前页面","icon":"fa-duotone fa-redo PETERRIVE","event":"window.location.reload()","group":"navigation"},{"id":"home","name":"回到首页","icon":"fa-duotone fa-home PETERRIVE","link":"/","group":"navigation"},{"id":"up","name":"回到顶部","icon":"fa-duotone fa-arrow-up PETERRIVE","event":"VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)","group":"navigation"}],"inputBox":[{"id":"copyPaste","name":"粘贴文本","icon":"fa-duotone PETERRIVE fa-paste","event":"copyPaste","group":"inputBox"},{"id":"copyAll","name":"全选文本","icon":"fa-duotone PETERRIVE fa-object-ungroup","event":"copyAll","group":"inputBox"},{"id":"copyCut","name":"剪切文本","icon":"fa-duotone PETERRIVE fa-cut","event":"copyCut","group":"inputBox"}],"seletctText":[{"id":"copyText","name":"复制文本","icon":"fa-duotone PETERRIVE fa-copy","event":"copyText","group":"seletctText"},{"id":"searchWord","name":"站内搜索","icon":"fa-duotone PETERRIVE fa-search","event":"OpenSearch(__text__)","group":"seletctText"},{"id":"bingSearch","name":"必应搜索","icon":"fa-duotone PETERRIVE fa-search","event":"window.open(`https://cn.bing.com/search?q=${__text__}`)","group":"seletctText"}],"elementCheck":[{"id":"openTab","name":"新标签页打开","icon":"fa-duotone PETERRIVE fa-external-link-square-alt","event":"window.open(__link__)","group":"elementCheck"},{"id":"copyLink","name":"复制链接地址","icon":"fa-duotone PETERRIVE fa-link","event":"copyLink","group":"elementCheck"}],"elementImage":[{"id":"copyImg","name":"复制图片","icon":"fa-duotone PETERRIVE fa-image","event":"copyImg","group":"elementImage"},{"id":"googleImg","name":"谷歌识图","icon":"fa-duotone PETERRIVE fa-images","event":"window.open(`https://www.google.com/searchbyimage?image_url=${__link__}`)","group":"elementImage"}],"articlePage":[{"id":"printMode","name":"打印页面","icon":"fa-duotone fa-print TURQUOISE","event":"printMode","group":"articlePage"},{"id":"readMode","name":"阅读模式","icon":"fa-duotone fa-book-open EMERALD","event":"readMode","group":"articlePage"}]},"menus":{"link":[{"id":"help","name":"常见问题","icon":"fa-solid fa-question","link":"https://volantis.js.org/faqs/","group":"link"},{"id":"examples","name":"示例博客","icon":"fa-solid fa-rss","link":"https://volantis.js.org/examples/","group":"link"},{"id":"contributors","name":"加入社区","icon":"fa-solid fa-fan","link":"https://volantis.js.org/contributors/","group":"link"},"hr",{"id":"source_docs","name":"本站源码","icon":"fa-solid fa-code-branch","link":"https://github.com/volantis-x/volantis-docs/","group":"link"},{"id":"source_theme","name":"主题源码","icon":"fa-solid fa-code-branch","link":"https://github.com/volantis-x/hexo-theme-volantis/","group":"link"}],"darkMode":[{"id":"darkMode","name":"暗黑模式","icon":"fa-duotone fa-eclipse-alt WISTERIA","event":"volantis.dark.toggle()","group":"darkMode"}]}}
      
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = Object.assign(volantis.pjax, {
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  });
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list=[]
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  volantis.scroll.ele = null;
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) => {
    if (!ele) return;
    volantis.scroll.ele = ele;
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(() => {
        if (volantis.scroll.ele != ele) {
          return
        }
        volantis.scroll.unengine.push(() => {
          let me = ele.getBoundingClientRect().top
          if(!(me >= -option.observerDic && me <= option.observerDic)){
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        },"unengineObserver")
      },1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = ()=>{
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e=>{
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
  <!-- front-matter head_end begin -->
  <!-- front-matter head_end end -->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <!-- import body_begin begin-->
    <!-- import body_begin end-->
    <!-- Custom Files bodyBegin begin-->
    
    <!-- Custom Files bodyBegin end-->
    <!-- front-matter body_begin begin -->
    <!-- front-matter body_begin end -->
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto shadow floatable blur " style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            CodingStudio <sup style="color:#ff9800">alpha</sup>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="文档"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-duotone fa-book faa-tada fa-fw'></i>文档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-duotone fa-play-circle faa-tada fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-duotone fa-question-circle faa-tada fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-duotone fa-heart fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="更多"
                  
                  
                  >
                  <i class='fa-duotone fa-ellipsis-v fa-fw'></i>更多
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-solid fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
                    
                      
            
              
                <li>
                  <a class="menuitem flat-box">
                    <i class='fa-solid fa-compact-disc fa-fw music'></i>背景音乐
                  </a>
                  <ul class="list-v">
                    <li>
                      <div class="aplayer-container">
                        

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.4'
      loop='all'
      order='random'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5062959861'
      list-folded='true'>
    </meting-js>
  


                      </div>
                    </li>
                  </ul>
                <li>
              
            
          
                    
                  </ul>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="文档"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-duotone fa-book faa-tada fa-fw'></i>文档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-duotone fa-play-circle faa-tada fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-duotone fa-question-circle faa-tada fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-duotone fa-heart fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="更多"
                  
                  
                  >
                  <i class='fa-duotone fa-ellipsis-v fa-fw'></i>更多
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-solid fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
                    
                      
            
              
            
          
                    
                  </ul>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="half" class='cover-wrapper post search' style="display: ;">
        
  <div id="parallax-window"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">CodingStudio</p>
    
    
      <p class="subtitle">努力进步</p>
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="搜一下" />
          <i class="icon fa-solid fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow floatable blur article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="http://jay1060950003.github.io/2022/03/31/计算机基础知识/C++Primer/">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="CodingStudio">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="CodingStudio">
    <meta itemprop="description" content="自己的创作及学习空间">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title" itemprop="name headline">
        C++Primer
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author' itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a itemprop="url" class='author' target="_blank" href="https://github.com/jay1060950003" rel="nofollow noopener">
    <img itemprop="image" src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/apple-touch-icon.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/apple-touch-icon.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
    <p itemprop="name">jay1060950003</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <i class="fa-solid fa-folder-open fa-fw" aria-hidden="true"></i>
    <a class="category-link" href="/categories/C/">C++</a>
    
      <span hidden itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/C/" itemprop="url"><span itemprop="name">C++</span></a>
      </span>
    
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateCreated datePublished" datetime="2022-03-31T16:52:28+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2022年3月31日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fa-solid fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>字数：104.5k 字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fa-solid fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>时长：392 分钟</p>
    </a>
  </div>


          
        
          
            


<div class="new-meta-item browse">
  <a class='notlink'>
    <p>
      <i class="fa-solid fa-eye fa-fw" aria-hidden="true"></i>
      
      <span id="busuanzi_value_page_pv"><i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i></span>
      
      <span>次浏览</span>
    </p>
  </a>
</div>


          
        
        <!-- Custom Files topMeta begin-->
        
        <!-- Custom Files topMeta end-->
      </div>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<ul>
<li>C++ Primer的学习笔记</li>
</ul>
<span id="more"></span>
<h1 id="1-开始"><a class="markdownIt-Anchor" href="#1-开始"></a> 1 开始</h1>
<div class="story post-story"><h2 id="12-初始输入输出"><a class="markdownIt-Anchor" href="#12-初始输入输出"></a> 1.2 初始输入输出</h2>
<ul>
<li>iostream库为IO库,其中包含两个基本类型istream和ostream,分别表示输入流和输出流
<ul>
<li>一个流就是一个字符序列,是从IO设备读出或写入IO设备的</li>
</ul>
</li>
<li>标准输入输出对象
<ul>
<li>cin标准输入</li>
<li>cout标准输出</li>
<li>cerr输出警告和错误信息,标准错误</li>
<li>clog输出程序运行时的一般性信息</li>
</ul>
</li>
<li>向流中写入数据
<ul>
<li>输出运算符&lt;&lt;
<ul>
<li>接受两个运算对象,左边为ostream对象,右边为要打印的值</li>
<li>std::endl为操纵符：结束当前行,并将与设备关联的缓冲区中的内容刷到设备中
<ul>
<li>缓冲刷新操作可以保证到目前为止程序所产生的所有输出真正写入输出流中,而不是仅停留在内存中等待写入流</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>从流中读取数据
<ul>
<li>输入运算符&gt;&gt;</li>
</ul>
</li>
</ul>
<hr />
<h1 id="2-变量和基本类型"><a class="markdownIt-Anchor" href="#2-变量和基本类型"></a> 2 变量和基本类型</h1>
</div><div class="story post-story"><h2 id="21-基本内置类型"><a class="markdownIt-Anchor" href="#21-基本内置类型"></a> 2.1 基本内置类型</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>布尔类型</td>
<td>未定义</td>
</tr>
<tr>
<td>char</td>
<td>字符</td>
<td>8位</td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符16</td>
<td>位</td>
</tr>
<tr>
<td>char16_t</td>
<td>unicode字符16</td>
<td>位</td>
</tr>
<tr>
<td>char32_t</td>
<td>unicode字符32</td>
<td>位</td>
</tr>
<tr>
<td>short</td>
<td>短整型16</td>
<td>位</td>
</tr>
<tr>
<td>int</td>
<td>整型16</td>
<td>位</td>
</tr>
<tr>
<td>long</td>
<td>长整型32</td>
<td>位</td>
</tr>
<tr>
<td>long long</td>
<td>长整型64</td>
<td>位</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>6位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>10位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>扩展精度浮点数</td>
<td>10位有效数字</td>
</tr>
</tbody>
</table>
<ul>
<li>C++规定,一个int至少和一个short一样大,一个long至少和一个int一样大,一个long long至少和一个long一样大
<ul>
<li><mark>long long在C++11中新定义</mark></li>
<li><mark>一个字节为8bit,一个字32或64bit</mark></li>
</ul>
</li>
<li>带符号类型和无符号类型
<ul>
<li>int,short,long和long long都是带符号的,<mark>在类型名前添加unsigned就可以得到无符号类型</mark></li>
<li>char,signed,unsigned char：char,signed并不一样</li>
</ul>
</li>
<li>类型转换
<ul>
<li><mark>赋给带符号类型一个超出表示范围的值时,结果是<strong>未定</strong>的</mark></li>
<li><mark>切勿混用带符号类型和无符号类型</mark></li>
</ul>
</li>
<li>字面值常量
<ul>
<li>以0开头的整数表示八进制数,以0x开头的整数表示十六进制数</li>
<li>浮点数字面值表现位一个小数或以科学计数法表示的指数,其中指数部分用E标识,默认的浮点型字面值为double</li>
<li><mark>单引号</mark>括起来的单个字符称为<mark>char型字面值</mark>,<mark>双括号</mark>括起来的零个或多个字符则构成<mark>字符串型字面值</mark>
<ul>
<li>字符串字面值实际上是由常量字符构成的数组,在末尾处有’\0’</li>
</ul>
</li>
<li><strong>转义字符</strong>：以反斜线作为开始
<ul>
<li>泛化的转义序列,其形式是\x后紧跟1个或多个十六进制,或者紧跟八进制数字,其中数字部分表示的是字符对应的数值</li>
</ul>
</li>
<li><strong>指定字面值的类型</strong>：添加前缀和后缀可以改变整型、浮点型和字符型字面值的默认类型
<ul>
<li>如果后缀中有U,则该字面值属于无符号类型</li>
<li>如果后缀中有L,则字面值的类型至少是long</li>
<li>如果后缀中有LL,则字面值的类型将是long long和unsigned long long 中的一种</li>
</ul>
</li>
<li><mark>nullptr是指针字面值</mark></li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="22-变量"><a class="markdownIt-Anchor" href="#22-变量"></a> 2.2 变量</h2>
<ul>
<li>C++是一种静态类型语言,其含义是在编译阶段检查类型</li>
<li>何为对象：对象是指一块能存储数据并具有某种类型的内部空间</li>
<li><mark>C++中,初始化和赋值为两个概念</mark>
<ul>
<li>C++11,引入<mark>列表初始化</mark>：<strong>用花括号来初始化变量</strong></li>
</ul>
</li>
<li>默认初始化：内置类型的变量未被显式初始化,值由定义的位置决定,定义于任何函数体之外的变量被初始化为0
<ul>
<li>定义在函数体内部的内部的内置类型变量将不被初始化</li>
<li><mark>一个未被初始化的内置类型变量的值是未被定义的</mark></li>
<li>一些类要求每个对象都显式初始化,如果创建了一个该类的对象而未对其做明确的初始化操作,将引发错误</li>
</ul>
</li>
<li>分离式编译
<ul>
<li>C++将声明和定义区分开,声明使得名字为程序所致,定义负责创建实体
<ul>
<li>变量声明规定了变量的类型和名字,同时申请存储空间</li>
</ul>
</li>
<li>声明变量而不定义,需要在变量名前添加<strong>extern</strong>,而且不要显式初始化变量
<ul>
<li><mark>extern:标示变量或者函数的定义在别的文件中,提示编译器遇到此变量和函数时在其他模块中寻找其定义</mark>
<ul>
<li><mark>在函数体内部,尝试初始化一个由extern关键字标记的变量将会引发错误</mark></li>
</ul>
</li>
</ul>
</li>
<li><mark>任何显式初始化的声明为定义</mark></li>
<li><mark>变量只能被定义一次,但可以声明多次</mark>,变量的定义必须出现在且只能出现在一个文件中,而其他用到该变量的文件必须对其进行声明,却绝对不能重复定义</li>
</ul>
</li>
<li>标识符
<ul>
<li>C++的标识符由字母、数字和下画线组成,其中必须以字母或下画线开头</li>
<li><mark>标识符的长度没有限制,但是对大小写字母敏感</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义变量并初始化</span></span><br><span class="line"><span class="type">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量而不定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;</span><br><span class="line"><span class="comment">// 声明并定义j</span></span><br><span class="line"><span class="type">int</span> j;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="23-复合类型"><a class="markdownIt-Anchor" href="#23-复合类型"></a> 2.3 复合类型</h2>
<h3 id="231-引用"><a class="markdownIt-Anchor" href="#231-引用"></a> 2.3.1 引用</h3>
<ul>
<li>引用为对象起了另一个名字,引用类型引用另外一种类型,通过将声明符携程&amp;d的形式来定义引用类型,其中d是声明的变量名</li>
<li><mark>一般在初始化变量时,初始值会被拷贝到新建的对象中,然而定义引用时,程序会把引用和它的初始值绑定在一起,而不是将初始值拷贝给引用</mark>
<ul>
<li>引用必须初始化(引用无法令引用重新绑定到另外一个对象)</li>
<li>一旦初始化完成,引用将和它的初始值对象一直绑定在一起</li>
<li>定义了一个引用之后,对其进行的所有操作都是在与之绑定的对象上进行的</li>
</ul>
</li>
</ul>
<h3 id="232-指针"><a class="markdownIt-Anchor" href="#232-指针"></a> 2.3.2 指针</h3>
<ul>
<li>与引用类似,指针也实现了对其他对象的间接访问</li>
<li>指针与引用相比又有很多不同点
<ol>
<li>指针本身就是一个对象,允许对指针赋值和拷贝,而且在指针的生命周期内它可以先后指向几个不同的对象</li>
<li>指针无须在定义时赋初值。和其他内置类型一样,在块作用域内定义的指针如果没有被初始化,也将拥有一个不确定的值</li>
</ol>
</li>
<li>定义指针类型的方法将声明写出*d的形式,其中d式变量名
<ul>
<li>在声明语句中指针的类型实际上被用于指定它所指向对象的类型,二者必须匹配。如果指针指向了一个其他类型的对象,对该对象的操作将发生错误</li>
<li><strong>获取对象的地址</strong>,需要使用取地址符&amp;</li>
</ul>
</li>
<li><strong>指针值的4种状态</strong>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针</li>
<li>无效指针
<ul>
<li>试图拷贝或以其他方式访问无效指针的值都将引发错误</li>
</ul>
</li>
</ul>
</li>
<li><strong>指针访问对象</strong>,需要使用解引用符*访问对象
<ul>
<li>对指针解引用会得出所指的对象,若给解引用的结果赋值,实际上也就是给指针所指的对象赋值</li>
<li><mark>解引用操作只适用于指向了某个对象的有效指针</mark></li>
</ul>
</li>
<li>空指针
<ul>
<li>C++11引入的新方法,使用nullptr初始化指针</li>
<li>nullptr是一种特殊类型的字面值,可以转换成任意其他类型的指针类型</li>
<li><mark>NULL的预处理变量来给指针赋值,其值为0,定义在cstdlib中</mark></li>
</ul>
</li>
<li>赋值和指针
<ul>
<li>指针和引用都能提供对其他对象的间接访问,<strong>在具体实现细节上二者有很大不同</strong>,其中最重要的一点就是<strong>引用本身并非一个对象</strong>
<ul>
<li><strong>一旦定义了引用,就无法令其再绑定到另外的对象,之后每次使用这个引用都是访问它最初绑定的那个对象</strong></li>
</ul>
</li>
<li><strong>指针和它存放的地址之间就没有这种限制了</strong>。和其他任何变量(只要不是引用)一样,给指针赋值就是令它存放一个新的地址,从而指向一个新的对象</li>
</ul>
</li>
<li>任何非0指针对应的条件值都是true</li>
<li>void* 指针
<ul>
<li>特殊的指针类型,可以存放任意对象的地址</li>
<li>利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出,或者赋给另外一个void*指针
<ul>
<li><mark>不能直接操作void*指针所指的对象</mark></li>
</ul>
</li>
<li><mark>以void*的视角来看内存空间也就仅仅是内存空间,没办法访问内存空间中所存的对象</mark></li>
</ul>
</li>
</ul>
<h3 id="233-理解复合类型"><a class="markdownIt-Anchor" href="#233-理解复合类型"></a> 2.3.3 理解复合类型</h3>
<ul>
<li>定义包括一个基本数据类型和<mark>一组声明符</mark></li>
<li><mark>定义多个变量时,基本数据类型是基本数据类型而非基本类型*,*仅仅是修饰了变量名而已</mark>
<ul>
<li><strong>将*或&amp;与变量名连在一起</strong></li>
</ul>
</li>
<li>指向指针的指针
<ul>
<li>**表示指向指针的指针</li>
<li>解引用指向指针的指针会得到一个指针</li>
<li>两次解引用指向指针的指针会得到最原始的对象</li>
</ul>
</li>
<li><strong>指向指针的引用</strong>
<ul>
<li>引用本身不是一个对象,不能定义指向引用的指针,<mark>但指针是对象,所以存在对指针的引用</mark></li>
<li>*&amp;r,理解时最简单的办法是<strong>从右向左阅读r</strong>的定义;离变量名最近的符号(此例中是&amp;r的符号&amp;)对变量的类型有最直接的影响,因此r是一个引用;声明符的其余部分用以确定r引用的类型是什么,此例中的符号*说明r引用的是一个指针;声明的基本数据类型部分指出r引用的是一个int指针</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;  <span class="comment">//定义指向int型对象的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival;     <span class="comment">//p存放ival的地址,p式指向变量ival的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p1,p2;     <span class="comment">//p1为一个指向int的指针,p2为int类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **pp = &amp;p;    <span class="comment">//pp1表示指向一个int指针的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p;    <span class="comment">//r是对指针p的引用</span></span><br><span class="line"></span><br><span class="line">r = &amp;i; <span class="comment">//r引用了一个指针,因此给r赋值&amp;i就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">//解引用r得到i,也就是p指向的对象,将i的值改为0</span></span><br><span class="line"><span class="comment">//要理解r的类型到底是什么,最简单的办法是从右向左阅读r的定义</span></span><br><span class="line"><span class="comment">//离变量名最近的符号(此例中是&amp;r的符号&amp;)对变量的类型有最直接的影响,因此r是一个引用</span></span><br><span class="line"><span class="comment">//声明符的其余部分用以确定r引用的类型是什么,此例中的符号＊说明r引用的是一个指针</span></span><br><span class="line"><span class="comment">//最后,声明的基本数据类型部分指出r引用的是一个int指针</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="24-const限定符"><a class="markdownIt-Anchor" href="#24-const限定符"></a> 2.4 const限定符</h2>
<ul>
<li>const限定符对变量的类型加以限制可以防止程序改变变量的值</li>
<li>const变量一旦创建其值就不能再改变,故const变量必须初始化</li>
<li>默认状态下,const对象仅在文件内有效
<ul>
<li>编译器在编译过程中将变量全部替换成对应的值</li>
<li><mark>当多个文件中出现了同名的const变量时,在不同文件中分别定义了独立的变量</mark></li>
<li>文件共享const变量时,<mark>对const变量的声明和定义都添加extern关键字</mark></li>
</ul>
</li>
</ul>
<h3 id="241-const引用常量引用"><a class="markdownIt-Anchor" href="#241-const引用常量引用"></a> 2.4.1 const引用(常量引用)</h3>
<ul>
<li>将引用绑定在const对象上,是对常量的引用
<ul>
<li>const引用与普通引用的不同：<mark>对常量的引用不能被用于修改它绑定的对象</mark></li>
</ul>
</li>
<li><mark>引用的类型必须与其所引用对象的类型一致</mark>
<ul>
<li><mark>在初始化常量引用时允许用任意表达式作为初始值,只要其结果可以转换成引用的类型即可</mark></li>
</ul>
</li>
<li>常量引用一个非const的对象：不允许通过常量引用修改对象的值</li>
</ul>
<h3 id="242-const和指针"><a class="markdownIt-Anchor" href="#242-const和指针"></a> 2.4.2 const和指针</h3>
<ul>
<li><strong>const指针(常量指针)</strong>：指向常量的指针,不可以修改其所指向对象的值
<ul>
<li><strong>常量指针</strong>为<strong>底层指针</strong>,表示指针指向的是常量</li>
<li><mark>常量只可以使用指向常量的指针存放常量的地址</mark></li>
<li><mark>常量指针可以指向其他对象,但不可以通过常量指针修改对象的值</mark></li>
<li>常量指针必须初始化,一旦初始化完成,指针不可以改变</li>
</ul>
</li>
<li><strong>指针常量</strong>：把*放在const关键字之前说明指针是一个常量,即不变的是指针本身的值而非指向的那个值
<ul>
<li><strong>指针常量</strong>为<strong>顶层const</strong>,指针本身就是常量</li>
<li><mark>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值</mark>,能否这样做完全依赖于所指对象的类型</li>
</ul>
</li>
<li><mark>注意区别指针常量和常量指针</mark></li>
</ul>
<h3 id="243-顶层const和底层const"><a class="markdownIt-Anchor" href="#243-顶层const和底层const"></a> 2.4.3 顶层const和底层const</h3>
<ul>
<li><strong>顶层const表示任意的对象是常量</strong></li>
<li><strong>底层const表示指向常量</strong></li>
<li>顶层const拷贝时,顶层const不受影响</li>
<li>底层const拷贝时
<ul>
<li><mark>拷入和拷出时的对象必须具有相同的底层const</mark>
<ul>
<li>或两个对象的数据类型必须可以转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="244-constexpr和常量表达式"><a class="markdownIt-Anchor" href="#244-constexpr和常量表达式"></a> 2.4.4 constexpr和常量表达式</h3>
<ul>
<li>常量表达式是指指不会改变并且在编译过程中就可以得到计算结果的表达式</li>
<li><mark>C++11中,允许变量声明为constexpr类型,以便编译器验证变量的值是否是常量表达式</mark>
<ul>
<li>新标准允许定义一种特殊的constexpr函数(以使得编译时就可以计算其结果,可以用constexpr函数去初始化constexpr变量)</li>
</ul>
</li>
<li><mark>声明为constexpr的变量一定是一个常量,而且必须用常量表达式初始化</mark></li>
<li>指针和引用定义成constexpr,constexpr指针初始化值必须是nullptr或0</li>
<li>指针和constexpr</li>
<li>在constexpr声明中定义了一个指针,限定符constexpr仅对指针有效,与指针所指的对象无关</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;  <span class="comment">//常量引用,但不可以通过其改变i的值</span></span><br><span class="line"></span><br><span class="line">r1 = <span class="number">0</span>;</span><br><span class="line">r2 = <span class="number">0</span>;     <span class="comment">//错误;r2为常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi;    <span class="comment">//ptr为普通指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;   <span class="comment">//指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> cptr = &amp;pi;   <span class="comment">//cptr是一个指向常量对象的常量指针</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptri = &amp;i;   <span class="comment">//ptri是一个指向int的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;   <span class="comment">//顶层const,不可以改变p1的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;    <span class="comment">//顶层const,不可以改变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;  <span class="comment">//底层const,可以改变p2的值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2;   <span class="comment">//左边的底层const,右边的顶层const</span></span><br><span class="line">i = ci;     </span><br><span class="line">p2 = p3;      <span class="comment">//p2,p3所指向的对象类型相同,p3顶层const部分不影响</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = p3;    <span class="comment">//错误,p不包含底层const含义</span></span><br><span class="line">p2 = p3;      <span class="comment">//正确</span></span><br><span class="line">p2 = &amp;i;      <span class="comment">//正确,int*可以转换成const int*</span></span><br><span class="line"><span class="type">int</span> &amp;r = ci;    <span class="comment">//错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;  <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//p3既是顶层const也是底层const</span></span><br><span class="line"><span class="comment">//拷贝p3时可以不在乎它是一个顶层const,但是必须清楚它指向的对象得是一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;   <span class="comment">// 为一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>;   <span class="comment">//  为一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="25-处理类型"><a class="markdownIt-Anchor" href="#25-处理类型"></a> 2.5 处理类型</h2>
<h3 id="251-类型别名"><a class="markdownIt-Anchor" href="#251-类型别名"></a> 2.5.1 类型别名</h3>
<ul>
<li>类型别名是一个名字,是某种类型的同义词</li>
<li>传统方法：使用typedef</li>
<li>C++11中使用<strong>别名声明</strong>,这种方法用关键字using作为别名声明的开始,其后紧跟着别名和等号,其作用是把等号左侧的名字规定成等号右侧类型的别名
<ul>
<li>类型别名和类型的名字等价</li>
</ul>
</li>
<li>指针,常量和类型别名
<ul>
<li><mark>在使用类型别名的声明语句时,不可以将别名替换成原来的样子</mark>,应将声明部分看成一个整体</li>
</ul>
</li>
</ul>
<h3 id="252-auto类型说明符"><a class="markdownIt-Anchor" href="#252-auto类型说明符"></a> 2.5.2 auto类型说明符</h3>
<ul>
<li>在C++11中,引入<strong>auto修饰符</strong>,可以让编译器分析表达式所属的类型,推算变量的类型</li>
<li>auto定义的变量必须给初始值
<ul>
<li>==当引用被用作初始值时,真正参与初始化的其实时引用对象的值</li>
<li>auto一般会忽略顶层const,保留底层const,需要顶层const时需要明确指出</li>
<li>==设置一个类型为auto的引用,初始化中的顶层const属性会保留</li>
</ul>
</li>
<li>==一条语句中定义多个变量,&amp;,*只从属于某个声明符,而非基本数据类型的一部分</li>
</ul>
<h3 id="253-decltype类型指示符"><a class="markdownIt-Anchor" href="#253-decltype类型指示符"></a> 2.5.3 decltype类型指示符</h3>
<ul>
<li><strong>C++11引入的第二种类型说明符</strong>,选择并返回操作数的数据类型</li>
<li>decltype处理顶层const和引用的方式与auto不同,若decltype使用的表达式是一个变量,则返回该变量的类型(包括顶层const和引用在内)
<ul>
<li><strong>引用从来都是作为其所指对象的同义词出现,但在decltype中例外</strong></li>
<li>如果decltype使用的表达式不是一个变量,则decltype返回表达式结果对应的类型</li>
<li>如果表达式内同是解引用操作,则decltype将得到引用类型</li>
<li><mark>如果decltype使用的是一个不加括号的变量,则得到的结果就是该变量的类型</mark></li>
<li><mark>如果给变量加上了一层或多层括号,编译器就会把它当成是一个表达式,得到引用类型(变量是一种可以作为赋值语句左值的特殊表达式)</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>;   <span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> pstring *ps;  <span class="comment">//ps是一个指针,其对象是指向char的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">//a为int类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;  <span class="comment">//b整型(ci的顶层const属性被忽略)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;  <span class="comment">//c整型</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;</span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;   <span class="comment">//指向整型常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = c; <span class="comment">//  const int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;g = <span class="number">42</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>; <span class="comment">//正确,可以为常量引用绑定字面值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;  <span class="comment">//sum的类型就是函数f的返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>,*p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;  <span class="comment">//  int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;   <span class="comment">//错误,c时int&amp;,必须初始化</span></span><br><span class="line"><span class="comment">// r是一个引用,因此结果为引用类型</span></span><br><span class="line"><span class="comment">// 但向让结果类型r是所指向的类型,需要使用表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>((i)) d;  <span class="comment">//d,int&amp;必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;  <span class="comment">//int</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="26-自定义数据结构"><a class="markdownIt-Anchor" href="#26-自定义数据结构"></a> 2.6 自定义数据结构</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体的定义</span></span><br><span class="line">Struct 结构体名&#123;</span><br><span class="line">  成员变量;</span><br><span class="line">  成员函数;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件保护符</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 头文件</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 头文件内容</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="3-字符串向量和数组"><a class="markdownIt-Anchor" href="#3-字符串向量和数组"></a> 3 字符串,向量和数组</h1>
</div><div class="story post-story"><h2 id="31-命名空间的using声明"><a class="markdownIt-Anchor" href="#31-命名空间的using声明"></a> 3.1 命名空间的using声明</h2>
<ul>
<li>using声明可以使用命名空间中的成员
<ul>
<li>每个名字都需要独立的using声明</li>
<li>头文件不应包含using声明</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using声明</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="32-标准库类型string"><a class="markdownIt-Anchor" href="#32-标准库类型string"></a> 3.2 标准库类型string</h2>
<ul>
<li>标准库类型<strong>string</strong>表示可变长字符序列,包含在string头文件中</li>
<li>定义和初始化string对象</li>
<li>使用=初始化变量,执行拷贝初始化,不使用=进行直接初始化</li>
<li>string操作的注意事项
<ul>
<li>getline函数的参数是一个输入流和一个string对象,函数从给定的输入流中读入内容,直到遇到换行符为止(注意换行符也被读进来了)
<ul>
<li>&gt;&gt;不会保留输入时的空白符,遇空白符停止</li>
</ul>
</li>
<li>string::size_type类型
<ul>
<li>所有用于存放string类的size函数返回值的变量,都是string::size_type类型的</li>
<li><mark>在C++11中,允许编译器通过auto或者decltype来推断变量的类型</mark>
<ul>
<li>避免因为符号数和无符号数产生意外的结果</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>C++11引入<strong>范围for</strong>语句
<ul>
<li>遍历给定序列中的每个元素并对序列中的每个值执行某种操作</li>
<li>for(declaration:expression)</li>
<li>expression部分是一个对象,用于表示一个序列;declaration部分负责定义一个变量,该变量将被用于访问序列中的基础元素;每次迭代,declaration部分的变量会被初始化为expression部分的下一个元素值
<ul>
<li>auto c可作为declaration部分</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>string的操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>os&lt;&lt;s</td>
<td>将s写出到输出流os中,返回os</td>
</tr>
<tr>
<td>is&gt;&gt;s</td>
<td>从is中读取字符串赋给s,字符串以空白分隔,返回is</td>
</tr>
<tr>
<td>getline(is,s)</td>
<td>从is中读取一行赋给s,返回is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s为空返回true</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回s中字符的个数</td>
</tr>
<tr>
<td>s[n]</td>
<td>返回s中第n个字符的引用</td>
</tr>
<tr>
<td>s1+s2</td>
<td>返回s1,s2连接后的结果</td>
</tr>
<tr>
<td>s1=s2</td>
<td>s2的副本替换s1中原来的字符</td>
</tr>
<tr>
<td>s1==s2</td>
<td>完全一样,则相等</td>
</tr>
<tr>
<td>&lt;,&lt;=,&gt;,&gt;=</td>
<td>对字典序进行比较</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>cctype头文件中的标准库函数操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>isalnum©</td>
<td>当c为字母或数字时为真</td>
</tr>
<tr>
<td>isalpha©</td>
<td>当c为字母时为真</td>
</tr>
<tr>
<td>iscntrl©</td>
<td>当c为控制字符时为真</td>
</tr>
<tr>
<td>isdigit©</td>
<td>当c为数字时为真</td>
</tr>
<tr>
<td>isgraph©</td>
<td>当c不是空格但可打印时为真</td>
</tr>
<tr>
<td>islower©</td>
<td>当c是小写字母时为真</td>
</tr>
<tr>
<td>isprint©</td>
<td>当c是可打印字符时为真(c为空格或具有可视形式)</td>
</tr>
<tr>
<td>ispunct©</td>
<td>当c是标点符号时为真</td>
</tr>
<tr>
<td>isspace©</td>
<td>当c是空白时为真</td>
</tr>
<tr>
<td>issupper©</td>
<td>当c是大写字母时为真</td>
</tr>
<tr>
<td>isxdigit©</td>
<td>当c是十六进制数字时为真</td>
</tr>
<tr>
<td>tolower©</td>
<td>输出小写字母</td>
</tr>
<tr>
<td>toupper©</td>
<td>输出大写字母</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line">string s1;    <span class="comment">//默认初始化</span></span><br><span class="line">string s2 = s1; <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;  <span class="comment">// 拷贝初始化</span></span><br><span class="line">string s3 = <span class="string">&quot;hiya&quot;</span>;   <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;hiya&quot;</span>)</span></span>;   <span class="comment">//直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>;    <span class="comment">//cccccccccc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写string对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  string s;</span><br><span class="line">  cin&gt;&gt;s;</span><br><span class="line">  cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写数量未知的string</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  string word;</span><br><span class="line">  <span class="keyword">while</span>(cin&gt;&gt;word)</span><br><span class="line">    cout&lt;&lt;word&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// auto推断</span></span><br><span class="line"><span class="keyword">auto</span> len = line.<span class="built_in">size</span>(); <span class="comment">//len string::size_type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围for</span></span><br><span class="line"><span class="keyword">for</span>(declaration:expression)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="33-标准库类型vector"><a class="markdownIt-Anchor" href="#33-标准库类型vector"></a> 3.3 标准库类型vector</h2>
<ul>
<li>标准库类型vector表示<strong>对象的集合</strong>,其中所有对象的类型都相同,常被称为容器
<ul>
<li>集合中每个对象都有一个与之对应的索引,索引用于访问对象</li>
<li>vector属于类模板
<ul>
<li>编译器根据模板创建类或函数的过程称为实例化,<strong>在模板名后跟着一对尖括号,在括号内放上信息,即可创建模板实例类</strong></li>
</ul>
</li>
<li><mark>vector能容纳绝大多数类型的对象作为其元素,但引用不属于对象,不存在包含引用的vector</mark></li>
</ul>
</li>
<li>定义和初始化vector对象
<ul>
<li>定义一个空vector,然后当运行时获取到元素的值后再逐一添加(在程序运行时高效地往vector对象中添加元素)</li>
<li>在定义对象时指定元素的初始值</li>
<li>C++11中可以使用列表初始化,用花括号括起来的元素值赋值给vector对象</li>
<li><mark>用圆括号初始化指定的一般为数量,用花括号初始化的为初始化列表</mark></li>
</ul>
</li>
<li>向vector对象中添加元素
<ul>
<li>使用<strong>push_back</strong>向vector对象添加元素,将值作为尾元素压入vector中
<ul>
<li><mark>vector对象(以及string对象)的下标运算符可用于访问已存在的元素,而不能用于添加元素</mark></li>
<li>添加元素后再分配内存空间,声明定义只是开辟内存头</li>
</ul>
</li>
<li><mark>vector对象可以高效地增长,可以快速添加元素</mark></li>
<li><mark>如果循环体内部包含有向vector对象添加元素的语句,则不能使用范围for循环</mark></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>定义vector对象的方法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector&lt;T&gt; v1</td>
<td>v1是一个空vector,建在元素是T类型</td>
</tr>
<tr>
<td>vector&lt;T&gt; v2(v1)</td>
<td>v2中包含有v1所有元素的副本</td>
</tr>
<tr>
<td>vector&lt;T&gt; v2=v1</td>
<td>v2中包含有v1所有元素的副本</td>
</tr>
<tr>
<td>vector&lt;T&gt; v3(n,val)</td>
<td>v3中包含n个val</td>
</tr>
<tr>
<td>vector&lt;T&gt; v4(n)</td>
<td>v4中包含n个重复地执行力值初始化的对象</td>
</tr>
<tr>
<td>vector&lt;T&gt; v5{a,b,c…}</td>
<td>v5中包含初始化个数的元素,每个元素被赋予相同的初始值</td>
</tr>
<tr>
<td>vector&lt;T&gt; v5={a,b,c…}</td>
<td>v5中包含初始化个数的元素,每个元素被赋予相同的初始值</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>vector对象地其他操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>v.empty()</td>
<td>v为空返回true</td>
</tr>
<tr>
<td>v.size()</td>
<td>返回v中字符的个数</td>
</tr>
<tr>
<td>v.push_back()</td>
<td>向v中添加元素</td>
</tr>
<tr>
<td>v[n]</td>
<td>返回v中第n个字符的引用</td>
</tr>
<tr>
<td>v1=v2</td>
<td>v2的副本替换v1中原来的字符</td>
</tr>
<tr>
<td>v1={a,b,c…}</td>
<td>拷贝替换</td>
</tr>
<tr>
<td>v1==v2</td>
<td>完全一样,则相等</td>
</tr>
<tr>
<td>&lt;,&lt;=,&gt;,&gt;=</td>
<td>对字典序进行比较</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">usind std::vector;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">ivec.<span class="built_in">push_back</span>(<span class="number">1</span>);  <span class="comment">//向ivec中添加元素</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="34-迭代器介绍"><a class="markdownIt-Anchor" href="#34-迭代器介绍"></a> 3.4 迭代器介绍</h2>
<ul>
<li>标准库容器可以使用<strong>迭代器</strong>,迭代器类似指针类型,提供了对对象的间接访问
<ul>
<li>使用迭代器可以访问某个元素,迭代器也能从一个元素移动到另一个元素;有效的迭代器指向某个元素或容器尾元素的下一个位置</li>
</ul>
</li>
<li>使用迭代器
<ul>
<li><strong>有迭代器的类型同时拥有返回迭代器的成员,这些类型拥有begin和end成员</strong>
<ul>
<li>begin成员负责指向第一个元素的迭代器</li>
<li>end成员负责指向尾元素的下一个位置,指示的是容器一个不存在的尾后元素,迭代器称为<strong>尾后迭代器</strong></li>
<li>由编译器决定迭代器的类型,一般使用<strong>auto关键字定义变量</strong></li>
<li>若容器为空,begin和end返回的是一个迭代器,都是尾后迭代器</li>
</ul>
</li>
<li>和指针类似,可通过解引用迭代器来获取它所指示的元素</li>
</ul>
</li>
<li><strong>begin和end返回的具体类型由对象是否是常量决定</strong>
<ul>
<li>如果对象是常量,begin和end返回const_iterator</li>
<li>如果对象不是常量,返回iterator</li>
</ul>
</li>
<li>拥有迭代器的标准库类型<strong>使用iterator和const_iterator来表示迭代器类型</strong>
<ul>
<li><mark>const_iterator为常量,可以读取但不能修改它所指向的元素值</mark>
<ul>
<li><mark>C++11中引入cbegin和cend获得const_iterator</mark></li>
</ul>
</li>
</ul>
</li>
<li>C++语言定义了箭头运算符-&gt;, <strong>箭头运算符把解引用和成员访问两个操作结合在一起</strong>,it-&gt;mem等价于(*it).mem</li>
</ul>
<table>
<thead>
<tr>
<th>迭代器运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>返回迭代器iter所指元素</td>
</tr>
<tr>
<td>iter-&gt;mem</td>
<td>解引用iter并获取该元素的名为mem的成员,等价于(*iter).mem</td>
</tr>
<tr>
<td>++iter</td>
<td>指示容器的下一个元素</td>
</tr>
<tr>
<td>–iter</td>
<td>指示容器的上一个元素</td>
</tr>
<tr>
<td>iter1 == iter2</td>
<td>判断两个迭代器是否相等</td>
</tr>
<tr>
<td>iter1 != iter2</td>
<td>判断两个迭代器是否相等</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>迭代器支持的运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter+n</td>
<td>迭代器向前移动n个元素</td>
</tr>
<tr>
<td>iter-n</td>
<td>迭代器向后移动n个元素</td>
</tr>
<tr>
<td>iter+=n</td>
<td>复合赋值语句</td>
</tr>
<tr>
<td>iter-=n</td>
<td>复合赋值语句</td>
</tr>
<tr>
<td>iter1-iter2</td>
<td>计算两个迭代器之间的距离</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(),e=v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it; <span class="comment">//it可以读写vector&lt;int&gt;的元素</span></span><br><span class="line">string::iterator it; <span class="comment">//it可以读写String的元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it; <span class="comment">//it可以读vector&lt;int&gt;的元素,但不可以写</span></span><br><span class="line">string::const_iterator it; <span class="comment">//it可以读String的元素</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="35-数组"><a class="markdownIt-Anchor" href="#35-数组"></a> 3.5 数组</h2>
<ul>
<li>数组与vector的区别
<ul>
<li>与vector相似的地方是,数组也是存放类型相同的对象的容器,这些对象本身没有名字,需要通过其所在位置访问</li>
<li>与vector不同的地方是,数组的大小确定不变,不能随意向数组中增加元素</li>
</ul>
</li>
<li>定义和初始化数组
<ul>
<li>数组为复合类型,默认情况下,数组的元素被默认初始化</li>
<li><mark>定义数组的时候必须指定数组的类型,不允许用auto关键字由初始值的列表推断类型</mark></li>
<li><strong>数组的元素应为对象,不存在引用的数组</strong></li>
<li>不能将数组的内容拷贝给其他数组作为其初始值,也不能用数组为其他数组赋值</li>
</ul>
</li>
<li>访问数组元素
<ul>
<li>可使用范围for语句</li>
<li>使用数组下标时,通常定义为<strong>size_t类型</strong>,该类型<strong>在cstddef头文件</strong>中,是一种机器相关的无符号类型</li>
</ul>
</li>
<li><mark>复杂的数组声明</mark>
<ul>
<li><strong>指针数组</strong>：存放指针的数组</li>
<li><strong>数组指针</strong>：数组的指针及数组的引用</li>
<li><mark>要想理解数组声明的含义,最好的办法是从数组的名字开始按照由内向外的顺序阅读</mark></li>
</ul>
</li>
<li><mark>复合类型的理解规则：从右到左,从内到外</mark></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> cnt = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> sz = <span class="number">42</span>;   <span class="comment">//常量表达式</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *parr[sz];  <span class="comment">//含有42个整型指针的数组</span></span><br><span class="line">string bad[cnt];  <span class="comment">//cnt不是常量表达式,错误</span></span><br><span class="line">string strs[<span class="built_in">get_size</span>()];    <span class="comment">//get_size()为常量表达式时正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ial[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;  <span class="comment">//a3[] = &#123;1,2,3,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;;  <span class="comment">//列表初始化,没有空字符</span></span><br><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;  <span class="comment">//列表初始化,含有显式空字符</span></span><br><span class="line"><span class="type">char</span> a1[] = <span class="string">&quot;C++&quot;</span>;  <span class="comment">//列表初始化,含有隐式空字符,表示字符串结束的空字符 size(a1)=4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];    <span class="comment">//ptrs是含有10个整型指针的数组,指针数组</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = $arr; <span class="comment">//Parry指向一个含有10个整数的数组,数组指针</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr; <span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *(&amp;arrRef)[<span class="number">10</span>] = ptrs;  <span class="comment">//arrRef是一个引用,引用一个指针数组,该数组包含10个指针</span></span><br></pre></td></tr></table></figure>
<h3 id="353-指针和数组"><a class="markdownIt-Anchor" href="#353-指针和数组"></a> 3.5.3 指针和数组</h3>
<ul>
<li>使用数组时编译器一般会将数组转换为指针</li>
<li>对数组使用下标运算符得到该数组指定位置的元素
<ul>
<li>对数组元素使用取地址符能得到指向该元素的指针</li>
<li><mark>数组名为一个指向数组首地址的指针</mark></li>
<li><mark>当使用数组作为一个auto变量的初始值时,推断得到的类型是指针而非数组</mark>
<ul>
<li><mark>使用decltype关键字时不会发生转换</mark></li>
</ul>
</li>
</ul>
</li>
<li><strong>指针作为迭代器</strong>
<ul>
<li>若得到尾后指针,使用时容易出错</li>
<li><mark>C++11新标准引入了两个名为begin和end的函数</mark>,可得到指向元素的首指针和尾元素下一个位置的指针,<strong>定义在iterator头文件中</strong></li>
<li>指针可执行所有迭代器运算,包括解引用、递增、比较、与整数相加、两个指针相减等,用在指针和用在迭代器上意义完全一致</li>
<li><strong>两指针相减时</strong>,得到<strong>ptrdiff_t</strong>的标准库类型,与size_t一样,是一种定义在cstddef头文件中的机器相关的类型
<ul>
<li>因为差值可能为负值,所以ptrdiff_t是一种带符号类型</li>
</ul>
</li>
<li><strong>两个指针指向同一个数组的元素,或者指向该数组的尾元素的下一位置,可利用关系运算符进行比较</strong>,否则不可以比较</li>
<li>对数组执行下标运算其实是对指向数组元素的指针执行下标运算
<ul>
<li>只要指针指向的是数组中的元素(或者数组中尾元素的下一位置),都可以执行下标运算</li>
<li><mark>标准库类型限定使用的下标必须是无符号类型,而内置的下标运算可以是有符号类型</mark></li>
<li><mark>内置的下标运算符可以处理负值,结果地址必须指向原来的指针所指同一数组中的元素</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string nums = &#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line">string *p = &amp;nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">string *p2 = nums;  <span class="comment">//等价于*p2=&amp;num[0]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>; <span class="comment">//ia2为一个整型指针,指向ia的第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//ia3为一个整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = &amp;ia[<span class="number">2</span>];    <span class="comment">//p指向索引为2的元素</span></span><br><span class="line"><span class="type">int</span> j = p[<span class="number">1</span>];       <span class="comment">//相当于*(p+1),ia[3]</span></span><br><span class="line"><span class="type">int</span> k = p[<span class="number">-2</span>];      <span class="comment">//p[-2]是ia[0]表示的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="354-c风格字符串"><a class="markdownIt-Anchor" href="#354-c风格字符串"></a> 3.5.4 C风格字符串</h3>
<ul>
<li>C风格的字符串为char数组,并以空字符(‘\0’)结束
<ul>
<li>一般利用指针来操作这些字符串</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>cstring头文件中,C风格字符串的函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>strlen(p)</td>
<td>返回p的长度,空字符不计算在内</td>
</tr>
<tr>
<td>strcmp(p1,p2)</td>
<td>比较相等性,&lt;返回正值</td>
</tr>
<tr>
<td>strcat(p1,p2)</td>
<td>p2附加在p1后,返回p1</td>
</tr>
<tr>
<td>strcpy(p1,p2)</td>
<td>p2拷贝给p1,返回p1</td>
</tr>
</tbody>
</table>
<h3 id="355-与旧代码的接口"><a class="markdownIt-Anchor" href="#355-与旧代码的接口"></a> 3.5.5 与旧代码的接口</h3>
<ul>
<li>string的c_str成员函数：将string转换为c风格的字符串
<ul>
<li>函数的返回结果是一个指针,该指针指向一个以空字符结束的字符数组,而这个数组所存的数据恰好与那个string对象的一样</li>
<li>指针的类型是const char*,从而确保我们不会改变字符数组的内容</li>
</ul>
</li>
<li>不允许使用一个数组为另一个内置类型的数组赋初值,也不允许使用vector对象初始化数组
<ul>
<li>允许使用数组来初始化vector对象</li>
<li>需指明要拷贝区域的首元素地址和尾后地址</li>
</ul>
</li>
<li><mark>尽量使用标准库类型而非数组</mark></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr),end(int_arr))</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(int_arr+<span class="number">1</span>,int_arr+<span class="number">4</span>)</span></span>;    <span class="comment">//拷贝3个元素,int_arr[1]~[3]</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="36-多维数组"><a class="markdownIt-Anchor" href="#36-多维数组"></a> 3.6 多维数组</h2>
<ul>
<li>多维数组初始化时,使用花括号进行初始化,可嵌套使用花括号</li>
<li>可使用范围for语句处理多维数组
<ul>
<li><mark>使用范围for语句处理多维数组,除了最内层的循环外,其他所有循环的控制变量都应该是引用类型</mark></li>
<li><mark>定义多维数组的指针时,多维数组其实是数组的数组</mark></li>
<li>使用auto或者decltype能尽可能地避免在数组前面加上一个指针类型</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出is中的每个元素的值,ia为二维数组,每个内层数组各占一行ia[3][4]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = ia;p!=ia+<span class="number">3</span>;++p)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> q = *p;q!=*p+<span class="number">4</span>;++q)</span><br><span class="line">    cout&lt;&lt;*q&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-表达式"><a class="markdownIt-Anchor" href="#4-表达式"></a> 4 表达式</h1>
</div><div class="story post-story"><h2 id="41-基础"><a class="markdownIt-Anchor" href="#41-基础"></a> 4.1 基础</h2>
<ul>
<li>重载运算符：当运算符作用与类类型的运算对象时,可以自定其含义
<ul>
<li>定义重载运算符时,其包括的运算对象的类型和返回值的类型都是由运算符定义的;但运算对象的个数,运算符的有限集和结合律都是无法改变的</li>
</ul>
</li>
<li><mark>左值和右值</mark>
<ul>
<li>左值可以位于赋值语句的左侧,右值则不能</li>
<li>当一个对象被用作右值的时候,用的是对象的值(内容)
<ul>
<li>当对象被用作左值的时候,用的是对象的身份(在内存中的位置)</li>
</ul>
</li>
<li><mark>在需要右值的地方可以用左值来代替,但是不能把右值当成左值(也就是位置)使用</mark>
<ul>
<li>当一个左值被当成右值使用时,实际使用的是它的内容(值)</li>
</ul>
</li>
<li>使用关键字decltype时,左值和右值也有所不同
<ul>
<li>如果表达式的求值结果是左值,decltype作用于该表达式得到一个引用类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="42-算数运算符"><a class="markdownIt-Anchor" href="#42-算数运算符"></a> 4.2 算数运算符</h2>
<ul>
<li>算数运算符包括
<ul>
<li>+ 加</li>
<li>- 减</li>
<li>* 乘</li>
<li>/ 除</li>
<li>% 取余</li>
</ul>
</li>
<li><mark>C++11中,规定商一律向0取整(即直接切除小数部分)</mark></li>
</ul>
</div><div class="story post-story"><h2 id="43-逻辑和关系运算符"><a class="markdownIt-Anchor" href="#43-逻辑和关系运算符"></a> 4.3 逻辑和关系运算符</h2>
<ul>
<li>
<p>逻辑和关系运算符包括</p>
<ul>
<li>逻辑非 !</li>
<li>小于 &lt;</li>
<li>大于 &gt;</li>
<li>小于等于 &lt;=</li>
<li>大于等于 &gt;=</li>
<li>相等 ==</li>
<li>不相等 !=</li>
<li>逻辑与 &amp;&amp;</li>
<li>逻辑或 ||</li>
</ul>
</li>
<li>
<p><strong>短路求值</strong>:逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值,当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值</p>
<ul>
<li>对于逻辑与运算符来说,当且仅当左侧运算对象为真时才对右侧运算对象求值</li>
<li>对于逻辑或运算符来说,当且仅当左侧运算对象为假时才对右侧运算对象求值</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="44-赋值运算符"><a class="markdownIt-Anchor" href="#44-赋值运算符"></a> 4.4 赋值运算符</h2>
<ul>
<li>赋值运算符的左侧运算对象必须是一个<strong>可修改的左值</strong></li>
<li>C++11允许使用花括号括起来的初始值列表<a href="#22-%E5%8F%98%E9%87%8F">跳转至列表初始化</a>作为赋值语句的右侧运算对象</li>
<li><mark>赋值运算符的优先级低于关系运算符的优先级</mark></li>
</ul>
</div><div class="story post-story"><h2 id="45-递增和递减运算符"><a class="markdownIt-Anchor" href="#45-递增和递减运算符"></a> 4.5 递增和递减运算符</h2>
<ul>
<li>前置版本++v
<ul>
<li>首先将运算对象加1(或减1),然后<strong>将改变后的对象作为求值结果</strong></li>
</ul>
</li>
<li>后置版本
<ul>
<li>将运算对象加1(或减1),但是<strong>求值结果是运算对象改变之前那个值的副本</strong></li>
</ul>
</li>
<li><mark>除非必须,否则不用递增递减运算符的后置版本</mark></li>
<li><mark>后置递增运算符的优先级高于解引用运算符</mark></li>
</ul>
</div><div class="story post-story"><h2 id="46-成员访问运算符"><a class="markdownIt-Anchor" href="#46-成员访问运算符"></a> 4.6 成员访问运算符</h2>
<ul>
<li>点运算符和箭头运算符都可以访问成员
<ul>
<li>点运算符获取类对象的一个成员</li>
<li><mark>箭头运算符与点运算符有关,表达式ptr-&gt;mem等价于(*ptr).mem</mark></li>
</ul>
</li>
<li><strong>箭头运算符作用于一个指针类型的运算对象</strong>,结果是一个左值</li>
<li>点运算符分成两种情况：
<ul>
<li>如果成员所属的对象是左值,那么结果是左值;</li>
<li>反之,如果成员所属的对象是右值,那么结果是右值</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;a string&quot;</span>, *p = &amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.<span class="built_in">size</span>(); <span class="comment">//运行string对象s1的size成员</span></span><br><span class="line">n = (*p).<span class="built_in">size</span>();    <span class="comment">//运行p所指对象的size成员</span></span><br><span class="line">n = p-<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="47-条件运算符"><a class="markdownIt-Anchor" href="#47-条件运算符"></a> 4.7 条件运算符</h2>
<ul>
<li>条件运算符 cond?expr1:expr2;
<ul>
<li>其中cond是判断条件的表达式,而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式</li>
<li>条件运算符的执行过程是：首先求cond的值,如果条件为真对expr1求值并返回该值,否则对expr2求值并返回该值</li>
</ul>
</li>
<li><mark>条件运算的嵌套最好别超过两到三层</mark></li>
</ul>
</div><div class="story post-story"><h2 id="48-位运算符"><a class="markdownIt-Anchor" href="#48-位运算符"></a> 4.8 位运算符</h2>
<ul>
<li>位运算符作用于整数类型的运算对象,并把运算对象看成是二进制位的集合</li>
<li>一种名为bitset的标准库类型也可以表示任意大小的二进制位集合</li>
<li>位运算符包括
<ul>
<li>位求反 `</li>
<li>左移 &lt;&lt;</li>
<li>右移 &gt;&gt;</li>
<li>位与 &amp;</li>
<li>位异或 ^</li>
<li>位或 |</li>
</ul>
</li>
<li>强烈建议仅将位运算符用于处理无符号类型</li>
</ul>
</div><div class="story post-story"><h2 id="49-sizeof运算符"><a class="markdownIt-Anchor" href="#49-sizeof运算符"></a> 4.9 sizeof运算符</h2>
<ul>
<li>sizeof运算符返回一条表达式或一个类型名字所占的字节数</li>
<li>sizeof运算符满足右结合律,其所得的值是一个size_t类型,<strong>是一个常量表达式</strong></li>
<li>形式1：sizeof(type)</li>
<li>形式2：sizeof expr
<ul>
<li>sizeof返回的是表达式结果类型的大小,sizeof并不实际计算其运算对象的值</li>
</ul>
</li>
<li>执行sizeof运算能得到整个数组的大小,<strong>可以用数组的大小除以单个元素的大小得到数组中元素的个数</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回数组中的元素数量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="built_in">sizeof</span>(ia)/<span class="built_in">sizeof</span>(*ia);</span><br><span class="line"><span class="type">int</span> arr2[sz];</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="410-逗号运算符"><a class="markdownIt-Anchor" href="#410-逗号运算符"></a> 4.10 逗号运算符</h2>
<ul>
<li>逗号运算符含有两个运算对象,按照从左向右的顺序依次求值</li>
<li><mark>对于逗号运算符来说,首先对左侧的表达式求值,然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值,那么最终的求值结果也是左值</mark></li>
</ul>
</div><div class="story post-story"><h2 id="411-类型转换"><a class="markdownIt-Anchor" href="#411-类型转换"></a> 4.11 类型转换</h2>
<ul>
<li>隐式转换
<ul>
<li>在大多数表达式中,比int类型小的整型值首先提升为较大的整数类型</li>
<li>在条件中,非布尔值转换成布尔类型</li>
<li>初始化过程中,初始值转换成变量的类型;在赋值语句中,右侧运算对象转换成左侧运算对象的类型</li>
<li>如果算术运算或关系运算的运算对象有多种类型,需要转换成同一种类型</li>
<li>函数调用时也会发生类型转换</li>
</ul>
</li>
<li><strong>算术转换</strong>：把一种算术类型转换成另外一种算术类型,其中运算符的运算对象将转换成最宽的类型</li>
<li><strong>数组转换成指针</strong>：在大多数用到数组的表达式中,数组自动转换成指向数组首元素的指针</li>
<li><strong>指针的转换</strong>
<ul>
<li>常量整数值0或者字面值nullptr能转换成任意指针类型</li>
<li>指向任意非常量的指针能转换成void*</li>
<li>指向任意对象的指针能转换成const void*</li>
<li>在有继承关系的类型间还有另外一种指针转换的方式</li>
</ul>
</li>
<li><strong>转换成布尔类型</strong>
<ul>
<li>存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0,转换结果是false;否则转换结果是true</li>
</ul>
</li>
<li><strong>转换成常量</strong>
<ul>
<li>允许将指向非常量类型的指针转换成指向相应的常量类型的指针,对于引用也是这样。也就是说,如果T是一种类型,就能将指向T的指针或引用分别转换成指向const T的指针或引用</li>
</ul>
</li>
<li><strong>类类型定义的转换</strong></li>
</ul>
<h3 id="4113-显式转换"><a class="markdownIt-Anchor" href="#4113-显式转换"></a> 4.11.3 显式转换</h3>
<ul>
<li>显式转换为<strong>强制类型转换</strong></li>
<li>命名的强制类型转换 cast-name&lt;type&gt;(expression);
<ul>
<li>type是转换的目标类型而expression是要转换的值</li>
<li>如果type是引用类型,则结果是左值</li>
<li>cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种</li>
</ul>
</li>
<li><strong>static_cast</strong>
<ul>
<li>任何具有明确定义的类型转换,只要不包含底层const,都可以使用static_cast</li>
<li>static_cast可以将一个较大的算术类型赋值给较小的类型</li>
<li>static_cast对于编译器无法自动执行的类型转换也非常有用</li>
<li>把指针存放在void*中,并且使用static_cast将其强制转换回原来的类型时,应该确保指针的值保持不变;强制转换的结果将与原始的地址值相等</li>
<li><mark>对右值引用的特许规则:虽然不能隐式地将一个左值转换成右值引用,但static_cast可以显式地将一个左值转换成一个右值</mark></li>
</ul>
</li>
<li><strong>const_cast</strong>
<ul>
<li>“去掉const性质”：将常量对象转换成非常量对象的行为</li>
<li>只有const_cast能改变表达式的常量属性,使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误</li>
</ul>
</li>
<li><strong>reinterpret_cat</strong>
<ul>
<li>为运算对象的位模式提供较低层次上的重新解释</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * p = &amp;d;</span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ip);</span><br></pre></td></tr></table></figure>
<h1 id="5-语句"><a class="markdownIt-Anchor" href="#5-语句"></a> 5 语句</h1>
</div><div class="story post-story"><h2 id="53-条件语句"><a class="markdownIt-Anchor" href="#53-条件语句"></a> 5.3 条件语句</h2>
<ul>
<li>C++语言提供了两种按条件执行的语句
<ul>
<li>一种是if语句,它根据条件决定控制流</li>
<li>另外一种是switch语句,它计算一个整型表达式的值,然后根据这个值从几条执行路径中选择一条</li>
</ul>
</li>
<li><strong>悬垂else</strong>
<ul>
<li>当一个if语句嵌套在另一个if语句内部时,很可能if分支会多于else分支</li>
<li><mark>C++规定else与离它最近的尚未匹配的if匹配</mark></li>
</ul>
</li>
<li>switch-case-default</li>
</ul>
</div><div class="story post-story"><h2 id="54-迭代语句"><a class="markdownIt-Anchor" href="#54-迭代语句"></a> 5.4 迭代语句</h2>
<ul>
<li>迭代语句通常称为循环,它重复执行操作直到满足某个条件才停下来
<ul>
<li>while和for语句在执行循环体之前检查条件</li>
<li>do while语句先执行循环体,然后再检查条件</li>
</ul>
</li>
<li>范围for语句for(declaration : expression) statement
<ul>
<li>expression表示的必须是一个序列</li>
<li>declaration定义一个变量,序列中的每个元素都得能转换成该变量的类型;确保类型相容最简单的办法是使用auto类型说明符
<ul>
<li><mark>需要对序列中的元素执行写操作,循环变量必须声明成引用类型</mark></li>
</ul>
</li>
<li>每次迭代都会重新定义循环控制变量,并将其初始化成序列中的下一个值,之后才会执行statement</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="55-跳转语句"><a class="markdownIt-Anchor" href="#55-跳转语句"></a> 5.5 跳转语句</h2>
<ul>
<li>C++语言提供了4种跳转语句：break,continue,goto和return</li>
<li>break语句<strong>负责终止离它最近的while、do while、for或switch语句,并从这些语句之后的第一条语句开始继续执行</strong>
<ul>
<li>break语句只能出现在迭代语句或者switch语句内部</li>
</ul>
</li>
<li>continue语句<strong>终止最近的循环中的当前迭代并立即开始下一次迭代</strong>
<ul>
<li>continue语句只能出现在for、while和do while循环的内部,或者嵌套在此类循环里的语句或块的内部</li>
</ul>
</li>
<li>goto语句的作用是<strong>从goto语句无条件跳转到同一函数内的另一条语句</strong>
<ul>
<li><mark>不要在程序中使用goto语句,因为它使得程序既难理解又难修改</mark></li>
<li>goto label;其中,label是用于标识一条语句的标示符</li>
<li>带标签语句是一种特殊的语句,语句之前有一个标示符以及一个冒号:</li>
</ul>
</li>
<li>return</li>
</ul>
</div><div class="story post-story"><h2 id="56-try语句块和异常处理"><a class="markdownIt-Anchor" href="#56-try语句块和异常处理"></a> 5.6 try语句块和异常处理</h2>
<ul>
<li>C++的异常处理包括
<ul>
<li>throw表达式,异常检查部分使用throw表达式表示遇到了无法处理的问题</li>
<li>try语句块,异常处理部分使用try语句块处理异常,try-catch语句块</li>
<li>一套异常类,用于在throw表达式和相关的catch子句之间传递异常的具体信息</li>
</ul>
</li>
</ul>
<h3 id="561-throw表达式"><a class="markdownIt-Anchor" href="#561-throw表达式"></a> 5.6.1 throw表达式</h3>
<ul>
<li>throw表达式包含关键字throw和紧随其后的一个表达式,其中表达式的类型就是抛出的异常类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>())</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);    <span class="comment">// throw表达式</span></span><br><span class="line">cout &lt;&lt; item1 + item2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="562-try语句块"><a class="markdownIt-Anchor" href="#562-try语句块"></a> 5.6.2 try语句块</h3>
<ul>
<li><mark>try语句块内声明的变量在块外部无法访问,特别是在catch子句内也无法访问</mark></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try语句块通用语法结构</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  program-statements</span><br><span class="line">&#125;<span class="built_in">catch</span>(exception-declaration)&#123;</span><br><span class="line">  handler-statements</span><br><span class="line">&#125;<span class="built_in">catch</span>(exception-declaration)&#123;</span><br><span class="line">  handler-statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="563-标准异常"><a class="markdownIt-Anchor" href="#563-标准异常"></a> 5.6.3 标准异常</h3>
<ul>
<li>C++标准库定义了异常类
<ul>
<li>exception头文件定义了最通用的异常类exception;只报告异常的发生,不提供任何额外信息</li>
<li>stdexcept头文件定义了几种常用的异常类,详细信息在表5.1中列出</li>
<li>new头文件定义了bad_alloc异常类型</li>
<li>type_info头文件定义了bad_cast异常类型</li>
</ul>
</li>
<li>标准库异常类只定义了几种运算,<mark>包括创建或拷贝异常类型的对象,以及为异常类型的对象赋值</mark></li>
<li><mark>只能以<strong>默认初始化的方式初始化exception、bad_alloc和bad_cast对象</strong>,不允许为这些对象提供初始值</mark>
<ul>
<li>其他异常类型不允许使用默认初始化的方式：应该使用string对象或者C风格字符串初始化这些类型的对象;当创建此类对象时,必须提供初始值,该初始值含有错误相关的信息</li>
</ul>
</li>
<li>异常类型只定义了一个名为what的成员函数,该函数没有任何参数,目的是提供关于异常的一些文本信息,返回值是一个指向C风格字符串的const char*</li>
</ul>
<table>
<thead>
<tr>
<th>&lt;stdexcept&gt;定义的异常类</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>exception</td>
<td>最常见的问题</td>
</tr>
<tr>
<td>runtime_error</td>
<td>只有在运行时才能检测出的问题</td>
</tr>
<tr>
<td>range_error</td>
<td>运行时错误：生成的结果超出了有意义的值域范围</td>
</tr>
<tr>
<td>overflow_error</td>
<td>运行时错误：计算上溢</td>
</tr>
<tr>
<td>underflow_error</td>
<td>运行时错误：计算下溢</td>
</tr>
<tr>
<td>logic_error</td>
<td>程序逻辑错误</td>
</tr>
<tr>
<td>domain_error</td>
<td>逻辑错误：参数对应的结果值不存在</td>
</tr>
<tr>
<td>invalid_error</td>
<td>逻辑错误：无效参数</td>
</tr>
<tr>
<td>length_error</td>
<td>逻辑错误：试图创建一个超出该类型最大长度的对象</td>
</tr>
<tr>
<td>out_of_range</td>
<td>逻辑错误：使用一个超出有效范围的值</td>
</tr>
</tbody>
</table>
<h1 id="6-函数"><a class="markdownIt-Anchor" href="#6-函数"></a> 6 函数</h1>
</div><div class="story post-story"><h2 id="61-函数基础"><a class="markdownIt-Anchor" href="#61-函数基础"></a> 6.1 函数基础</h2>
<ul>
<li>典型的函数包括：返回类型,函数名字,由0个或多个形参组成的列表以及函数体</li>
<li>通过调用运算符来执行函数,调用运算符的形式是一对圆括号,作用于一个表达式,该表达式是函数或者指向函数的指针</li>
<li>实参和形参
<ul>
<li>实参是形参的初始值</li>
<li>实参的类型必须与形参类型匹配</li>
<li>任意两个形参都不能同名,而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字</li>
<li><mark>是否设置未命名的形参并不影响调用时提供的实参数量</mark>
<ul>
<li><mark>即使某个形参不被函数使用,也必须为它提供一个实参</mark></li>
</ul>
</li>
</ul>
</li>
<li>函数的返回类型<mark>不能是数组或函数类型,但可以是指向数组或函数的指针</mark></li>
</ul>
<h3 id="611-局部对象"><a class="markdownIt-Anchor" href="#611-局部对象"></a> 6.1.1 局部对象</h3>
<ul>
<li>形参和函数体内部定义的变量称为局部变量</li>
<li>对函数而言是局部的,仅在函数的作用域内可见,同时局部变量会隐藏在外层作用域中同名的其他所有声明</li>
<li>存在于块执行器件的对象称为<strong>自动对象</strong>,当块的执行结束后,块中创建的自动对象的值就为未定义的
<ul>
<li>形参是一种自动对象,函数开始时为形参申请存储空间,函数终止,形参被销毁</li>
</ul>
</li>
<li><strong>局部静态对象</strong>
<ul>
<li>static类型：局部变量的生命周期贯穿函数调用及之后的时间</li>
<li>局部静态对象在程序执行路径第一次经过对象定义语句时初始化,并且直到程序终止才被销毁,在此期间即使对象所在函数结束执行也不会对它有影响</li>
</ul>
</li>
</ul>
<h3 id="612-函数声明"><a class="markdownIt-Anchor" href="#612-函数声明"></a> 6.1.2 函数声明</h3>
<ul>
<li>函数声明与函数定义类似,唯一的区别就是函数声明无需函数体,使用一个分号代替</li>
<li>函数的三要素(返回类型,函数名,形参类型)描述了函数接口,说明了调用该函数所需的全部信息</li>
<li>函数声明也叫做<strong>函数原型</strong></li>
<li><strong>建议在头文件中进行函数声明</strong>
<ul>
<li>含有函数声明的头文件应该被包含到定义函数的源文件中</li>
</ul>
</li>
</ul>
<h3 id="613-分离式编译"><a class="markdownIt-Anchor" href="#613-分离式编译"></a> 6.1.3 分离式编译</h3>
<ul>
<li>分离式遍历-链接形成可执行文件</li>
</ul>
</div><div class="story post-story"><h2 id="62-参数传递"><a class="markdownIt-Anchor" href="#62-参数传递"></a> 6.2 参数传递</h2>
<ul>
<li>当形参是引用类型,对应的实参被<strong>引用传递</strong>或函数被<strong>传引用调用</strong></li>
<li>当实参的值被拷贝给形参时,形参和实参是两个相互独立的对象,实参被<strong>值传递</strong>或函数被<strong>传值调用</strong></li>
</ul>
<h3 id="621-传值参数"><a class="markdownIt-Anchor" href="#621-传值参数"></a> 6.2.1 传值参数</h3>
<ul>
<li>初始化一个非引用类型变量时,初始值被拷贝给变量
<ul>
<li>对变量的改动不会影响初始值</li>
<li>函数对形参的所有操作都不会影响实参</li>
</ul>
</li>
<li><strong>指针参数</strong>
<ul>
<li>指针的行为和其他非引用类型一样</li>
<li>当执行指针拷贝操作时,拷贝的是指针的值,拷贝之后,两个指针是不同的指针</li>
<li>可以使用指针修改它所指向的对象的值(指针可以间接访问所指的对象)</li>
</ul>
</li>
<li><mark>在C++中,建议使用引用类型的形参代替指针访问函数外部的对象</mark></li>
</ul>
<h3 id="622-传引用参数"><a class="markdownIt-Anchor" href="#622-传引用参数"></a> 6.2.2 传引用参数</h3>
<ul>
<li>引用的操纵实际上是作用在引用所引的对象上</li>
<li>通过使用引用形参,允许函数改变一个或多个实参的值</li>
<li>使用引用可以避免拷贝</li>
<li>函数无需修改引用形参的值,最好将其声明为常量引用</li>
<li>传递引用形参可以帮助返回额外信息</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>, i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> *ip)</span></span>&#123;</span><br><span class="line">  *ip = <span class="number">0</span>;  <span class="comment">//改变了指针ip所指对象的值</span></span><br><span class="line">  ip = <span class="number">0</span>;   <span class="comment">//改变了ip的局部拷贝,实参未被改变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reset</span>(&amp;i);  <span class="comment">//改变i的值,而非i的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传递引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> &amp;i)</span>  <span class="comment">//i是传递给reset函数的对象的另一个名字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">reset</span>(j);   <span class="comment">//传引用,j的值会发生改变</span></span><br></pre></td></tr></table></figure>
<h3 id="623-const形参和实参"><a class="markdownIt-Anchor" href="#623-const形参和实参"></a> 6.2.3 const形参和实参</h3>
<ul>
<li><a href="#243-%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const">顶层const和底层const</a></li>
<li>形参是const时,若为<strong>顶层const</strong>,初始化时会<strong>忽略顶层const属性</strong>
<ul>
<li><strong>底层const可以使用非常量进行初始化,反之不成立</strong></li>
<li><mark>C++允许用字面值初始化常量引用</mark></li>
</ul>
</li>
<li>尽量使用常量引用
<ul>
<li>把函数不会改变的形参定义成普通的引用会给函数的调用者产生误导,即函数可以修改他的实参值</li>
<li><mark>使用引用而非常量引用也会极大地限制函数所能接受的实参类型,不能把const对象,字面值或需要类型转换的对象传递给普通的引用形参</mark></li>
<li>函数嵌套调用时,假如其他函数(正确地)将它们的形参定义成常量引用,那么内层函数(普通引用)无法正常使用</li>
</ul>
</li>
</ul>
<h3 id="624-数组形参"><a class="markdownIt-Anchor" href="#624-数组形参"></a> 6.2.4 数组形参</h3>
<ul>
<li>数组的特殊性
<ul>
<li>不允许拷贝数组</li>
<li>使用数组时会将其转换成指针</li>
</ul>
</li>
<li><mark>数组进行传递时,传递的是指向数组首元素的指针,不可以进行值传递</mark>
<ul>
<li><mark>可以将形参携程类似数组的形式</mark></li>
<li>数组是以指针的形式传递给函数的,但<strong>需要指明数组的确切尺寸</strong>
<ul>
<li>使用标记指定数组长度</li>
<li>使用标准库规范,传递指向数组首元素和尾后元素的指针</li>
<li>显式传递一个表示数组大小的形参</li>
</ul>
</li>
</ul>
</li>
<li>数组形参和const
<ul>
<li>当函数不需要对数组元素执行写操作时,数组形参应该是指向const的指针,只有需要改变元素值是才定义为非常量的指针</li>
</ul>
</li>
<li>数组引用形参
<ul>
<li>形参可以是数组的引用,引用形参绑定到对应的数组上</li>
</ul>
</li>
<li>传递多维数组
<ul>
<li>处理的是数组的数组,首元素本身就是一个数组,<strong>指针就是一个指向数组的指针</strong></li>
<li>数组第二维(以及后面所有维度)的大小都是数组类型的一部分,不能省略</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const int ia[]等价于const int* ia</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 形参为数组引用,维度是类型的一部分</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 二维数组</span></span></span><br><span class="line"><span class="function"><span class="comment">// matrix指向数组的首元素,该数组的元素是由10个整数构成的数组</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*matrix)[<span class="number">10</span>],<span class="type">int</span> rowSize)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 等价于</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> matrix[][<span class="number">10</span>], <span class="type">int</span> rowSize)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="625-main处理命令行选项"><a class="markdownIt-Anchor" href="#625-main处理命令行选项"></a> 6.2.5 main:处理命令行选项</h3>
<ul>
<li>main函数传递实参可以通过命令行选项通过两个形参传递给main函数</li>
<li>int main(int argv, char *argv[])
<ul>
<li>第一个形参argc表示数组中字符串的数量</li>
<li>第二个形参argv是一个数组,它的元素是指向C风格字符串的指针</li>
</ul>
</li>
</ul>
<h3 id="626-含有可变形参的函数"><a class="markdownIt-Anchor" href="#626-含有可变形参的函数"></a> 6.2.6 含有可变形参的函数</h3>
<ul>
<li>编写处理不同数量实参的函数,两种方法
<ul>
<li>如果实参类型相同,传递一个名为initializer_list的标准库类型</li>
<li>如果实参的类型不同,编写可变参数模板函数</li>
<li><mark>利用省略符,传递可变数量的实参,一般只用于与C函数交互的接口程序</mark></li>
</ul>
</li>
<li><strong>使用initializer_list类型的形参</strong>表示<strong>函数的实参数量未知但是全部实参的类型都相同</strong>
<ul>
<li>initializer_list是一种标准库类型,用于表示某种特定类型的值的数组</li>
<li>initializer_list类型定义在同名的头文件中</li>
<li>和vector一样,initializer_list也是一种模板类型
<ul>
<li>定义initializer_list对象时,必须说明列表中所含元素的类型</li>
</ul>
</li>
<li>和vector不一样的是,initializer_list对象中的元素永远是常量值,<strong>无法改变initializer_list对象中元素的值</strong></li>
</ul>
</li>
<li>省略符形参
<ul>
<li>为了C++程序访问某些特殊的C代码而设置</li>
<li>省略符形参应该仅仅用于C和C++通用的类型
<ul>
<li>特别应该注意的是,大多数类类型的对象在传递给省略符形参时都无法正确拷贝</li>
</ul>
</li>
<li><mark>省略符形参只出现在形参列表的最后一个位置</mark></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>initializer_list提供的操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>initializer_list&lt;T&gt; lst;</td>
<td>默认初始化;T类型元素的空列表</td>
</tr>
<tr>
<td>initializer_list&lt;T&gt; lst{a,b,c…};</td>
<td>lst的元素数量和初始值一样多;lst元素是对应初始值的副本</td>
</tr>
<tr>
<td>lst2(lst)</td>
<td>拷贝或赋值一个initializer_list对象不会拷贝列表中的元素;拷贝后,原始列表和副本共享元素</td>
</tr>
<tr>
<td>lst2=lst</td>
<td>拷贝或赋值一个initializer_list对象不会拷贝列表中的元素;拷贝后,原始列表和副本共享元素</td>
</tr>
<tr>
<td>lst.size()</td>
<td>列表中的元素数量</td>
</tr>
<tr>
<td>lst.begin()</td>
<td>首元素的指针</td>
</tr>
<tr>
<td>lst.end()</td>
<td>尾元素下一位置的指针</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;string&gt; ls;</span><br><span class="line">initializer_list&lt;<span class="type">int</span>&gt; li;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>();beg != il.<span class="built_in">end</span>();++beg)</span><br><span class="line">    cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(parm_list, ...)</span>    <span class="comment">//省略符形参</span></span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="63-返回类型和return语句"><a class="markdownIt-Anchor" href="#63-返回类型和return语句"></a> 6.3 返回类型和return语句</h2>
<h3 id="631-无返回值函数"><a class="markdownIt-Anchor" href="#631-无返回值函数"></a> 6.3.1 无返回值函数</h3>
<ul>
<li>没有返回值的return语句只能用在返回类型是void的函数中</li>
<li>返回void的函数不要求非得有return语句(会隐式地执行return)</li>
</ul>
<h3 id="632-有返回值的函数"><a class="markdownIt-Anchor" href="#632-有返回值的函数"></a> 6.3.2 有返回值的函数</h3>
<ul>
<li>return语句提供了函数的结果
<ul>
<li>只要函数的返回类型不是void,则该函数内的每条return语句必须返回一个值</li>
<li>return语句返回值的类型必须与函数的返回类型相同,或者能隐式地转换成函数的返回类型</li>
</ul>
</li>
<li><strong>值是如何被返回的</strong>
<ul>
<li>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量,该临时量就是函数调用的结果</li>
<li>若函数返回引用,则该引用仅是它所引对象的一个别名</li>
</ul>
</li>
<li><strong>不要返回局部变量的引用或指针</strong>
<ul>
<li>函数完成后,局部变量所占的存储空间被释放,随之指针和引用不再有效</li>
</ul>
</li>
<li><strong>引用返回左值</strong>
<ul>
<li><mark>调用一个返回引用的函数得到左值,其他返回类型得到右值</mark></li>
<li>可以像使用其他左值那样来使用返回引用的函数的调用,特别是,我们能为返回类型是非常量引用的函数的结果赋值</li>
</ul>
</li>
<li><strong>列表初始化返回值</strong>
<ul>
<li><mark>C++11规定,函数可以返回花括号包围的值的列表</mark></li>
<li>类似于其他返回结果,此处的列表也用来对表示函数返回的临时量进行初始化
<ul>
<li>如果列表为空,临时量执行值初始化;否则,返回的值由函数的返回类型决定</li>
</ul>
</li>
</ul>
</li>
<li>主函数main的返回值
<ul>
<li>允许main函数没有return语句直接结束,编译器会隐式插入一条返回0的return语句</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">get_val</span><span class="params">(string &amp;str,string::size_type ix)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">get_val</span>(s,<span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;   <span class="comment">//将s[0]值改为A </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回值是引用,因此调用是个左值,和其他左值一样它也能出现在赋值运算符的左侧</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="keyword">if</span>(expected.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(expected == actual)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okay&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,expected, actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="633-返回数组指针"><a class="markdownIt-Anchor" href="#633-返回数组指针"></a> 6.3.3 返回数组指针</h3>
<ul>
<li>声明一个返回数组指针的函数
<ul>
<li>定义一个返回数组指针的函数,<mark>数组的维度必须跟在函数名字之后</mark></li>
<li>函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度</li>
<li>Type (*function(parameter_list))[dimension]</li>
</ul>
</li>
<li><strong>尾置返回类型</strong>
<ul>
<li>在C++11中引入尾置返回类型</li>
<li>任何函数的定义都能使用尾置返回,但是这种形式对于返回类型比较复杂的函数最有效</li>
<li><mark>尾置返回类型跟在形参列表后面并以一个-&gt;符号开头</mark></li>
<li><mark>为了表示函数真正的返回类型跟在形参列表之后,在本应该出现返回类型的地方放置一个auto</mark></li>
</ul>
</li>
<li>使用decltype
<ul>
<li>知道函数返回的指针指向哪个数组就可以使用decltype关键字声明返回类型</li>
<li>decltype并不负责把数组类型转换成对应的指针,结果是个数组</li>
<li><mark>要想返回指针还必须在函数声明时加一个*符号</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回类型</span></span><br><span class="line"><span class="comment">// 返回一个指针,该指针指向含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span>[10]</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">  <span class="keyword">return</span> (i%<span class="number">2</span>):&amp;odd:&amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="64-函数重载"><a class="markdownIt-Anchor" href="#64-函数重载"></a> 6.4 函数重载</h2>
<ul>
<li><strong>重载函数</strong>：同一个作用域内的几个函数名字相同但形参列表不同的函数
<ul>
<li>main函数不能重载</li>
</ul>
</li>
<li>定义重载函数
<ul>
<li>重载函数在形参数量或形参类型上不同</li>
<li><mark>不允许两个参数除了返回类型外其他所有要素都相同</mark></li>
</ul>
</li>
<li>重载和const形参
<ul>
<li>顶层const不影响传入函数的对象</li>
<li><mark>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开</mark></li>
<li><mark>形参是某种类型的指针或引用,指向的是常量对象和指向非常量对象的函数可以重载,此时的const是底层的</mark></li>
</ul>
</li>
<li>const_cast和重载
<ul>
<li><mark>const_cast在重载函数的情景中最有用</mark><a href="#4113-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2">const_cast</a></li>
</ul>
</li>
<li><strong>函数匹配</strong>：把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较,然后根据比较的结果决定到底调用哪个函数</li>
<li>在内层作用域中声明名字,将隐藏外层作用域中声明的同名实体
<ul>
<li>在不同的作用域中无法重载函数名</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),</span><br><span class="line">                          <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="65-特殊用途语言特性"><a class="markdownIt-Anchor" href="#65-特殊用途语言特性"></a> 6.5 特殊用途语言特性</h2>
<h3 id="651-默认实参"><a class="markdownIt-Anchor" href="#651-默认实参"></a> 6.5.1 默认实参</h3>
<ul>
<li>调用含有默认实参的函数时,可以包含该实参,也可以省略该实参</li>
<li>默认实参初始化
<ul>
<li>局部变量不能作为默认实参</li>
<li>只要表达式的类型能转换成形参所需的类型,该表达式就能作为默认实参</li>
<li>函数的后续声明只能为之前那些没有默认值的形参添加默认实参,而且该形参右侧的所有形参必须都有默认值</li>
<li>用作默认实参的名字在函数声明所在的作用域内解析,<mark>名字的求值过程发生在函数调用时</mark></li>
</ul>
</li>
</ul>
<h3 id="652-内联函数和constexpr函数"><a class="markdownIt-Anchor" href="#652-内联函数和constexpr函数"></a> 6.5.2 内联函数和constexpr函数</h3>
<ul>
<li><strong>内联函数</strong>：通常就是将它在每个调用点上内联地展开消除在运行时的开销</li>
<li>在返回类型前面加<strong>关键字inline</strong>就可以声明为<strong>内联函数</strong>
<ul>
<li>一般来说,内联机制用于优化规模较小、流程直接、频繁调用的函数</li>
</ul>
</li>
<li><strong>constexpr函数是指能用于常量表达式的函数</strong>
<ul>
<li>定义constexpr函数：<mark>函数的返回类型及所有形参的类型都得是字面值类型,而且函数体中必须有且只有一条return语句</mark></li>
<li>执行该初始化任务时,编译器把对constexpr函数的调用替换成其结果值</li>
<li><mark>为了能在编译过程中随时展开,constexpr函数被隐式地指定为内联函数</mark></li>
<li>constexpr函数体内也可以包含其他语句,只要这些语句在运行时不执行任何操作就行
<ul>
<li>例如,constexpr函数中可以有空语句、类型别名以及using声明</li>
</ul>
</li>
<li><mark>constexpr函数不一定返回常量表达式</mark></li>
</ul>
</li>
<li><mark>内联函数和constexpr函数经常放在头文件中</mark></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内联版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = new_sz; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<h3 id="653-调试帮助"><a class="markdownIt-Anchor" href="#653-调试帮助"></a> 6.5.3 调试帮助</h3>
<ul>
<li>屏蔽调试代码的方法
<ul>
<li>assert</li>
<li>NDEBUG</li>
</ul>
</li>
<li>assert预处理宏
<ul>
<li>assert是一种预处理宏(预处理变量),类似于内联函数,定义在cassert文件中</li>
<li>预处理名字由预处理器而非编译器管理,<mark>可以直接使用预处理名字而无须提供using声明</mark></li>
<li>assert宏使用一个表达式作为它的条件: assert(expr);
<ul>
<li>首先对expr求值,如果表达式为假,assert输出信息并终止程序的执行;为真,assert什么也不做</li>
</ul>
</li>
<li><mark>assert宏常用于检查“不能发生”的条件</mark></li>
</ul>
</li>
<li>NDEBUG
<ul>
<li>assert的行为依赖于一个名为NDEBUG的预处理变量的状态</li>
<li>定义NDEBUG能避免检查各种条件所需的运行时开销,当然此时根本就不会执行运行时检查
<ul>
<li>可以把assert当成调试程序的一种辅助手段</li>
</ul>
</li>
<li>预处理器定义了对于程序调试很有用的名字
<ul>
<li>_ <em>FILE</em> _ 存放文件名的字符串字面值</li>
<li>_ <em>LINE</em> _ 存放当前行号的整型字面值</li>
<li>_ <em>TIME</em> _ 存放文件编译时间的字符串字面值</li>
<li>_ <em>DATE</em> _ 存放文件编译日期的字符串字面值</li>
<li>_ <em>func</em> _当前调试的函数的名字</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用#define语句定义NDEBUG从而关闭调试状态</span></span><br><span class="line">$ CC -D NDEBUG main.c</span><br><span class="line"><span class="comment">// 等价于在main.c文件的一开始写#define NDEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用NDEBUG编写自己的条件调试代码</span></span><br><span class="line"><span class="comment">// 如果NDEBUG未定义,将执行#ifndef和#endif之间的代码;如果定义了NDEBUG,这些代码将被忽略掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    cerr &lt;&lt; __func__ &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="66-函数匹配"><a class="markdownIt-Anchor" href="#66-函数匹配"></a> 6.6 函数匹配</h2>
<ul>
<li>函数匹配步骤
<ul>
<li>第一步是选定本次调用对应的重载函数集,集合中的函数称为候选函数
<ul>
<li>候选函数具备两个特征：一是与被调用的函数同名,二是其声明在调用点可见</li>
</ul>
</li>
<li>第二步考察本次调用提供的实参,然后从候选函数中选出能被这组实参调用的函数,这些新选出的函数称为可行函数
<ul>
<li>可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等,二是每个实参的类型与对应的形参类型相同,或者能转换成形参的类型</li>
<li>如果函数含有默认实参,则在调用该函数时传入的实参数量可能少于它实际使用的实参数量</li>
</ul>
</li>
<li>第三步是从可行函数中选择与本次调用最匹配的函数</li>
<li>如果有且只有一个函数满足下列条件,则匹配成功：
<ul>
<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="661-实参类型转换"><a class="markdownIt-Anchor" href="#661-实参类型转换"></a> 6.6.1 实参类型转换</h3>
<ul>
<li>为了确定最佳匹配,编译器将实参类型到形参类型的转换划分成几个等级,具体排序如下所示：
<ol>
<li>精确匹配,包括以下情况：
<ul>
<li>实参类型和形参类型相同。</li>
<li>实参从数组类型或函数类型转换成对应的指针类型</li>
<li>向实参添加顶层const或者从实参中删除顶层const。</li>
</ul>
</li>
<li>通过const转换实现的匹配</li>
<li>通过类型提升实现的匹配</li>
<li>通过算术类型转换或指针转换实现的匹配</li>
</ol>
</li>
</ul>
</div><div class="story post-story"><h2 id="67-函数指针"><a class="markdownIt-Anchor" href="#67-函数指针"></a> 6.7 函数指针</h2>
<ul>
<li>函数指针指向的是函数而非对象
<ul>
<li><mark>函数指针指向某种特定类型,函数的类型由它的返回类型和形参类型共同决定,与函数名无关</mark></li>
<li>声明函数指针：在函数声明中,<mark>只需要用指针替换函数名即可</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义pf函数指针</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;); <span class="comment">//未初始化</span></span><br><span class="line"><span class="comment">// *pf两端的括号必不可少</span></span><br><span class="line"><span class="comment">// 如果不写这对括号,则pf是一个返回值为bool指针的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> *<span class="title">pf</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>; <span class="comment">//未初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用函数指针
<ul>
<li><mark>把函数名作为一个值使用时,该函数自动地转换成指针</mark></li>
<li><mark>直接使用指向函数的指针调用该函数,无须提前解引用指针</mark></li>
<li><mark>可以为函数指针赋一个nullptr或者值为0的整型常量表达式,表示该指针没有指向任何一个函数</mark></li>
</ul>
</li>
<li>重载函数指针：如果定义了指向重载函数的指针,编译器通过指针类型决定选用哪个函数,指针类型必须与重载函数中的某一个精确匹配</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pf函数指针</span></span><br><span class="line">pf = lengthCompare;   <span class="comment">//pf指向lengthCompare函数</span></span><br><span class="line">pf = &amp;lengthCompare;    <span class="comment">//等价赋值语句</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);    <span class="comment">//调用lengthCompare函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cstringCompare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line">pf = <span class="number">0</span>; <span class="comment">//正确,不指向任何函数</span></span><br><span class="line">pf = sumLength; <span class="comment">//错误,返回类型不匹配</span></span><br><span class="line"></span><br><span class="line">pf = cstringCompare;  <span class="comment">//错误,形参类型不匹配</span></span><br><span class="line">pf = lengthCompare; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*pf1)(<span class="type">unsigned</span> <span class="type">int</span>) = ff;   <span class="comment">//pf1指向ff(unsigned)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>函数指针形参</strong>
<ul>
<li>和数组类似,虽然不能定义函数类型的形参,但形参可以是指向函数的指针</li>
<li><mark>形参看起来是函数类型,但实际上当作指针使用</mark>
<ul>
<li><mark>直接把函数作为实参,会自动转换成指针</mark></li>
</ul>
</li>
</ul>
</li>
<li><strong>返回指向函数的指针</strong>
<ul>
<li>必须把返回类型写出指针形式,<mark>编译器不会自动地将函数返回类型当成对应的指针类型处理</mark></li>
<li><mark>要想声明一个返回函数指针的函数,最简单的办法是使用类型别名</mark>
<ul>
<li><mark>和函数类型的形参不一样,返回类型不会自动地转换成指针;需要显式地将返回类型指定为指针</mark></li>
</ul>
</li>
<li><mark>可以使用尾置返回类型的方式声明一个返回函数指针的函数</mark></li>
</ul>
</li>
<li>将auto和decltype用于函数指针类型
<ul>
<li>如果明确知道返回的函数是哪一个,就能使用decltype简化书写函数指针返回类型的过程</li>
<li>将decltype作用于某个函数时,返回函数类型而非指针类型
<ul>
<li><mark>需要显式地加上*以表明我们需要返回指针,而非函数本身</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">// 等价显式定义为指向函数的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动将函数转换为函数指针</span></span><br><span class="line"><span class="built_in">useBigger</span>(s1,s2,lengthCompare);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指向函数的指针</span></span><br><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span> *, <span class="type">int</span>); <span class="comment">//F是函数类型,不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = (<span class="type">int</span>*)(<span class="type">int</span> *,<span class="type">int</span>); <span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">//正确;PF是指向函数的指针,f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;   <span class="comment">//正确;显式指定返回类型是指向函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价声明</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span>*,<span class="type">int</span>);</span><br><span class="line"><span class="comment">//照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表,所以f1是个函数</span></span><br><span class="line"><span class="comment">// f1前面有*,所以f1返回一个指针;进一步观察发现,指针的类型本身也包含形参列表,因此指针指向函数,该函数的返回类型是int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span> <span class="params">(<span class="type">int</span>*,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="7-类"><a class="markdownIt-Anchor" href="#7-类"></a> 7 类</h1>
<ul>
<li>类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>
<ul>
<li>数据抽象是一种依赖于接口和实现分离的编程技术
<ul>
<li>类的接口包括用户所能执行的操作;</li>
<li>类的实现则包括类的数据成员,负责接口实现的函数体以及定义类所需的各种私有函数</li>
</ul>
</li>
<li>封装实现了类的接口和实现的分离
<ul>
<li>封装后的类隐藏了它的实现细节</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="71-定义抽象数据类型"><a class="markdownIt-Anchor" href="#71-定义抽象数据类型"></a> 7.1 定义抽象数据类型</h2>
<h3 id="711-定义改进的类"><a class="markdownIt-Anchor" href="#711-定义改进的类"></a> 7.1.1 定义改进的类</h3>
<ul>
<li>成员函数的声明必须在类的内部,<mark>定义既可以在类的内部也可以在类的外部</mark>
<ul>
<li>定义在类内部的函数是<mark>隐式的inline函数</mark></li>
</ul>
</li>
<li><mark>作为接口组成部分的非成员函数,定义和声明在类的外部</mark></li>
<li>this参数
<ul>
<li>成员函数通过一个名为<strong>this</strong>的额外的隐式参数来访问调用它的哪个对象</li>
<li><strong>this是一个常量指针</strong>,总是指向这个对象</li>
<li>在成员函数内部,可以直接使用调用该函数的对象的成员,而无须成员访问运算符,
<ul>
<li>因为this所指的正是这个对象,<mark>任何对类成员的直接访问都被看作this的隐式引用</mark></li>
</ul>
</li>
</ul>
</li>
<li><mark>引入const成员函数(常量成员函数)</mark>
<ul>
<li>默认情况下,this的类型是<mark>指向类类型非常量版本的指针常量</mark>
<ul>
<li>因此在默认情况下,不能把this绑定在常量对象上,不能在常量对象上调用普通的成员函数</li>
</ul>
</li>
<li><mark>修改为指向常量的指针常量,需要在参数列表后添加const关键词,表示this是指向常量的指针常量</mark></li>
<li><mark>常量对象,以及常量对象的引用或指针都只能调用常量成员函数</mark></li>
</ul>
</li>
<li>在类的外部定义成员函数,定义需要与声明匹配,类外部定义的成员的名字必须包含所属的类名,使用::作用符</li>
<li><strong>定义返回this对象的函数</strong>
<ul>
<li>函数的返回类型为类,return语句返回*this</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量成员函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">isbn</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> bookNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">Sales_data::isbn</span><span class="params">(<span class="type">const</span> Sales_data *<span class="type">const</span> this)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;isbn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义返回this对象的函数</span></span><br><span class="line">Sales_data&amp; <span class="title function_">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span>&#123;</span><br><span class="line">  units_sold += rhs.units_dold;</span><br><span class="line">  revenue += tho.revenue;</span><br><span class="line">  <span class="keyword">return</span> *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total.combine(trans);   <span class="comment">// 更新total的值</span></span><br><span class="line"><span class="comment">// total的地址被绑定到隐式的this参数上,而rhs绑定到了trans上。</span></span><br><span class="line"><span class="comment">// 效果等同于求total.units_sold和trans.unit_sold的和,然后把结果保存到total.units_sold中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无须使用隐式的this指针访问函数调用者的某个具体成员,而是需要把调用函数的对象当成一个整体来访问：</span></span><br><span class="line"><span class="keyword">return</span> *this;</span><br><span class="line"><span class="comment">// 其中,return语句解引用this指针以获得执行该函数的对象,调用返回total的引用</span></span><br></pre></td></tr></table></figure>
<h3 id="713-定义类相关的非成员函数"><a class="markdownIt-Anchor" href="#713-定义类相关的非成员函数"></a> 7.1.3 定义类相关的非成员函数</h3>
<ul>
<li>如果函数在概念上属于类但是不定义在类中,则它<mark>一般应与类声明(而非定义)在同一个头文件内</mark>
<ul>
<li>在这种方式下,用户使用接口的任何部分都只需要引入一个文件</li>
</ul>
</li>
</ul>
<h3 id="714-构造函数"><a class="markdownIt-Anchor" href="#714-构造函数"></a> 7.1.4 构造函数</h3>
<ul>
<li><strong>构造函数</strong>：初始化类对象的数据成员,无论何时只要类的对象被创建,就会执行函数
<ul>
<li><mark>构造函数的名字和类名相同,但构造函数没有返回类型</mark></li>
<li><mark>构造函数不能声明为const,直到构造函数完成初始化过程,对象才能真正取得其常量属性,构造函数在const对象的构造过程中可以向其写值</mark></li>
</ul>
</li>
<li><strong>合成的默认构造函数</strong>
<ul>
<li>类通过一个特殊的构造函数来控制默认初始化过程</li>
<li>如果存在类内的初始值,用它来初始化成员,否则默认初始化该成员</li>
</ul>
</li>
<li><strong>不能合成默认构造函数的情况</strong>
<ul>
<li>类没有声明任何构造函数,编译器会自动合成默认构造函数</li>
<li>类包含有内置类型或复合类型的成员,则只有当这些成员全都被赋予了类内的初始值,这个类才适合使用默认的构造函数</li>
</ul>
</li>
<li><strong>=default</strong>
<ul>
<li>在C++11中,需要默认的行为,可以在参数列表后写上 <strong>=default</strong> 来要求编译器生成构造函数</li>
<li><strong>=default</strong> 既可以和声明一起出现在类的内部(默认构造函数为内联函数),可以作为定义出现在类外部</li>
</ul>
</li>
<li><strong>构造函数初始化列表</strong>
<ul>
<li>构造函数冒号后的部分为构造初始化列表,构造函数初始值是成员名字的一个列表,每个名字后面紧跟着括号括起来的成员初始值,不同成员的初始化通过逗号分隔开</li>
<li>负责新创建的对象的一个或几个数据成员赋初值</li>
</ul>
</li>
<li><strong>类的外部定义构造函数</strong>：使用 <strong>类名::类名</strong> 的结构</li>
</ul>
<h3 id="715-拷贝赋值和析构"><a class="markdownIt-Anchor" href="#715-拷贝赋值和析构"></a> 7.1.5 拷贝,赋值和析构</h3>
<ul>
<li>编译器可以合成拷贝,赋值和析构函数,但生成的版本可能无法正常工作</li>
</ul>
</div><div class="story post-story"><h2 id="72-访问控制与封装"><a class="markdownIt-Anchor" href="#72-访问控制与封装"></a> 7.2 访问控制与封装</h2>
<ul>
<li>使用<strong>访问说明符</strong>加强<strong>类的封装性</strong>
<ul>
<li>定义在<strong>public说明符</strong>之后的成员在整个程序内可被访问
<ul>
<li>public成员定义类的接口</li>
</ul>
</li>
<li>定义在<strong>private说明符</strong>之后的成员可被类的成员函数防备,但不能在使用类的代码访问
<ul>
<li>private部分封装了类的实现细节</li>
</ul>
</li>
</ul>
</li>
<li><mark>使用class或struct关键字</mark>
<ul>
<li>使用class关键字定义类,成员默认是private的</li>
<li>使用struct关键字定义类,成员默认是public的</li>
</ul>
</li>
</ul>
<h3 id="721-友元"><a class="markdownIt-Anchor" href="#721-友元"></a> 7.2.1 友元</h3>
<ul>
<li><strong>友元</strong>：类可以允许其他类或者函数访问它的非共有成员,方法是令其他类或函数成为它的友元
<ul>
<li>只需要增加一条以friend关键字开始的函数声明语句即可</li>
<li>友元声明只能出现在类定义的内部,但类出现的具体位置不限</li>
<li><mark>友元不是类的成员也不受它所在区域访问控制级别的约束,最好再类定义开始或结束前的位置声明友元</mark></li>
</ul>
</li>
<li><strong>封装的好处</strong>
<ul>
<li>确保用户代码不会无意间破坏封装对象的状态</li>
<li>被封装的类的具体实现细节可以随时改变,而无须调整用户级别的代码</li>
<li>防止由于用户的原因造成数据被破坏</li>
</ul>
</li>
<li><strong>友元的声明</strong>
<ul>
<li><mark>如果希望类的用户能够调用某个友元函数,那么就必须在友元声明之外再专门对函数进行一次声明</mark>
<ul>
<li>为了使友元对类的用户可见,通常把友元的声明与类本身放置在同一个头文件中(类的外部)</li>
<li><mark>需要调用的友元函数,在类的外部需再次声明</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="73-类的其他特性"><a class="markdownIt-Anchor" href="#73-类的其他特性"></a> 7.3 类的其他特性</h2>
<h3 id="731-类成员再探"><a class="markdownIt-Anchor" href="#731-类成员再探"></a> 7.3.1 类成员再探</h3>
<ul>
<li>类内部的成员函数自动是inline的
<ul>
<li>可以在类内部把inline显式声明,但不推荐;最好在类外部定义的地方声明inline</li>
</ul>
</li>
<li>成员函数可以被重载</li>
<li><strong>可变数据成员</strong>
<ul>
<li><strong>使用mutable关键字</strong></li>
<li><mark>一个可变数据成员永远不会是const,即使是const对象的成员</mark></li>
<li>一个const成员函数可以改变一个可变成员的值</li>
</ul>
</li>
<li>在C++11中将默认值声明成<strong>类内初始值</strong>,可以在默认初始化时拥有默认初始值
<ul>
<li><mark>类内初始值必须使用=的初始化形式或者花括号括起来的直接初始化形式</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr;  <span class="comment">//即使在const对象内也能被修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ++access_ctr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尽管some_member是一个const成员函数,它仍然能够改变access_ctr的值</span></span><br><span class="line"><span class="comment">// 该成员是个可变成员,因此任何成员函数,包括const函数在内都能改变它的值</span></span><br></pre></td></tr></table></figure>
<h3 id="732-返回this的成员函数"><a class="markdownIt-Anchor" href="#732-返回this的成员函数"></a> 7.3.2 返回*this的成员函数</h3>
<ul>
<li><a href="#711-%E5%AE%9A%E4%B9%89%E6%94%B9%E8%BF%9B%E7%9A%84%E7%B1%BB">定义返回this对象的函数</a></li>
<li><strong>从const成员函数返回*this</strong>
<ul>
<li>一个const成员函数如果以引用的形式返回*this,那返回类型将是常量引用</li>
<li>函数声明中返回的是const类型的类引用</li>
</ul>
</li>
<li>基于const的重载
<ul>
<li><mark>区分成员函数是否是const可以对函数进行重载</mark></li>
<li><mark>非常量版本的函数对常量对象是不可用的,需要在一个常量对象上调用const成员函数;但可以在非常量对象上调用const成员函数,但建议显式匹配</mark></li>
</ul>
</li>
</ul>
<h3 id="733-类类型"><a class="markdownIt-Anchor" href="#733-类类型"></a> 7.3.3 类类型</h3>
<ul>
<li>每个类定义了唯一的类型,即使两个类的成员列表完全一致,也是不同的类型</li>
<li>可以把类名作为类型的名字使用,从而直接指向类类型
<ul>
<li>或者,也可以把类名跟在关键字class或struct后面</li>
</ul>
</li>
<li><strong>类的声明</strong>：声明类而暂时不定义
<ul>
<li>class 类名; 声明称为前向声明,向程序中引入类,但声明类之后类是一个不完全类型,不清楚包括哪些成员</li>
</ul>
</li>
</ul>
<h3 id="734-友元再探"><a class="markdownIt-Anchor" href="#734-友元再探"></a> 7.3.4 友元再探</h3>
<ul>
<li>类之间的友元关系
<ul>
<li>友元类的成员函数可以访问此类包括非公有成员在内的所有成员</li>
<li><mark>友元关系不存在传递性,每个类负责控制自己的友元类或友元函数</mark></li>
</ul>
</li>
<li><strong>令成员函数作为友元</strong>
<ul>
<li>当把一个成员函数声明为友元时,必须知名成员函数属于哪个类</li>
</ul>
</li>
<li>函数重载和友元
<ul>
<li>一个类想把一组重载函数声明为它的友元,需要对这组函数中的每一个分别声明</li>
</ul>
</li>
<li>友元声明和作用域
<ul>
<li>类和非成员函数的声明不是必须在友元声明之前</li>
<li>在类的内部定义该函数,必须在类的外部提供相应的声明从而使得函数可见
<ul>
<li>即使仅仅是用声明友元的类的成员调用该友元函数,它也必须是被声明过的</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">  <span class="comment">// windos_mgr::clear必须在Screen类之前被声明</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">  <span class="comment">// Screen类的剩余部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 必须按照如下方式设计程序：</span></span><br><span class="line"><span class="comment">// · 首先定义Window_mgr类,其中声明clear函数,但是不能定义它。在clear使用Screen的成员之前必须先声明Screen</span></span><br><span class="line"><span class="comment">// · 接下来定义Screen,包括对于clear的友元声明</span></span><br><span class="line"><span class="comment">// · 最后定义clear,此时它才可以使用Screen的成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="built_in">X</span>()&#123;<span class="built_in">f</span>();&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::g</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">f</span>();&#125;  <span class="comment">//错误f()未声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::h</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">f</span>();&#125;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="74-类的作用域"><a class="markdownIt-Anchor" href="#74-类的作用域"></a> 7.4 类的作用域</h2>
<ul>
<li>在类的作用域之外,普通的数据和函数成员只能由对象,引用或指针使用成员访问运算符进行访问</li>
<li>对于类类型成员使用作用域运算符::来访问</li>
<li>当成员函数定义在类的外部时,返回类型中使用的名字都位于类的作用域之外时,返回类型必须指明它是哪个类的成员</li>
</ul>
<h3 id="741-名字查找与类的作用域"><a class="markdownIt-Anchor" href="#741-名字查找与类的作用域"></a> 7.4.1 名字查找与类的作用域</h3>
<ul>
<li>内层作用域可以重新定义外层作用域中的名字,即使该名字已经在内层作用域中使用过</li>
<li>在类中,如果成员使用了外层作用域中的某个名字,而该名字代表一种类型,则类不能在之后重新定义该名字</li>
<li>在类中,成员函数中定义的成员会隐藏类中的同名成员,但可以使用类名或this指针强制访问成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Accout</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> bal;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> Money; <span class="comment">//错误,不能重新定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dummy_fcn</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">      cursor = width * height;   <span class="comment">//是那个参数</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不建议的写法,成员函数中的名字不应该隐藏同名的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">    cursor = width * <span class="keyword">this</span>-&gt;height;   <span class="comment">//成员height</span></span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    cursor = width * Screen::height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议的写法：不要把成员名字作为参数或其他局部变量使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos ht)</span></span>&#123;</span><br><span class="line">  cursor = width * height;   <span class="comment">//成员height</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不建议的写法,不应该隐藏外层作用域中可能用到的名字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">  cursor = width * ::height;   <span class="comment">//全局的height</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="75-构造函数再探"><a class="markdownIt-Anchor" href="#75-构造函数再探"></a> 7.5 构造函数再探</h2>
<h3 id="751-构造函数初始值列表"><a class="markdownIt-Anchor" href="#751-构造函数初始值列表"></a> 7.5.1 构造函数初始值列表</h3>
<ul>
<li>初始化const或引用类型的唯一机会就是通过构造函数初始值
<ul>
<li><mark>如果成员是const,引用,或者属于某种未提供默认构造函数的类类型,我们必须通过构造函数初始值列表为这些成员提供初值</mark></li>
</ul>
</li>
<li><strong>建议：使用构造函数初始值</strong>
<ul>
<li>在很多类中,初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员,后者则先初始化再赋值</li>
<li>除了效率问题外更重要的是,一些数据成员必须被初始化</li>
</ul>
</li>
<li><strong>构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序</strong>
<ul>
<li>但一个成员是用于另一个成员初始化时,位置关系较为重要</li>
<li><mark>最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且若可能的话,尽量避免使用某些成员初始化其他成员</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii);</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci;</span><br><span class="line">    <span class="type">int</span> &amp;ri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数体一开始执行,初始化就完成了</span></span><br><span class="line"><span class="comment">// 显式初始化引用和const成员</span></span><br><span class="line">ConstRef::<span class="built_in">ConstRef</span>(<span class="type">int</span> ii): <span class="built_in">i</span>(ii), <span class="built_in">ci</span>(ii), <span class="built_in">ri</span>(i)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="752-委托构造函数"><a class="markdownIt-Anchor" href="#752-委托构造函数"></a> 7.5.2 委托构造函数</h3>
<ul>
<li>C++11中扩展了构造函数初始值的功能,可以定义<strong>委托构造函数</strong>
<ul>
<li>委托构造函数使用它所属类的其他构造函数执行自己的初始化过程,它把自己的一些职责委托给了其他构造函数</li>
<li>委托构造函数具有成员初始化列表和一个函数体,成员初始化列表只有类名本身一个入口</li>
<li>成员初始值:类名后面紧跟着圆括号形成的参数列表,<mark>参数列表必须和类中另外一个构造函数匹配</mark></li>
<li>先执行该构造函数的函数体代码再执行被委托构造函数的函数体</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price):</span><br><span class="line">      <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(cnt*price)&#123;&#125;</span><br><span class="line">    <span class="comment">// 其他构造函数委托给另一个构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() : <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s) : <span class="built_in">Sales_data</span>(s,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;is) : Sales_data&#123;<span class="built_in">read</span>(is,*<span class="keyword">this</span>);&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="753-默认构造函数的作用"><a class="markdownIt-Anchor" href="#753-默认构造函数的作用"></a> 7.5.3 默认构造函数的作用</h3>
<ul>
<li>当对象被默认初始化或值初始化时自动执行默认构造函数</li>
<li>默认初始化在以下情况下发生：
<ul>
<li>当我们在块作用域内不使用任何初始值定义一个<strong>非静态变量</strong>或者<a href="#35-%E6%95%B0%E7%BB%84">数组</a>时</li>
<li>当一个类本身含有类类型的成员且使用合成的<a href="#714-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">默认构造函数</a></li>
<li>当类类型的成员没有在构造函数初始值列表中显式地初始化时<a href="#714-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">显式初始化</a></li>
</ul>
</li>
<li>值初始化在以下情况下发生
<ul>
<li>在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时</li>
<li>当我们不使用初始值定义一个局部静态变量时,<a href="#611-%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1">局部对象</a></li>
<li>当我们通过书写形如T( )的表达式显式地请求值初始化时,其中T是类型名(vector的一个构造函数只接受一个实参用于说明<a href="#33-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector">vector</a>大小,它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化)</li>
</ul>
</li>
</ul>
<h3 id="754-隐式的类类型转换"><a class="markdownIt-Anchor" href="#754-隐式的类类型转换"></a> 7.5.4 隐式的类类型转换</h3>
<ul>
<li><strong>类定义隐式转换规则</strong>:如果构造函数只接受一个实参,则它实际上定义了转换为此类类型的隐式转换机制,这种构造函数称作<strong>转换构造函数</strong>
<ul>
<li>在需要该类对象的地方,可以使用其他可转换的对象类型作为替代</li>
<li>只允许一步类型转换,编译器指挥自动地执行一步类型转换</li>
</ul>
</li>
<li>可以将构造函数声明为<strong>explicit</strong>抑制构造函数定义的隐式转换
<ul>
<li>explicit只对一个实参的构造函数有效</li>
</ul>
</li>
<li><strong>explicit构造函数只能用于直接初始化</strong>
<ul>
<li><strong>发生隐式转换的一种情况</strong>是当执行拷贝形式(=)的初始化时</li>
<li>以直接初始化的形式可以使用explicit构造函数抑制自动转换</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>;</span><br><span class="line"><span class="comment">// 构造一个临时的Sales_data对象</span></span><br><span class="line">item.<span class="built_in">combine</span>(null_book);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误,两步转换</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="string">&quot;9-999-99999-9&quot;</span>);</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">&quot;9-999-99999-9&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式构造</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));</span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></table></figure>
<h3 id="755-聚合类"><a class="markdownIt-Anchor" href="#755-聚合类"></a> 7.5.5 聚合类</h3>
<ul>
<li><strong>聚合类</strong>使得用户可以直接访问其成员,并且具有特殊的初始化语法形式</li>
<li>当一个类满足如下条件时,为聚合的：
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值<a href="#621-%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0">,参考</a></li>
<li><mark>没有基类,也没有virtual函数</mark></li>
</ul>
</li>
<li><mark>可以使用花括号的成员初始值列表初始化聚合类的数据成员</mark>
<ul>
<li>初始值的列表必须和声明的顺序一致</li>
<li>初始值列表中的元素个数少于类的成员数量,靠后的成员被值初始化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">  <span class="type">int</span> ival;</span><br><span class="line">  string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Data vall = &#123;<span class="number">0</span>, <span class="string">&quot;Anna&#125;;</span></span><br></pre></td></tr></table></figure>
<h3 id="756-字面值常量类"><a class="markdownIt-Anchor" href="#756-字面值常量类"></a> 7.5.6 字面值常量类</h3>
<ul>
<li><a href="#652-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0">constexpr</a>,其中提到constexpr函数的参数和返回值都必须是字面值类型</li>
<li>字面值类型的类可能含有constexpr函数成员
<ul>
<li>成员必须符合constexpr函数的所有要求,是隐式const的</li>
</ul>
</li>
<li>数据成员都是字面值类型的聚合类是字面值常量类</li>
<li>如果一个类不是聚合类,但符合下述要求,则也是一个字面值常量类：
<ul>
<li>数据成员都必须是字面值类型</li>
<li><mark>类必须至少含有一个constexpr构造函数</mark></li>
<li>如果一个数据成员含有类内初始值,则内置类型成员的初始值必须是一条常量表达式;或者如果成员属于某种类类型,则初始值必须使用成员自己的constexpr构造函数</li>
<li>类必须使用析构函数的默认定义</li>
</ul>
</li>
<li><strong>constexpr构造函数</strong>
<ul>
<li>字面值常量类的构造函数可以是constexpr函数</li>
<li>constexpr构造函数可以声明成=default的形式(或者是删除函数的形式)
<ul>
<li>否则,constexpr构造函数就必须既符合构造函数的要求(意味着不能包含返回语句),又符合constexpr函数的要求(意味着它能拥有的唯一可执行语句就是返回语句</li>
</ul>
</li>
<li><mark>由上述可知,constexpr构造函数体一般来说应该是空的</mark></li>
<li>constexpr构造函数必须初始化所有数据成员,初始值或者使用constexpr构造函数,或者是一条常量表达式
<ul>
<li>constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面值常量类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> b = <span class="literal">true</span>)</span>: hw(b),io(b),other(b)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> h, <span class="type">bool</span> i, <span class="type">bool</span> o)</span>: hw(h),io(i),other(o)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">any</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> hw||io||other;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_io</span><span class="params">(<span class="type">bool</span> b)</span></span>&#123;io=b;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_hw</span><span class="params">(<span class="type">bool</span> b)</span></span>&#123;hw=b;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_other</span><span class="params">(<span class="type">bool</span> b)</span></span>&#123;hw=b;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> hw;</span><br><span class="line">    <span class="type">bool</span> io;</span><br><span class="line">    <span class="type">bool</span> other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">io_sub</span><span class="params">(<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>)</span></span>; <span class="comment">//调试io</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">if</span>(io_sub.<span class="built_in">any</span>())</span><br><span class="line">  cerr &lt;&lt; <span class="string">&quot;print error&quot;</span> &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">prod</span><span class="params">(<span class="literal">false</span>)</span></span>;  <span class="comment">//无调试</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">if</span>(prod.<span class="built_in">any</span>())</span><br><span class="line">  cerr &lt;&lt; <span class="string">&quot;print error&quot;</span> &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="76-类的静态成员"><a class="markdownIt-Anchor" href="#76-类的静态成员"></a> 7.6 类的静态成员</h2>
<ul>
<li>声明静态成员
<ul>
<li>声明成员为<strong>static</strong>使得其<strong>与类关联在一起</strong></li>
<li>可以是public或private,可以是常量,引用,指针,类类型等</li>
</ul>
</li>
<li>类的静态成员存在于任何对象之外,对象中不包含任何与静态数据成员有关的数据
<ul>
<li><mark>静态成员函数不会与任何对象绑定在一起,不包含this指针</mark></li>
<li><mark>静态成员函数不能声明称const,且不能在静态成员函数中使用this指针</mark></li>
</ul>
</li>
<li>通过**作用域运算符::**访问静态成员,可以使用类的对象,引用或指针来访问静态成员。
<ul>
<li>成员函数不用通过作用域运算符就可以直接访问静态成员</li>
</ul>
</li>
<li><strong>定义静态成员</strong>
<ul>
<li>可以在类的内部或外部定义静态成员函数</li>
<li>在类的外部定义静态成员时,不能重复static关键字,<mark>该static关键字只能出现在类内部的声明中</mark></li>
<li>静态数据成员不属于类的任何一个对象,不是由类的构造函数初始化的,因此需要在类的外部定义和初始化每个静态成员,静态数据只能定义一次,且存在于程序的整个声明周期</li>
</ul>
</li>
<li><strong>静态成员的类内初始化</strong>
<ul>
<li>通常情况下,类的静态成员不应该在类的内部初始化</li>
<li><mark>然而,可以为静态成员提供const整数类型的类内初始值,不过要求静态成员必须是字面值常量类型的constexpr</mark></li>
<li>即使一个常量静态数据成员在类内部被初始化了,通常情况下也应该在类的外部定义一下该成员</li>
</ul>
</li>
<li><mark>静态数据可以作为默认实参,非静态数据成员不能作为默认实参,因为它的值本身属于对象的一部分</mark></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并初始化一个静态成员</span></span><br><span class="line"><span class="type">double</span> Account::interestRate = <span class="built_in">initRate</span>();</span><br><span class="line"><span class="comment">// 该对象是类Account的静态成员,其类型是double</span></span><br><span class="line"><span class="comment">// 从类名开始,这条定义语句的剩余部分就都位于类的作用域之内了</span></span><br><span class="line"><span class="comment">// 因此,可以直接使用initRate函数</span></span><br><span class="line"><span class="comment">// 注意,虽然initRate是私有的,也能用它初始化interestRate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员的类内初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>; <span class="comment">//常量表达式</span></span><br><span class="line">    <span class="type">double</span> daily_tbl[period];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="8-io库"><a class="markdownIt-Anchor" href="#8-io库"></a> 8 IO库</h1>
<ul>
<li>io库的基础设施
<ul>
<li>istream</li>
<li>ostream</li>
<li>cin</li>
<li>cout</li>
<li>cerr</li>
<li>&gt;&gt;</li>
<li>&lt;&lt;</li>
<li>getline()</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="81-io类"><a class="markdownIt-Anchor" href="#81-io类"></a> 8.1 IO类</h2>
<table>
<thead>
<tr>
<th>IO库类型和头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream,wistream从流读取数据</td>
</tr>
<tr>
<td>ostream,wistream向流写入数据</td>
<td></td>
</tr>
<tr>
<td>iostream,wiostream读写流</td>
<td></td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream,wifstream从文件读取数据</td>
</tr>
<tr>
<td>ofstream,wofstream向文件写入数据</td>
<td></td>
</tr>
<tr>
<td>fstream,wfstream读写文件</td>
<td></td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream,wistringstream从string读取数据</td>
</tr>
<tr>
<td>ostringstream,wostringstream向string写入数据</td>
<td></td>
</tr>
<tr>
<td>stringstream,wstringstream读写string</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>宽字符版本的类型和函数的名字以w开始
<ul>
<li>wcin,wcout和wcerr对应cin,cout,cerr</li>
</ul>
</li>
<li>IO类型间的关系
<ul>
<li>概念上,设备类型和字符大小都不会影响要执行的IO操作</li>
<li>标准库使我们可以忽略不同类型的流之间的差异,是通过继承机制实现的</li>
</ul>
</li>
</ul>
<h3 id="811-io对象无拷贝或赋值"><a class="markdownIt-Anchor" href="#811-io对象无拷贝或赋值"></a> 8.1.1 IO对象无拷贝或赋值</h3>
<ul>
<li><mark>不能拷贝或对IO对象赋值</mark>,<mark>因此不能将形参或返回类型设置为流类型</mark>
<ul>
<li>进行IO操作的函数通常以引用方式传递和返回流,读写一个IO对象会改变其状态,传递和返回引用不能是const</li>
</ul>
</li>
</ul>
<h3 id="812-条件状态"><a class="markdownIt-Anchor" href="#812-条件状态"></a> 8.1.2 条件状态</h3>
<table>
<thead>
<tr>
<th>IO库条件状态</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>strm::iostate</td>
<td>strm是一种IO类型,iostate是一种机器相关的类型,提供了表达条件状态的完整功能</td>
</tr>
<tr>
<td>strm::badbit</td>
<td>指出流已崩溃</td>
</tr>
<tr>
<td>strm::failbit</td>
<td>指出一个IO操作失败</td>
</tr>
<tr>
<td>strm::eofbit</td>
<td>指出流到达了文件结束</td>
</tr>
<tr>
<td>strm::goodbit</td>
<td>指出流未处于错误状态</td>
</tr>
<tr>
<td>s.eof()</td>
<td>若流s的eofbit置位,则返回true</td>
</tr>
<tr>
<td>s.fail()</td>
<td>若流s的failbit或badbit置位,则返回true</td>
</tr>
<tr>
<td>s.bad()</td>
<td>若流s的badbit置位,则返回true</td>
</tr>
<tr>
<td>s.good()</td>
<td>若流s处于有效状态,则返回true</td>
</tr>
<tr>
<td>s.clear()</td>
<td>若流s中所有条件状态位复位,将流的状态设置位有效,返回void</td>
</tr>
<tr>
<td>s.clear(flags)</td>
<td>根据给定的flags标志位,将流s中对应条件状态位复位。flags的类型位strm::iostate。返回void</td>
</tr>
<tr>
<td>s.setstate(flags)</td>
<td>根据给定的flags标志位,将流s中对应条件状态位置位。flags的类型位strm::iostate。返回void</td>
</tr>
<tr>
<td>s.rdstate()</td>
<td>返回流s的当前条件状态,返回类型位strm::iostate</td>
</tr>
</tbody>
</table>
<ul>
<li>IO库定义了一个与机器无关的iostate类型,提供了表达流状态的完整功能,这个类型作为一个位集合使用
<ul>
<li>IO库定义了4个iostate类型的constexpr值,表示特定的位状态</li>
<li>badbit表示系统级错误,通常情况下,一旦badbit被置位,流就无法再使用了</li>
<li>在发生可恢复错误后,failbit被置位,通常是可以修正的,流还可以继续使用</li>
<li>如果到达文件结束位置,eofbit和failbit都会被置位</li>
<li>goodbit的值为0,表示流未发生错误</li>
</ul>
</li>
<li>管理条件状态
<ul>
<li>流对象的rdstate成员返回一个iostate值,对应流的当前状态</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记住cin当前状态</span></span><br><span class="line"><span class="comment">// clear不接受参数的版本清除(复位)所有错误标志位</span></span><br><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();</span><br><span class="line">cin.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">process_input</span>(cin); <span class="comment">//使用cin</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);  <span class="comment">//置位会原有状态</span></span><br><span class="line"><span class="comment">// 带参数的clear版本接受一个iostate值,表示流的新状态</span></span><br><span class="line"><span class="comment">// 复位failbit和badbit,其他位保持不变</span></span><br><span class="line">cin.<span class="built_in">clear</span>(cin.rdstate &amp; ~cin.failbit &amp; ~cin.badbit);</span><br></pre></td></tr></table></figure>
<h3 id="813-管理输出缓冲"><a class="markdownIt-Anchor" href="#813-管理输出缓冲"></a> 8.1.3 管理输出缓冲</h3>
<ul>
<li>每个输出流都管理一个缓冲区,用来保存程序读写的数据</li>
<li>导致缓冲刷新的原因
<ul>
<li>程序正常结束,作为main函数的return操作的一部分,缓冲刷新被执行</li>
<li>缓冲区满时,需要刷新缓冲,而后新的数据才能继续写入缓冲区</li>
<li>可以使用操纵符如endl来显式刷新缓冲区</li>
<li>在每个输出操作之后,可以用操纵符unitbuf设置流的内部状态,来清空缓冲区
<ul>
<li>默认情况下,对cerr是设置unitbuf的,因此写到cerr的内容都是立即刷新的</li>
</ul>
</li>
<li>一个输出流可能被关联到另一个流。在这种情况下,当读写被关联的流时,关联到的流的缓冲区会被刷新
<ul>
<li>默认情况下,cin和cerr都关联到cout。因此,读cin或写cerr都会导致cout的缓冲区被刷新</li>
</ul>
</li>
</ul>
</li>
<li><strong>刷新输出缓冲区</strong>
<ul>
<li>endl</li>
<li>IO库中的flush和ends
<ul>
<li>flush刷新缓冲区,但不输出任何额外的字符</li>
<li>ends向缓冲区插入一个空字符,然后刷新缓冲区</li>
</ul>
</li>
</ul>
</li>
<li><strong>unitbu操作符</strong>
<ul>
<li>可控制不每次输出操作后都刷新缓冲区</li>
<li><strong>nounitbu</strong>重置流,使其恢复正常使用</li>
</ul>
</li>
<li><mark>程序崩溃,输出缓冲区不会被刷新</mark></li>
<li>关联输入和输出
<ul>
<li>当一个输入流被关联到一个输出流时,任何试图从输入流读取数据的操作都会先刷新关联的输出流</li>
<li><strong>标准库将cout和cin关联在一起</strong></li>
<li>tie有两个重载的版本
<ul>
<li>不带参数：返回指向输出流的指针(如果本对象当前关联到一个输出流,则返回的就是指向这个流的指针,如果对象未关联到流,则返回空指针)</li>
<li>接受一个指向ostream的指针：将自己关联到此ostream( x.tie(&amp;o)将x关联到输出流o)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;flush;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;ends;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; unitbuf;</span><br><span class="line">cout &lt;&lt; nounitbuf;</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cout);</span><br><span class="line"></span><br><span class="line">ostream *old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);</span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie);</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="82-文件输入输出"><a class="markdownIt-Anchor" href="#82-文件输入输出"></a> 8.2 文件输入输出</h2>
<ul>
<li>头文件fstream定义了三个类型来支持文件IO：
<ul>
<li>ifstream从一个给定文件读取数据</li>
<li>ofstream向一个给定文件写入数据</li>
<li>fstream可以读写给定文件</li>
</ul>
</li>
<li>使用IO运算符读写文件,可以用getline从一个ifstream读取数据</li>
</ul>
<table>
<thead>
<tr>
<th>fstream特有的操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>fstream fstrm</td>
<td>创建一个未绑定的文件流。fstream时头文件fstream中定义的一个类型</td>
</tr>
<tr>
<td>fstream fstrm(s)</td>
<td>创建一个未绑定的文件流,并打开名为s的文件</td>
</tr>
<tr>
<td>fstream fstrm(s,mode)</td>
<td>创建一个未绑定的文件流,以mode打开名为s的文件</td>
</tr>
<tr>
<td>fstrm.open(s)</td>
<td>打开名为s的文件,并将文件与fstrm绑定</td>
</tr>
<tr>
<td>fstrm.close()</td>
<td>关闭于fstrm绑定的文件,返回void</td>
</tr>
<tr>
<td>fstrm.is_open()</td>
<td>返回一个bool值,指出与fstrm关联的文件是否成功打开且尚未关闭</td>
</tr>
</tbody>
</table>
<h3 id="821-使用文件流对象"><a class="markdownIt-Anchor" href="#821-使用文件流对象"></a> 8.2.1 使用文件流对象</h3>
<ul>
<li>想要读写一个文件时,可以定义一个文件流对象,并将对象与文件关联起来,每个文件流类都定义了一个名为open的成员函数,完成一些系统相关的操作,用来定位给定的文件,并视情况打开为读或写模式</li>
<li><strong>用fstream代替iostream&amp;</strong>
<ul>
<li>在要求使用基类型对象的地方,可以用继承类型的对象来替代</li>
<li>接受一个iostream类型引用(或指针)参数的函数,可以用一个对应的fstream(或sstream)类型来调用
<ul>
<li>如果有一个函数接受一个ostream&amp;参数,在调用这个函数时,可以传递给它一个ofstream对象,对istream&amp;和ifstream也是类似的</li>
</ul>
</li>
</ul>
</li>
<li><strong>成员函数open和close</strong>
<ul>
<li>定义一个文件流对下昂,随后可以调用open将文件关联起来(调用open失败,failbit会被置位)</li>
</ul>
</li>
<li><strong>自动析构</strong>：当一个fstream对象被销毁时,close会自动被调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>; <span class="comment">//构建一个ifstream并代开给定文件</span></span><br><span class="line">ofstream out; <span class="comment">//输出文件流未关联到任何文件</span></span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>])</span></span>;  <span class="comment">//打开销售记录文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">output</span><span class="params">(argv[<span class="number">2</span>])</span></span>;</span><br><span class="line">Sales_data total;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(input,total))&#123;</span><br><span class="line">  Sales_data trans;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">read</span>(input,trans))&#123;</span><br><span class="line">    <span class="keyword">if</span>(total.<span class="built_in">isbn</span>()==trans.<span class="built_in">isbn</span>())</span><br><span class="line">      total.<span class="built_in">combine</span>(trans);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">print</span>(output,total)&lt;&lt;endl;</span><br><span class="line">      total = trans;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(out,total) &lt;&lt;endl;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  cerr&lt;&lt;<span class="string">&quot;No data?!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open文件流</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;</span><br><span class="line">ofstream out;</span><br><span class="line">out.<span class="built_in">open</span>(ifile + <span class="string">&quot;.copy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(out) <span class="comment">//检测open是否成功</span></span><br><span class="line"></span><br><span class="line">in.close;</span><br><span class="line">in.<span class="built_in">open</span>(ifile + <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="822-文件模式"><a class="markdownIt-Anchor" href="#822-文件模式"></a> 8.2.2 文件模式</h3>
<table>
<thead>
<tr>
<th>文件模式</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>以读方式打开</td>
</tr>
<tr>
<td>out</td>
<td>以写方式打开</td>
</tr>
<tr>
<td>app</td>
<td>每次写操作前均定位到文件末尾</td>
</tr>
<tr>
<td>ate</td>
<td>打开文件后立即定位到文件末尾</td>
</tr>
<tr>
<td>trunc</td>
<td>截断文件</td>
</tr>
<tr>
<td>binary</td>
<td>以二进制方式进行IO</td>
</tr>
</tbody>
</table>
<ul>
<li>只可以对ofstream或fstream对象设定out模式</li>
<li>只可以对ifstream或fstream对象设定in模式</li>
<li>只有当out也被设定时才可设定trunc模式</li>
<li>只要trunc没被设定,就可以设定app模式。在app模式下,即使没有显式指定out模式,文件也总是以输出方式被打开</li>
<li>默认情况下,即使我们没有指定trunc,以out模式打开的文件也会被截断。为了保留以out模式打开的文件的内容,我们必须同时指定app模式,这样只会将数据追加写到文件末尾;或者同时指定in模式,即打开文件同时进行读写操作</li>
<li>ate和binary模式可用于任何类型的文件流对象,且可以与其他任何文件模式组合使用</li>
<li>每个文件流类型都定义了一个默认的文件模式,当我们未指定文件模式时,就使用此默认模
<ul>
<li>与ifstream关联的文件默认以in模式打开</li>
<li>与ofstream关联的文件默认以out模式打开</li>
<li>与fstream关联的文件默认以in和out模式打开</li>
</ul>
</li>
<li><mark>在每次打开文件时,都要设置文件模式,可能是显式地设置,也可能是隐式地设置。当程序未指定模式时,就使用默认值</mark></li>
</ul>
</div><div class="story post-story"><h2 id="83-string流"><a class="markdownIt-Anchor" href="#83-string流"></a> 8.3 string流</h2>
<ul>
<li>istringstream从string读取数据</li>
<li>ostringstream向string写入数据</li>
<li>stringstream既可从string读数据也可向string写数据</li>
</ul>
<table>
<thead>
<tr>
<th>stringstream特有地操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>sstream strm;</td>
<td>strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的一个类型</td>
</tr>
<tr>
<td>sstream strm(s);</td>
<td>strm是一个sstream对象。保存string s的一个拷贝。此构造函数时explicit的</td>
</tr>
<tr>
<td>strm.str()</td>
<td>返回strm所保存的string的拷贝</td>
</tr>
<tr>
<td>strm.str(s)</td>
<td>将string s拷贝strm中。返回void</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>使用istringstream</strong>：当某些工作是对整行文本进行处理,而其他一些工作是处理行内的单个单词时,通常可以使用istringstream</li>
<li><strong>使用ostringstream</strong>：当逐步构造输出,希望最后一起打印时,ostringstream是很有用的</li>
</ul>
<h1 id="9-序容器"><a class="markdownIt-Anchor" href="#9-序容器"></a> 9 序容器</h1>
<ul>
<li>顺序容器为程序员提供了控制元素存储和访问顺序的能力</li>
</ul>
</div><div class="story post-story"><h2 id="91-顺序容器概述"><a class="markdownIt-Anchor" href="#91-顺序容器概述"></a> 9.1 顺序容器概述</h2>
<table>
<thead>
<tr>
<th>顺序容器类型</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素会很慢</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td>
</tr>
<tr>
<td>list</td>
<td>双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快</td>
</tr>
<tr>
<td>forward_list</td>
<td>单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度很快</td>
</tr>
<tr>
<td>array</td>
<td>固定大小数组。支持快速随机访问。不能添加或删除元素</td>
</tr>
<tr>
<td>string</td>
<td>与vector相似的容器,但专门用于保存字符。随机访问快。在尾部插入/删除速度快</td>
</tr>
</tbody>
</table>
<ul>
<li>除了固定大小的array外,其他容器都提供高效,灵活的内存管理
<ul>
<li>可以添加和删除元素,扩张和收缩容器的大小</li>
<li>string和vector将元素保存在连续的内存空间中
<ul>
<li>可以由元素的下标来计算其地址是非常快速的,两个容器的中间位置添加和删除元素会非常耗时</li>
</ul>
</li>
<li>list和forward_list两个容器的设计目的是令容器任何位置的添加和删除都很快捷,但不支持元素的随机访问(为了访问元素只能遍历整个容器),其额外内存开销也很大</li>
<li>deque中间的位置添加或删除元素的代价很高,但在两端添加或删除元素很快,与list和forward_list添加删除元素的速度相当</li>
</ul>
</li>
<li>C++11中新添加的类型,forward_list和array
<ul>
<li>与内置数组类似,array对象的大小是固定的
<ul>
<li>array不支持添加和删除元素以及改变容器大小的操作</li>
</ul>
</li>
<li>forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能
<ul>
<li><mark>因此forward_list没有size操作,因为保存或计算其大小就会比手写链表多出额外的开销</mark></li>
<li>对其他容器而言,size保证是一个快速的常量时间的操作</li>
</ul>
</li>
</ul>
</li>
<li>选择容器的基本原则
<ul>
<li>除非你有很好的理由选择其他容器,否则应使用vector</li>
<li>如果程序有很多小的元素,且空间的额外开销很重要,则不要使用list或forward_list</li>
<li>如果程序要求随机访问元素,应使用vector或deque</li>
<li>如果程序要求在容器的中间插入或删除元素,应使用list或forward_list</li>
<li>如果程序需要在头尾位置插入或删除元素,但不会在中间位置进行插入或删除操作,则使用deque</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素,随后需要随机访问元素,则
<ul>
<li>首先,确定是否真的需要在容器中间位置添加元素。当处理输入数据时,通常可以很容易地向vector追加数据,然后再调用标准库的sort函数来重排容器中的元素,从而避免在中间位置添加元素</li>
<li>如果必须在中间位置插入元素,考虑在输入阶段使用list,一旦输入完成,将list中的内容拷贝到一个vector中</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="92-容器库概览"><a class="markdownIt-Anchor" href="#92-容器库概览"></a> 9.2 容器库概览</h2>
<ul>
<li>每个容器都定义在一个头文件中,文件名与类型名相同,容器均为模板类</li>
<li>对容器可保存的元素类型的限制
<ul>
<li>顺序容器可以保存任意类型的元素,特别是,可以定义一个容器,其元素类型是另一个容器</li>
<li>可以为不支持特定操作需求的类型定义容器(但只能使用那些没有特殊需求的容器操作)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>容器操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型别名</strong></td>
<td>-</td>
</tr>
<tr>
<td>iterator</td>
<td>此容器类型的迭代器类型</td>
</tr>
<tr>
<td>const_iterator</td>
<td>可以读取元素,但不能修改元素的迭代器类型</td>
</tr>
<tr>
<td>size_type</td>
<td>无符号整数类型,足够保存此种容器类型最大可能容器的大小</td>
</tr>
<tr>
<td>difference_type</td>
<td>带符号整数类型,足够保存两个迭代器之间的距离</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>reference</td>
<td>元素的左值类型,与value_type&amp;含义相同</td>
</tr>
<tr>
<td>const_reference</td>
<td>元素的const左值类型,与const value_type&amp;含义相同</td>
</tr>
<tr>
<td><strong>构造函数</strong></td>
<td>-</td>
</tr>
<tr>
<td>C c</td>
<td>默认构造函数,构造空容器</td>
</tr>
<tr>
<td>C c1(c2)</td>
<td>构造c2的拷贝c1</td>
</tr>
<tr>
<td>C c(b,e)</td>
<td>构造c,将迭代器b和e指定的范围内的元素拷贝到c</td>
</tr>
<tr>
<td>C c{a,b,c…}</td>
<td>列表初始化c</td>
</tr>
<tr>
<td><strong>赋值与swap</strong></td>
<td>-</td>
</tr>
<tr>
<td>c1=c2</td>
<td>将c1中的元素替换成c2中元素</td>
</tr>
<tr>
<td>c1={…}</td>
<td>将c1中的元素替换成列表中元素</td>
</tr>
<tr>
<td>a.swap(b)</td>
<td>交换a和b的元素</td>
</tr>
<tr>
<td>swap(a,b)</td>
<td>交换a和b的元素</td>
</tr>
<tr>
<td><strong>大小</strong></td>
<td>-</td>
</tr>
<tr>
<td>c.size()</td>
<td>c中的元素数目(不支持forward_list)</td>
</tr>
<tr>
<td>c.max_size()</td>
<td>c中可保存的最大元素数目</td>
</tr>
<tr>
<td>c.empty()</td>
<td>c保存了元素返回false</td>
</tr>
<tr>
<td><strong>添加/删除元素(不适用于array)</strong></td>
<td>-</td>
</tr>
<tr>
<td>c.insert(args)</td>
<td>将args中的元素拷贝进c</td>
</tr>
<tr>
<td>c.emplace(inits)</td>
<td>使用inits构造c中的一个元素</td>
</tr>
<tr>
<td>c.erase(args)</td>
<td>删除args指定的元素</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除c中的所有元素</td>
</tr>
<tr>
<td>关系运算符</td>
<td>-</td>
</tr>
<tr>
<td>==,!=</td>
<td>所有容器都支持相等运算符</td>
</tr>
<tr>
<td>&lt;,&gt;=,&lt;=,&gt;=</td>
<td>关系运算符(无序容器不支持)</td>
</tr>
<tr>
<td><strong>获取迭代器</strong></td>
<td>-</td>
</tr>
<tr>
<td>c.begin() c.end()</td>
<td>返回迭代器</td>
</tr>
<tr>
<td>c.cbegin() c.cend()</td>
<td>返回const_iterator</td>
</tr>
<tr>
<td><strong>反向容器的额外成员(不支持forward_list</strong></td>
<td>-</td>
</tr>
<tr>
<td>reverse_iterator</td>
<td>逆序寻址元素的迭代器</td>
</tr>
<tr>
<td>const_reverse_iterator</td>
<td>不能修改元素的逆序迭代器</td>
</tr>
<tr>
<td>c.rbegin() c.rend()</td>
<td>返回reverse_iterator</td>
</tr>
<tr>
<td>c.crbegin() c.crend()</td>
<td>返回const_reverse_iterator</td>
</tr>
</tbody>
</table>
<h3 id="921-迭代器"><a class="markdownIt-Anchor" href="#921-迭代器"></a> 9.2.1 迭代器</h3>
<ul>
<li>与容器一样,迭代器有公共的接口：迭代器提供的操作的实现方式都是相同的
<ul>
<li>forward_list迭代器不支持递减运算符</li>
</ul>
</li>
<li>迭代器范围
<ul>
<li>一个迭代器范围由一对迭代器表示,两个迭代器分别指向同一容器中的元素(begin,first)或者尾元素(end,last,尾元素的下一个元素)之间的元素</li>
<li>元素范围为<strong>左闭合区间</strong></li>
</ul>
</li>
<li>构成范围的迭代器的要求
<ul>
<li>两个迭代器begin和end构成一个迭代器
<ul>
<li>指向同一容器的元素,或者是容器最后一个元素之后的位置,且可以通过递增begin到达end</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="923-begin和end成员"><a class="markdownIt-Anchor" href="#923-begin和end成员"></a> 9.2.3 begin和end成员</h3>
<ul>
<li>begin和end操作生成指向容器第一个元素和尾元素之后位置的迭代器,形成一个包含容器内所有元素的迭代器范围</li>
<li>带r的反向迭代器</li>
<li>带c的返回const迭代器的版本
<ul>
<li>C++11新引入的,用于支持auto与begin和end函数相结合</li>
<li><mark>当不需要写访问时,应该使用cbegin和cend</mark></li>
</ul>
</li>
</ul>
<h3 id="924-容器定义和初始化"><a class="markdownIt-Anchor" href="#924-容器定义和初始化"></a> 9.2.4 容器定义和初始化</h3>
<table>
<thead>
<tr>
<th>容器定义和初始化</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>C c</td>
<td>默认构造函数,构造空容器,若C是array,则c中元素按默认方式初始化</td>
</tr>
<tr>
<td>C c1(c2)</td>
<td>构造c2的拷贝c1</td>
</tr>
<tr>
<td>C c1 = c2</td>
<td>相同的容器类型,且保存的是相同的元素类型;对于array还应具有相同的大小</td>
</tr>
<tr>
<td>C c{a,b,c…}</td>
<td>列表初始化c</td>
</tr>
<tr>
<td>C c = {a,b,c…}</td>
<td>列表初始化c</td>
</tr>
<tr>
<td>C c(b,e)</td>
<td>构造c,将迭代器b和e指定的范围内的元素拷贝到c</td>
</tr>
<tr>
<td>只有顺序容器(不包括array)的构造函数才可以接受大小参数</td>
<td>-</td>
</tr>
<tr>
<td>C seq(n)</td>
<td>seq包含n个元素,这些元素进行值初始化;此构造函数是explicit</td>
</tr>
<tr>
<td>C seq(n,t)</td>
<td>seq包含n个初始值为t的元素</td>
</tr>
</tbody>
</table>
<ul>
<li>将一个容器初始化为另一个容器的拷贝
<ul>
<li>可以直接拷贝整个容器
<ul>
<li>两个容器的类型及其元素类型必须匹配</li>
</ul>
</li>
<li>拷贝由一个迭代器对指定元素范围
<ul>
<li>新容器和原容器中元素类型可以不同,只要能将拷贝元素转换为要初始化的容器的元素类型即可</li>
<li>构造函数接受两个迭代器参数,为第一个元素和尾元素之后的元素</li>
</ul>
</li>
</ul>
</li>
<li>列表初始化
<ul>
<li>C++11中可以对容器进行列表初始化,显式指定容器中每个元素的值</li>
</ul>
</li>
<li>与顺序容器大小相关的构造函数
<ul>
<li>接受一个容器大小和一个可选的元素初始值</li>
<li><mark>只有顺序容器的构造函数才接受大小参数,关联容器并不支持</mark></li>
</ul>
</li>
<li>标准库array由固定大小
<ul>
<li>定义array时不仅要指定元素类型,也要指定大小</li>
<li>不支持普通的容器构造函数,一个默认构造的array非空,包含于大小一样多的默认初始化的元素</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>,<span class="string">&quot;Shakespeare&quot;</span>,<span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;    <span class="comment">//正确</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span><span class="params">(authors)</span></span>;  <span class="comment">//错误,容器类型不匹配</span></span><br><span class="line"><span class="function">forward_list&lt;string&gt; <span class="title">words</span><span class="params">(articles.begin(),articles.end())</span></span>;  <span class="comment">//正确,可以将const char*元素转换为string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝元素,直到(不包括)it指向的元素</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span><span class="params">(authors.begin(),it)</span></span>;</span><br><span class="line"></span><br><span class="line">array&lt;<span class="type">int</span>,42&gt;   <span class="comment">//保存42个int的数组</span></span><br><span class="line">array&lt;<span class="type">int</span>,10&gt;::size_type i;   <span class="comment">//数组类型包括元素类型和大小</span></span><br></pre></td></tr></table></figure>
<h3 id="925-赋值和swap"><a class="markdownIt-Anchor" href="#925-赋值和swap"></a> 9.2.5 赋值和swap</h3>
<table>
<thead>
<tr>
<th><strong>赋值与swap</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>c1=c2</td>
<td>将c1中的元素替换成c2中元素</td>
</tr>
<tr>
<td>c1={…}</td>
<td>将c1中的元素替换成列表中元素</td>
</tr>
<tr>
<td>a.swap(b)</td>
<td>交换a和b的元素</td>
</tr>
<tr>
<td>swap(a,b)</td>
<td>交换a和b的元素</td>
</tr>
<tr>
<td>assign操作不适用于关联容器和array</td>
<td>-</td>
</tr>
<tr>
<td>seq.assign(b,e)</td>
<td>将seq中的元素替换为迭代器b和e所表示的范围中的元素</td>
</tr>
<tr>
<td>seq.assign(il)</td>
<td>将seq中的元素替换为初始化列表il中的元素</td>
</tr>
<tr>
<td>seq.assign(n,t)</td>
<td>将seq中的元素替换为n个值为t的元素</td>
</tr>
</tbody>
</table>
<ul>
<li>赋值相关操作会导致指向坐标容器内部的迭代器,引用和指针失效</li>
<li>swap会将容器内容交换,不会导致指向容器的迭代器,引用和指针失效(容器类型为array和string除外)</li>
<li>使用assign(仅顺序容器)
<ul>
<li>允许从一个不同但相容的类型赋值,或者从容器的一个子序列赋值</li>
<li><mark>由于其旧元素被替换,因此传递给assign的迭代器不能指向调用assign的容器</mark></li>
</ul>
</li>
<li>使用swap
<ul>
<li>除array外,swap不对任何元素进行拷贝、删除或插入操作,因此可以保证在常数时间内完成</li>
</ul>
</li>
</ul>
<h3 id="927-关系运算符"><a class="markdownIt-Anchor" href="#927-关系运算符"></a> 9.2.7 关系运算符</h3>
<ul>
<li>每个容器类型都支持相等运算符</li>
<li>除了无序关联容器外的所有容器都支持关系运算符</li>
<li>比较两个容器实际上是进行元素的逐对比较
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等,则这两个容器相等;否则两个容器不等</li>
<li>如果两个容器大小不同,但较小容器中每个元素都等于较大容器中的对应元素,则较小容器小于较大容器</li>
<li>如果两个容器都不是另一个容器的前缀子序列,则它们的比较结果取决于第一个不相等的元素的比较结果</li>
</ul>
</li>
<li><mark>只有当其元素类型也定义了相应的比较运算符时,才可以使用关系运算符来比较两个容器</mark>
<ul>
<li>容器的相等运算符实际上是使用元素的==运算符实现比较的,而其他关系运算符是使用元素的&lt;运算符</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="93-顺序容器操作"><a class="markdownIt-Anchor" href="#93-顺序容器操作"></a> 9.3 顺序容器操作</h2>
<h3 id="931-向顺序容器添加元素"><a class="markdownIt-Anchor" href="#931-向顺序容器添加元素"></a> 9.3.1 向顺序容器添加元素</h3>
<ul>
<li><mark>除array外,所有的标准库容器提供灵活的内存管理,在运行时可以动态添加或删除元素来改变容器大小</mark>
<ul>
<li>forward_list有自己版本的insert和emplace</li>
<li>forward_list不支持push_back和emplace_back</li>
<li>vector和string不支持push_front和emplace_front</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>向顺序容器添加元素的操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.push_back(t)</td>
<td>在c的尾部创建一个值为t或由args创建的元素</td>
</tr>
<tr>
<td>c.emplace_back(t)</td>
<td>在c的尾部创建一个值为t或由args创建的元素</td>
</tr>
<tr>
<td>c.push_front(t)</td>
<td>在c的头部创建一个值为t或由args创建的元素</td>
</tr>
<tr>
<td>c.emplace_front(t)</td>
<td>在c的头部创建一个值为t或由args创建的元素</td>
</tr>
<tr>
<td>c.insert(p,t)</td>
<td>在迭代器p指向的元素之前创建一个值为t的元素。返回指向新添加元素的迭代器</td>
</tr>
<tr>
<td>c.emplace(p,args)</td>
<td>在迭代器p指向的元素之前创建一个值为t的元素。返回指向新添加元素的迭代器</td>
</tr>
<tr>
<td>c.insert(p,n,t)</td>
<td>在迭代器p指向的元素之前创建n个值为t的元素。返回指向新添加的第一个元素的迭代器</td>
</tr>
<tr>
<td>c.insert(p,b,e)</td>
<td>将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前</td>
</tr>
<tr>
<td>c.insert(p,il)</td>
<td>il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器;若列表为空,则返回p</td>
</tr>
</tbody>
</table>
<ul>
<li>向一个vector,string或deque插入元素会使所有指向容器的迭代器,引用和指针失效</li>
<li><strong>使用push_back</strong>
<ul>
<li>除了array和forward_list之外,每个顺序容器都支持push_back</li>
<li><mark>当用一个对象来初始化容器时,或将一个对象插入到容器中时,实际上放入到容器中的是对象值的一个拷贝,而不是对象本身</mark></li>
</ul>
</li>
<li><strong>使用push_front</strong>
<ul>
<li>list,forward_list和deque还支持push_front,将元素插入到容器头部</li>
<li>deque提供了随机访问元素的能力,且支持push_front,但vector具有随机访问的能力不支持push_front,插入元素非常耗时</li>
</ul>
</li>
<li><strong>在容器特定位置添加元素</strong>：insert成员,vector、deque、list和string都支持insert成员,但vector、deque和string插入元素耗时</li>
<li><strong>插入范围内元素</strong>：insert带参数的版本</li>
<li><strong>使用emplace操作</strong>
<ul>
<li>emplace_front、emplace和emplace_back,这些操作构造而不是拷贝元素,分别对应push_front、insert和push_back,允许将元素放置在容器头部、一个指定位置之前或容器尾部</li>
<li>当调用push或insert成员函数时,将元素类型的对象传递给它们,这些对象被拷贝到容器中</li>
<li>而当调用一个emplace成员函数时,则是将参数传递给元素类型的构造函数,emplace成员使用这些参数在容器管理的内存空间中直接构造元素(传递给emplace函数的参数必须和构造函数相匹配)</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在c的末尾构造一个Sales_data对象</span></span><br><span class="line"><span class="comment">// 使用三个参数的Sales_data构造函数</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(<span class="string">&quot;978-0590353403&quot;</span>,<span class="number">25</span>,<span class="number">15.99</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个临时的对象传递给push_back</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;978-0590353403&quot;</span>,<span class="number">25</span>,<span class="number">15.99</span>));</span><br></pre></td></tr></table></figure>
<h3 id="932-访问元素"><a class="markdownIt-Anchor" href="#932-访问元素"></a> 9.3.2 访问元素</h3>
<ul>
<li>包括array在内的每个顺序容器都有一个front成员函数,而除forward_list之外的所有顺序容器都有一个back成员函数,分别返回首元素和尾元素的引用
<ul>
<li>间接的方法：通过解引用begin返回的迭代器来获取首元素的引用,以及通过递减然后解引用end返回的迭代器来获得尾元素的引用</li>
</ul>
</li>
<li>at和下标操作只适用于string,vector,deque和array
<ul>
<li>back不适用于forward_list</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>在顺序容器中访问元素的操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.back()</td>
<td>返回c中尾元素的引用。若c为空,函数行为未定义</td>
</tr>
<tr>
<td>c.front()</td>
<td>返回c中首元素的引用。若c为空,函数行为未定义</td>
</tr>
<tr>
<td>c[n]</td>
<td>返回c中下标未n的元素的引用</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://c.at">c.at</a>(n)</td>
<td>返回下标未n的元素引用</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>访问成员函数返回的是引用</strong>：在容器中访问元素的成员函数返回的都是引用
<ul>
<li>如果容器是一个const对象,则返回值是const的引用</li>
<li><mark>如果使用auto变量来保存函数的返回值,使用此变量来改变元素的值,应将变量定义为引用类型</mark></li>
</ul>
</li>
<li><strong>安全的随机访问</strong>：使用at函数,类似下标运算符,若下标越界则抛出out_of_range异常</li>
</ul>
<h3 id="933-删除元素"><a class="markdownIt-Anchor" href="#933-删除元素"></a> 9.3.3 删除元素</h3>
<ul>
<li>forward_list由特殊版本的erase</li>
<li>forward_list不支持pop_back;vector和string不支持pop_front</li>
<li>删除deque中除首尾位置之外的任何元素都会使所有迭代器,引用和指针失效
<ul>
<li>指向vector或string中删除点之后位置的迭代器,引用和指针都会失效</li>
</ul>
</li>
<li>删除元素的成员函数并不检查其参数,在删除之前必须确保它们使存在的</li>
</ul>
<table>
<thead>
<tr>
<th><strong>顺序容器的删除操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.pop_back()</td>
<td>删除c中尾元素</td>
</tr>
<tr>
<td>c.pop_front()</td>
<td>删除c中首元素</td>
</tr>
<tr>
<td>c.erase(p)</td>
<td>删除迭代器p所指的元素,返回一个指向被删元素之后元素的迭代器,若p指向尾元素,则返回尾后迭代器</td>
</tr>
<tr>
<td>c.erase(b,e)</td>
<td>删除迭代器b和e所指范围内的元素</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除c中的所有元素,返回void</td>
</tr>
</tbody>
</table>
<h3 id="934-特殊的forward_list操作"><a class="markdownIt-Anchor" href="#934-特殊的forward_list操作"></a> 9.3.4 特殊的forward_list操作</h3>
<table>
<thead>
<tr>
<th><strong>在forward_list中插入或删除元素的操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>lst.before_begin()</td>
<td>返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用</td>
</tr>
<tr>
<td>lst.cbefore_begin()</td>
<td>-</td>
</tr>
<tr>
<td>lst.insert_after(p,t)</td>
<td>在迭代器p之后的位置插入元素。t是一个对象</td>
</tr>
<tr>
<td>lst.insert_after(p,n,t)</td>
<td>在迭代器p之后的位置插入元素。t是一个对象,n是数量</td>
</tr>
<tr>
<td>lst.insert_after(p,b,e)</td>
<td>b,e表示范围的一对迭代器</td>
</tr>
<tr>
<td>lst.insert_after(p,il)</td>
<td>il是一个花括号列表</td>
</tr>
<tr>
<td>emplace_after(p,args)</td>
<td>使用args在p指定的位置之后创建一个元素</td>
</tr>
<tr>
<td>lst.erase_after(p)</td>
<td>删除p指向的位置之后的元素</td>
</tr>
<tr>
<td>lst.erase_after(b,e)</td>
<td>删除b之后直到e之间的元素</td>
</tr>
</tbody>
</table>
<h3 id="935-改变容器大小"><a class="markdownIt-Anchor" href="#935-改变容器大小"></a> 9.3.5 改变容器大小</h3>
<ul>
<li>resize来增大或缩小容器(array不支持resize)
<ul>
<li>如果当前大小大于所要求的大小,容器后部的元素会被删除</li>
<li>如果当前大小小于新大小,会将新元素添加到容器后部</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>顺序容器大小操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.resize(n)</td>
<td>调整c的大小为n个元素</td>
</tr>
<tr>
<td>c.resize(n,t)</td>
<td>调整c的大小为n个元素,任何新添加的元素都初始化为值t</td>
</tr>
</tbody>
</table>
<h3 id="936-容器操作可能是迭代器失效"><a class="markdownIt-Anchor" href="#936-容器操作可能是迭代器失效"></a> 9.3.6 容器操作可能是迭代器失效</h3>
<ul>
<li>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误,很可能引起与使用未初始化指针一样的问题</li>
<li>在向容器添加元素后：
<ul>
<li>如果容器是vector或string,且存储空间被重新分配,则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配,指向插入位置之前的元素的迭代器、指针和引用仍有效,但指向插入位置之后元素的迭代器、指针和引用将会失效</li>
<li>对于deque,插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素,迭代器会失效,但指向存在的元素的引用和指针不会失效</li>
<li>对于list和forward_list,指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍有效。<br />
当我们从一个容器中删除元素后,指向被删除元素的迭代器、指针和引用会失效,这应该不会令人惊讶。毕竟,这些元素都已经被销毁了。当我们删除一个元素后：
<ul>
<li>对于list和forward_list,指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、引用和指针仍有效</li>
<li>对于deque,如果在首尾之外的任何位置删除元素,那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素,则尾后迭代器也会失效,但其他迭代器、引用和指针不受影响;如果是删除首元素,这些也不会受影响</li>
<li>对于vector和string,指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时,尾后迭代器总是会失效</li>
</ul>
</li>
</ul>
</li>
<li><mark>不要保存end返回的迭代器</mark></li>
</ul>
</div><div class="story post-story"><h2 id="94-vector对象是如何增长的"><a class="markdownIt-Anchor" href="#94-vector对象是如何增长的"></a> 9.4 vector对象是如何增长的</h2>
<ul>
<li>vector和string的实现通常会分配比新的空间需求更大的内存空间,容器预留了这些文件作为备用,用来保存更多的新元素
<ul>
<li>这种策略比每次添加新元素时重新分配内存空间高效,实际性能表现的足够好</li>
</ul>
</li>
<li><strong>管理容器的成员函数</strong>
<ul>
<li>vector和string类型提供了一些成员函数,允许我们与它的实现中内存分配部分互动</li>
<li>capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素</li>
<li>reserve操作允许我们通知容器它应该准备保存多少个元素</li>
</ul>
</li>
<li>shrink_to_fit只适用于vector,string和deque
<ul>
<li>capacity和reserve只适用于vector和string</li>
<li>reserve并不改变容器中元素的数量,它仅影响vector预先分配多大的内存空间
<ul>
<li>如果需求大小大于当前容量,reserve至少分配与需求一样大的内存空间(可能更大)</li>
<li>如果需求大小小于或等于当前容量,reserve什么也不做(且容器不会退回内存空间)</li>
</ul>
</li>
</ul>
</li>
<li>在C++11中,可以调用shrink_to_fit来要求deque、vector或string退回不需要的内存空间
<ul>
<li>此函数指出不再需要任何多余的内存空间</li>
<li>但具体的实现可以选择忽略此请求(调用shrink_to_fit也并不保证一定退回内存空间)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>容器大小管理操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.shrink_to_fit()</td>
<td>将capacity()减少为于size()相同大小</td>
</tr>
<tr>
<td>c.capacity()</td>
<td>不重新分配内存空间的话,c可以保存多少元素</td>
</tr>
<tr>
<td>c.reserve(n)</td>
<td>分配至少能容纳n个元素的内存空间</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>capacity和size</strong>
<ul>
<li><strong>size</strong>：指它已经保存的元素的数目</li>
<li><strong>capacity</strong>：在不分配新的内存空间的前提下最多可以保存多少元素</li>
</ul>
</li>
<li>每个vector实现都可以选择自己的内存分配策略
<ul>
<li>但必须遵守的一条原则：只有当迫不得已时才可以分配新的内存空间</li>
<li>只有在执行insert操作时size与capacity相等,或者调用resize或reserve时给定的大小超过当前capacity,vector才可能重新分配内存空间</li>
</ul>
</li>
<li>虽然不同的实现可以采用不同的分配策略,但所有实现都应遵循一个原则：
<ul>
<li>确保用push_back向vector添加元素的操作有高效率</li>
<li>从技术角度说,就是通过在一个初始为空的vector上调用n次push_back来创建一个n个元素的vector,所花费的时间不能超过n的常数倍</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="95-额外的string操作"><a class="markdownIt-Anchor" href="#95-额外的string操作"></a> 9.5 额外的string操作</h2>
<h3 id="951-构造string的其他方法"><a class="markdownIt-Anchor" href="#951-构造string的其他方法"></a> 9.5.1 构造string的其他方法</h3>
<p><a href="#924-%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96">容器定义和初始化方法</a></p>
<table>
<thead>
<tr>
<th><strong>string支持的其他构造函数</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s(cp,n)</td>
<td>s是cp指向的数组中前n个字符的拷贝,此数组至少应该包括n个字符</td>
</tr>
<tr>
<td>string s(s2,pos2)</td>
<td>s是string s2从下标pos2开始的字符的拷贝</td>
</tr>
<tr>
<td>string s(s2,pos2,len2)</td>
<td>s是string s2从下标pos2开始len2个字符的拷贝</td>
</tr>
</tbody>
</table>
<ul>
<li>构造函数接受一个string或一个const char*参数
<ul>
<li>传递一个string时可以给定一个下标来指出从哪里开始拷贝</li>
<li>传递const char*时指针指向的数组必须以空字符结尾,拷贝操作时遇到空字符时停止</li>
<li>传递构造函数一个计数值,数组就不必以空字符结尾</li>
</ul>
</li>
<li><strong>substr操作</strong>
<ul>
<li>s.substr(pos,n) 返回一个string,包含s中从pos开始的n个字符的拷贝。pos的默认值为0.n的默认值为s.size()-pos,即拷贝从pos开始的所有字符</li>
</ul>
</li>
</ul>
<h3 id="952-改变string的其他方法"><a class="markdownIt-Anchor" href="#952-改变string的其他方法"></a> 9.5.2 改变string的其他方法</h3>
<table>
<thead>
<tr>
<th><strong>修改string的操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.insert(pos,args)</td>
<td>在pos之前插入args指定的字符(pos可以是下标或一个迭代器),接受下标的版本返回一个指向s的引用;接受迭代器的版本返回指向第一个插入字符的迭代器</td>
</tr>
<tr>
<td>s.erase(pos,len)</td>
<td>删除从位置pos开始的len个字符。若len被省略则删除所有字符。返回一个指向s的引用</td>
</tr>
<tr>
<td>s.assign(args)</td>
<td>将s中的字符<strong>替换</strong>args指定的字符。返回一个指向s的引用</td>
</tr>
<tr>
<td>s.append(args)</td>
<td>将args<strong>追加</strong>到s,返回一个指向s的引用</td>
</tr>
<tr>
<td>s.replace(range,args)</td>
<td>删除s中范围range内的字符,替换为args指定的字符。range或者是一个下标和一个长度,或者是一对指向s的迭代器。返回一个指向s的引用</td>
</tr>
<tr>
<td>args可以是下列形式之一;</td>
<td>append和assign可以使用所有形式</td>
</tr>
<tr>
<td>str不能与s相同,迭代器版本b和e不能指向e</td>
<td>-</td>
</tr>
<tr>
<td>str</td>
<td>字符串str</td>
</tr>
<tr>
<td>str,pos,len</td>
<td>str中从pos开始最多len个字</td>
</tr>
<tr>
<td>cp,len</td>
<td>从cp指向的字符数组的前len个字符</td>
</tr>
<tr>
<td>cp</td>
<td>cp指向的以空字符结尾的字符数组</td>
</tr>
<tr>
<td>n,c</td>
<td>n个字符c</td>
</tr>
<tr>
<td>b,e</td>
<td>迭代器b和e指定的范围内的字符</td>
</tr>
<tr>
<td>初始化列表</td>
<td>花括号包围的,以逗号分隔的字符列表</td>
</tr>
</tbody>
</table>
<h3 id="953-string搜索操作"><a class="markdownIt-Anchor" href="#953-string搜索操作"></a> 9.5.3 string搜索操作</h3>
<ul>
<li>每个搜索操作都返回一个string::size_type值,表示匹配发生位置的下标
<ul>
<li>如果搜索失败,则返回一个名为string::npos的static成员</li>
<li>标准库将npos定义为一个const string::size_type类型,并初始化为值-1
<ul>
<li>由于npos是一个unsigned类型,此初始值意味着npos等于任何string最大的可能大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>string搜索操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find(args)</td>
<td>查找s中args第一次出现的位置</td>
</tr>
<tr>
<td>s.rfind(args)</td>
<td>查找s中args最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_of(args)</td>
<td>查找s中args中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td>s.find_last_of(args)</td>
<td>查找s中args中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>查找s中第一个不在args中的字符</td>
</tr>
<tr>
<td>s.find_last_not_of(args)</td>
<td>查找s中最后一个不在args中的字符</td>
</tr>
<tr>
<td><strong>args可以是下列形式之一</strong></td>
<td>-</td>
</tr>
<tr>
<td>c,pos</td>
<td>从s中位置pos开始查找字符c。pos默认值为0</td>
</tr>
<tr>
<td>s2,pos</td>
<td>从s中位置pos开始查找字符串s2。pos默认值为0</td>
</tr>
<tr>
<td>cp,pos</td>
<td>从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。pos默认值为0</td>
</tr>
<tr>
<td>cp,pos,n</td>
<td>从s中位置pos开始查找指针cp指向的数组的前n个字符。pos默认值为0</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string::size_type pos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每步循环查找name中下一个数</span></span><br><span class="line"><span class="keyword">while</span>((pos=name.<span class="built_in">find_first_of</span>(numbers,pos))!=string::npos)&#123;</span><br><span class="line">  cout&lt;&lt;pos&lt;&lt;name[pos]&lt;&lt;endl;</span><br><span class="line">  ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="954-compare函数"><a class="markdownIt-Anchor" href="#954-compare函数"></a> 9.5.4 compare函数</h3>
<table>
<thead>
<tr>
<th><strong>s.compare的几种参数形式</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>s2</td>
<td>比较s和s2</td>
</tr>
<tr>
<td>pos1,n1,s2</td>
<td>将s中从pos1开始的n1个字符与s2进行比较</td>
</tr>
<tr>
<td>pos1,n1,s2,pos2,n2</td>
<td>将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较</td>
</tr>
<tr>
<td>cp</td>
<td>比较s与cp指向的以空字符结尾的字符串数组</td>
</tr>
<tr>
<td>pos1,n1,cp</td>
<td>将s中从pos1开始n1的字符与cp指向的以空字符结尾的字符数组进行比较</td>
</tr>
<tr>
<td>pos1,n1,cp,n2</td>
<td>将s中从pos1开始n1的字符与cp指向的地址开始的n2个字符进行比较</td>
</tr>
</tbody>
</table>
<h3 id="955-数值转换"><a class="markdownIt-Anchor" href="#955-数值转换"></a> 9.5.5 数值转换</h3>
<ul>
<li>如果string不能转换为一个数值,这些函数抛出一个invalid_argument异常</li>
<li>如果转换得到的数值无法用任何类型来表示,则抛出一个out_of_range异常</li>
</ul>
<table>
<thead>
<tr>
<th><strong>string和数值之间的转换</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_string</td>
<td>一组重载函数,返回数值val的string表示</td>
</tr>
<tr>
<td>stoi(s,p,b)</td>
<td>返回s的起始子串(表示整数内容),返回值类型为int</td>
</tr>
<tr>
<td>stol(s,p,b)</td>
<td>返回s的起始子串(表示整数内容),返回值类型为long</td>
</tr>
<tr>
<td>stoul(s,p,b)</td>
<td>返回s的起始子串(表示整数内容),返回值类型为unsigned long</td>
</tr>
<tr>
<td>stoll(s,p,b)</td>
<td>返回s的起始子串(表示整数内容),返回值类型为long long</td>
</tr>
<tr>
<td>stoull(s,p,b)</td>
<td>返回s的起始子串(表示整数内容),返回值类型为unsigned long long</td>
</tr>
<tr>
<td>stof(s,p)</td>
<td>返回s的起始子串(表示浮点数内容)的数值,返回值类型为float</td>
</tr>
<tr>
<td>stod(s,p)</td>
<td>返回s的起始子串(表示浮点数内容)的数值,返回值类型为double</td>
</tr>
<tr>
<td>stold(s,p)</td>
<td>返回s的起始子串(表示浮点数内容)的数值,返回值类型为long double</td>
</tr>
</tbody>
</table>
</div><div class="story post-story"><h2 id="96-容器适配器"><a class="markdownIt-Anchor" href="#96-容器适配器"></a> 9.6 容器适配器</h2>
<ul>
<li>顺序容器适配器：stack,queue和priority_queue</li>
<li><strong>适配器</strong>是标准库中一个通用概念(容器,迭代器和函数都有适配器)
<ul>
<li>一个内容适配器接受一个已有的容器类型,使其行为看起来像一种不同的类型</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>所有容器适配器都支持的操作和类型</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_string</td>
<td>一组重载函数,返回数值val的string表示</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>container_type</td>
<td>实现适配器的底层容器类型</td>
</tr>
<tr>
<td>A a</td>
<td>创建一个名为a的空适配器</td>
</tr>
<tr>
<td>A a©</td>
<td>创建一个名为a的适配器,带有容器c的一个拷贝</td>
</tr>
<tr>
<td>关系运算符</td>
<td>运算符返回底层容器的比较结果</td>
</tr>
<tr>
<td>a.empty()</td>
<td>若a包含任何元素,返回false</td>
</tr>
<tr>
<td>a.size()</td>
<td>返回a中的元素数目</td>
</tr>
<tr>
<td>swap(a,b)</td>
<td>交换a和b的内容,a和b必须由相同类型,包括底层容器类型也必须相同</td>
</tr>
<tr>
<td>a.swap(b)</td>
<td>交换a和b的内容,a和b必须由相同类型,包括底层容器类型也必须相同</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>定义一个适配器</strong>：默认构造函数创建一个空对象,接受一个容器的构造函数拷贝该容器来初始化适配器
<ul>
<li>默认情况下,stack和queue是基于deque实现的,priority_queue是在vector之上实现的</li>
</ul>
</li>
<li>对于一个给定的适配器,可以使用哪些容器是有限制的
<ul>
<li>所有适配器都要求容器具有添加和删除元素的能力(适配器不能构造在array上)
<ul>
<li>类似的,也不能用forward_list来构造适配器,因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力</li>
</ul>
</li>
<li>stack只要求push_back、pop_back和back操作,因此可以使用除array和forward_list之外的任何容器类型来构造stack</li>
<li>queue适配器要求back、push_back、front和push_front,因此它可以构造于list或deque之上,但不能基于vector构造</li>
<li>priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力,因此它可以构造于vector或deque之上,但不能基于list构造</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span></span>;    <span class="comment">//从deq拷贝元素到stk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在vector上实现的空栈</span></span><br><span class="line">stack&lt;string,vector&lt;string&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">// str_stk2在vector上实现,初始化时保存svec的拷贝</span></span><br><span class="line">stack&lt;string,vector&lt;string&gt;&gt; <span class="built_in">str_stk2</span>(svec);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>栈适配器</strong>
<ul>
<li>stack类型定义在stack头文件中</li>
<li>栈默认基于deque实现,也可以在list或vector上实现的</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>未列出的栈操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.pop()</td>
<td>删除栈顶元素,但不返回该元素值</td>
</tr>
<tr>
<td>s.push(item)</td>
<td>创建一个新元素压入栈顶,该元素通过拷贝或移动item而来</td>
</tr>
<tr>
<td>s.emplace(args)</td>
<td>创建一个新元素压入栈顶,该元素由args构造</td>
</tr>
<tr>
<td>s.top()</td>
<td>返回栈顶元素,但不将元素弹出栈</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填满栈</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> ix = <span class="number">0</span>;ix!=<span class="number">10</span>;++ix)</span><br><span class="line">  intStack.<span class="built_in">push</span>(ix);    <span class="comment">//intStack保存0到9十个数</span></span><br><span class="line"><span class="keyword">while</span>(!intStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">  <span class="type">int</span> value = intStack.<span class="built_in">top</span>();</span><br><span class="line">  <span class="comment">// 使用栈顶值的代码</span></span><br><span class="line">  intStack.<span class="built_in">pop</span>(); <span class="comment">//弹出栈顶元素,继续循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>队列适配器</strong>
<ul>
<li>queue和priority_queue适配器定义在queue头文件中</li>
<li>标准库queue使用一种先进先出(FIFO)的存储和访问策略</li>
<li>priority_queue允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前</li>
<li>queue默认基于deque实现,priority_queue默认基于vector实现
<ul>
<li>queue也可以用list或vector实现,priority_queue可以用deque实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>未列出的queue和priority_queue操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>q.pop()</td>
<td>返回queue的首元素或priority_queue的最高优先级的元素</td>
</tr>
<tr>
<td>q.front()</td>
<td>返回首元素或尾元素,但不删除此元素</td>
</tr>
<tr>
<td>q.back()</td>
<td>只适用于queue</td>
</tr>
<tr>
<td>q.top()</td>
<td>返回最高优先级元素,但不删除该元素</td>
</tr>
<tr>
<td>-</td>
<td><strong>只适用于priority_queue</strong></td>
</tr>
<tr>
<td>s.push(item)</td>
<td>在queue末尾或priority_queue中恰当的位置创建一个元素,其值为item</td>
</tr>
<tr>
<td>s.emplace(args)</td>
<td>在queue末尾或priority_queue中恰当的位置创建一个元素,其值由args构造</td>
</tr>
</tbody>
</table>
<h1 id="10-泛型算法"><a class="markdownIt-Anchor" href="#10-泛型算法"></a> 10 泛型算法</h1>
</div><div class="story post-story"><h2 id="101-概述"><a class="markdownIt-Anchor" href="#101-概述"></a> 10.1 概述</h2>
<ul>
<li>大多数的算法都定义在<strong>头文件algorithm</strong>中,还在<strong>头文件numeric</strong>中定义了<strong>一组数值泛型算法</strong>
<ul>
<li>一般情况下,算法不直接操作容器,而是遍历由两个迭代器指定的一个元素范围来进行操作(通常情况下,算法遍历范围,对其中每个元素进行一些处理)</li>
</ul>
</li>
<li><mark>迭代器令算符不依赖于容器,但算法依赖于元素类型的操作</mark></li>
<li><strong>算法永远不会执行容器的操作</strong>：
<ul>
<li>泛型算法本身不会执行容器的操作,它们只会运行于迭代器之上,执行迭代器的操作</li>
<li>泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小</li>
<li>算法可能改变容器中保存的元素的值,也可能在容器内移动元素,但永远不会直接添加或删除元素</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="102-初始泛型算法"><a class="markdownIt-Anchor" href="#102-初始泛型算法"></a> 10.2 初始泛型算法</h2>
<h3 id="1021-只读算法"><a class="markdownIt-Anchor" href="#1021-只读算法"></a> 10.2.1 只读算法</h3>
<ul>
<li>一些算法只会读取输入范围内的元素,而不改变元素</li>
<li>对于读取而不改变元素的算法,通常最好使用cbegin()和cend(),但若需要使用算法返回迭代器来改变元素的值,需要使用begin()和end()的结果作为参数</li>
</ul>
<h3 id="1022-写容器元素的算法"><a class="markdownIt-Anchor" href="#1022-写容器元素的算法"></a> 10.2.2 写容器元素的算法</h3>
<ul>
<li>一些算法将新值赋予序列中的元素,使用这些算法时,必须注意确保序列原大小至少不小于要求算法写入的元素数目
<ul>
<li>算法不会执行容器操作,因此自身不可能改变大小</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法fill接受一对迭代器表示一个范围,还接受一个值作为第三个参数</span></span><br><span class="line"><span class="comment">// fill将给定的这个值赋予输入序列的每个元素</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>) <span class="comment">//将每个元素重置为0</span></span><br><span class="line"><span class="comment">// 将容器的一个子序列设置为10</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">begin</span>()+vec.<span class="built_in">size</span>()/<span class="number">2</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>迭代器参数</strong>
<ul>
<li>一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器</li>
<li>操作两个序列的算法之间的区别在于<strong>如何传递第二个序列</strong>
<ul>
<li>如equal,接受三个迭代器,前两个表示第一个序列的范围,第三个表示第二个序列的首元素
<ul>
<li>用一个单一的迭代器表示第二个序列的算法都是假定第二个序列至少与第一个一样长,确保算法不会试图访问第二个序列中不存在的元素</li>
</ul>
</li>
<li>其他算法接受四个迭代器,前两个表示第一个序列的元素范围,后两个表示第二个序列的范围</li>
</ul>
</li>
</ul>
</li>
<li><strong>算法不检查写操作</strong>
<ul>
<li>一些算法接受一个迭代器来指出一个单独的目的位置,算法将新值赋予一个序列的元素,该序列从目的位置迭代器指向的元素开始</li>
<li>向目的位置迭代器写入数据的算法假定目的位置足够大,能容纳要写入的元素</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用fill_n将一个新值赋予vector中的元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;  <span class="comment">//空vector</span></span><br><span class="line"><span class="comment">// 使用vec,赋予它不同值</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">size</span>(), <span class="number">0</span>);   <span class="comment">//将所有元素重置为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数fill_n假定写入指定个元素是安全的</span></span><br><span class="line"><span class="built_in">fill_n</span>(dest, n, val)</span><br><span class="line"><span class="comment">// fill_n假定dest指向一个元素,而从dest开始的序列至少包含n个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在空容器上调用fill_n</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;  <span class="comment">//空向量</span></span><br><span class="line"><span class="comment">// 灾难：修改vec中的10个不存在元素</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>介绍back_inserter</strong>
<ul>
<li>一种保证算法有足够元素空间来容纳数据的方法是使用插入迭代器</li>
<li>插入迭代器是一种向容器中添加元素的迭代器,通常情况通过一个插入迭代器赋值时,一个与赋值号右侧值相等的元素被添加到容器中</li>
<li><strong>iterator函数中back_insert函数</strong>：接受一个指向容器的引用,返回一个与该容器绑定的插入迭代器
<ul>
<li>通过此迭代器赋值时,赋值运算符会调用push_back将一个具有给定值的元素添加到容器中</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;  <span class="comment">//空向量</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_insert</span>(vec);</span><br><span class="line">*it = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用back_insert创建迭代器,作为算法的目的位置来使用</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;  <span class="comment">//空向量</span></span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_insert</span>(vec),<span class="number">10</span>,<span class="number">0</span>);  <span class="comment">//添加10个元素到vec</span></span><br></pre></td></tr></table></figure>
<ul>
<li>拷贝算法
<ul>
<li>是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法</li>
<li>接受三个迭代器：前两个表示一个输入范围,第三个表示目的序列的起始位置;将输入范围内的元素拷贝到目的系列中</li>
<li><strong>copy算法</strong></li>
<li><strong>replace算法</strong>：读入一个序列,并将其中所有等于给定值的元素都改为另一个值,接收4个参数,前两个是迭代器,表示输入序列,后两个一个是搜索的值,另一个是新值</li>
<li><strong>replace_copy</strong>：保留原序列不变,需要支持额外的第三个迭代器参数,指出保存后序列的位置</li>
</ul>
</li>
</ul>
<h3 id="1023-重排容器元素的算法"><a class="markdownIt-Anchor" href="#1023-重排容器元素的算法"></a> 10.2.3 重排容器元素的算法</h3>
<ul>
<li><strong>sort算法</strong>：重排输入序列中的元素,利用元素类型的&lt;运算符来实现排序</li>
<li><strong>unique算法</strong>：重排输入序列,将相邻的重复项消除,并返回一个指向不重复值范围末尾的迭代器</li>
<li><strong>erase算法</strong>：删除无用元素</li>
</ul>
</div><div class="story post-story"><h2 id="103-定制操作"><a class="markdownIt-Anchor" href="#103-定制操作"></a> 10.3 定制操作</h2>
<ul>
<li>很多算法会比较输入序列的元素：默认情况下,这类算法使用元素类型的&lt;或==运算符完成比较;</li>
</ul>
<h3 id="1031-向算法传递函数"><a class="markdownIt-Anchor" href="#1031-向算法传递函数"></a> 10.3.1 向算法传递函数</h3>
<ul>
<li>按长度重排vector,将使用sort的重载版本,接收三个参数,此参数是一个<strong>谓词</strong>
<ul>
<li><strong>谓词</strong>：是一个可调用的表达式,其返回结果是一个能用作条件的值
<ul>
<li>接收谓词参数的算法对输入序列中的元素调用谓词,因此元素类型必须能转换为谓词的参数类型</li>
</ul>
</li>
<li>接收二元谓词的sort版本用谓词代替&lt;来比较元素</li>
</ul>
</li>
<li><strong>stable_sort算法</strong>：保持等长元素间的字典序,重排输入序列中的元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较函数,用来按长度排序单词</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按长度由短至长排序</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br></pre></td></tr></table></figure>
<h3 id="1032-lambda表达式"><a class="markdownIt-Anchor" href="#1032-lambda表达式"></a> 10.3.2 lambda表达式</h3>
<ul>
<li>可以向一个算法传递任何类别的可调用对象
<ul>
<li>对于一个对象或一个表达式,如果可以对其调用运算符,则称它为可调用的,e为一个可调用表达式,则可编写e(args),其中args是一个逗号分割的一个或多个参数列表</li>
<li>==可调用对象：函数,函数指针,重载了函数调用运算符的类,lambda表达式</li>
</ul>
</li>
<li><strong>lambda表达式</strong>：表示一个可调用单元源代码,可理解为一个未命名的内联函数(具有返回类,参数列表和函数体),可定义在函数内部
<ul>
<li>lambda表达式的形式:[capture list](parameter list) -&gt; return type{function body}
<ul>
<li>capture list是一个lambda所在函数中定义的局部变量的列表;</li>
<li>可以忽略参数列表和返回类型,但必须永远包含捕获列表和函数体</li>
<li>忽略参数列表等价于一个空参数列表,若忽略返回类型,lambda根据函数体中的代码推断出返回类型;若函数体只是一个return语句,则返回类型从返回表达式的类型推断而来</li>
</ul>
</li>
</ul>
</li>
<li><strong>向lambda传递参数</strong>
<ul>
<li>调用lambda时给定的实参会被用来初始化lambda的形参,但不能带默认参数(因此lambda调用的实参数目永远与形参数目相等)</li>
<li>空捕获列表表示lambda不使用它所在函数中的任何局部变量</li>
</ul>
</li>
<li><strong>使用捕获列表</strong>
<ul>
<li>捕获列表指引lambda在其内部包含访问局部变量所需的信息</li>
<li>一个lambda通过将局部变量包含在其捕获列表中指出将会使用这些变量</li>
<li><mark>一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量,才能在函数体中使用该变量</mark></li>
<li><mark>捕获列表只用于局部非static变量,lambda可以直接使用局部static变量和它所在函数之外声明的名字</mark></li>
</ul>
</li>
<li><strong>for_each算法</strong>
<ul>
<li>使用for_each接收一个可调用对象,并将输入序列中每个元素调用此对象</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">  [](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();&#125;)</span><br><span class="line"></span><br><span class="line">[sz](<span class="type">const</span> string &amp;a) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz;&#125;</span><br><span class="line"></span><br><span class="line">for_each(wc,words.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> string &amp;s) &#123;cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;)</span><br><span class="line">cout &lt;&lt; endl;  </span><br></pre></td></tr></table></figure>
<h3 id="1033-lambda捕获和返回"><a class="markdownIt-Anchor" href="#1033-lambda捕获和返回"></a> 10.3.3 lambda捕获和返回</h3>
<ul>
<li>当定义一个lambda时,编译器生成一个与lambda对应的新的类类型
<ul>
<li>当向一个函数传递一个lambda时,同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象(当使用auto定义一个用lambda初始化的变量时,定义了一个从lambda生成的类型的对象)</li>
<li>默认情况下,从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员</li>
</ul>
</li>
<li><strong>值捕获</strong>
<ul>
<li>被捕获的变量的值是在lambda创建时拷贝,而不是调用时拷贝</li>
</ul>
</li>
<li><strong>引用捕获</strong>
<ul>
<li>一个以引用方式捕获的变量与其他任何类型的引用的行为类似</li>
<li><mark>在lambda函数体内使用此变量时,实际上使用的是引用所绑定的对象</mark></li>
<li><mark>采用引用方式捕获一个变量,就必须确保被引用的对象在lambda执行的时候是存在的</mark></li>
</ul>
</li>
<li><strong>建议：尽量保持lambda的变量捕获简单</strong>
<ul>
<li>捕获一个普通变量,如int、string或其他非指针类型,通常可以采用简单的值捕获方式。在此情况下,只需关注变量在捕获时是否有所需的值就可以了</li>
<li>如果捕获一个指针或迭代器,或采用引用捕获方式,就必须确保在lambda执行时,绑定到迭代器、指针或引用的对象仍然存在。而且,需要保证对象具有预期的值</li>
</ul>
</li>
<li><strong>隐式捕获</strong>
<ul>
<li>让编译器根据lambda体中的代码来推断要使用变量</li>
<li>应在捕获列表中写一个&amp;或=
<ul>
<li>&amp;告诉编译器采用捕获引用方式</li>
<li>=表示采用值捕获方式</li>
</ul>
</li>
<li><mark>混合使用隐式捕获和显式捕获时,捕获列表中的第一个元素必须是一个&amp;或=(指定了默认捕获方式为引用或值),且显式捕获和隐式捕获必须采用不同的方式</mark></li>
</ul>
</li>
<li><strong>可变lambda</strong>
<ul>
<li>默认情况下,对于一个值被拷贝的变量,lambda不会改变其值,若希望能改变一个被捕获的变量的值,必须在参数列表首加上关键字mutable
<ul>
<li>可变lambda能省略参数列表</li>
</ul>
</li>
<li>引用可以修改依赖于此引用指向的是一个const类型还是非const类型</li>
</ul>
</li>
<li><strong>指定lambda返回类型</strong>
<ul>
<li>为一个lambda定义返回类型时,必须使用尾置返回类型<a href="#633-%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88">(跳转尾置返回类型)</a></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">auto</span> f = [v1] &#123;<span class="keyword">return</span> v1;&#125;;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> j = <span class="built_in">f</span>();   <span class="comment">//j值为42</span></span><br><span class="line">  <span class="comment">// 由于被捕获变量的值是在lambda创建时拷贝,因此随后对其修改不会影响到lambda内对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">auto</span> f = [&amp;v1] &#123;<span class="keyword">return</span> v1;&#125;;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> j = <span class="built_in">f</span>();   <span class="comment">//j值为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">          [=](<span class="type">const</span> string &amp;s) &#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变lambda</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">fcn3</span>()&#123;</span><br><span class="line">  <span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1;&#125;;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> j = <span class="built_in">f</span>();   <span class="comment">//j值为43</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),vi.<span class="built_in">begin</span>(),</span><br><span class="line">        [](<span class="type">int</span> i) -&gt; <span class="type">int</span> </span><br><span class="line">        &#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="1034-参数绑定"><a class="markdownIt-Anchor" href="#1034-参数绑定"></a> 10.3.4 参数绑定</h3>
<ul>
<li><mark>对于捕获局部变量的地方,建议使用lambda</mark></li>
<li><strong>标准库bind函数</strong>：
<ul>
<li>定义在头文件functional中</li>
<li>可将bind函数看作一个通用的函数适配器,接受一个可调用对象,生成一个新的可调用对象来适应原对象的参数列表</li>
<li>调用的一般形式：auto newCallable = bind(callable,arg_list);
<ul>
<li>其中,newCallable本身是一个可调用对象,arg_list是一个逗号分隔的参数列表,对应给定的callable的参数</li>
<li>当调用newCallable时,newCallable会调用callable,并传递给它arg_list中的参数。arg_list中的参数可能包含形如_n的名字,其中n是一个整数。这些参数是“占位符”,表示newCallable的参数,占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数,_2为第二个参数,依此类推</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用placeholders名字</strong>
<ul>
<li>定义在头文件functional中</li>
<li><mark>名字_n都定义在一个名为placeholders的命名空间中,而这个命名空间本身定义在std命名空间中</mark></li>
<li>为了使用这些名字,两个命名空间都要写上</li>
</ul>
</li>
<li><strong>用bind重排参数顺序</strong></li>
<li><strong>绑定引用</strong>
<ul>
<li>默认情况下,bind的不是占位符的参数被拷贝进bind返回的可调用对象中,但有时对有些绑定的参数希望以引用方式传递或时要绑定的参数的类型无法拷贝</li>
<li>ref和cref定义在functional中</li>
<li><strong>ref函数</strong>：返回一个对象,包含给定的引用,此对象是可以拷贝的</li>
<li><strong>cref函数</strong>：生成一个保存const引用的类</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_size</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将使用bind生成一个调用check_size的对象</span></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size,_1,<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 此bind调用只有一个占位符,表示check6只接受单一参数</span></span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">bool</span> bl = <span class="built_in">check6</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换示例</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>()</span><br><span class="line">                  [sz](<span class="type">const</span> string &amp;a));</span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>()</span><br><span class="line">                  <span class="built_in">bind</span>(check_size,_1,sz));</span><br><span class="line"><span class="comment">// 此bind调用生成一个可调用对象,将check_size的第二个参数绑定到sz的值</span></span><br><span class="line"><span class="comment">// 当find_if对words中的string调用这个对象时,这些对象会调用check_size,将给定的string和sz传递给它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用_1</span></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="comment">// 或声明全部placeholders</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由短到长排序</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),isShorter);</span><br><span class="line"><span class="comment">// 由长到短排序</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),<span class="built_in">bind</span>(isShorter,_2,_1));</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> string &amp;s, <span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> os&lt;&lt;s&lt;&lt;c;</span><br><span class="line">&#125;</span><br><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">        <span class="built_in">bind</span>(print,<span class="built_in">ref</span>(os),_1,<span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="104-再探迭代器"><a class="markdownIt-Anchor" href="#104-再探迭代器"></a> 10.4 再探迭代器</h2>
<ul>
<li>迭代器的四种类型：
<ul>
<li>插入迭代器：迭代器被绑定到一个容器上,可用来向容器插入元素</li>
<li>流迭代器：迭代器被绑定到输入或输出流上,可用来遍历所关联的IO流</li>
<li>反向迭代器：迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器</li>
<li>移动迭代器：专用的迭代器不是拷贝其中的元素,而是移动它们</li>
</ul>
</li>
</ul>
<h3 id="1041-插入迭代器"><a class="markdownIt-Anchor" href="#1041-插入迭代器"></a> 10.4.1 插入迭代器</h3>
<ul>
<li>插入迭代器是一种迭代器适配器,接受一个容器,生成一个迭代器,能实现向给定容器添加元素
<ul>
<li>通过插入迭代器进行赋值时,该迭代器调用容器操作来向给定容器的指定尾置插入一个元素</li>
</ul>
</li>
<li>插入迭代器操作
<ul>
<li>it=t 在it指定的当前位置插入值t</li>
<li>*it,<ins>it,it</ins></li>
</ul>
</li>
<li>插入器的三种类型,差异在于元素插入的位置
<ul>
<li>back_inserter 创建一个使用push_back的迭代器</li>
<li>front_inserter 创建一个使用push_front的迭代器
<ul>
<li>当调用front_inserter©时,得到一个插入迭代器,接下来会调用push_front</li>
<li>当每个元素被插入到容器c中时,它变为c的新的首元素</li>
<li><mark>因此,front_inserter生成的迭代器会将插入的元素序列的顺序颠倒过来,而inserter和back_inserter则不会</mark></li>
</ul>
</li>
<li>inserter 创建一个使用insert的迭代器(接受第二个参数,指向给定容器的迭代器,元素将被插入到给定迭代器表示的元素之前)</li>
</ul>
</li>
<li><mark>只有在容器支持push_front的情况下,才可以使用front_inserter。类似的,只有在容器支持push_back的情况下,才能使用back_inserter</mark></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*it = val;</span><br><span class="line"><span class="comment">//等效代码</span></span><br><span class="line">it = c.<span class="built_in">insert</span>(it,val);</span><br><span class="line">++it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//front_insert</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst2,lst3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝完成后lst2包含 4 3 2 1 </span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(),lst.<span class="built_in">cend</span>(),<span class="built_in">front_inserter</span>(lst2));</span><br><span class="line"><span class="comment">// 拷贝完成后lst3包含 1 2 3 4 </span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(),lst.<span class="built_in">cend</span>(),<span class="built_in">insert</span>(lst3,lst3.<span class="built_in">begin</span>())</span><br></pre></td></tr></table></figure>
<h3 id="1042-iostream迭代器"><a class="markdownIt-Anchor" href="#1042-iostream迭代器"></a> 10.4.2 iostream迭代器</h3>
<ul>
<li>标准库定义了用于IO类型对象的迭代器</li>
<li>istream_iterator读取输入流,ostream_iterator向一个输出流写数据
<ul>
<li>迭代器将对应的流当作一个特定类型的元素序列来处理,通过使用流迭代器,可以用泛型算法从流对象读取数据以及向其写入数据</li>
</ul>
</li>
<li><strong>istream_iterator操作</strong>
<ul>
<li>当创建一个流迭代器时,必须指定迭代器将要读写的对象类型</li>
<li>一个istream_iterator使用&gt;&gt;读取流</li>
<li>创建一个istream_iterator时,可以将它绑定到一个流
<ul>
<li>还可以默认初始化迭代器,创建一个可以当作尾后值使用的迭代器</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用算法操作流迭代器</strong>：由于算法使用迭代器操作处理数据,而流迭代器又至少支持某些迭代器操作,因此至少可以用某些算法来操作流迭代器</li>
<li><strong>istream_iterator允许使用懒惰求值</strong>：
<ul>
<li>当讲istream_iterator绑定到一个流时,标准库并不保证迭代器立即从流读取数据</li>
<li>具体实现可以推迟从流中读取数据,直到使用迭代器时才真正读取(该操作办证第一次解引用迭代器之前,从流中读取数据的操作已经完成)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>istream_iterator操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>istream_iterator&lt;T&gt; in(is)</td>
<td>in从输入流is读取类型为T的值</td>
</tr>
<tr>
<td>istream_iterator&lt;T&gt; end</td>
<td>读取类型为T的值的istream_iterator迭代器,表示尾后位置</td>
</tr>
<tr>
<td>in1 == in2</td>
<td>in1和in2必须读取相同类型;如果它们都是尾后迭代器,或绑定到相同的输入,则两者相等</td>
</tr>
<tr>
<td>*in</td>
<td>返回从流中的读取的值</td>
</tr>
<tr>
<td>in-&gt;men</td>
<td>返回从流中的读取的值</td>
</tr>
<tr>
<td><ins>in,in</ins></td>
<td>使用元素类型所定义的&gt;&gt;运算符从输入流中读取下一个值(前置版本返回一致指向递增后迭代器的引用,后置版本返回旧值)</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_it</span><span class="params">(cin)</span></span>;  <span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; int_eof;  <span class="comment">//尾后迭代器</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;afile&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator&lt;string&gt; <span class="title">str_in</span><span class="params">(in)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用istream_iterator从标准输入读取数据,存入vector</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; eof;</span><br><span class="line"><span class="keyword">while</span>(in_iter != eof)</span><br><span class="line">  vec.<span class="built_in">push_back</span>(*in_iter++);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span>,eof</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(in_in_iter,eof)</span></span>;</span><br><span class="line"><span class="comment">// 用一对表示元素范围的迭代器来构造vec</span></span><br><span class="line"><span class="comment">// 两个迭代器是istream_iterator,这意味着元素范围是通过从关联的流中读取数据获得的</span></span><br><span class="line"><span class="comment">// 这个构造函数从cin中读取数据,直至遇到文件尾或者遇到一个不是int的数据为止</span></span><br><span class="line"><span class="comment">// 从流中读取的数据被用来构造vec</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用一对istream_iterator调用accumulate</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(cin)</span>,eof</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">accumulate</span>(in,eof,<span class="number">0</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ostream_iterator操作</strong>
<ul>
<li>可以对任何具有输出运算符(&lt;&lt;)的类型定义ostream_iterator</li>
<li>创建一个ostream_iterator时,可以提供第二参数,在输出每个元素后都会打印此字符串</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>ostream_iterator操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>ostream_iterator&lt;T&gt; out(os)</td>
<td>out将类型为T的值写出到输出流os中</td>
</tr>
<tr>
<td>ostream_iterator&lt;T&gt; out(os,d)</td>
<td>out将类型为T的值写出到输出流os中,每个值后面都输出一个d。d指向一个空字符结尾的字符数组</td>
</tr>
<tr>
<td>out = val</td>
<td>用&lt;&lt;运算符将val写入到out所绑定的ostream中</td>
</tr>
<tr>
<td>*out,<ins>out,out</ins></td>
<td>不对out做任何事情。每个运算符都返回out</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout,<span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:vec)</span><br><span class="line">  *out_iter++ = e;  <span class="comment">//赋值语句实际上将元素写到cout</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符*和++实际上对ostream_iterator对象不做任何事情,因此忽略它们对我们的程序没有任何影响</span></span><br><span class="line"><span class="comment">// 但是,推荐第一种形式。在这种写法中,流迭代器的使用与其他迭代器的使用保持一致</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:vec)</span><br><span class="line">  out_iter = e;  <span class="comment">//赋值语句实际上将元素写到cout</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以调用copy</span></span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),out_iter);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用流迭代器处理类类型</strong>
<ul>
<li>可以为任何定义了输入运算符的类型创建istream_iterator,可以为任何定义了输出运算符的类型创建ostream_iterator</li>
</ul>
</li>
</ul>
<h3 id="1043-反向迭代器"><a class="markdownIt-Anchor" href="#1043-反向迭代器"></a> 10.4.3 反向迭代器</h3>
<ul>
<li>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器
<ul>
<li>对于反向迭代器,递增,递减操作的含义会颠倒过来
<ul>
<li>递增一个反向迭代器(++it)会移动到前一个元素</li>
<li>递减一个迭代器(–it)会移动到下一个元素</li>
</ul>
</li>
<li><mark>除了forward_list或一个流迭代器之外,其他容器都支持反向迭代器</mark>
<ul>
<li>除了forward_list之外,标准容器上的其他迭代器都既支持递增运算又支持递减运算</li>
<li>流迭代器不支持递减运算,因为不可能在一个流中反向移动</li>
</ul>
</li>
<li><mark>可以通过调用rbegin、rend、crbegin和crend成员函数来获得反向迭代器</mark>
<ul>
<li>这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器</li>
<li>与普通迭代器一样,反向迭代器也有const和非const版本</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="105-泛型算法结构"><a class="markdownIt-Anchor" href="#105-泛型算法结构"></a> 10.5 泛型算法结构</h2>
<table>
<thead>
<tr>
<th>迭代器类别</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入迭代器</td>
<td>只读,不写;单遍扫描,只能递增</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>只写,不读;单遍扫描,只能递增</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>可读写;多遍扫描,只能递增</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>可读写;多遍扫描,可递增递减</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>可读写;多遍扫描,支持全部迭代器运算</td>
</tr>
</tbody>
</table>
<h3 id="1051-5类迭代器"><a class="markdownIt-Anchor" href="#1051-5类迭代器"></a> 10.5.1 5类迭代器</h3>
<ul>
<li><strong>输入迭代器</strong>：可以读取序列中的元素
<ul>
<li>用于比较两个迭代器的相等和不相等运算符(==、！=)</li>
<li>用于推进迭代器的前置和后置递增运算(++)</li>
<li>用于读取元素的解引用运算符(*);解引用只会出现在赋值运算符的右侧</li>
<li>箭头运算符(-&gt;),等价于(*it).member,即,解引用迭代器,并提取对象的成员</li>
<li>输入迭代器只用于顺序访问
<ul>
<li>对于一个输入迭代器,*it++保证是有效的,但递增它可能导致所有其他指向流的迭代器失效。其结果就是,不能保证输入迭代器的状态可以保存下来并用来访问元素</li>
</ul>
</li>
</ul>
</li>
<li><strong>输出迭代器</strong>：可以看作输入迭代器功能上的补集——只写而不读元素
<ul>
<li>用于推进迭代器的前置和后置递增运算(++)</li>
<li>解引用运算符(*),只出现在赋值运算符的左侧(向一个已经解引用的输出迭代器赋值,就是将值写入它所指向的元素)</li>
</ul>
</li>
<li><strong>前向迭代器</strong>：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作,而且可以多次读写同一个元素。因此,我们可以保存前向迭代器的状态,使用前向迭代器的算法可以对序列进行多遍扫描。</li>
<li><strong>双向迭代器</strong>：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外,双向迭代器还支持前置和后置递减运算符(–)</li>
<li><strong>随机访问迭代器</strong>：提供在常量时间内访问序列中任意元素的能力
<ul>
<li>用于比较两个迭代器相对位置的关系运算符(&lt;、&lt;=、&gt;和&gt;=)</li>
<li>迭代器和一个整数值的加减运算(+、+=、-和-=),计算结果是迭代器在序列中前进(或后退)给定整数个元素后的位置</li>
<li>用于两个迭代器上的减法运算符(-),得到两个迭代器的距离</li>
<li>下标运算符(iter[n]),与*(iter[n])等价</li>
</ul>
</li>
</ul>
<h3 id="1053-算法命名规范"><a class="markdownIt-Anchor" href="#1053-算法命名规范"></a> 10.5.3 算法命名规范</h3>
<ul>
<li>一些算法使用重载形式传递一个谓词
<ul>
<li>接受谓词参数来代替&lt;或==运算符的算法,以及那些不接受额外参数的算法,通常都是重载的函数
<ul>
<li>函数的一个版本用元素类型的运算符来比较元素</li>
<li>另一个版本接受一个额外谓词参数,来代替&lt;或==</li>
</ul>
</li>
</ul>
</li>
<li><strong>_if版本的算法</strong>
<ul>
<li>接受一个元素值的算法通常有另一个不同名的(不是重载的)版本,该版本接受一个谓词代替元素值</li>
<li>接受谓词参数的算法都有附加的_if前缀</li>
</ul>
</li>
<li><strong>区分拷贝元素的版本和不拷贝的版本</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique</span>(beg,end);    <span class="comment">//使用==运算符比较元素</span></span><br><span class="line"><span class="built_in">unique</span>(beg,end,comp); <span class="comment">//使用comp比较元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span>(beg,end,val);  <span class="comment">//查找输入范围中val第一次出现的位置</span></span><br><span class="line"><span class="built_in">find_if</span>(beg,end,pred);  <span class="comment">//查找第一个令pred为真的元素</span></span><br><span class="line"><span class="comment">// 两个算法提供了命名上差异的版本,而非重载版本,因为两个版本的算法都接受相同数目的参数</span></span><br><span class="line"><span class="comment">// 因此可能产生重载歧义,虽然很罕见,但为了避免任何可能的歧义,标准库选择提供不同名字的版本而不是重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从v1中删除奇数元素</span></span><br><span class="line"><span class="built_in">remove_if</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>()</span><br><span class="line">          [](<span class="type">int</span> i) &#123;<span class="keyword">return</span> i%<span class="number">2</span>;&#125;);</span><br><span class="line"><span class="comment">// 将偶数元素从v1拷贝到v2;v1不变</span></span><br><span class="line"><span class="built_in">remove_if</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),<span class="built_in">back_inserter</span>(v2),</span><br><span class="line">          [](<span class="type">int</span> i) &#123;<span class="keyword">return</span> i%<span class="number">2</span>;&#125;);</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="106-特定容器算法"><a class="markdownIt-Anchor" href="#106-特定容器算法"></a> 10.6 特定容器算法</h2>
<ul>
<li>对于list和forward_list,应该优先使用成员函数版本的算法而不是通用算法</li>
<li>链表特有的操作会改变容器
<ul>
<li>多数链表特有的算法都与其通用版本很相似,但不完全相同</li>
<li>链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器</li>
<li>类似的,merge和splice会销毁其参数</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>list和forward_list成员函数版本的算法(返回void)</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>lst.merge(lst2)</td>
<td>将来自lst2的元素合并如lst</td>
</tr>
<tr>
<td>lst.merge(lst2,comp)</td>
<td>元素将从lst2中删除(在合并之后,lst2变成空)</td>
</tr>
<tr>
<td>lst.remove(val)</td>
<td>调用erase删除掉与给定值相等或令一元谓词为真的每个元素</td>
</tr>
<tr>
<td>lst.remove_if(pred)</td>
<td>调用erase删除掉与给定值相等或令一元谓词为真的每个元素</td>
</tr>
<tr>
<td>lst.reverse()</td>
<td>反转lst中元素的顺序</td>
</tr>
<tr>
<td>lst.sort()</td>
<td>使用&lt;或给定比较操作排序元素</td>
</tr>
<tr>
<td>lst.sort(comp)</td>
<td>使用&lt;或给定比较操作排序元素</td>
</tr>
<tr>
<td>lst.unique()</td>
<td>调用erase删除同一值得连续拷贝.第一个版本使用=,第二个版本使用给定的二元谓词</td>
</tr>
<tr>
<td>lst.unique(pred)</td>
<td>调用erase删除同一值得连续拷贝.第一个版本使用=,第二个版本使用给定的二元谓词</td>
</tr>
</tbody>
</table>
<h1 id="11-关联容器"><a class="markdownIt-Anchor" href="#11-关联容器"></a> 11 关联容器</h1>
<ul>
<li>关联容器中的元素时按关键字来保存和访问的,支持高效的关键字查找和访问</li>
<li>两个主要的关联容器：<strong>map</strong>和<strong>set</strong>
<ul>
<li>map中的元素是一些关键字-值对：关键字起到索引的作用,值则表示与索引相关联的数据</li>
<li>set中每个元素只包含一个关键字;set支持高效的关键字查询操作(检查一个给定关键字是否在set中)</li>
</ul>
</li>
<li><strong>头文件</strong>
<ul>
<li>类型map和multimap定义在头文件map中</li>
<li>set和multiset定义在头文件set中</li>
<li>无序容器则定义在头文件unordered_map和unordered_set中</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>关联容器类型</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>按关键字有序保存元素</strong></td>
<td>-</td>
</tr>
<tr>
<td>map</td>
<td>关联数组;保存关键字-值对</td>
</tr>
<tr>
<td>set</td>
<td>关键字即值</td>
</tr>
<tr>
<td>multimap</td>
<td>关键字可重复出现的map</td>
</tr>
<tr>
<td>multiset</td>
<td>关键字可重复出现的set</td>
</tr>
<tr>
<td><strong>无序集合</strong></td>
<td>-</td>
</tr>
<tr>
<td>unordered_map</td>
<td>用哈希函数组织的map</td>
</tr>
<tr>
<td>unordered_set</td>
<td>用哈希函数组织的set</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>哈希组织的map,关键字可重复出现</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>哈希组织的set,关键字可重复出现</td>
</tr>
</tbody>
</table>
</div><div class="story post-story"><h2 id="111-使用关联容器"><a class="markdownIt-Anchor" href="#111-使用关联容器"></a> 11.1 使用关联容器</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用关联数组进行单词计数</span></span><br><span class="line"><span class="comment">// 统计每个单词在输入中出现的次数</span></span><br><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_count;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)</span><br><span class="line">  ++word_count[word];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;w:word_count)</span><br><span class="line">cout&lt;&lt;w.first&lt;&lt;<span class="string">&quot; occurs &quot;</span>&lt;&lt;w.second&lt;&lt;((w.second &gt;<span class="number">1</span>)? <span class="string">&quot;times&quot;</span> : <span class="string">&quot; time&quot;</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计输入中每个单词出现的次数</span></span><br><span class="line"><span class="comment">// 可忽略部分单词</span></span><br><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_count;</span><br><span class="line">set&lt;string&gt; exclude = &#123;<span class="string">&quot;The&quot;</span>,<span class="string">&quot;But&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)</span><br><span class="line">  <span class="keyword">if</span>(exclude.<span class="built_in">find</span>(word) == exclude.<span class="built_in">end</span>() )</span><br><span class="line">    ++word_count[word];</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="112-关联容器概述"><a class="markdownIt-Anchor" href="#112-关联容器概述"></a> 11.2 关联容器概述</h2>
<ul>
<li>关联容器支持普通容器操作,但不支持顺序容器的位置相关的操作
<ul>
<li>关联容器中元素时根据关键字存储的,这些操作对关联容器没有意义,而且关联容器不支持构造函数或插入操作这些接受一个元素值和一个数量值得操作</li>
</ul>
</li>
</ul>
<h3 id="1121-定义关联容器"><a class="markdownIt-Anchor" href="#1121-定义关联容器"></a> 11.2.1 定义关联容器</h3>
<ul>
<li>每个关联容器都定义一个默认构造函数,创建了一个指定类型的空容器
<ul>
<li>定义map,必须既指明关键字类型又指明值类型
<ul>
<li>初始化时,必须提供关键字类型和值类型{key,value}</li>
</ul>
</li>
<li>定义set,只需指明关键字类型
<ul>
<li>元素类型就是关键字类型</li>
</ul>
</li>
</ul>
</li>
<li><strong>初始化multimap和multiset</strong>
<ul>
<li>允许多个元素具有相同的关键字</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将创建一个名为ivec的保存int的vector,它包含20个元素：0到9每个整数有两个拷贝</span></span><br><span class="line"><span class="comment">// 将使用此vector初始化一个set和一个multiset</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type i= <span class="number">0</span>;i!=<span class="number">10</span>;++i)&#123;</span><br><span class="line">  ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">  ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">iset</span><span class="params">(ivec.cbegin(), ivec.cend())</span></span>;</span><br><span class="line"><span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">miset</span><span class="params">(ivec.cbegin,ivec.cend())</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="1122-关键字类型的要求"><a class="markdownIt-Anchor" href="#1122-关键字类型的要求"></a> 11.2.2 关键字类型的要求</h3>
<ul>
<li>关键容器对其关键字类型有一定限制
<ul>
<li>对于有序容器map,multimap,set,multiset,<strong>关键字类型必须定义元素比较的方法</strong></li>
<li>默认情况下,标准库使用关键字类型的&lt;运算符比较两个关键字</li>
</ul>
</li>
<li><strong>有序容器的关键字类型</strong>
<ul>
<li>可以向算法提供自定义的比较操作,也可以提供自定义的操作代替关键字上的&lt;运算符</li>
<li>所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>(可看作小于等于)</li>
</ul>
</li>
<li><strong>使用关键字类型的比较函数</strong>
<ul>
<li>用来组织一个容器中元素的操作的类型也是该容器类型的一部分</li>
<li>为了指定使用自定义的操作,必须在定义关联容器类型时提供此操作的类型</li>
<li>在尖括号中出现的每个类型,就仅仅是一个类型而已
<ul>
<li>当创建一个容器(对象)时,才会以构造函数参数的形式提供真正的比较操作(其类型必须与在尖括号中指定的类型相吻合)</li>
</ul>
</li>
</ul>
</li>
<li>为了使用自定义的操作,在定义multiset时必须提供两个类型：关键字类型,以及比较操作类型(函数指针类型)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格弱序函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data % lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">multiset&lt;Sales_data,<span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br><span class="line"><span class="comment">// 用compareIsbn来初始化bookstore对象,这表示当我们向bookstore添加元素时,通过调用compareIsbn来为这些元素排序</span></span><br></pre></td></tr></table></figure>
<h3 id="1123-pair类型"><a class="markdownIt-Anchor" href="#1123-pair类型"></a> 11.2.3 pair类型</h3>
<ul>
<li><strong>pair</strong>的标准库类型,定义在头文件utility中
<ul>
<li>一个pair保存两个数据成员(创建时需要提供两个类型名)</li>
<li>与其他标准库类型不同,pair的数据成员是public的,<mark>两个成员分别命名为first和second</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string,string&gt; anon;</span><br><span class="line">pair&lt;string,<span class="type">size_t</span>&gt; word_count;</span><br><span class="line">pair&lt;string,vector&lt;<span class="type">int</span>&gt;&gt; line;</span><br><span class="line"></span><br><span class="line">pair&lt;string,string&gt; author&#123;<span class="string">&quot;James&quot;</span>,<span class="string">&quot;Joyce&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>pair上的操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>pair&lt;T1,T2&gt; p;</td>
<td>p是pair,对两个成员进行了值初始化</td>
</tr>
<tr>
<td>pair&lt;T1,T2&gt; p(v1,v2);</td>
<td>p是pair,对两个成员v1,v2进行了值初始化</td>
</tr>
<tr>
<td>pair&lt;T1,T2&gt; p={v1,v2};</td>
<td>同上</td>
</tr>
<tr>
<td>make_pair(v1,v2);</td>
<td>返回一个用v1和v2初始化的pair</td>
</tr>
<tr>
<td>p.first</td>
<td>返回p的first数据成员</td>
</tr>
<tr>
<td>p.second</td>
<td>返回p的second数据成员</td>
</tr>
<tr>
<td>p1 relop p2</td>
<td>关系运算符(relop为关系运算符)运算</td>
</tr>
<tr>
<td>p1 == p2</td>
<td>相等性判断</td>
</tr>
<tr>
<td>p1 != p2</td>
<td>相等性判断</td>
</tr>
</tbody>
</table>
</div><div class="story post-story"><h2 id="113-关联容器操作"><a class="markdownIt-Anchor" href="#113-关联容器操作"></a> 11.3 关联容器操作</h2>
<table>
<thead>
<tr>
<th>关联容器额外的类型别名</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>key_type</td>
<td>此容器类型的关键字类型</td>
</tr>
<tr>
<td>mapped_type</td>
<td>每个关键字关联的类型,<strong>只适用于map</strong></td>
</tr>
<tr>
<td>value_type</td>
<td>对于set与key_type相同;<strong>对于map为pair&lt;const key_type,mapped_type&gt;</strong></td>
</tr>
</tbody>
</table>
<h3 id="1131-关联容器迭代器"><a class="markdownIt-Anchor" href="#1131-关联容器迭代器"></a> 11.3.1 关联容器迭代器</h3>
<ul>
<li><mark>解引用一个关联容器迭代器时,得到一个类型为容器的value_type的值的引用</mark></li>
<li>一个map的value_type是一个pair,我们可以改变pair的值,但不能改变关键字成员的值</li>
<li><strong>set的迭代器是const的</strong>：虽然set类型同时定义了iterator和const_iterator类型,但两种类型都只允许只读访问set中的元素</li>
<li><strong>遍历关联容器</strong>：map和set类型都支持begin和end操作,可以用这些函数获取迭代器,然后用迭代器来遍历容器</li>
<li><strong>关联容器和算法</strong>：
<ul>
<li>通常不对关联容器使用泛型算法
<ul>
<li>关键词是const意味着不能将关联容器传递给修改或重排容器元素的算法</li>
</ul>
</li>
<li>关联容器只可用于只读取元素的算法</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_cout.<span class="built_in">begin</span>();</span><br><span class="line">map_it-&gt;first = <span class="string">&quot;new key&quot;</span>;  <span class="comment">//错误,关键字是const</span></span><br><span class="line">++map_it-&gt;second; <span class="comment">//可通过迭代器改变元素</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator set_it = iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span>(set_it != iset.<span class="built_in">end</span>())&#123;</span><br><span class="line">  *set_it = <span class="number">42</span>; <span class="comment">//错误,set中关键字只读</span></span><br><span class="line">  cout &lt;&lt; *set_it &lt;&lt;endl; <span class="comment">//正确,可以读关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1132-添加元素"><a class="markdownIt-Anchor" href="#1132-添加元素"></a> 11.3.2 添加元素</h3>
<ul>
<li>关联容器的insert成员向容器中添加一个元素或元素范围
<ul>
<li>insert有两个版本,分别接受一对迭代器,或是一个初始化器列表</li>
</ul>
</li>
<li><strong>向map添加元素</strong>
<ul>
<li><strong>元素类型是pair</strong>,可以在insert的参数列表中创建一个pair</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>关联容器insert操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.insert(v)</td>
<td>v是value_type类型的对象</td>
</tr>
<tr>
<td>c.emplace(args)</td>
<td>构造一个元素</td>
</tr>
<tr>
<td>c.insert(b,e)</td>
<td>b,e是迭代器,表示一个c::value_type类型值的范围</td>
</tr>
<tr>
<td>c.insert(il)</td>
<td>il是花括号列表</td>
</tr>
<tr>
<td>c.insert(p,v)</td>
<td>将迭代器p作为指示从哪里开始搜索新元素应存储的位置</td>
</tr>
<tr>
<td>c.insert(p,args)</td>
<td>将迭代器p作为指示从哪里开始搜索新元素应存储的位置</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>检测insert的返回值</strong>
<ul>
<li>对于map和set,只有当元素的关键字不在c中才插入元素,函数返回一个pair,包含一个迭代器,指向具有指定关键字的元素,以及一个指示插入是否成功的bool值
<ul>
<li>若关键字已在容器中,bool部分为false</li>
</ul>
</li>
<li>对于multimap和multiset,总会插入给定元素,并返回一个指向新元素的迭代器</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计每个单词在输入中出现次数的繁琐方法</span></span><br><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_count;</span><br><span class="line">string sord;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)&#123;</span><br><span class="line">  <span class="keyword">auto</span> ret = word_cout.<span class="built_in">insert</span>(&#123;word,<span class="number">1</span>&#125;);</span><br><span class="line">  <span class="keyword">if</span>(!ref.second)</span><br><span class="line">    ++ret.first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ret 保存insert返回的值,是一个pair</span></span><br><span class="line"><span class="comment">// ret.first是pair的第一个成员,是一个map迭代器,指向具有给定关键字的元素</span></span><br><span class="line"><span class="comment">// ret.first-&gt; 解引用此迭代器,提取map中的元素,元素也是一个pair</span></span><br><span class="line"><span class="comment">// ret.first-&gt;second map中元素的值部分</span></span><br><span class="line"><span class="comment">// ++ret.first-&gt;second 递增此值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ret的实际类型</span></span><br><span class="line">pair&lt;map&lt;string,<span class="type">size_t</span>&gt;::iterator,<span class="type">bool</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1133-删除元素"><a class="markdownIt-Anchor" href="#1133-删除元素"></a> 11.3.3 删除元素</h3>
<table>
<thead>
<tr>
<th>从关联容器删除元素</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.erase(k)</td>
<td>从c中删除每个关键字为k的元素.返回一个size_type值(指出删除元素的数量)</td>
</tr>
<tr>
<td>c.erase(p)</td>
<td>从c中删除迭代器p指定的元素.p必须指向c中的一个真实元素。返回一个指向p之后元素的迭代器</td>
</tr>
<tr>
<td>c.erase(b,e)</td>
<td>删除迭代器对b和e所表示的范围中的元素,返回e</td>
</tr>
</tbody>
</table>
<h3 id="1134-map的下标操作"><a class="markdownIt-Anchor" href="#1134-map的下标操作"></a> 11.3.4 map的下标操作</h3>
<ul>
<li>map和unordered_map容器提供了下标运算符和一个对应的at函数
<ul>
<li>不能对一个multimap或一个unordered_multimap进行下标操作,因为这些容器中可能有多个值与一个关键字相关联</li>
<li>map下标运算符接受一个索引,获取与此关键字相关联的值</li>
<li>但如果关键字并不在map中,会为它创建一个元素并插入到map中,关联值将进行值初始化</li>
</ul>
</li>
<li><mark>set类型不支持下标,因为set中没有与关键字相关联的“值”</mark></li>
</ul>
<table>
<thead>
<tr>
<th>map和unordered_map的下标操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>c[k]</td>
<td>返回关键字为k的元素;若k不在c中,添加元素并进行初始化</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://c.at">c.at</a>(k)</td>
<td>访问关键字为k的元素,带参数检查,若不存在,则抛出一个out_of_range异常</td>
</tr>
</tbody>
</table>
<ul>
<li><mark>当对一个map进行下标操作时,会获得一个mapped_type对象</mark></li>
<li><mark>当解引用一个map迭代器时,会得到一个value_type对象</mark></li>
</ul>
<h3 id="1135-访问元素"><a class="markdownIt-Anchor" href="#1135-访问元素"></a> 11.3.5 访问元素</h3>
<ul>
<li>关心一个特定元素是否已在容器中,find函数是最佳选择
<ul>
<li>对于允许重复关键字的容器,count还会统计有多少个元素有相同的关键字</li>
</ul>
</li>
<li><strong>对map使用find代替下标操作</strong></li>
<li><strong>在multimap或multiset中查找元素</strong>：如果一个multimap或multiset中有多个元素具有给定关键字,则这些元素在容器中会相邻存储</li>
<li><strong>不同的面向迭代器查找元素</strong>：
<ul>
<li>用lower_bound和upper_bound来解决此问题</li>
<li>两个操作都接受一个关键字,返回一个迭代器
<ul>
<li>如果关键字在容器中,lower_bound返回的迭代器将指向第一个具有给定关键字的元素,而upper_bound返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置</li>
<li>如果元素不在multimap中,则lower_bound和upper_bound会返回相等的迭代器</li>
<li><mark>如果lower_bound和upper_bound返回相同的迭代器,则给定关键字不在容器中</mark></li>
</ul>
</li>
</ul>
</li>
<li><strong>equal_range函数</strong>
<ul>
<li>函数接受一个关键字,返回一个迭代器pair</li>
<li>若关键字存在,则第一个迭代器指向第一个与关键字匹配的元素,第二个迭代器指向最后一个匹配元素之后的位置</li>
<li>若未找到匹配元素,则两个迭代器都指向关键字可以插入的位置</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>在一个关联容器中查找元素的操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>lower_bound和upper_bound不适用于无序容器</td>
</tr>
<tr>
<td>-</td>
<td><strong>下标和at操作只适用于非const的map和unordered_map</strong></td>
</tr>
<tr>
<td>c.find(k)</td>
<td>返回一个迭代器,指向第一个关键字为k的元素;若无k,则返回尾后迭代器</td>
</tr>
<tr>
<td>c.count(k)</td>
<td>返回关键字等于k的数量</td>
</tr>
<tr>
<td>c.lower_bound(k)</td>
<td>返回一个迭代器,指向第一个关键字不小于k的元素</td>
</tr>
<tr>
<td>c.upper_bound(k)</td>
<td>返回一个迭代器,指向第一个关键字大于k的元素</td>
</tr>
<tr>
<td>c.equal_range(k)</td>
<td>返回一个迭代器pair,表示关键字等于k的元素的范围;若不存在,两个成员为c.end()</td>
</tr>
</tbody>
</table>
</div><div class="story post-story"><h2 id="114-无序容器"><a class="markdownIt-Anchor" href="#114-无序容器"></a> 11.4 无序容器</h2>
<ul>
<li><strong>新标准定义了4个无序关联容器</strong>,使用哈希函数和关键字类型的==运算符</li>
<li><strong>使用无序容器</strong>
<ul>
<li>除了哈希管理操作之外,无序容器还提供了与有序容器相同的操作(find,insert等)</li>
<li>用于map和set的操作也能用于unordered_map和unordered_set</li>
<li>通常可用一个无序容器替换对应的有序容器</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用unordered_map重写单词计数程序</span></span><br><span class="line">unordered_map&lt;string,<span class="type">size_t</span>&gt; word_count;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)</span><br><span class="line">  ++word_count[word];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;w:word_count)</span><br><span class="line">  cout&lt;&lt;w.first&lt;&lt;<span class="string">&quot; occurs &quot;</span> &lt;&lt; w.second &lt;&lt; ((w.second &gt;<span class="number">1</span>)? <span class="string">&quot; times&quot;</span>:<span class="string">&quot; time&quot;</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>管理桶</strong>
<ul>
<li>无序容器在存储上组织为一组桶(使用一个哈希函数将元素映射到桶),每个桶保存零个或多个元素</li>
<li>为了访问一个元素,容器首先计算元素的哈希值,它指出应该搜索哪个桶,容器将具有一个特定哈希值的所有元素都保存在相同的桶中,如果容器允许重复关键字,所有具有相同关键字的元素也都会在同一个桶中</li>
<li>因此,无序容器的性能依赖于哈希函数的质量和桶的数量和大小</li>
<li>对于相同的参数,哈希函数必须总是产生相同的结果。理想情况下,哈希函数还能将每个特定的值映射到唯一的桶。但是,将不同关键字的元素映射到相同的桶也是允许的</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>无序容器管理操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>桶接口</strong></td>
<td>-</td>
</tr>
<tr>
<td>c.bucket_count()</td>
<td>正在使用桶的数目</td>
</tr>
<tr>
<td>c.max_bucket_count()</td>
<td>容器能容纳最多的桶的数量</td>
</tr>
<tr>
<td>c.bucket_size(n)</td>
<td>第n个桶中有多少个元素</td>
</tr>
<tr>
<td>c.bucket(k)</td>
<td>关键字为k的元素在哪个桶中</td>
</tr>
<tr>
<td><strong>桶迭代</strong></td>
<td>-</td>
</tr>
<tr>
<td>local_iterator</td>
<td>可以用来访问桶中元素的迭代器类型</td>
</tr>
<tr>
<td>const_local_iterator</td>
<td>桶迭代器的const版本</td>
</tr>
<tr>
<td>c.begin(n),c.end(n)</td>
<td>桶n的首元素迭代器和尾后迭代器</td>
</tr>
<tr>
<td>c.cbegin(n),c.cend(n)</td>
<td>返回const_local_iterator</td>
</tr>
<tr>
<td><strong>哈希策略</strong></td>
<td>-</td>
</tr>
<tr>
<td>c.load_factor</td>
<td>每个桶的平均元素数量,返回float值</td>
</tr>
<tr>
<td>c.max_load_factor</td>
<td>c试图维护的平均桶大小,返回float值。c会在需要时添加新的桶,以使得load_factor&lt;=max_load_factor&gt;</td>
</tr>
<tr>
<td>c.rehash(n)</td>
<td>重组存储,使得bucket_count&gt;=n,且bucket_count&gt;size/max_load_factor</td>
</tr>
<tr>
<td>c.reserve(n)</td>
<td>重组存储,使得c可以保存n个元素且不必rehash</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>无序容器对关键字类型的要求</strong>
<ul>
<li>默认情况下,无序容器使用关键字类型的==运算符来比较元素,它们还使用一个hash&lt;key_type&gt;类型的对象来生成每个元素的哈希值</li>
<li>标准库为内置类型(包括指针)提供了hash模板,还为一些标准库类型,包括string和智能指针类型定义了hash</li>
<li>因此,可以直接定义关键字是内置类型(包括指针类型)、string还是智能指针类型的无序容器</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hasher</span><span class="params">(<span class="type">const</span> Sales_data &amp;sd)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;() (sd.<span class="built_in">isbn</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eqOp</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的hasher函数使用一个标准库hash类型对象来计算ISBN成员的哈希值,该hash类型建立在string类型之上</span></span><br><span class="line"><span class="comment">// 类似的,eqOp函数通过比较ISBN号来比较两个Sales_data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SD_multiset = unordered_multiset&lt;Sales_data,<span class="built_in">dacltype</span>(hasher)*,<span class="keyword">decltype</span>(eqOp)*&gt;;</span><br><span class="line"><span class="comment">// 参数使桶大小,哈希函数指针和相等性判断运算符指针</span></span><br><span class="line"><span class="function">SD_multiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>,hasher,eqOp)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="12-动态内存"><a class="markdownIt-Anchor" href="#12-动态内存"></a> 12 动态内存</h1>
<ul>
<li>目前为止只使用过静态内存或栈内存(分配在静态或栈内存中的对象由编译器自动创建和销毁)
<ul>
<li>静态内存用来保存局部static对象,类static数据成员以及定义在任何函数之外的变量</li>
<li>栈内存用来保存定义在函数内的非static对象
<ul>
<li>对于栈对象,仅在其定义的程序块运行时才存在</li>
<li>static对象在使用之前分配,在程序结束时销毁</li>
</ul>
</li>
</ul>
</li>
<li>除了静态内存和栈内存,每个程序还拥有一个内存池。这部分内存被称作自由空间或堆
<ul>
<li>程序用堆来存储动态分配的对象</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="121-动态内存与智能指针"><a class="markdownIt-Anchor" href="#121-动态内存与智能指针"></a> 12.1 动态内存与智能指针</h2>
<ul>
<li>在C++中,动态内存使通过一对运算符来完成的：
<ul>
<li><strong>new</strong>,在动态内存中位对象分配空间并返回一个指向该对象的指针,可以选择对对象进行初始化</li>
<li><strong>delete</strong>,接受一个动态对象的指针,销毁该对象,并释放与之关联的内存</li>
</ul>
</li>
<li>在新标准中,提供两种智能指针来管理动态对象,与普通指针的区别是可以自动释放所指向的对象
<ul>
<li>在<strong>memory头文件</strong>中</li>
<li><strong>shared_ptr</strong>：允许多个对象指向同一个对象</li>
<li><strong>unique_ptr</strong>：独占所指向的对象</li>
<li><strong>weak_ptr</strong>：伴随类,弱引用,指向shared_ptr所管理的对象</li>
</ul>
</li>
</ul>
<h3 id="1211-shared_ptr类"><a class="markdownIt-Anchor" href="#1211-shared_ptr类"></a> 12.1.1 shared_ptr类</h3>
<ul>
<li>智能指针是模板,创建时必须提供额外的信息(指针可以指向的类型,在&lt;&gt;内给出类型)
<ul>
<li>默认初始化的智能指针中保存着一个空指针</li>
<li>解引用一个智能指针返回它所指向的对象</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;</span><br><span class="line">shared_ptr&lt;list&lt;<span class="type">int</span>&gt;&gt; p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p1 &amp;&amp; p1-&gt;<span class="built_in">empty</span>())</span><br><span class="line">  *p1 = <span class="string">&quot;hi&quot;</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>shared_ptr和unique_ptr都支持的操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>shared_ptr&lt;T&gt; sp</td>
<td>空智能指针,可以指向类型为T的对象</td>
</tr>
<tr>
<td>unique_ptr&lt;T&gt; up</td>
<td>空智能指针,可以指向类型为T的对象</td>
</tr>
<tr>
<td>p</td>
<td>将p用作一个条件判断,若p指向一个对象,则为true</td>
</tr>
<tr>
<td>*p</td>
<td>解引用p,获得它所指向的对象</td>
</tr>
<tr>
<td>p-&gt;mem</td>
<td>等价于(*p).mem</td>
</tr>
<tr>
<td>p.get()</td>
<td>返回p中保存的指针</td>
</tr>
<tr>
<td>swap(p,q)</td>
<td>交换p和q中的指针</td>
</tr>
<tr>
<td>p.swap(q)</td>
<td>交换p和q中的指针</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>shared_ptr独有的操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>make_shared&lt;T&gt;(args)</td>
<td>返回一个shared_ptr,指向一个动态分配的类型为T的对象,使用args初始化此对象</td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt;p(q)</td>
<td>p是返回shared_ptr的拷贝;此操作会递增q中的计数器;q中的指针必须能转换成T*</td>
</tr>
<tr>
<td>p=q</td>
<td>所保存的指针必须能相互转换;此操作会递减p的引用计数,递增q的引用计数</td>
</tr>
<tr>
<td>p.unique()</td>
<td>若p.use_count()为1,返回true</td>
</tr>
<tr>
<td>p.use_count()</td>
<td>返回与p共享对象的智能指针数量(<strong>用于调试</strong>)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>make_shared函数</strong>
<ul>
<li>最安全的分配和使用动态内存的方法：<strong>调用make_shared函数</strong>
<ul>
<li>此函数在动态内存中分配一个对象并初始化,返回指向此对象的shared_ptr</li>
</ul>
</li>
<li>类似顺序容器的emplace成员,make_shared用其参数来构造给定类型的对象</li>
<li><strong>可以使用auto定义一个对象保存make_shared的结果</strong></li>
</ul>
</li>
<li><strong>shared_ptr的拷贝和赋值</strong>
<ul>
<li>当进行拷贝或赋值操作时,每个shared_ptr会记录有多少个其他shared_ptr指向相同的对象</li>
<li>每个shared_ptr都有一个关联的计数器,通常称其为<strong>引用计数</strong>,拷贝shared_ptr,计数器都会递增</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">shared_ptr&lt;string&gt; p3 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;    <span class="comment">//p和q指向相同对象,此对象有两个引用者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">r = q;  </span><br><span class="line"><span class="comment">//递增r所指向的对象的引用计数;</span></span><br><span class="line"><span class="comment">// 递减r原来指向对象的引用计数;</span></span><br><span class="line"><span class="comment">// r原来指向的对象已经没有引用者,会自动释放</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>shared_ptr自动销毁所管理的对象以及相关联的内存</strong>
<ul>
<li>当指向一个对象的最后一个shared_ptr被销毁时,shared_ptr类会自动销毁此对象</li>
<li>通过<strong>析构函数</strong>完成销毁工作,析构函数一般用来释放对象所分配的资源
<ul>
<li><strong>shared_ptr的析构函数会递减</strong>所指向的对象的引用计数</li>
</ul>
</li>
<li>当动态对象不再被使用时,shared_ptr类会自动释放动态对象</li>
<li>由于在最后一个shared_ptr销毁前内存都不会释放,保证shared_ptr在无用之后不再保留非常重要
<ul>
<li><mark>如果将shared_ptr存放于一个容器中,而后不再需要全部元素,而只使用其中一部分,要记得用erase删除不再需要的那些元素</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factory返回一个shared_ptr,指向一个动态分配的对象</span></span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">facory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make_shared</span>&lt;Foo&gt;(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">  shared_ptr&lt;Foo&gt; p = <span class="built_in">factory</span>(arg);</span><br><span class="line">&#125;<span class="comment">//p离开作用域,所指向的内存会被自动释放掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">  shared_ptr&lt;Foo&gt; p = <span class="built_in">factory</span>(arg);</span><br><span class="line">  <span class="comment">// 使用p</span></span><br><span class="line">  <span class="keyword">return</span> p; <span class="comment">//当返回p时,引用计数进行了递增操作</span></span><br><span class="line">&#125;<span class="comment">//p离开了作用域,但它指向的内存不会被释放掉</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用了动态生存期的资源的类</strong>
<ul>
<li>程序使用动态内存出现三种原因之一：
<ol>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据
<ul>
<li>一般而言,如果两个对象共享底层数据,当某个对象被销毁,不能单方面地销毁底层数据</li>
</ul>
</li>
</ol>
</li>
<li><mark>使用动态内存的一个常见原因是允许多个对象共享相同的类型</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlob</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::vector&lt;std::string&gt;::size_type size_type;</span><br><span class="line">    <span class="built_in">StrBlob</span>();</span><br><span class="line">    <span class="built_in">StrBlob</span>(std::initializer_list&lt;std::string&gt; il);</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> data-&gt;<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> std::string &amp;t)</span> </span>&#123;data-&gt;<span class="built_in">push_back</span>(t);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;str::vector&lt;std::string&gt;&gt; data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlob::<span class="built_in">StrBlob</span>(): <span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;) &#123;&#125;</span><br><span class="line">strBlob::<span class="built_in">StrBolb</span>(initializer_list&lt;string&gt; il):</span><br><span class="line">                    <span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;()) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrBlob::check</span><span class="params">(size_type i, <span class="type">const</span> string &amp;msg)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string&amp; <span class="title">StrBlob::front</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;front on empty StrBlob&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data-&gt;<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string&amp; <span class="title">StrBlob::back</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;back on empty StrBlob&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string&amp; <span class="title">StrBlob::pop_bakc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;pop_back on empty StrBlob&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似Sales_data类,StrBlob使用默认版本的拷贝、赋值和销毁成员函数来对此类型的对象进行这些操作</span></span><br><span class="line"><span class="comment">// 默认情况下,这些操作拷贝、赋值和销毁类的数据成员</span></span><br><span class="line"><span class="comment">// StrBlob类只有一个数据成员,它是shared_ptr类型</span></span><br><span class="line"><span class="comment">// 因此,当我们拷贝、赋值或销毁一个StrBlob对象时,它的shared_ptr成员会被拷贝、赋值或销毁</span></span><br></pre></td></tr></table></figure>
<h3 id="1212-直接管理内存"><a class="markdownIt-Anchor" href="#1212-直接管理内存"></a> 12.1.2 直接管理内存</h3>
<ul>
<li>运算符new分配内存,delete释放nre分配的内存</li>
<li><strong>使用new动态分配和初始化对象</strong>
<ul>
<li>在自由空间分配的内存是无名的,因此new无法为其分配的对象命名,而是返回一个指向该对象的指针</li>
<li>默认情况下,动态分配的对象是默认初始化的,意味着内置类型或组合类型的对象的值是未定义的,而类类型对象将用默认构造进行初始化
<ul>
<li>可以使用直接初始化方式来初始化动态分配的对象,或使用列表初始化(使用花括号)</li>
<li>可以对动态分配的对象进行值初始化(在类型名之后跟一对空括号)
<ul>
<li><mark>如果使用括号包围的仅有单一初始化器,可以使用auto推断元素类型</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>动态分配的const对象</strong>
<ul>
<li>动态分配的const对象必须进行初始化(定义了默认构造函数的类类型,可以隐式初始化)</li>
</ul>
</li>
<li><strong>内存耗尽</strong>
<ul>
<li>一旦一个程序用光了所有的可用内存,new表达式会报错,抛出bad_alloc异常</li>
<li><strong>定位new</strong>：允许向new传递额外的参数,(传递nothrow意图不能抛出异常,返回空指针)
<ul>
<li>nothrow和bad_alloc定义在new头文件中</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">string *ps = <span class="keyword">new</span> string;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>();  <span class="comment">//值初始化为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in">auto</span>(obj);</span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125;;  <span class="comment">//错误,括号中只能由单个初始化器</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>)</span><br><span class="line"><span class="type">const</span> string *pcs = <span class="keyword">new</span> <span class="type">const</span> string;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> *p2 = <span class="built_in">new</span> (nothrow) <span class="type">int</span>;  <span class="comment">//分配失败,new返回空指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>释放动态内存</strong>
<ul>
<li>使用<strong>delete表达式</strong>来讲动态内存归还给系统
<ul>
<li>两个动作：销毁给定指针指向的对象,释放对应的内存</li>
</ul>
</li>
<li>delete表达式接受一个指针,指向要释放的对象</li>
</ul>
</li>
<li><strong>指针和delete</strong>
<ul>
<li><mark>delete必须指向动态分配的内存或空指针(释放一块非new分配的内存,该行为未定义)</mark></li>
<li><mark>const对象的值不能被修改,但本身是可以被销毁的</mark></li>
</ul>
</li>
<li><strong>动态对象的生存期直到被释放时为止</strong>
<ul>
<li>由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放</li>
<li>通过内置指针类型来管理的内存,直到被显式释放之前它都是存在的
<ul>
<li><strong>返回动态内存的指针的函数需要记得释放内存</strong></li>
<li>当一个指针离开其作用域时,它所指向的对象什么都不会发生;如果这个指针指向的时动态内存,内存将不会被自动释放</li>
</ul>
</li>
</ul>
</li>
<li><strong>小心：动态内存的管理非常容易出错</strong>
<ul>
<li>使用new和delete管理动态内存存在三个常见问题：
<ol>
<li>忘记delete内存</li>
<li>使用已经释放掉的对象</li>
<li>同一块内存释放两次</li>
</ol>
</li>
</ul>
</li>
<li><strong>delete之后重置指针值</strong>
<ul>
<li>delete一个指针后,指针为<strong>空悬指针</strong>
<ul>
<li>不再使用该指针：在指针即将离开其作用域之前释放它所关联的内存</li>
<li>需要使用该指针：将指针赋值为nullptr,指明指针不再指向任何对象</li>
</ul>
</li>
<li><mark>多个指针指向相同内存,delete一个指针后,另一个指针需要置为nullptr</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">delete p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放const对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = new <span class="type">const</span> <span class="type">int</span>(<span class="number">1024</span>);</span><br><span class="line">delete pci;</span><br><span class="line"></span><br><span class="line"><span class="comment">// factory返回一个指针,指向一个动态分配的对象</span></span><br><span class="line">Foo* <span class="title function_">factory</span><span class="params">(T arg)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> new Foo(arg);  <span class="comment">//调用者负责释放此内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">use_factory</span><span class="params">(T arg)</span>&#123;</span><br><span class="line">  Foo *p = factory(arg);</span><br><span class="line">  <span class="comment">//使用p但不delete</span></span><br><span class="line">&#125; <span class="comment">//p离开作用域,但所指向的内存没有释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得释放内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">use_factory</span><span class="params">(T arg)</span>&#123;</span><br><span class="line">  Foo *p = factory(arg);</span><br><span class="line">  <span class="comment">//使用p</span></span><br><span class="line">  delete p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">p</span><span class="params">(new <span class="type">int</span>(<span class="number">42</span>))</span>;</span><br><span class="line"><span class="keyword">auto</span> q = p;</span><br><span class="line">delete p;</span><br><span class="line">p = nullptr;</span><br></pre></td></tr></table></figure>
<h3 id="1213-shared_ptr和new结合使用"><a class="markdownIt-Anchor" href="#1213-shared_ptr和new结合使用"></a> 12.1.3 shared_ptr和new结合使用</h3>
<ul>
<li>接受指针参数的智能指针构造函数是explicit的
<ul>
<li>不能将一个内置指针隐式转换为一个智能指针,必须使用直接初始化形式来初始化一个智能指针</li>
<li><mark>不能进行内置指针到智能指针间的隐式转换</mark></li>
</ul>
</li>
<li>默认情况下,一个用来初始化智能指针的普通指针必须指向动态内存,因为智能指针默认使用delete释放它所关联的对象
<ul>
<li>可以将智能指针绑定到一个指向其他类型的资源的指针上,但是为了这样做,必须提供自己的操作来替代delete</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用new返回的指针来初始化智能指针</span></span><br><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; p1;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能将一个内置指针隐式转换为一个智能指针,必须使用直接初始化形式来初始化一个智能指针</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>); <span class="comment">//错误：必须使用直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;  <span class="comment">//正确：使用直接初始化形式</span></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(p);    <span class="comment">//错误,存在隐式转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>定义和改变shared_ptr的其他方法</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>shared_ptr&lt;T&gt; p(q)</td>
<td>p管理内置指针q所指向的对象;q必须指向new分配的内存,且能转换为T*类型</td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt; p(u)</td>
<td>p从unique_ptr u那里接管了对象的所有权,将u置为空</td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt; p(q,d)</td>
<td>p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用对象d来代替delete</td>
</tr>
<tr>
<td>shared_ptr&lt;T&gt; p(p2,d)</td>
<td>p时shared_ptr p2的拷贝,唯一的区别时p将用可调用对象d来代替delete</td>
</tr>
<tr>
<td>p.reset()</td>
<td>若p是唯一指向其对象的shared_ptr,reset会释放此对象</td>
</tr>
<tr>
<td>p.reset(q)</td>
<td>若传递了可选的参数内置指针q,会令p指向q,否则会将p置为空</td>
</tr>
<tr>
<td>p.reset(q,d)</td>
<td>若传递了参数d,将会调用d而不是delete来释放q</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>不要混合使用普通指针和智能指针</strong>
<ul>
<li>shared_ptr可以协调对象的析构,但仅限于其自身的拷贝之间(推荐make_shared而不是new的原因)</li>
<li>在分配对象的同时就将shared_ptr与之绑定,从而避免无意中将同一块内存绑定到多个独立创建的shared_ptr上</li>
<li>将一个shared_ptr绑定到一个普通指针时,就将内存的管理责任交给了这个shared_ptr
<ul>
<li>一旦这样做了,就不应该再使用内置指针来访问shared_ptr所指向的内存了</li>
</ul>
</li>
<li><mark>使用一个内置指针来访问一个智能指针所负责的对象是很危险的,因为无法知道对象何时会被销毁</mark></li>
</ul>
</li>
<li><strong>不要使用get初始化另一个智能指针或为智能指针赋值</strong>
<ul>
<li>智能指针类型定义了一个get函数,返回一个内置指针,指向智能指针管理的对象
<ul>
<li>使用场景：<mark>需要向不支持使用智能指针的代码传递指针</mark></li>
</ul>
</li>
<li><strong>使用get返回的指针不能delete</strong></li>
</ul>
</li>
<li><strong>用reset将新的指针赋予一个shared_ptr</strong>:
<ul>
<li>与赋值类似,reset会更新引用计数,如果需要的话,会释放p指向的对象</li>
<li>reset成员经常与unique一起使用,来控制多个shared_ptr共享的对象</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数被调用时ptr被创建并初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用ptr</span></span><br><span class="line">&#125; <span class="comment">//ptr离开作用域,被销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// process的参数是传值方式传递</span></span><br><span class="line"><span class="comment">// 拷贝一个shared_ptr会递增其引用计数,因此,在process运行过程中,引用计数值至少为2</span></span><br><span class="line"><span class="comment">// 当process结束时,ptr的引用计数会递减,但不会变为0</span></span><br><span class="line"><span class="comment">// 因此,当局部变量ptr被销毁时,ptr指向的内存不会被释放</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">//引用计数为1</span></span><br><span class="line"><span class="built_in">process</span>(p); <span class="comment">//拷贝p会递增它的引用计数;在process中引用计数值为2</span></span><br><span class="line"><span class="type">int</span> i = *p; <span class="comment">//正确;引用计数值为1</span></span><br><span class="line"><span class="comment">// 虽然不能传递给process一个内置指针,但可以传递给它一个(临时的)shared_ptr,这个shared_ptr是用一个内置指针显式构造的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然不能传递给process一个内置指针,但可以传递给它一个(临时的)shared_ptr,这个shared_ptr是用一个内置指针显式构造的</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;</span><br><span class="line"><span class="built_in">process</span>(x); <span class="comment">//错误：不能将int*转换为一个shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));  <span class="comment">//合法的,但内存会被释放</span></span><br><span class="line"><span class="type">int</span> j = *x; <span class="comment">//未定义的：x是一个空悬指针</span></span><br><span class="line"><span class="comment">// 将一个临时shared_ptr传递给process</span></span><br><span class="line"><span class="comment">// 当这个调用所在的表达式结束时,这个临时对象就被销毁了</span></span><br><span class="line"><span class="comment">// 但x继续指向(已经释放的)内存,从而变成一个空悬指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将另一个智能指针绑定到get返回的指针上是错误的</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="type">int</span> *q = p.<span class="built_in">get</span>();</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 新程序块</span></span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(q);</span><br><span class="line">&#125;<span class="comment">//程序块结束,q被销毁,它指向的内存被释放</span></span><br><span class="line"><span class="type">int</span> foo = *p; <span class="comment">//未定义：p指向的内存已被释放</span></span><br><span class="line"></span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);  <span class="comment">//错误：不能将一个指针赋予shared_ptr</span></span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>)); <span class="comment">//正确：p指向一个新对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在改变底层对象之前,我们检查自己是否是当前对象仅有的用户。如果不是,在改变之前要制作一份新的拷贝</span></span><br><span class="line"><span class="keyword">if</span>(!p.<span class="built_in">unique</span>())</span><br><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));</span><br><span class="line">*p += newVal;</span><br></pre></td></tr></table></figure>
<h3 id="1214-智能指针和异常"><a class="markdownIt-Anchor" href="#1214-智能指针和异常"></a> 12.1.4 智能指针和异常</h3>
<ul>
<li><mark>可以使用智能指针确保资源被释放</mark>
<ul>
<li>如果使用智能指针,即使程序块过早结束,智能指针类也能确保在内存不再需要时将其释放</li>
</ul>
</li>
<li><strong>使用自定义的释放操作</strong>
<ul>
<li><strong>删除器函数</strong>必须能够完成对shared_ptr中保存的指针进行释放的操作</li>
</ul>
</li>
<li>正确使用智能指针,必须坚持一些基本规范：
<ul>
<li>不使用相同的内置指针值初始化(或reset)多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>不使用get()初始化或reset另一个智能指针</li>
<li>如果使用get()返回的指针,记住当最后一个对应的智能指针销毁后,指针就变为无效了</li>
<li>如果使用智能指针管理的资源不是new分配的内存,记住传递给它一个删除器</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络库代码(示例)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>;</span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connect)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">  <span class="comment">//获得一个连接</span></span><br><span class="line">  connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line"><span class="comment">// 使用连接</span></span><br><span class="line">  <span class="comment">// 如果在f推出之  前忘记调用disconnect,就无法关闭c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放操作,删除器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123;<span class="built_in">disconnect</span>(*p);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">  <span class="comment">//获得一个连接</span></span><br><span class="line">  connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">  <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c,end_connection)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使用连接</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 如果在f推出之  前忘记调用disconnect,就无法关闭c</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="1215-unique_ptr"><a class="markdownIt-Anchor" href="#1215-unique_ptr"></a> 12.1.5 unique_ptr</h3>
<ul>
<li><strong>一个unique_ptr拥有它所指向的对象</strong>
<ul>
<li>与shared_ptr不同,某个时刻只能有一个unique_ptr指向一个给定对象</li>
<li>当unique_ptr被销毁时,它所指向的对象也被销毁</li>
<li>当定义一个unique_ptr时,需要将其绑定到一个new返回的指针上
<ul>
<li>类似shared_ptr,初始化unique_ptr必须采用直接初始化形式</li>
</ul>
</li>
<li><mark>unique_ptr不支持普通的拷贝或赋值操作</mark></li>
</ul>
</li>
<li>可调用release或reset将指针的所有权转移
<ul>
<li>release成员返回unique_ptr当前保存的指针并将其置为空
<ul>
<li>release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值</li>
<li>调用release会切断unique_ptr和它原来管理的对象间的联系</li>
</ul>
</li>
<li>reset成员接受一个可选的指针参数,令unique_ptr重新指向给定的指针</li>
</ul>
</li>
<li><strong>传递unique_ptr参数和返回unique_ptr</strong>
<ul>
<li>可以拷贝或赋值一个将要被销毁的unique_ptr</li>
<li>auto_ptr(标准库的较早版本,具有unique_ptr的部分特性,但不是全部)
<ul>
<li>不能在容器中保存auto_ptr,也不能从函数中返回auto_ptr</li>
<li>虽然auto_ptr仍是标准库的一部分,但编写程序时应该使用unique_ptr</li>
</ul>
</li>
</ul>
</li>
<li><strong>向unique_ptr传递删除器</strong>
<ul>
<li>重载一个unique_ptr中默认的删除器</li>
<li>必须在尖括号中unique_ptr指向类型之后提供删除器类型</li>
<li>在创建或reset一个这种unique_ptr类型的对象时,必须提供一个指定类型的可调用对象(删除器)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>unique_ptr操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>unique_ptr&lt;T&gt; u1</td>
<td>空unique_ptr,可以指向类型为T的对象。u1会使用delete来释放它的指针</td>
</tr>
<tr>
<td>unique_ptr&lt;T,D&gt; u2</td>
<td>u2会使用一个类型为D的可调用对象来释放它的指针</td>
</tr>
<tr>
<td>unique_ptr&lt;T,D&gt; u(d)</td>
<td>空unique_ptr,指向类型为T的对象,用类型为D的对象d代替delete</td>
</tr>
<tr>
<td>u=nullptr</td>
<td>释放u指向的对象,将u置为空</td>
</tr>
<tr>
<td>u.release()</td>
<td>u放弃对指针的控制权,返回指针,并将u置为空</td>
</tr>
<tr>
<td>u.reset()</td>
<td>释放u指向的对象</td>
</tr>
<tr>
<td>u.reset(q)</td>
<td>如果提供了内置指针q,令u指向这个对象</td>
</tr>
<tr>
<td>u.reset(nullptr)</td>
<td>如果提供了内置指针q,令u指向这个对象</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Stegosaurus&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从函数返回一个unique_ptr</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p指向一个类型为objT的对象,并使用一个类型为delT的对象释放objT对象</span></span><br><span class="line"><span class="comment">// 调用一个名为fcn的delT类型对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT,delT&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> objT,fcn)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="1216-weak_ptr"><a class="markdownIt-Anchor" href="#1216-weak_ptr"></a> 12.1.6 weak_ptr</h3>
<ul>
<li>weak_ptr是一种不控制所指向对象生存期的智能指针,它指向由一个shared_ptr管理的对象
<ul>
<li>将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数</li>
<li>一旦最后一个指向对象的shared_ptr被销毁,对象就会被释放(即使有weak_ptr指向对象)</li>
</ul>
</li>
<li>由于对象可能不存在,不能使用weak_ptr直接访问对象,而必须调用lock
<ul>
<li>此函数检查weak_ptr指向的对象是否仍存在</li>
<li>如果存在,lock返回一个指向共享对象的shared_ptr</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>weak_ptr操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>weak_ptr&lt;T&gt; w</td>
<td>空weak_ptr,可以指向类型为T的对象</td>
</tr>
<tr>
<td>weak_ptr&lt;T&gt; w(sp)</td>
<td>与shared_ptr sp指向相同对象的weak_ptr</td>
</tr>
<tr>
<td>w = p</td>
<td>p可以是一个shared_ptr或一个weak_ptr。w与p共享对象</td>
</tr>
<tr>
<td>w.reset()</td>
<td>将w置为空</td>
</tr>
<tr>
<td>w.use_count()</td>
<td>与w共享对象的shared_ptr的数量</td>
</tr>
<tr>
<td>w.expired()</td>
<td>若w.use_count为0,返回true</td>
</tr>
<tr>
<td>w.lock()</td>
<td>若expired为true,返回一个空shared_ptr;否则返回一个指向w的对象的shared_ptr</td>
</tr>
</tbody>
</table>
</div><div class="story post-story"><h2 id="122-动态数组"><a class="markdownIt-Anchor" href="#122-动态数组"></a> 12.2 动态数组</h2>
<ul>
<li>C++语言和标准库提供了两种一次分配一个对象数组的方法</li>
<li>C++语言定义了另一种new表达式语法,可以分配并初始化一个对象数组</li>
<li>标准库中包含一个名为allocator的类,允许我们将分配和初始化分离</li>
</ul>
<h3 id="1221-new和数组"><a class="markdownIt-Anchor" href="#1221-new和数组"></a> 12.2.1 new和数组</h3>
<ul>
<li>为了new分配一个对象数组,需要在类型名之后跟一对方括号,在其中指明要分配的对象的数目</li>
<li>new分配一个数组时,得到的是<strong>一个数组元素类型的指针</strong>
<ul>
<li>分配的内存不是一个数组类型,不能对动态数组调用begin和end,不能用范围for语句</li>
</ul>
</li>
<li>初始化动态分配对象的数组
<ul>
<li>可以对数组中的元素进行值初始化,在大小后跟着一对空括号
<ul>
<li><mark>不能在括号中给出初始化器,意味着不能用auto分配数组</mark></li>
</ul>
</li>
<li>可以使用元素初始化器的花括号列表</li>
</ul>
</li>
<li><strong>使用new[0]时</strong>：动态数组正确,对于零长度的数组来说,此指针就像尾后指针一样,但<strong>指针不能解引用</strong></li>
<li><strong>释放动态数组</strong>
<ul>
<li>特殊形式的delete：在指针前加一个空方括号</li>
<li><mark>如果在delete一个数组指针时忘记了方括号,或者在delete一个单一对象的指针时使用了方括号,编译器很可能不会给出警告。程序可能在执行过程中在没有任何警告的情况下行为异常</mark></li>
</ul>
</li>
<li><strong>智能指针和动态数组</strong>
<ul>
<li>可以管理new分配的数组的unique_ptr版本,必须在对象类型后面跟一对空方括号
<ul>
<li>当一个unique_ptr指向一个数组时,不能使用点和箭头成员运算符(毕竟unique_ptr指向的是一个数组而不是单个对象),可以使用下标访问成员</li>
</ul>
</li>
<li><mark>使用shared_ptr管理一个动态数组,必须提供自定义的删除器</mark>
<ul>
<li>shared_ptr不直接支持动态数组管理这一特性会影响访问数组中的元素
<ul>
<li>为了访问数组中的元素,必须用get获取一个内置指针,然后用它来访问数组元素</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>指向数组的unique_ptr</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>unique_ptr&lt;T[]&gt; u</td>
<td>u可以指向一个动态分配的数组</td>
</tr>
<tr>
<td>unique_ptr&lt;T[]&gt; u(p)</td>
<td>u可以指向内置指针p所指向的动态分配的数组;p必须能转换成类型T*</td>
</tr>
<tr>
<td>u[i]</td>
<td>返回u拥有的数组中位置i处的对象</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">get_size</span>()];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>](); <span class="comment">//10个值初始化为0的int</span></span><br><span class="line"><span class="type">int</span> *pia1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [] pa;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">up.<span class="built_in">release</span>();   <span class="comment">//自动用delete[]销毁其指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了使用shared_ptr,必须提供删除器</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>],[](<span class="type">int</span> *p) &#123;<span class="keyword">delete</span>[] p;&#125;)</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>(); <span class="comment">//使用提供的lambda释放数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用get获取一个内置指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i!=<span class="number">10</span>;++i)&#123;</span><br><span class="line">  *(sp.<span class="built_in">get</span>()+i) = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1222-allocator类"><a class="markdownIt-Anchor" href="#1222-allocator类"></a> 12.2.2 allocator类</h3>
<ul>
<li>new灵活性上的限制：希望将内存分配和对象初始化组合在一起</li>
<li><strong>allocator类</strong>
<ul>
<li><strong>在头文件memory中</strong></li>
<li>帮助将内存分配和对象构造分离开,提供类型感知的内存分配方法,分配的内存时原始的,未构造的</li>
<li>必须指明allocator可以分配的对象类型(当一个allocator对象分配内存时,会根据给定的对象类型来确定恰当的内存大小和对齐位置)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>allocator类及其算法</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>allocator&lt;T[]&gt; a</td>
<td>定义了一个名为a的allocator对象,可为类型T的对象分配内存</td>
</tr>
<tr>
<td>a.allocator(n)</td>
<td>分配一段原始的,未构造的内存,保存n个类型为T的对象</td>
</tr>
<tr>
<td>a.deallocator(p,n)</td>
<td>释放从T*指针p中地址开始的内存;p必须是一个先前有allocate返回的指针,且n必须是p创建时所要求的大小;在调用之前必须对这块内存中的对象调用destory</td>
</tr>
<tr>
<td>a.construct(p,args)</td>
<td>p必须时一个类型为T*的指针,指向一块原始内存;arg被传递给类型为T的构造函数,用来在p指向的内存中构造一个对象</td>
</tr>
<tr>
<td>a.destroy(p)</td>
<td>对p指向的对象执行析构函数</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>allocator分配未构造的内存</strong>
<ul>
<li>construct成员函数接受一个指针和额外参数,初始化构造对象(额外参数必须时与构造的对象的类型相匹配的合法初始化器)</li>
<li>一旦元素被销毁后,就可以重新使用这部分内存来保存其他对象,也可以将其归还给系统
<ul>
<li>释放内存通过调用deallocate来完成</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;  <span class="comment">//可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n); <span class="comment">//分配n个未初始化的string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> q = p; <span class="comment">//q指向最后构造的元素之后的位置</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++); <span class="comment">//*q为空字符串</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++,<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>); <span class="comment">//*q为cccccccccc</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++,<span class="string">&quot;hi&quot;</span>); <span class="comment">//*q为hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁对象</span></span><br><span class="line"><span class="keyword">while</span>(q != p)</span><br><span class="line">  alloc.<span class="built_in">destroy</span>(--q);   <span class="comment">//释放真正构造的string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p,n);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>allocator算法</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>uninitialized_copy(b,e,b2)</td>
<td>从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中</td>
</tr>
<tr>
<td>uninitialized_copy_n(b,n,b2)</td>
<td>从迭代器b指向的元素开始,拷贝n个元素到b2开始的内存</td>
</tr>
<tr>
<td>uninitialized_fill(b,e,t)</td>
<td>在迭代器b和e指定的原始内存范围中创建对象,对象的值均为t的拷贝</td>
</tr>
<tr>
<td>uninitialized_fill_n(b,n,t)</td>
<td>在迭代器b指向的内存地址开始创建n个对象</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="13-拷贝控制"><a class="markdownIt-Anchor" href="#13-拷贝控制"></a> 13 拷贝控制</h1>
<ul>
<li>一个类通过定义5种特殊的成员函数来控制显式地或隐式地指定在此类型地的对象拷贝,移动或销毁时做什么
<ul>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数</li>
<li>移动赋值运算符</li>
<li>析构函数</li>
</ul>
</li>
<li>拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么</li>
<li>拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么</li>
<li>析构函数定义了当此类型对象销毁时做什么</li>
</ul>
</div><div class="story post-story"><h2 id="131-拷贝赋值与销毁"><a class="markdownIt-Anchor" href="#131-拷贝赋值与销毁"></a> 13.1 拷贝,赋值与销毁</h2>
<h3 id="1311-拷贝构造函数"><a class="markdownIt-Anchor" href="#1311-拷贝构造函数"></a> 13.1.1 拷贝构造函数</h3>
<ul>
<li>拷贝构造函数：<mark>构造函数的第一个参数是自身的引用</mark>,且任何额外参数都有默认值
<ul>
<li>拷贝构造函数通常<strong>不应该是explicit的</strong></li>
</ul>
</li>
<li><strong>合成拷贝构造函数</strong>
<ul>
<li>即使定义了其他构造函数,编译器也会合成一个拷贝构造函数
<ul>
<li><strong>对某些类,合成拷贝构造函数用来阻止拷贝该类类型的对象</strong></li>
<li>一般情况,合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中(拷贝每个非static成员)
<ul>
<li><strong>对于类类型,会使用其拷贝构造函数拷贝</strong></li>
<li>内置类型的成员则直接拷贝</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>拷贝初始化</strong>
<ul>
<li>使用直接初始化,实际上是要求编译器使用普通的函数匹配来选择与提供的参数最匹配的构造函数</li>
<li>使用拷贝初始化,要求编译器将右侧运算对象拷贝到正在创建的对象中(必要时还要进行类型转换)</li>
<li><mark>如果一个类由一个移动构造函数,则拷贝初始化有时候会使用移动构造函数而非拷贝构造函数完成</mark>
<ul>
<li>拷贝初始化在用=定义变量时会发生</li>
<li>将一个对象作为实参传递给一个非引用类型的形参会发生</li>
<li>从一个返回类型为非引用类型的函数返回一个对象会发生</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员会发生</li>
</ul>
</li>
</ul>
</li>
<li>参数和返回值
<ul>
<li>在函数调用过程中,具体非引用类型的参数要进行拷贝初始化
<ul>
<li>当一个函数具有非引用的返回类型时,返回值会被用来初始化调用方的结果</li>
</ul>
</li>
<li>拷贝构造函数用来初始化非引用类类型参数(若其参数不是引用类型则调用不成功)</li>
</ul>
</li>
<li><strong>拷贝初始化的限制</strong>：若初始化过程需要通过<strong>一个explicit的构造函数</strong>来进行类型转换,使用拷贝初始化还是直接初始化就都可以</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;);</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(<span class="type">const</span> Sakes_data&amp; orig):</span><br><span class="line">    <span class="built_in">bookNo</span>(orig.bookNo),<span class="built_in">units_sold</span>(orig.units_sold),<span class="built_in">revenue</span>(orig.revenue)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">dots</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27; &#x27;</span>)</span></span>; <span class="comment">//直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(dots)</span></span>;   <span class="comment">//直接初始化</span></span><br><span class="line">string s2 = dots; <span class="comment">//拷贝初始化</span></span><br><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>; <span class="comment">//拷贝初始化</span></span><br><span class="line">string nines = <span class="built_in">string</span>(<span class="number">100</span>,<span class="string">&#x27;9&#x27;</span>);   <span class="comment">//拷贝初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = <span class="number">10</span>;    <span class="comment">//错误,接收大小参数的构造函数是explicit</span></span><br></pre></td></tr></table></figure>
<h3 id="1312-拷贝赋值运算符"><a class="markdownIt-Anchor" href="#1312-拷贝赋值运算符"></a> 13.1.2 拷贝赋值运算符</h3>
<ul>
<li>类控制其对象如何让赋值
<ul>
<li>类未定义拷贝赋值运算符时,编译器会合成拷贝赋值运算符</li>
</ul>
</li>
<li><strong>重载赋值运算符</strong>
<ul>
<li>重载运算符本质上时函数,其名字<strong>由operator关键字</strong>后接表示要定义的运算符的符号组成
<ul>
<li>重载赋值运算符就是operator=的函数</li>
</ul>
</li>
<li>重载运算符的参数必须表示运算符的运算对象,某些运算符必须定义为成员函数
<ul>
<li><mark>若运算符时一个成员函数,其左侧运算符对象就绑定到隐式的this参数</mark></li>
</ul>
</li>
<li>为了与内置类型的赋值保持一致,<mark>赋值运算符通常返回一个指向其左侧运算对象的引用</mark></li>
</ul>
</li>
<li><strong>合成拷贝赋值运算符</strong>
<ul>
<li>类似拷贝构造函数,对于某些类,合成拷贝赋值运算符用来禁止该类型对象的赋值</li>
<li>拷贝赋值运算符会将右侧运算对象的每个非static成员赋给左侧运算对象对象的成员</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝赋值运算符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;); <span class="comment">//赋值运算符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于合成拷贝赋值运算符</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="type">const</span> Sakes_data&amp; orig)</span><br><span class="line">&#123;</span><br><span class="line">  bookNo = orig.bookNo;</span><br><span class="line">  units_sold = orig.units_sold;</span><br><span class="line">  revenue = orig.revenue;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1313-析构函数"><a class="markdownIt-Anchor" href="#1313-析构函数"></a> 13.1.3 析构函数</h3>
<ul>
<li>析构函数释放对象使用的资源,并销毁对象的非static数据成员
<ul>
<li>析构函数是类的成员函数,名字由波浪号接类名构成,没有返回值也不接受参数</li>
</ul>
</li>
<li>析构函数,首先执行函数体,然后销毁成员,成员按初始化顺序销毁使用
<ul>
<li><mark>隐式销毁一个内置指针类型的成员不会delete它所指向的对象</mark></li>
<li><mark>智能指针成员在析构时会被自动销毁</mark></li>
<li><mark>当一个对象的引用或指针离开作用域时,析构函数不会执行</mark></li>
</ul>
</li>
<li><strong>合成析构函数</strong>：合成函数用来阻止该类型的对象被销毁,如果不是这种情况,合成析构函数的函数体为空</li>
</ul>
<h3 id="1314-三五法则"><a class="markdownIt-Anchor" href="#1314-三五法则"></a> 13.1.4 三/五法则</h3>
<ul>
<li>三个基本操作可以控制类的拷贝操作：拷贝构造函数,拷贝赋值运算符,析构函数
<ul>
<li>新标准中,可以定义移动构造函数和移动赋值运算符</li>
</ul>
</li>
<li><strong>需要析构函数的类也需要拷贝和赋值操作</strong></li>
<li><strong>需要拷贝构造函数的类也需要拷贝赋值运算符,反之亦然</strong></li>
</ul>
<h3 id="1315-使用default"><a class="markdownIt-Anchor" href="#1315-使用default"></a> 13.1.5 使用=default</h3>
<ul>
<li><mark>可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成地版本</mark>
<ul>
<li>在类内用=default修饰成员的声明时,合成的函数将隐式地声明为内联的</li>
<li><mark>只能对具有合成版本的成员函数使用=default(即,默认构造函数或拷贝控制成员)</mark></li>
<li>如果不希望合成的成员是内联函数,应该只对成员的类外定义使用=default</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝控制成员;使用default</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Sales_data&amp;);</span><br><span class="line">    ~<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="type">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1316-阻止拷贝"><a class="markdownIt-Anchor" href="#1316-阻止拷贝"></a> 13.1.6 阻止拷贝</h3>
<ul>
<li>对于拷贝构造函数和拷贝赋值运算符没有意义地类,定义时必须采用某种机制阻止拷贝或赋值
<ul>
<li>新标准下,可以<strong>通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝</strong></li>
<li>删除的函数：虽然声明了,但不能以任何方式使用,在函数的参数列表后面加上=delete来指明希望定义为删除的
<ul>
<li><mark>=delete必须出现在函数第一次声明时</mark></li>
</ul>
</li>
</ul>
</li>
<li><strong>析构函数不能是删除的函数(避免无法销毁此类型的对象)</strong>
<ul>
<li>删除了析构函数的类型编译器将不允许定义该类型的变量或创建该类的临时对象</li>
</ul>
</li>
<li><strong>合成的拷贝控制成员可能是删除的</strong>
<ul>
<li><mark>如果一个类有数据成员不能默认构造、拷贝、复制或销毁,则对应的成员函数将被定义为删除的,编译器将这些合成的成员定义为删除的函数</mark></li>
<li>一个成员由删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的</li>
<li>对于具有引用成员或无法默认构造的const成员的类,编译器不会为其合成默认构造函数
<ul>
<li>如果一个类有const成员,则不能使用合成的拷贝赋值运算符</li>
<li>对于有引用成员的类,合成拷贝赋值运算符被定义为删除的
<ul>
<li>将一个新值赋予一个引用成员,为这样的类合成拷贝赋值运算符,则赋值后,左侧运算对象仍然指向赋值前一样的对象,而不会与右侧运算对象指向相同的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>private拷贝控制</strong>
<ul>
<li>在新标准之前,类是通过将其拷贝构造函数和拷贝赋值运算符声明为private阻止拷贝</li>
<li><mark>现在不推荐使用</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCopy</span>&#123;</span><br><span class="line">  <span class="built_in">NoCopy</span>() = <span class="built_in">default</span>();</span><br><span class="line">  <span class="built_in">NoCopy</span>(<span class="type">const</span> Nocopy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  NoCopy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;  <span class="comment">//阻止赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoDtor</span>&#123;</span><br><span class="line">  <span class="built_in">NoDtor</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">NoDtor</span>() = <span class="keyword">delete</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NoDtor *p = <span class="keyword">new</span> <span class="built_in">NoDtor</span>();   <span class="comment">//正确,但不能delete p</span></span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//错误,析构函数是删除的</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="132-拷贝控制和资源管理"><a class="markdownIt-Anchor" href="#132-拷贝控制和资源管理"></a> 13.2 拷贝控制和资源管理</h2>
<ul>
<li>管理类外资源的类必须定义拷贝控制成员
<ul>
<li>这种类需要通过析构函数来释放对象所分配的资源(一个类需要析构函数必须肯定需要拷贝构造函数和拷贝赋值运算符)</li>
<li>为了定义这些成员,首先必须确定此类型对象的拷贝语义,有两种选择：定义拷贝操作,使类的行为看起来像一个值或像一个指针
<ul>
<li><strong>类的行为像一个值,意味着应该有自己的状态</strong>;拷贝一个像值的对象时,副本和原对象使完全独立的,<strong>改变副本不会对原对象产生任何影响</strong></li>
<li><strong>行为像指针的类则共享状态</strong>;拷贝一个类使,副本和原对象使用相同的底层数据;改变副本会改变原对象,反之亦然</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1321-行为像值的类"><a class="markdownIt-Anchor" href="#1321-行为像值的类"></a> 13.2.1 行为像值的类</h3>
<ul>
<li>为了提供类值得行为,对于类管理的资源,每个对象都应该拥有一份自己的拷贝</li>
<li><strong>类值拷贝赋值运算符</strong>
<ul>
<li><mark>赋值运算符通常组合了析构函数和构造函数的操作</mark>
<ul>
<li>赋值运算符会从右侧运算对象拷贝数据</li>
<li>赋值运算符会销毁左侧运算对象的资源</li>
</ul>
</li>
<li><mark>即使是将一个对象赋予它自身,也要能正确工作,一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 意味着对于ps指向string,每个HasPtr对象都必须有自己的拷贝</span></span><br><span class="line"><span class="comment">// 为了实现类值,需要定义一个拷贝构造函数,析构函数,拷贝赋值运算符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">      <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)),<span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//对ps指向的string,每个HasPtr对象都有自己的拷贝</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr &amp;p):</span><br><span class="line">      <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(*p.ps)),<span class="built_in">i</span>(p.i)&#123;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp;);</span><br><span class="line">    ~<span class="built_in">HasPtr</span>()&#123;<span class="keyword">delete</span> ps;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string *ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本例中,通过先拷贝右侧运算对象,可以处理自赋值情况,并且能保证在异常发生时代码安全</span></span><br><span class="line"><span class="comment">// 完成拷贝后,释放左侧运算对象的资源,并更新指针指向新分配的string</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; rhs)&#123;</span><br><span class="line">  <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">  <span class="keyword">delete</span> ps;</span><br><span class="line"></span><br><span class="line">  ps = newp;</span><br><span class="line">  i = rhs.i;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1322-定义行为像指针的类"><a class="markdownIt-Anchor" href="#1322-定义行为像指针的类"></a> 13.2.2 定义行为像指针的类</h3>
<ul>
<li>对于行为类似指针的类,需要定义拷贝构造函数和拷贝赋值运算符
<ul>
<li><mark>类展现类似指针的行为的最好办法是使用shared_ptr来管理类中的资源</mark>
<ul>
<li>拷贝(或赋值)一个shared_ptr会拷贝(赋值)shared_ptr所指向的指针,shared_ptr类自己记录共享所指向对象的数量;没有用户使用对象时,shared_ptr类负责释放资源</li>
</ul>
</li>
<li><mark>直接管理资源,使用<strong>引用计数</strong></mark>
<ul>
<li>引用计数的工作方式
<ul>
<li>除了初始化对象外,每个构造函数要创建一个引用计数,用来记录有多少个对象与正在创建的对象共享状态</li>
<li>构造函数不分配新的计数器,而是拷贝给定对象的数据成员</li>
<li>析构函数递减计数器,指出共享状态的用户减少一个</li>
<li>拷贝赋值运算符递减右侧运算对象的计数器,递减左侧运算对象的计数器</li>
</ul>
</li>
</ul>
</li>
<li><mark>在动态内存中保存计数器</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个使用引用计数的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> std::string &amp;s = std::<span class="built_in">string</span>()):</span><br><span class="line">      <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)),<span class="built_in">i</span>(<span class="number">0</span>),<span class="built_in">use</span>(<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr &amp;p):</span><br><span class="line">      <span class="built_in">ps</span>(p.ps),<span class="built_in">i</span>(p.i),<span class="built_in">use</span>(p.use)  &#123;++*use;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp;);</span><br><span class="line">    ~<span class="built_in">HasPtr</span>();</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string *ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::<span class="type">size_t</span> *use; <span class="comment">//用来记录有多少个对象共享*ps的成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr::~<span class="built_in">HasPtr</span>()&#123;</span><br><span class="line">  <span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">delete</span> use;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; rhs)&#123;</span><br><span class="line">  ++*rhs.use;</span><br><span class="line">  <span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">delete</span> use;</span><br><span class="line">  &#125;</span><br><span class="line">  ps = rhs.ps;</span><br><span class="line">  i = rhs.i;</span><br><span class="line">  use = rhs.use;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="133-交换操作"><a class="markdownIt-Anchor" href="#133-交换操作"></a> 13.3 交换操作</h2>
<ul>
<li>除了定义拷贝控制成员,管理资源的类还定义了一个swap的函数
<ul>
<li>swap函数应该调用swap,而不是std::swap</li>
</ul>
</li>
<li><strong>在赋值运算符中使用swap</strong>
<ul>
<li>定义swap的类通常用swap来定义赋值运算符,使用<strong>拷贝并交换</strong>的技术</li>
<li>使用拷贝和交换的赋值运算符自动就是异常安全的,且能正确处理自赋值</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line">  <span class="comment">// 将swap定义为friend,以便能访问HasPtr的(private的)数据成员</span></span><br><span class="line">  <span class="comment">// 由于swap的存在就是为了优化代码,将其声明为inline函数</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs,HasPtr &amp;rhs)</span></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;</span><br><span class="line">  <span class="built_in">swap</span>(lhs.ps,rhs.ps);</span><br><span class="line">  <span class="built_in">swap</span>(lhs.i,rhs.i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意rhs是按值传递的,意味着HasPtr的拷贝构造函数</span></span><br><span class="line"><span class="comment">// 将右侧运算对象中的string拷贝到rhs</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)&#123;</span><br><span class="line">  <span class="built_in">swap</span>(*<span class="keyword">this</span>,rhs);  <span class="comment">//rhs现在指向本对象曾经使用的内存</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">//  rhs被销毁,从而delete了rhs中的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="135-动态内存管理类"><a class="markdownIt-Anchor" href="#135-动态内存管理类"></a> 13.5 *动态内存管理类</h2>
<ul>
<li>某些类需要在运行时分配可变大小的内存空间,可以使用标准库容器来保存它们的数据
<ul>
<li>某些类需要自己进行内存分配,这些类必须定义自己的拷贝控制成员来管理所分配的内存</li>
</ul>
</li>
<li>将实现标准库vector类的一个简化版本,只针对于string,被命名为StrVec</li>
<li><strong>StrVec类的设计</strong>
<ul>
<li>在StrVec类中使用allocator类获得原始内存</li>
<li>使用destroy成员来销毁元素</li>
<li>alloc_n_copy会分配内存,并拷贝一个给定范围中的元素</li>
<li>free会销毁构造的元素并释放内存</li>
<li>chk_n_alloc保证StrVec至少有容纳一个新元素的空间</li>
<li>reallocate在内存用完时为StrVec分配新内存</li>
</ul>
</li>
<li><strong>使用construct</strong>
<ul>
<li>函数push_back调用chk_n_alloc确保空间容纳新元素</li>
</ul>
</li>
<li><strong>在重新分配内存的过程中移动而不是拷贝元素</strong>
<ul>
<li>移动拷贝函数</li>
<li>std::move;move的标准库函数,位于utility文件中</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrVec</span>():   <span class="comment">//allocator成员进行默认初始化</span></span><br><span class="line">      <span class="built_in">elements</span>(<span class="literal">nullptr</span>),<span class="built_in">first_free</span>(<span class="literal">nullptr</span>),<span class="built_in">cap</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">StrVec</span>(<span class="type">const</span> StrVec&amp;);    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    StrVec &amp;<span class="keyword">operator</span>=(<span class="type">const</span> StrVec&amp;);   <span class="comment">//拷贝赋值运算符</span></span><br><span class="line">    ~<span class="built_in">StrVec</span>();        <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> std::string&amp;)</span></span>;   <span class="comment">//拷贝元素</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> first_free - elements;&#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> cap - elements;&#125;</span><br><span class="line">    <span class="function">std::string *<span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> elements;&#125;</span><br><span class="line">    <span class="function">std::string *<span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> first_free;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Static std::allocator&lt;std::string&gt; alloc; <span class="comment">//分配元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">        <span class="built_in">reallocate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工具函数,被拷贝构造函数,赋值运算符和析构函数所使用</span></span><br><span class="line">    <span class="function">std::pair&lt;std::string*,std::string*&gt;  <span class="title">alloc_n_copy</span></span></span><br><span class="line"><span class="function">      <span class="params">(<span class="type">const</span> std::string*,<span class="type">const</span> std::string*)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reallocate</span><span class="params">()</span></span>;</span><br><span class="line">    std::string *elements;</span><br><span class="line">    std::string *first_free;</span><br><span class="line">    std::string *cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="136-对象移动"><a class="markdownIt-Anchor" href="#136-对象移动"></a> 13.6 对象移动</h2>
<ul>
<li>新标准的一个最主要特征是：<mark>可以移动而非拷贝对象的能力</mark>
<ul>
<li>标准库容器,string和shared_ptr类既支持移动也支持拷贝.IO类和unique_ptr类可以移动但不能拷贝</li>
</ul>
</li>
</ul>
<h3 id="1361-右值引用"><a class="markdownIt-Anchor" href="#1361-右值引用"></a> 13.6.1 右值引用</h3>
<ul>
<li><a href="#41-%E5%9F%BA%E7%A1%80">左值与右值的介绍</a></li>
<li>为了支持移动操作,新标准引入了新的引用类型——<strong>右值引用</strong>
<ul>
<li>右值引用就是必须绑定到右值的引用,使用&amp;&amp;获得右值引用,且只能绑定到一个将要销毁的对象</li>
<li>左值引用不能将其绑定到要求转换的表达式,字面常量或返回右值的表达式
<ul>
<li>返回左值引用的函数,连同赋值,下标,解引用和前置递增运算符都是返回左值,可以用左值引用绑定</li>
</ul>
</li>
<li>右值引用可以绑定到这类表达式上
<ul>
<li>返回非引用类型的函数,连通算数,关系,位以及后置递增运算符都生成右值,可以用const左值引用或右值绑定</li>
</ul>
</li>
</ul>
</li>
<li>左值持久,右值短暂
<ul>
<li>左值有持久的状态,而右值要么是字面常量,要么是表达式求值过程中创建的临时对象</li>
</ul>
</li>
<li><strong>变量是左值</strong>：变量可以看作只有一个运算对象而没有运算符的表达式
<ul>
<li>不能将一个右值引用绑定到一个右值引用类型的变量上</li>
<li>变量是左值,不能将一个右值引用直接绑定到一个变量(包括右值引用类型的变量)上</li>
</ul>
</li>
<li><strong>标准库move函数</strong>
<ul>
<li>可以显式地将一个左值转换位对应地右值引用</li>
<li>调用move就承诺：除了对左值赋值或销毁它之外,将不再使用它,且调用move之后,不能对移动后原对象地值做任何假设
<ul>
<li>可以销毁一个移后源对象,也可以赋予它新值,但不能使用一个移后源对象的</li>
<li><mark>使用move的代码应该使用std：：move而不是move,可以避免潜在的名字冲突</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1;    <span class="comment">//错误：表达式rr1是左值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);</span><br></pre></td></tr></table></figure>
<h3 id="1362-移动构造函数和移动赋值运算符"><a class="markdownIt-Anchor" href="#1362-移动构造函数和移动赋值运算符"></a> 13.6.2 移动构造函数和移动赋值运算符</h3>
<ul>
<li>移动拷贝函数的第一个参数是该类类型的一个引用
<ul>
<li>该引用为一个右值引用</li>
<li>任何额外的参数都必须有默认实参</li>
</ul>
</li>
<li>需要保证移后源对象处于销毁无害的状态,且一旦资源完成移动,源对象必须不再指向被移动的资源
<ul>
<li>动构造函数不分配任何新内存,而是接管给定的内存</li>
<li>接管内存后,将对象中的指针都置为nullptr</li>
</ul>
</li>
<li><strong>noexcept</strong>
<ul>
<li>承诺函数不抛出异常的一种方法,在参数列表后指定noexcept</li>
<li><mark>不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StrVec类定义移动构造函数</span></span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> <span class="comment">//移动操作不应抛出任何异常</span></span><br><span class="line">      : <span class="built_in">elements</span>(s.elements),<span class="built_in">first_free</span>(s.first_free),<span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 对其运行析构函数是安全的</span></span><br><span class="line">  s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>移动赋值运算符</strong>
<ul>
<li>移动赋值运算符执行于析构函数和移动构造函数相同的工作</li>
<li>以移动构造函数一样,若移动赋值运算符不跑出任何异常,就应该标记为noexcept</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;rhs)&#123;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = rhs.elements;</span><br><span class="line">    first_free = rhs.first_free;</span><br><span class="line">    cap = rhs.cap;</span><br><span class="line">    rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>移后源对象必须可析构</strong>
<ul>
<li>从一个对象移动数据并不会销毁此对象,但有时在移动操作完成后,源对象会被销毁
<ul>
<li>因此,当编写一个移动操作时,必须确保移后源对象进入一个可析构的状态</li>
<li>可通过将移后源对象的指针成员置为nullptr来实现的。</li>
</ul>
</li>
<li>除了将移后源对象置为析构安全的状态之外,移动操作还必须保证对象仍然是有效的
<ul>
<li>一般来说,对象有效就是指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值</li>
<li>另一方面,移动操作对移后源对象中留下的值没有任何要求</li>
<li>因此程序不应该依赖于移后源对象中的数据</li>
</ul>
</li>
</ul>
</li>
<li><strong>合成的移动操作</strong>
<ul>
<li>若一个类定义了拷贝构造函数,拷贝赋值运算符或析构函数,编译器就不会合成移动构造函数和移动赋值运算符</li>
<li>只有当一个类没有定义任何自己版本的拷贝控制成员,且类的每个非static数据成员都可以移动时,编译器才会为它合成移动构造函数或移动赋值运算符
<ul>
<li>编译器可以移动内置类型的成员</li>
<li>如果一个成员是类类型,且该类有对应的移动操作,编译器也能移动这个成员</li>
</ul>
</li>
<li>移动操作永远不会隐式定义为删除的函数
<ul>
<li>可以显式要求生成=default的移动操作,且编译器不能移动所有成员,则编译器会将移动操作定义为删除的函数</li>
<li>移动构造函数被定义为删除的函数的条件是：
<ul>
<li>有类成员定义了自己的拷贝构造函数且未定义移动构造函数,或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似</li>
<li>如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的,则类的移动构造函数或移动赋值运算符被定义为删除的</li>
<li>类似拷贝构造函数,如果类的析构函数被定义为删除的或不可访问的,则类的移动构造函数被定义为删除的</li>
<li>类似拷贝赋值运算符,如果有类成员是const的或是引用,则类的移动赋值运算符被定义为删除的</li>
</ul>
</li>
<li>移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符,则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的,需要定义自己的拷贝操作</li>
</ul>
</li>
</ul>
</li>
<li><mark>如果一个类有一个可用的拷贝构造函数而没有移动构造函数,则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。</mark></li>
<li><strong>拷贝并交换赋值运算符和移动操作</strong>
<ul>
<li>拷贝并交换赋值运算符：是函数匹配和移动操作间相互关系的一个很好的示例</li>
</ul>
</li>
<li>所有五个拷贝控制成员应该看作一个整体：一般来说,如果一个类定义了任何一个拷贝操作,它就应该定义所有五个操作。如前所述,某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//添加的移动构造函数</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(HasPtr &amp;&amp;p) <span class="keyword">noexcept</span> :<span class="built_in">ps</span>(p.ps),<span class="built_in">i</span>(p.i)&#123;p.ps = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 赋值运算符既是移动赋值运算符,也是拷贝赋值运算符</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)&#123;</span><br><span class="line">      <span class="built_in">swap</span>(*<span class="keyword">this</span>,rhs);</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为类添加了一个移动构造函数,它接管了给定实参的值</span></span><br><span class="line"><span class="comment">// 构造函数体将给定的HasPtr的指针置为0,从而确保销毁移后源对象是安全的</span></span><br><span class="line"></span><br><span class="line">hp = hp2; <span class="comment">//hp2是左值使用拷贝构造函数拷贝</span></span><br><span class="line">hp = std::<span class="built_in">move</span>(hp2);  <span class="comment">//移动构造函数移动hp2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>移动迭代器</strong>
<ul>
<li>一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器,<strong>移动迭代器的解引用运算符生成一个右值引用</strong></li>
<li>调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器</li>
</ul>
</li>
<li><strong>建议：不要随意使用移动操作</strong>
<ul>
<li>由于一个移后源对象具有不确定的状态,对其调用std：：move是危险的</li>
<li>调用move时,必须绝对确认移后源对象没有其他用户</li>
</ul>
</li>
</ul>
<h3 id="1363-右值引用和成员函数"><a class="markdownIt-Anchor" href="#1363-右值引用和成员函数"></a> 13.6.3 右值引用和成员函数</h3>
<ul>
<li>除了构造函数和赋值运算符之外,一个成员函数同时提供拷贝和移动版本,一个版本接收一个指向const的左值引用,第二个版本接收一个指向非const的右值引用
<ul>
<li><mark>区分移动和拷贝的重载函数通常有一个版本接受一个const T&amp;,而另一个版本接受一个T&amp;&amp;</mark></li>
<li>push_bakc的标准库容器提供两个版本</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> X&amp;)</span></span>; <span class="comment">//拷贝,绑定到任意类型的X</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>; <span class="comment">//移动,只能绑定到类型X的可修改的右值</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>右值和左值引用成员函数</strong>
<ul>
<li>在一个对象上调用成员函数,而不管该对象是一个左值还是右值</li>
<li>新标准中仍然允许向右值赋值,若希望阻止这种用法,希望强制左侧运算对象(即this指向的对象)是一个左值</li>
<li><strong>this的左右值属性与定义const成员函数相同</strong>,即在参数列表后放置一个<strong>引用限定符</strong>
<ul>
<li><mark>引用限定符可以是&amp;或&amp;&amp;,分别指出this可以指向一个左值或右值</mark></li>
<li><mark>类似const限定符,引用限定符只能用于(非static)成员函数,且必须同时出现在函数的声明和定义中</mark></li>
<li><mark>一个函数可以同时用const和引用限定。但引用限定符必须跟随在const限定符之后</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;a value&quot;</span>,s2 = <span class="string">&quot;another&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> n = (s1+s2).<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 + s2 = <span class="string">&quot;wow&quot;</span>;  <span class="comment">//正确,但应阻止这种用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) &amp;; <span class="comment">//只能向可修改的左值放置</span></span><br><span class="line">&#125;;</span><br><span class="line">Foo &amp;Foo::<span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;rhs) &amp;&#123;</span><br><span class="line">  <span class="comment">//do something works;</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="type">const</span> &amp;</span>; <span class="comment">//正确,const限定符在前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>重载和引用函数</strong>
<ul>
<li>可以综合引用限定符和const来区分一个成员函数的重载版本</li>
<li>当定义const成员函数时,可以定义两个版本,唯一的差别是一个版本有const限定而另一个没有</li>
<li><strong>引用限定的函数则不一样</strong>：如果定义两个或两个以上具有相同名字和相同参数列表的成员函数,就必须对所有函数都加上引用限定符,或者所有都不加
<ul>
<li><mark>如果一个成员函数有引用限定符,则具有相同参数列表的所有版本都必须有引用限定符</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="14-重载运算与类型转换"><a class="markdownIt-Anchor" href="#14-重载运算与类型转换"></a> 14 重载运算与类型转换</h1>
</div><div class="story post-story"><h2 id="141-基本概念"><a class="markdownIt-Anchor" href="#141-基本概念"></a> 14.1 基本概念</h2>
<ul>
<li>重载的运算符具有特殊名字的函数：名字由operator和其后要定义的运算符号共同组成,也包含返回类型,参数列表以及函数体
<ul>
<li>如果运算符函数是成员函数,则第一个左侧运算对象绑定到隐式的this指针上(成员运算符函数的显式参数数量比运算符的运算对象总数少一个)</li>
<li>对于一个运算符函数来说,它或者是类的成员,或者至少含有一个类类型的参数,意味着当运算符作用于内置类型的运算对象时,无法改变该运算符的含义</li>
</ul>
</li>
<li><strong>不能被重载的运算符</strong>
<ul>
<li>::</li>
<li>.*</li>
<li>.</li>
<li>? :</li>
</ul>
</li>
<li><strong>直接调用一个重载的运算符函数</strong>
<ul>
<li>将运算符作用于类型正确的实参,从而以这种简介调用重载的运算符函数</li>
<li><mark>可以像调用普通函数一样直接调用运算符函数,先指定函数名字,然后再传入数量正确,类型适当的实参</mark></li>
<li>可以显式调用成员运算符的函数：首先指定运算函数的对象的名字,然后使用点运算符访问希望调用的函数</li>
</ul>
</li>
<li><strong>某些运算符不应该被重载</strong>
<ul>
<li>某些运算符指定了运算对象求值的顺序,若重载则运算对象求值顺序的规则不发应用到重载的运算符上
<ul>
<li>特使是：逻辑与,逻辑或和逗号运算符</li>
</ul>
</li>
<li>C++对逗号运算符和取地址运算符定义了特殊含义,一般不会被重载</li>
</ul>
</li>
<li><strong>使用于内置类型一致的含义</strong>
<ul>
<li>某些操作在逻辑上与运算符相关,则适合于定义成重载的运算符</li>
<li>重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容,逻辑运算符和关系运算符应该返回bool,算数运算符应该返回一个类类型的值,赋值运算符和复合赋值运算符应该返回左侧运算对象的引用</li>
</ul>
</li>
<li><strong>选择作为成员或者非成员</strong>
<ul>
<li>定义重载的运算符时,必须首先决定将其声明为类的成员函数还是声明为一个普通的非成员函数
<ul>
<li>赋值(=),下标([ ]),调用(( ))和成员访问箭头(-&gt;)运算符必须是成员</li>
<li>复合赋值运算符一般来说应该是成员,但并非必须,这一点与赋值运算符略有不同</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符,如递增、递减和解引用运算符,通常应该是成员</li>
<li>具有对称性的运算符可能转换任意一端的运算对象,例如算术、相等性、关系和位运算符等,因此它们通常应该是普通的非成员函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：不饿能为int重定义内置的运算符</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个非成员运算符函数的等价调用</span></span><br><span class="line">data1 + data2;</span><br><span class="line"><span class="keyword">operator</span>+(data1,data2);</span><br><span class="line"><span class="comment">// 调用非成员函数operator+,传入data1,data2作为实参</span></span><br><span class="line"></span><br><span class="line">data1 += data2;</span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);</span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string t = s + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span> + s;  <span class="comment">//如果+时string的成员则产生错误</span></span><br><span class="line"><span class="comment">// 如果operator+时string类的成员,则上面的第一个加法等价于s.operator+(&quot;!&quot;)</span></span><br><span class="line"><span class="comment">// &quot;hi&quot;+s等价于&quot;hi&quot;.operator+(s)</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="142-输入和输出运算符"><a class="markdownIt-Anchor" href="#142-输入和输出运算符"></a> 14.2 输入和输出运算符</h2>
<ul>
<li>IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作
<ul>
<li>对两个运算符来说,IO库定义了用其读写内置类型的版本,而类需要自定义适合其对象的新版本以支持IO操作</li>
</ul>
</li>
</ul>
<h3 id="1421-重载输出运算符"><a class="markdownIt-Anchor" href="#1421-重载输出运算符"></a> 14.2.1 重载输出运算符&lt;&lt;</h3>
<ul>
<li>通常情况下,输出运算符的第一个形参是一个非常量ostream对象的引用,之所以ostream是非常量是因为向流写入内容会改变其状态;而该形参是引用时因为无法直接复制一个ostream对象
<ul>
<li>第二个形参一般来说是一个常量的引用,该常量是我们想要打印的类类型,第二个形参是引用的原因是我们希望避免复制实参</li>
<li>为了与其他输出运算符保持一致,operator&lt;&lt;一般要返回它的ostream形参</li>
</ul>
</li>
<li><strong>输出运算符尽量减少格式化操作</strong>
<ul>
<li>用于内置类型的输出运算符不太考虑格式化操作,尤其不会打印换行符</li>
<li>如果运算符打印了换行符,则用户就无法在对象的同一行内接着打印一些描述性的文本,相反,令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节</li>
<li><mark>通常,输出运算符应该主要负责打印对象的内容而非控制格式,输出运算符不应该打印换行符</mark></li>
</ul>
</li>
<li><strong>输入输出运算符必须使非成员函数</strong>
<ul>
<li>与iostream标准库兼容的输入输出运算符必须是普通的非成员函数,而不能是类的成员函数,否则左侧运算对象是类的一个对象</li>
<li>假设输入输出运算符是某个类的成员,则它们也必须是istream或ostream的成员,然而,这两个类属于标准库,并且无法给标准库中的类添加任何成员
<ul>
<li>如果希望为类自定义IO运算符,则必须将其定义成非成员函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sales_data的输出运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)&#123;</span><br><span class="line">  os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; item.revenus &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sales_data data;</span><br><span class="line">data&lt;&lt;cout; <span class="comment">//如果operator&lt;&lt;是Sales_data的成员</span></span><br></pre></td></tr></table></figure>
<h3 id="1422-重载输入运算符"><a class="markdownIt-Anchor" href="#1422-重载输入运算符"></a> 14.2.2 重载输入运算符&gt;&gt;</h3>
<ul>
<li>输入运算符的第一个形参是运算符将要读取的流的引用,第二个形参是将要读入到的对象的引用,该运算符通常会返回某个给定流的引用
<ul>
<li><strong>第二个形参之所以必须是非常量是因为输入运算符本身的目的就是将数据读入到这个对象中</strong></li>
</ul>
</li>
<li><mark>输入运算符必须处理输入可能失败的情况,而输出运算符不需要</mark></li>
<li>输入时的错误
<ul>
<li>当流含有错误类型的数据时读取操作可能会失败</li>
<li>当读取操作到达文件末尾或遇到输入流的其他错误时也会失败</li>
<li><strong>通常将对象置于合法的状态,能略微保护使用者免于受到输入错误的影响,当读取操作发生错误时,输入运算符应该负责从错误中恢复</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sales_data的输入运算符</span></span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is,Sales_data &amp;item)&#123;</span><br><span class="line">  <span class="type">double</span> price;</span><br><span class="line">  is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt;price;</span><br><span class="line">  <span class="keyword">if</span>(is)</span><br><span class="line">    item.revenue = item.units_sold * price;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    item = <span class="built_in">Sales_data</span>();</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="143-算术和关系运算符"><a class="markdownIt-Anchor" href="#143-算术和关系运算符"></a> 14.3 算术和关系运算符</h2>
<ul>
<li>通常情况下,把算数和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换
<ul>
<li>这些运算符一般不需要改变运算对象的状态,形参都是常量的引用</li>
</ul>
</li>
<li>算数运算符通常会计算它的两个运算对象并得到一个新值,操作完成后返回该局部变量的副本作为其结果
<ul>
<li>如果类定义了算数运算符,则一般也会定义一个对应的复合赋值运算符</li>
</ul>
</li>
<li><mark>如果类同时定义了算数运算符和相关的复合赋值运算符,则通常情况下应该使用复合赋值来实现算术运算符</mark></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最有效的方法是使用复合赋值来定义算数运算符</span></span><br><span class="line"><span class="comment">// 假设两个对象指向同一本书</span></span><br><span class="line">Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">  Sales_data sum = lhs;</span><br><span class="line">  sum += rhs;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1431-相等运算符"><a class="markdownIt-Anchor" href="#1431-相等运算符"></a> 14.3.1 相等运算符</h3>
<ul>
<li>C++中的类通过定义相等运算符来检测两个对象是否相等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>() &amp;&amp;</span><br><span class="line">         lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">         lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">  <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设计准则：
<ul>
<li>如果一个类含有判断两个对象是否相等的操作,则它显然应该把函数定义成operator==而非一个普通的命名函数</li>
<li>如果类定义了operator==,则该运算符应该能判断一组给定的对象中是否含有重复数据</li>
<li>通常情况下,相等运算符应该具有传递性</li>
<li>如果类定义了operator==,则这个类也应该定义operator!=</li>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另外一个,这意味着其中一个运算符应该负责实际比较对象的工作,而另一个运算符则只是调用那个真正工作的运算符</li>
</ul>
</li>
</ul>
<h3 id="1432-关系运算符"><a class="markdownIt-Anchor" href="#1432-关系运算符"></a> 14.3.2 关系运算符</h3>
<ul>
<li>定义了相等运算符的类常常包含关系运算符,特别是,因为关联容器和一些算法要用到小于运算符,所以定义operator&lt;会比较有用</li>
<li>通常情况下关系运算符应该
<ul>
<li>定义顺序关系,令其与关联容器中对关键字的要求一致;</li>
<li>如果类同时含有<mark>运算符的话,则定义一种关系令其与</mark>保持一致</li>
</ul>
</li>
<li>如果存在唯一一种逻辑可靠的&lt;定义,则应该考虑为这个类定义&lt;运算符</li>
<li>如果类同时还包含==,则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符</li>
</ul>
</div><div class="story post-story"><h2 id="144-赋值运算符"><a class="markdownIt-Anchor" href="#144-赋值运算符"></a> 14.4 赋值运算符</h2>
<ul>
<li>拷贝赋值和移动赋值运算符可以把类的一个对象赋值给该类的另一个对象
<ul>
<li>类可以定义其他赋值运算符以使用别的类型作为右侧运算对象</li>
</ul>
</li>
<li>和拷贝赋值及移动赋值运算符一样,其他重载的赋值运算符也必须先释放当前内存空间,再创建一个新空间
<ul>
<li>不同之处是运算符无须检查对象向自身的赋值</li>
</ul>
</li>
<li><strong>可以重载赋值运算符,不论形参的类型是什么,赋值运算符都必须定义为成员函数</strong></li>
<li><strong>复合赋值运算符</strong>
<ul>
<li>复合赋值运算符不非得是类的成员,但还是倾向于把包括复合赋值在内的所有赋值运算符都定义在类的内部</li>
<li><mark>为了与内置类型的复合赋值保持一致,类中的复合赋值运算符也要返回其左侧运算对象的引用</mark></li>
</ul>
</li>
<li>赋值运算符必须定义成类的成员,复合赋值运算符也通常定义为类的成员(两类运算符都应该返回左侧运算对象的引用)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库vector定义了第三种赋值运算符,接受花括号内的元素列表作为参数</span></span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line">v = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样也可以把这个运算符添加到StrVec类中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    StrVec &amp;<span class="keyword">operator</span>=(std::initializer_list&lt;std::string&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了与内置类型的赋值运算符保持一致,新的赋值运算符将返回其左侧运算对象的引用</span></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;string&gt; il)&#123;</span><br><span class="line">  <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span>(),il.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">free</span>();</span><br><span class="line">  elements = data.first;</span><br><span class="line">  first_free = cap = data.second;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sales_data类中复合赋值运算符的定义</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="type">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">  units_sold += rhs.units_sold;</span><br><span class="line">  revenue += rhs.revenue;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="145-下标运算符"><a class="markdownIt-Anchor" href="#145-下标运算符"></a> 14.5 下标运算符</h2>
<ul>
<li>表示容器的类通常可以通过元素在容器中的位置访问元素,这些类一般会定义下标运算符operator[]</li>
<li><mark>下标运算符必须是成员函数</mark>
<ul>
<li>下标运算符通常以所访问元素的引用作为返回值</li>
<li>最好定义下标运算符的常量版本和非常量版本,当作用于一个常量对象时,下标运算符返回常量引用确保不会给返回的对象赋值</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n)&#123;</span><br><span class="line">      <span class="keyword">return</span> elements[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> elements[n];</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string *elements;  <span class="comment">//指向数组首元素的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="146-递增和递减运算符"><a class="markdownIt-Anchor" href="#146-递增和递减运算符"></a> 14.6 递增和递减运算符</h2>
<ul>
<li>对于内置类型来说,递增和递减运算符既有前置版本还有后置版本
<ul>
<li>应该为类定义两个版本递增和递减运算符</li>
</ul>
</li>
<li>为了与内置版本保持一致前置运算符<strong>应该返回递增或递减后对象的引用</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递增和递减运算符的工作机理非常相似</span></span><br><span class="line"><span class="comment">// 前置版本：返回递增/递减对象的引用</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">  <span class="built_in">check</span>(curr,<span class="string">&quot;increment past end of StrBlobPtr&quot;</span>);</span><br><span class="line">  ++curr;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()&#123;</span><br><span class="line">  --curr;</span><br><span class="line">  <span class="built_in">check</span>(curr,<span class="string">&quot;decrement past begin of StrBlobPtr&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>区分前置和后置运算符</strong>
<ul>
<li>要想同时定义前置和后置运算符,需要解决同一个符号的重载问题
<ul>
<li><strong>后置版本接收一个额外的int类型的形参</strong>
<ul>
<li>当使用后置运算符时,编译器为形参提供了值为0的实参</li>
<li>形参的唯一作用就是区分前置版本和后置版本的函数,而不是真的在实现后置版本时参与运算</li>
</ul>
</li>
</ul>
</li>
<li><mark>为了与内置版本保持一致,后置运算符应该返回对象的原值(递增或递减之前的值),返回的形式是一个值而非引用</mark></li>
</ul>
</li>
<li><strong>显式地调用后置运算符</strong>
<ul>
<li>可以显式地调用一个重载的运算符,其效果与在表达式中以运算符号的形式使用它完全一样</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加后置运算符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在递增对象之前需要首先记录对象的状态</span></span><br><span class="line">StrBlobStr StrBlobStr::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">  StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">  ++*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">StrBlobStr StrBlobStr::<span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">  StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">  --*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用函数调用地方式调用后置版本</span></span><br><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;</span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);</span><br><span class="line">p.<span class="keyword">operator</span>++();</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="147-成员访问运算符"><a class="markdownIt-Anchor" href="#147-成员访问运算符"></a> 14.7 成员访问运算符</h2>
<ul>
<li>在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符
<ul>
<li>箭头运算符必须是类的成员,解引用运算符通常也是类的成员</li>
</ul>
</li>
<li><strong>对箭头运算符返回值的限定</strong>
<ul>
<li>令operator*完成任何指定操作,可以让operator*返回一个固定值或打印对象的内容或其他</li>
<li><mark>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>*() <span class="type">const</span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> p = <span class="built_in">check</span>(curr,<span class="string">&quot;dereference past end&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">    &#125;</span><br><span class="line">    std::string* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解引用运算符首先检查curr是否仍在作用范围内,如果是,则返回curr所指元素的一个引用</span></span><br><span class="line"><span class="comment">// 箭头运算符不执行任何自己的操作,而是调用解引用运算符并返回解引用结果元素的地址</span></span><br><span class="line"><span class="comment">// 值得注意的是,我们将这两个运算符定义成了const成员,这是因为与递增和递减运算符不一样,获取一个元素并不会改变StrBlobPtr对象的状态</span></span><br><span class="line"><span class="comment">// 同时,它们的返回值分别是非常量string的引用或指针,因为一个StrBlobPtr只能绑定到非常量的StrBlob对象</span></span><br><span class="line"></span><br><span class="line">(*point).mem; <span class="comment">//point是一个内置的指针类型</span></span><br><span class="line">point.<span class="built_in">operator</span>()-&gt;mem;  <span class="comment">//point是类的一个对象</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="148-函数调用运算符"><a class="markdownIt-Anchor" href="#148-函数调用运算符"></a> 14.8 函数调用运算符</h2>
<ul>
<li>如果类重载了函数调用运算符,可以像使用函数一样使用该类的对象
<ul>
<li>因为这样的类同时能存储状态,所以与普通函数相比更加灵活</li>
</ul>
</li>
<li><mark>函数调用运算符必须是成员函数</mark>
<ul>
<li>一个类可以定义多个不同版本的调用运算符,相互之间应该在参数数量或类型上有所区别</li>
<li>如果类定义了调用运算符,则该类的对象称作函数对象;因为可以调用这种对象,所以说这些对象的“行为像函数一样”</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">absInt</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val&lt;<span class="number">0</span>? -val:val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一种操作：函数调用运算符,它负责接受一个int类型的实参,然后返回该实参的绝对值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt abdObj;</span><br><span class="line"><span class="type">int</span> ui = <span class="built_in">absObj</span>(i);   <span class="comment">//将i传递给absObj.operator()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>含有状态的函数对象类
<ul>
<li>和其他类一样,函数对象除了operator()之外可以包含其他成员</li>
<li>函数对象类通常含有一些数据成员,成员被用于定制调用运算符中的操作</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintString</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream &amp;o = cout, <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>):</span><br><span class="line">      <span class="built_in">os</span>(o),<span class="built_in">sep</span>(c)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span> </span>&#123;os &lt;&lt; s &lt;&lt; seq;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;</span><br><span class="line">    <span class="type">char</span> seq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类有一个构造函数,它接受一个输出流的引用以及一个用于分隔的字符,这两个形参的默认实参分别是cout和空格。之后的函数调用运算符使用这些成员协助其打印给定的string</span></span><br></pre></td></tr></table></figure>
<h3 id="1481-lambda是函数对象"><a class="markdownIt-Anchor" href="#1481-lambda是函数对象"></a> 14.8.1 lambda是函数对象</h3>
<ul>
<li>在lambda表达式产生的类中含有一个重载的函数调用运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递给stable_sort作为最后一个实参的lambda表达式</span></span><br><span class="line"><span class="comment">// 根据单词长度第七进行排序,对于长度相同的字母按照字母表顺序排序</span></span><br><span class="line"><span class="function">stable <span class="title">sort</span><span class="params">(words.begin(),words.end())</span>,</span></span><br><span class="line"><span class="function">        []<span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为类似一个类的未命名对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShorterString</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在默认情况下,由lambda产生的类当中的函数调用运算符是一个const成员函数。如果lambda被声明为可变的,则调用运算符就不是const的了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用这个类代替lambda</span></span><br><span class="line"><span class="function">stable <span class="title">sort</span><span class="params">(words.begin(),words.end(),ShorterString())</span></span>;</span><br><span class="line"><span class="comment">// 第三个实参是新构建的ShorterString对象,当stable_sort内部的代码每次比较两个string时就会“调用”这一对象,此时该对象将调用运算符的函数体,判断第一个string的大小小于第二个时返回true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>表示lambda及相应捕获行为的类</strong>
<ul>
<li>当lambda表达式通过引用捕获变量时,需要确保lambda执行时引用所引用的对象确实存在</li>
<li>通过值捕获的变量被拷贝到lambda中
<ul>
<li>lambda产生的类必须为每个值捕获的变量建立对应的数据成员,同时创建构造函数,令其使用比获得变量的值来初始化数据成员</li>
</ul>
</li>
</ul>
</li>
<li><mark>lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数;它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定</mark></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到第一个长度不小于给定值的string对象</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),</span><br><span class="line">          [sz](<span class="type">const</span> string &amp;a)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=sz;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式产生的类将形成</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SizeComp</span>&#123;</span><br><span class="line">  <span class="built_in">sizeComp</span>(<span class="type">size_t</span> n):<span class="built_in">sz</span>(n)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第一个指向满足条件元素的迭代器,该元素满足size() is &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),<span class="built_in">SizeComp</span>(sz));</span><br></pre></td></tr></table></figure>
<h3 id="1482-标准库定义的函数对象"><a class="markdownIt-Anchor" href="#1482-标准库定义的函数对象"></a> 14.8.2 标准库定义的函数对象</h3>
<ul>
<li>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类,每个类分别定义了一个执行命名操作的调用运算符
<ul>
<li><strong>定义在functional头文件中</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>算术</th>
<th>关系</th>
<th>逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>plus&lt;Type&gt;</td>
<td>equal_to&lt;Type&gt;</td>
<td>logical_and&lt;Type&gt;</td>
</tr>
<tr>
<td>minus&lt;Type&gt;</td>
<td>no_equal_to&lt;Type&gt;</td>
<td>logical_or&lt;Type&gt;</td>
</tr>
<tr>
<td>multiplies&lt;Type&gt;</td>
<td>greater&lt;Type&gt;</td>
<td>logical_not&lt;Type&gt;</td>
</tr>
<tr>
<td>divides&lt;Type&gt;</td>
<td>greater_equal&lt;Type&gt;</td>
<td></td>
</tr>
<tr>
<td>modulus&lt;Type&gt;</td>
<td>less&lt;Type&gt;</td>
<td></td>
</tr>
<tr>
<td>negate&lt;Type&gt;</td>
<td>less_equal&lt;Type&gt;</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="1483-可调用对象与function"><a class="markdownIt-Anchor" href="#1483-可调用对象与function"></a> 14.8.3 可调用对象与function</h3>
<ul>
<li>C++中可调用的对象
<ul>
<li>函数</li>
<li>函数指针</li>
<li>lambda表达式</li>
<li>bind创建的对象</li>
<li>重载了函数调用运算符的类</li>
</ul>
</li>
<li>两个不同类型的可调用对象可以共享同一种调用形式
<ul>
<li>调用形式指明了调用返回类型以及传递给调用的实参类型</li>
<li>一种调用形式对应一个函数类型</li>
</ul>
</li>
<li>不同类型可能具有相同的调用形式</li>
<li>对于几个可调用对象共享同一种调用形式的情况,有时希望把它们看成具有相同的类型</li>
<li><strong>函数表</strong>：用于存储指向可调用对象的指针,当程序需要执行某个特定的操作时,从表中查找该调用函数
<ul>
<li>函数表可以使用map实现</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)</span><br><span class="line"><span class="comment">// 函数类型,接收两个int,返回一个int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑下列不同类型的可调用对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> i, <span class="type">int</span> j)&#123;<span class="keyword">return</span> i%j;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divide</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> denominator,<span class="type">int</span> divisor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> denominator/divisor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享一种调用形式</span></span><br><span class="line"><span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map实现函数表</span></span><br><span class="line">map&lt;string,<span class="type">int</span>(*)(<span class="type">int</span>,<span class="type">int</span>)&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>&#125;,add); <span class="comment">//&#123;&quot;+&quot;,add&#125;是一个pair</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>function的操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>function&lt;T&gt; f;</td>
<td>f是一个用来存储可调用对象的空function,这些可调用对象的调用形式应该与函数类型T相同</td>
</tr>
<tr>
<td>function&lt;T&gt; f(nullptr);</td>
<td>显式地构造一个空function</td>
</tr>
<tr>
<td>function&lt;T&gt; f(obj);</td>
<td>在f中存储可调用对象obj的副本</td>
</tr>
<tr>
<td>f</td>
<td>将f作为条件;当f含有一个可调用对象时为真;否则为假</td>
</tr>
<tr>
<td>f(args)</td>
<td>调用f中的对象,参数是args</td>
</tr>
<tr>
<td>定义为function&lt;T&gt;的成员的类型</td>
<td>-</td>
</tr>
<tr>
<td>result_type</td>
<td>该function类型的可调用对象返回的类型</td>
</tr>
<tr>
<td>argument_type</td>
<td>当T有一个或两个实参时定义的类型</td>
</tr>
<tr>
<td>first_argument_type</td>
<td>第一个实参类型</td>
</tr>
<tr>
<td>second_argument_type</td>
<td>第二个实参类型</td>
</tr>
</tbody>
</table>
<ul>
<li>function是一个模板,在创建时需要提供额外的信息</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用形式</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f1 = add;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f2 = <span class="built_in">divide</span>();</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f3 = [](<span class="type">int</span> i,<span class="type">int</span> j)&#123;<span class="keyword">return</span> i*j;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新定义map</span></span><br><span class="line">map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; binops;</span><br><span class="line"></span><br><span class="line">map&lt;string,function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">  &#123;<span class="string">&quot;+&quot;</span>,add&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;-&quot;</span>,std::<span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;/&quot;</span>,<span class="built_in">devide</span>()&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>重载的函数与function
<ul>
<li>不能直接将重载函数的名字存入function类型的对象中</li>
<li>解决二义性的一条途径：<strong>存储函数指针而非函数的名字</strong></li>
<li>第二条途经：<strong>使用lambda</strong></li>
</ul>
</li>
<li>新版本标准库中的function类与旧版本中的unary_function和binary_function没有关联,后两个类已经被更通用的bind函数替代了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*fp)(<span class="type">int</span>,<span class="type">int</span>) = add;</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,fp&#125;);</span><br><span class="line"></span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> <span class="built_in">add</span>(a,b);&#125;&#125;);</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="149-重载类型转换与运算符"><a class="markdownIt-Anchor" href="#149-重载类型转换与运算符"></a> 14.9 重载,类型转换与运算符</h2>
<ul>
<li><a href="#754-%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">跳转</a>：由一个实参调用的非显式构造函数定义了一种隐式的类型转换,这种构造函数将实参类型的对象转换成类类型</li>
<li>可以定义对于类类型的类型转换,通过定义类型转换运算符可以做到,<strong>转换构造函数和类型转换运算符共同定义了类类型转换</strong></li>
</ul>
<h3 id="1491-类型转换运算符"><a class="markdownIt-Anchor" href="#1491-类型转换运算符"></a> 14.9.1 类型转换运算符</h3>
<ul>
<li><strong>类型转换运算符</strong>：类的一种特殊成员函数,负责将一个类类型的值转换成其他类型
<ul>
<li>一般形式:operator type() const</li>
<li>类型转换运算符既没有显式的返回类型,也没有形参,而且必须定义成类的成员函数</li>
<li>类型转换运算符通常不应该改变待转换对象的内容,因此类型转换运算符一般被定义成const成员</li>
</ul>
</li>
<li><mark>一个类型转换函数必须是类的成员函数;它不能声明返回类型,形参列表也必须为空。类型转换函数通常应该是const</mark></li>
<li><mark>类型转换运算符是隐式执行的,无法给这些函数传递实参,当然也就不能在类型转换运算符的定义中使用任何形参</mark>
<ul>
<li>同时,尽管类型转换函数不负责指定返回类型,但实际上每个类型转换函数都会返回一个对应类型的值</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义含有类型转换运算符的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> i=<span class="number">0</span>):<span class="built_in">val</span>(i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的SmallInt类既定义了向类类型的转换,也定义了从类类型向其他类型的转换</span></span><br><span class="line"><span class="comment">// 其中,构造函数将算术类型的值转换成SmallInt对象,而类型转换运算符将SmallInt对象转换成int</span></span><br><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>;</span><br><span class="line">si +<span class="number">3</span>;  <span class="comment">//首先将si隐式转换成int,然后执行整数加法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SamllInt</span>;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt&amp;)</span></span>;  <span class="comment">//错误,不是成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//错误,制定了返回类型</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="type">int</span> =<span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//错误,参数列表不为空</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="type">int</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;  <span class="comment">//错误,42不是指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>显式的类型转化运算符</strong>：C++11新标准引入的
<ul>
<li>编译器不会将一个显式的类型转换运算符用于隐式类型转换
<ul>
<li>当表达式出现在下列位置时,显式的类型转换将被隐式地执行
<ul>
<li>if、while及do语句的条件部分</li>
<li>for语句头的条件表达式</li>
<li>逻辑非运算符(！)、逻辑或运算符(||)、逻辑与运算符(&amp;&amp;)的运算对象</li>
<li>条件运算符(？ ：)的条件表达式</li>
</ul>
</li>
</ul>
</li>
<li>在C++11新标准下,IO标准库通过定义一个向bool的显式类型转换实现向void*转换
<ul>
<li>向bool的类型转换通常用在条件部分,因此operator bool一般定义成explicit的</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式的类型转换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ecplicit <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si =<span class="number">3</span>;</span><br><span class="line">si + <span class="number">3</span>; <span class="comment">//错误发生了隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无论我们什么时候在条件中使用流对象,都会使用为IO类型定义的operator bool。例如：</span></span><br><span class="line"><span class="keyword">while</span>(std::cin&gt;&gt;value)</span><br><span class="line"><span class="comment">// while语句的条件执行输入运算符,它负责将数据读入到value并返回cin。为了对条件求值,cin被istream operator bool类型转换函数隐式地执行了转换</span></span><br><span class="line"><span class="comment">// 如果cin的条件状态是good,则该函数返回为真;否则该函数返回为假</span></span><br></pre></td></tr></table></figure>
<h3 id="1492-避免有二义性的类型转换"><a class="markdownIt-Anchor" href="#1492-避免有二义性的类型转换"></a> 14.9.2 避免有二义性的类型转换</h3>
<ul>
<li>如果类中包含一个或多个类型转换,则必须确保在类类型和目标之间只有唯一的转换方式
<ul>
<li>多重转换路径：
<ul>
<li>第一种情况是两个类提供相同的类型转换</li>
<li>第二种情况是定义了多个类型转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了两种将B转换成A的方法：一种使用B的类型转换运算符、另一种使用A的以B为参数的构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> B&amp;);  <span class="comment">//将B转换成A</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = <span class="built_in">f</span>(b); <span class="comment">//二义性错误：含义是f(B::operator A())还是f(A::A(const B&amp;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要显式调用</span></span><br><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>());</span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>以下的经验规则可能避免类型转换产生二义性有帮助：</p>
<ul>
<li>不要令两个类执行相同的类型转换：如果Foo类有一个接受Bar类对象的构造函数,则不要在Bar类中再定义转换目标是Foo类的类型转换运算符</li>
<li>避免转换目标是内置算术类型的类型转换。特别是当你已经定义了一个转换成算术类型的类型转换时,接下来
<ul>
<li>不要再定义接受算术类型的重载运算符。如果用户需要使用这样的运算符,则类型转换操作将转换你的类型的对象,然后使用内置的运算符</li>
<li>不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作</li>
</ul>
</li>
<li>一言以蔽之：除了显式地向bool类型的转换之外,我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数</li>
</ul>
</li>
<li>
<p>重载函数与转换构造函数：如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型,则这通常意味着程序的设计存在不足。在调用重载函数时,如果需要额外的标准类型转换,则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个,则该调用具有二义性</p>
</li>
</ul>
<h3 id="1493-函数匹配与重载运算符"><a class="markdownIt-Anchor" href="#1493-函数匹配与重载运算符"></a> 14.9.3 函数匹配与重载运算符</h3>
<ul>
<li>和普通函数调用不同,不能通过调用的形式来区分当前调用的是成员函数还是非成员函数
<ul>
<li>当使用重载运算符作用于类类型的运算对象时,候选函数中包含该运算符的普通非成员版本和内置版本。除此之外,如果左侧运算对象是类类型,则定义在该类中的运算符的重载版本也包含在候选函数内</li>
<li>当我们一个命名的函数时,具有该名字的成员函数和非成员函数不会彼此重载
<ul>
<li>因为用来调用命名函数的语法形式对于成员函数和非成员函数来说是不相同的</li>
<li>当通过类类型的对象(或者该对象的指针及引用)进行函数调用时,只考虑该类的成员函数</li>
<li>而当在表达式中使用重载的运算符时,无法判断正在使用的是成员函数还是非成员函数,因此二者都应该在考虑的范围内</li>
</ul>
</li>
</ul>
</li>
<li><mark>如果对同一个类既提供了转换目标是算术类型的类型转换,也提供了重载的运算符,则将会遇到重载运算符与内置运算符的二义性问题</mark></li>
</ul>
<h1 id="15-面向对象程序设计"><a class="markdownIt-Anchor" href="#15-面向对象程序设计"></a> 15 面向对象程序设计</h1>
</div><div class="story post-story"><h2 id="151-oop概述"><a class="markdownIt-Anchor" href="#151-oop概述"></a> 15.1 OOP概述</h2>
<ul>
<li>面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定
<ul>
<li>通过数据抽象,可以将类的接口与实现分离</li>
<li>使用继承,可以定义相似的类型并对其相似关系建模</li>
<li>使用动态绑定,可以在一定程度上忽略相似类型的区别,以同一的方式使用它们的对象</li>
</ul>
</li>
<li><strong>继承</strong>
<ul>
<li>通过继承联系在一起的类构成一种层次关系</li>
<li>通常在层次关系的根部有一个<strong>基类</strong>,其他类直接或简介地从基类继承而来,继承得到的类称为<strong>派生类</strong></li>
<li>基类负责定义层次关系中所有类共同拥有的成员,每个派生类定义各自特有的成员</li>
<li>C++语言中,基类将类型相关的函数与派生类不做改变直接继承的函数区分对待
<ul>
<li>对于某些函数,基类希望派生类各自定义适合自身的版本,此时<strong>基类将这些函数声明为虚函数</strong></li>
<li>派生类必须使用类派生列表指出是由哪个基类继承而来</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类派生列表的形式是：首先是一个冒号,后面紧跟以逗号分隔的基类列表,其中每个基类前面可以有访问说明符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>动态绑定</strong>
<ul>
<li>通过使用动态绑定,能用同一段代码分类处理两个类中的对象</li>
<li>在运行时选择函数的版本,动态绑定又称为<strong>运行时绑定</strong></li>
<li>当使用基类的引用(或指针)调用一个虚函数时将发生动态绑定</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算并打印销售给定数量的某种书籍所得的费用</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,<span class="type">const</span> Quote &amp;item, <span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 根据传入item形参的对象类型调用Quote::net_price</span></span><br><span class="line">  <span class="comment">// 或者Bulk_quote::net_price</span></span><br><span class="line">  <span class="type">double</span> ret = item.<span class="built_in">net_price</span>(n);</span><br><span class="line">  os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; n &lt;&lt; ret &lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basic的类型是Quote,bulk的类型是Bulk_quote</span></span><br><span class="line"><span class="built_in">print_total</span>(cout,basic,<span class="number">20</span>); <span class="comment">//调用Quote的net_price</span></span><br><span class="line"><span class="built_in">print_total</span>(cout,bulk,<span class="number">20</span>); <span class="comment">//调用Bulk_quote的net_price</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="152-定义基类和派生类"><a class="markdownIt-Anchor" href="#152-定义基类和派生类"></a> 15.2 定义基类和派生类</h2>
<h3 id="1521-定义基类"><a class="markdownIt-Anchor" href="#1521-定义基类"></a> 15.2.1 定义基类</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Quote</span>(<span class="type">const</span> std::string &amp;book,<span class="type">double</span> sales_price):</span><br><span class="line">          <span class="built_in">bookNo</span>(book),<span class="built_in">price</span>(sales_price)&#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> n * price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>; <span class="comment">//对析构函数进行动态绑定</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>基类都应该定义一个<strong>虚析构函数</strong>,即使该函数不执行任何操作</li>
<li><strong>成员函数与继承</strong>
<ul>
<li>派生类可以继承其基类的成员,派生类需要对部分操作提供自己的新定义以覆盖(override)从基类继承来的旧定义</li>
</ul>
</li>
<li>基类必须将两种成员函数分开：
<ul>
<li>一类是基类希望其派生类进行覆盖的函数(<strong>虚函数</strong>)
<ul>
<li>当使用指针或引用调用虚函数时,该调用被动态绑定(执行基类版本或派生类版本)</li>
<li>在成员函数语句之前<strong>加virtual使得函数执行动态绑定</strong>
<ul>
<li>任何构造函数之外的函数都可以是虚函数</li>
<li>virtual智能出现在类内部的声明语句中</li>
</ul>
</li>
</ul>
</li>
<li>一类是基类希望派生类直接继承而不要改变的函数</li>
</ul>
</li>
<li>访问控制与继承：基类允许派生类访问基类的成员,但禁止其他用户访问,使用<strong>受保护的(protected)访问运算</strong></li>
</ul>
<h3 id="1522-定义派生类"><a class="markdownIt-Anchor" href="#1522-定义派生类"></a> 15.2.2 定义派生类</h3>
<ul>
<li>派生类必须通过使用<strong>类派生列表</strong>明确指出是从哪个基类继承而来的
<ul>
<li>类派生列表的形式是,首先一个冒号,后面紧跟以逗号分割的基类列表,其中每个基类前都可以有三类访问说明符的一个public,protected,private</li>
</ul>
</li>
<li>如果一个派生是公共的,则基类的公共成员也是派生类接口的组成部分</li>
<li>派生类中的虚函数
<ul>
<li>派生类经常覆盖它继承的虚函数,如果派生类没有覆盖其基类中的某个虚函数,则该虚函数的行为类似于其他的普通成员,派生类会直接继承其在基类中的版本
<ul>
<li>派生类可以在它覆盖的函数前使用virtual关键字,但不是非要这么做</li>
<li>C++11新标准允许派生类显式注明它在使用某个成员函数覆盖了它继承的虚函数</li>
</ul>
</li>
</ul>
</li>
<li><strong>派生类对象及派生类向基类的类型转换</strong>
<ul>
<li>一个派生类对象包含多个组成部分：一个派生类对象包含多个组成部分,一个含有派生类自定义的非静态成员的子对象,以及一个与该派生类继承的基类对应的子对象</li>
<li>在一个对象中,继承自基类的部分和派生类自定义的部分不一定是连续存储的</li>
<li>派生类对象中含有与基类对应的组成部分,可以把派生类的对象当作基类对象来使用,而且也能将基类的指针或引用绑定到派生类对象中的基类部分</li>
<li><strong>派生类到基类的类型转换,和其他类型转换一样,编译器会隐式地执行派生类到基类的转换</strong>
<ul>
<li>隐式特性意味着可以把派生类对象或派生类对象的引用用在需要基类引用的地方;同时可以把派生类对象的指针用在需要基类指针的地方</li>
</ul>
</li>
</ul>
</li>
<li><strong>派生类构造函数：派生类可以访问基类的公共成员和受保护成员</strong></li>
<li><strong>继承与静态成员</strong>
<ul>
<li>基类定义了一个静态成员,则在整个继承中只存在该成员的唯一定义</li>
<li>若基类中的成员是private,派生类无权访问</li>
</ul>
</li>
<li><strong>被用作基类的类</strong>
<ul>
<li>一个类是基类,同时也可以是派生类</li>
<li>直接基类出现在派生列表中,而简介基类有派生类通过其直接基类继承而来</li>
<li>每个类都会继承直接基类的所有成员</li>
</ul>
</li>
<li><strong>防止继承的发生</strong>
<ul>
<li><strong>在类名后跟final关键字可以防止继承发生</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp;, <span class="type">double</span>,std::<span class="type">size_t</span>,<span class="type">double</span>);</span><br><span class="line">    <span class="comment">// 覆盖基类的函数版本以实现基于大量购买折扣政策</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(dts::<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> min_qty = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Quote item; <span class="comment">//基类对象</span></span><br><span class="line">Bulk_quote bulk;  <span class="comment">//派生类对象</span></span><br><span class="line">Quote *p = &amp;item; <span class="comment">//p指向Quote对象</span></span><br><span class="line">p = &amp;bulk;  <span class="comment">//p指向bulk的Quote部分</span></span><br><span class="line">Quote &amp;r = bulk;  <span class="comment">//r绑定到bulk的Quote部分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> NoDerived <span class="title">final</span><span class="params">()</span></span>;    <span class="comment">//NoDerived不能作为基类</span></span><br></pre></td></tr></table></figure>
<h3 id="1523-类型转换与继承"><a class="markdownIt-Anchor" href="#1523-类型转换与继承"></a> 15.2.3 类型转换与继承</h3>
<ul>
<li>可以将基类的指针绑定到派生类对象上
<ul>
<li>当使用基类的引用时,实际上不清楚引用所绑定的真实类型,该对象可能是基类的对象,也可能是派生类的对象</li>
<li>和内置指针一样,智能指针类也支持派生类向基类的类型转换(可以将派生类对象的指针存储在一个基类的智能指针内)</li>
</ul>
</li>
<li><strong>静态类型与动态内存</strong>
<ul>
<li>当使用存在继承关系的类型时,必须将一个变量或其他表达式的<strong>静态类型</strong>与该表达式表示的对象的<strong>动态类型</strong>区分开
<ul>
<li>如果表达式既不是引用也不是指针,则它的动态类型永远与静态类型一致</li>
<li>基类的指针或引用的静态类型可能与其动态类型不一致</li>
</ul>
</li>
</ul>
</li>
<li><strong>不存在从基类向派生类的隐式类型转换</strong>
<ul>
<li>之所以存在派生类向基类的类型转换时因为每个派生类对象都包含一个基类部分,而基类的引用或指针可以绑定到该基类部分上</li>
<li>一个基类的对象既可以以独立的形式存在,也可以作为派生类对象的一部分存在</li>
<li>如果基类对象不是派生类对象的一部分,则它只含有基类定义的成员</li>
<li><mark>不存在从基类向派生类的自动类型转换</mark></li>
<li>即使一个基类指针或引用绑定在一个派生类对象上,也不能执行从基类向派生类的转换</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个基类的对象可能是派生类对象的一部分,也可能不是</span></span><br><span class="line"><span class="comment">// 不存在从基类向派生类的自动类型转换</span></span><br><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP = &amp;base;  <span class="comment">//错误,不能将基类转换成派生类</span></span><br><span class="line">Bulk_quote&amp; bulkP = base;  <span class="comment">//错误,不能将基类转换成派生类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使一个基类指针或引用绑定在一个派生类对象上,也不能执行从基类向派生类的转换</span></span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = itemP;  <span class="comment">//错误,不能将基类转换成派生类</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在对象之间不存在类型转化</strong>
<ul>
<li>派生类向基类的自动类型转换只对指针或引用类型有效,在派生类类型和基类类型之间不存在这种转换</li>
<li><mark>当用派生类对象为一个基类对象初始化或赋值时,只有该派生类对象中的基类部分会被拷贝,移动或赋值,它的派生类部分将被忽略掉</mark></li>
</ul>
</li>
<li><strong>存在继承关系的类型之间的转换规则</strong>
<ul>
<li>从派生类向基类的类型转换只对指针或引用类型有效</li>
<li>基类向派生类不存在隐式类型转换</li>
<li>和任何其他成员一样,派生类向基类的类型转换也可能会由于访问数显而变得不可行</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="153-虚函数"><a class="markdownIt-Anchor" href="#153-虚函数"></a> 15.3 虚函数</h2>
<ul>
<li>使用基类的引用或指针调用一个虚成员函数时会执行动态绑定
<ul>
<li>必须为所有虚函数都提供定义</li>
</ul>
</li>
<li><strong>对虚函数的调用可能在运行时才被解析</strong>
<ul>
<li>当某个虚函数通过指针或引用调用时,编译器产生的代码直到运行时才能确定应该调用哪个版本的函数</li>
<li>被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的一个</li>
</ul>
</li>
<li>动态绑定只有当通过指针或引用调用虚函数时才会发生
<ul>
<li>通过一个具有普通类型的表达式调用虚函数时,在编译时就能将调用的版本确认下来</li>
</ul>
</li>
<li><strong>C++的多态性</strong>
<ul>
<li>把具有继承关系的多个类型称为多态类型</li>
<li>引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在</li>
<li>当使用基类的引用或指针调用基类中定义的一个函数时,并不知道该函数真正作用的对象是什么类型,因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数,则直到运行时才会决定到底执行哪个版本,判断的依据是引用或指针所绑定的对象的真实类型</li>
<li>另一方面,对非虚函数的调用在编译时进行绑定
<ul>
<li>类似的,通过对象进行的函数(虚函数或非虚函数)调用也在编译时绑定。对象的类型是确定不变的,无论如何都不可能令对象的动态类型与静态类型不一致。因此,通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上</li>
</ul>
</li>
</ul>
</li>
<li><strong>派生类中的虚函数</strong>
<ul>
<li>当在派生类中覆盖了某个虚函数时,可以再一次使用virtual关键字指出该函数的性质(<strong>一旦被声明为虚函数,在所有的派生类中都是虚函数</strong>)</li>
<li>基类中的虚函数在派生类中隐含的也是一个虚函数,派生类覆盖了某个虚函数时,该函数在基类中的形参必须与派生类中的形参严格匹配</li>
</ul>
</li>
<li><strong>final和override说明符</strong>
<ul>
<li>在新标准中,使用<strong>override关键字</strong>说明派生类中的虚函数</li>
<li><strong>某个函数指定为final,之后任何尝试覆盖该函数的操作都将引发错误</strong></li>
<li>final和override说明符出现在形参列表以及尾置返回类型之后</li>
</ul>
</li>
<li><strong>虚函数与默认形参</strong>：虚函数也可以拥有默认实参
<ul>
<li>如果某次函数调用使用了默认实参,则该实参值由本次调用的静态类型决定
<ul>
<li>如果通过基类的引用或指针调用函数,则使用基类中定义的默认实参,即使实际运行的是派生类中的函数版本也是如此</li>
</ul>
</li>
</ul>
</li>
<li><strong>回避虚函数机制</strong>
<ul>
<li>希望对虚函数的调用不要进行动态绑定,而是强迫执行虚函数的某个特定版本,可以<strong>使用作用域运算符</strong></li>
<li>如果一个派生类虚函数需要调用它的基类版本,但是没有使用作用域作用符,则在运行时该调用将被解析为对派生类版本自身的调用,从而导致无限递归</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 到底调用net_price的哪个版本完全依赖于运行时绑定到item的实参的实际(动态)类型</span></span><br><span class="line"><span class="function">Quote <span class="title">base</span><span class="params">(<span class="string">&quot;0-201-82470-1&quot;</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout,base,<span class="number">10</span>);  <span class="comment">//调用Quote::net_price</span></span><br><span class="line"><span class="function">Bulk_total <span class="title">derived</span><span class="params">(<span class="string">&quot;0-201-82470-1&quot;</span>,<span class="number">50</span>,<span class="number">5</span>,<span class="number">.19</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout,derived,<span class="number">10</span>); <span class="comment">//调用Bulk_quote::net_price</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回避虚函数机制</span></span><br><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="154-抽象基类"><a class="markdownIt-Anchor" href="#154-抽象基类"></a> 15.4 抽象基类</h2>
<ul>
<li><strong>纯虚函数</strong>
<ul>
<li>纯虚函数无需定义,通过<strong>在函数体的位置书写=0</strong>可以将一个虚函数说明为纯虚函数,=0智能出现在类内部的虚函数声明语句处
<ul>
<li>可以为纯虚函数提供定义,但函数体必须定义在类的外部(<mark>不能在类的内部为一个=0的函数提供函数体</mark>)</li>
</ul>
</li>
</ul>
</li>
<li>含有纯虚函数的类是抽象基类
<ul>
<li>抽象基类负责定义接口,而后续的其他类可以覆盖该接口</li>
<li>不能直接创建一个抽象基类的对象,可定义派生类的对象(<mark>前提是提前覆盖率纯虚函数</mark>)</li>
</ul>
</li>
<li><strong>派生类构造函数只初始化它的直接基类</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dis_quote</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Disc_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Disc_quote</span>(<span class="type">const</span> std::string&amp; book,<span class="type">double</span> price,std::<span class="type">size_t</span> qty, <span class="type">double</span> disc):</span><br><span class="line">              <span class="built_in">Quote</span>(book,price),<span class="built_in">quantity</span>(qty),<span class="built_in">discount</span>(disc)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    std::<span class="type">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>:<span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book,<span class="type">double</span> price, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc):</span><br><span class="line">              <span class="built_in">Disc_quote</span>(book,price,qty,disc)&#123;&#125;</span><br><span class="line">              <span class="comment">// 覆盖基类中的函数版本以实现一种新的折扣策略</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="155-访问控制与继承"><a class="markdownIt-Anchor" href="#155-访问控制与继承"></a> 15.5 访问控制与继承</h2>
<ul>
<li>每个类分别控制自己的成员初始化过程,与之类似,每个类还分别控制其成员对于派生类是否<strong>可访问</strong></li>
<li><strong>受保护的成员</strong>
<ul>
<li>一个类使用protect关键字来声明那些希望与派生类分享但不想被其他公共访问使用的成员</li>
<li>protect说明符可以看作是public和private中和后的产物
<ul>
<li>和私有成员类似,受保护的成员对于类的用户来说是不可访问的</li>
<li>和公有成员类似,受保护的成员对于派生类的成员和友元来说是可访问的</li>
<li><strong>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>公有,私有和受保护继承</strong>
<ul>
<li>某个类对其继承而来的成员的访问权限受到两个因素影响
<ul>
<li>在基类中该成员的访问说明符</li>
<li>在派生类的派生列表中的访问说明符</li>
</ul>
</li>
<li>派生访问说明符的目的是控制派生类用户(包括派生类的派生类)对于基类成员的访问权限</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  protect:</span><br><span class="line">    <span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>; <span class="comment">//能访问Sneaky::prot_mem</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>; <span class="comment">//不能访问Base::prot_mem</span></span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123;s.j = s.prot_mem = <span class="number">0</span>;&#125; <span class="comment">//正确可以访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123;b.prot_mem = <span class="number">0</span>;&#125;   <span class="comment">//错误,不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pub_mem</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">protected</span>:</span></span><br><span class="line"><span class="function">    int prot_mem;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pub_Derv</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;</span><br><span class="line">  <span class="function"><span class="type">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> priv_mem;&#125; <span class="comment">//错误,不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Priv_Derv</span> : <span class="keyword">private</span> Base&#123;</span><br><span class="line">  <span class="comment">// private不影响派生类的访问权限</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>派生类向基类转换的可访问性</strong>
<ul>
<li>派生类向基类的转换是否可访问由使用该转换的代码决定,同时派生类的派生访问说明符也会有影响</li>
<li>假定D继承自B
<ul>
<li>只有当D公有地继承B时,用户代码才能使用派生类向基类的转换;如果D继承B的方式是受保护的或者私有的,则用户代码不能使用该转换</li>
<li>不论D以什么方式继承B,D的成员函数和友元都能使用派生类向基类的转换;派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的</li>
<li>如果D继承B的方式是公有的或者受保护的,则D的派生类的成员和友元可以使用D向B的类型转换;反之,如果D继承B的方式是私有的,则不能使用</li>
</ul>
</li>
<li>对于代码中的某个给定节点来说,如果基类的公有成员是可访问的,则派生类向基类的类型转换也是可访问的,反之则不行</li>
</ul>
</li>
<li>类的设计与受保护的成员
<ul>
<li>普通用户：编写的代码使用类的对象,这部分代码只能访问类的公有(接口)成员</li>
<li>实现者：负责编写类的成员和友元的代码,成员和友元既能访问类的公有部分,也能访问类的私有(实现)部分</li>
<li>派生类：基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员,而派生类及其友元仍旧不能访问私有成员</li>
<li>和其他类一样,基类应该将其接口成员声明为公有的;同时将属于其实现的部分分成两组：一组可供派生类访问,另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的,这样派生类就能在实现自己的功能时使用基类的这些操作和数据;对于后者应该声明为私有的</li>
</ul>
</li>
<li><strong>友元与继承</strong>
<ul>
<li>友元关系不能继承</li>
<li>基类的友元在访问派生类成员时不具有特殊性,类似的,派生类的友元也不能随意访问基类的成员</li>
<li>当一个类将另一个类声明为友元时,这种友元关系只对做出声明的类有效;对于原来的类,其友元的基类或派生类不具有特殊的访问能力</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="comment">// 添加friend声明,其他成员与之前的版本一致</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>; <span class="comment">//Pal在访问Base的派生类时不具有特殊性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pal</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123;<span class="keyword">return</span> b.prot_mem;&#125;  <span class="comment">//正确,Pal时Base的友元</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.j;&#125;    <span class="comment">//错误,Pal不是Sneaky的友元</span></span><br><span class="line">    <span class="comment">// 对基类的访问权限由基类本身控制,即使对于派生类的基类部分也是如此</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s_prot.mem;&#125; <span class="comment">//正确,Pal是Base的友元</span></span><br><span class="line">    <span class="comment">// Pal是Base的友元,所以Pal能够访问Base对象的成员,这种可访问性包括了Base对象内嵌在其派生类对象中的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// D2对Base的protected和privated成员不具有特殊的访问能力</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>: <span class="keyword">public</span> Pal&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mem</span><span class="params">(Base b)</span> </span>&#123;<span class="keyword">return</span> b.prot_mem;&#125;  <span class="comment">//错误：友元关系不能继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>改变个别成员的可访问性</strong>
<ul>
<li>需要改变派生类继承的某个名字的访问级别,<strong>通过使用using声明</strong>可达到这一目的
<ul>
<li>using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定</li>
<li>如果一条using声明语句出现在类的private部分,则该名字只能被类的成员和友元访问</li>
<li>如果using声明语句位于public部分,则类的所有用户都能访问它</li>
<li>如果using声明语句位于protected部分,则该名字对于成员、友元和派生类是可访问的</li>
</ul>
</li>
<li><strong>派生类只能为那些它可以访问的名字提供using声明</strong></li>
</ul>
</li>
<li><strong>默认的继承保护机制</strong>
<ul>
<li>默认派生运算符也由定义派生类所用的关键字来决定</li>
<li>使用class关键字定义的派生类默认是私有继承的</li>
<li>使用struct关键字定义的派生类是公有继承的</li>
<li><mark>建议显式声明</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 保持对象尺寸相关的成员的访问级别</span></span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用using声明语句改变了这些成员的可访问性。改变之后,Derived的用户将可以使用size成员,而Derived的派生类将能使用n</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="156-继承中的类作用域"><a class="markdownIt-Anchor" href="#156-继承中的类作用域"></a> 15.6 继承中的类作用域</h2>
<ul>
<li>在编译时进行名字查找
<ul>
<li>一个对象,引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致,但是能使用哪些成员还是由静态类型决定的</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给Disc_quote添加一个新成员,该成员返回一个存有最小(或最大)数量及折扣价格的pair</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Disc_quote</span>:<span class="keyword">public</span> Quote&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">size_t</span>, <span class="type">double</span>&gt; <span class="title">discount_policy</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> &#123;quantity,discount&#125;;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能通过Disc_quto及其派生类的对象,引用或指针使用discount_policy</span></span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Bulk_quote *bulkP = &amp;bulk;  <span class="comment">//静态类型与动态类型一致</span></span><br><span class="line">Quote *itemP = &amp;bulk;  <span class="comment">//静态类型与动态类型不一致</span></span><br><span class="line">bulkP-&gt;<span class="built_in">discount_policy</span>();  <span class="comment">//正确:bulkP的类型是Bulk_quote*</span></span><br><span class="line">itemP-&gt;<span class="built_in">discount_policy</span>();  <span class="comment">//错误:itemP的类型是Quote*</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>名字冲突与继承</strong>
<ul>
<li>和其他作用域一致,派生类也能重用定义在其直接基类或间接基类中的名字,此时定义在内层作用域的名字将隐藏定义在外层作用域的名字</li>
<li>派生类的成员将隐藏同名的基类成员</li>
</ul>
</li>
<li><strong>通过作用域运算符来使用隐藏的成员</strong>
<ul>
<li>可以通过使用作用域运算符来使用一个被隐藏的基类成员</li>
<li>除了覆盖继承而来的虚函数之外,派生类最好不要宠用其他定义在基类中的名字</li>
</ul>
</li>
<li><strong>名字查找优先于类型检查</strong>：
<ul>
<li>定义派生类中的函数也不会重载其基类中的成员</li>
<li>如果派生类(即内层作用域)的成员与基类(即外层作用域)的某个成员同名,则派生类将在其作用域内隐藏该基类成员(即使派生类成员和基类成员的形参列表不一致,基类成员也仍然会被隐藏掉)</li>
</ul>
</li>
<li><strong>虚函数与作用域</strong>
<ul>
<li>假如基类与派生类的虚函数接受的实参不同,则无法通过基类的引用或指针调用派生类的虚函数</li>
</ul>
</li>
<li>覆盖重载的函数
<ul>
<li>和其他函数一样,成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例</li>
<li>如果派生类希望所有的重载版本对于它来说都是可见的,那么它就需要覆盖所有的版本,或者一个也不覆盖
<ul>
<li>一种好的解决方案是为重载的成员提供一条using声明语句,这样就无须覆盖基类中的每一个重载版本</li>
<li>using声明语句指定一个名字而不指定形参列表,所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时,派生类只需要定义其特有的函数就可以了,而无须为继承而来的其他函数重新定义</li>
<li>类内using声明的一般规则同样适用于重载函数的名字;基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的访问实际上是对using声明点的访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="built_in">Base</span>():<span class="built_in">mem</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> mem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: Base&#123;</span><br><span class="line">  <span class="built_in">Derived</span>(<span class="type">int</span> i):<span class="built_in">mem</span>(i)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> mem;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用隐藏的成员</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Base::mem;&#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> mem;    <span class="comment">//隐藏基类中的mem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">d.<span class="built_in">get_mem</span>();    <span class="comment">//42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span>)</span></span>;   <span class="comment">//形参列表与Base中的fcn不一致</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;  <span class="comment">//是一个新的虚函数,在Base中不存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>:<span class="keyword">public</span> D1&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span>)</span></span>;   <span class="comment">//是一个非虚函数,隐藏了D1::fcn(int)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fcn</span><span class="params">()</span></span>;    <span class="comment">//覆盖了Base的虚函数fcn</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;    <span class="comment">//覆盖了D1的虚函数f2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用隐藏的虚函数的方法</span></span><br><span class="line">Base bobj;D1 d1obj;D2 d2obj;</span><br><span class="line"></span><br><span class="line">Base *bp1 = &amp;bobj,*bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line">bp1-&gt;<span class="built_in">fcn</span>();   <span class="comment">//虚调用,将在运行时调用Base::fcn</span></span><br><span class="line">bp2-&gt;<span class="built_in">fcn</span>();   <span class="comment">//虚调用,将在运行时调用Base::fcn</span></span><br><span class="line">bp3-&gt;<span class="built_in">fcn</span>();   <span class="comment">//虚调用,将在运行时调用D2::fcn</span></span><br><span class="line"></span><br><span class="line">D1 *d1p = &amp;d1obj;</span><br><span class="line">D2 *d2p = &amp;d2obj;</span><br><span class="line">bp2-&gt;<span class="built_in">f2</span>();    <span class="comment">//错误,Base没有名为f2的成员</span></span><br><span class="line">d1p-&gt;<span class="built_in">f2</span>();    <span class="comment">//虚调用,将在运行时调用D1::f2()</span></span><br><span class="line">d2p-&gt;<span class="built_in">f2</span>();    <span class="comment">//虚调用,将在运行时调用D2::f2()</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="157-构造函数与拷贝控制"><a class="markdownIt-Anchor" href="#157-构造函数与拷贝控制"></a> 15.7 构造函数与拷贝控制</h2>
<h3 id="1571-虚析构函数"><a class="markdownIt-Anchor" href="#1571-虚析构函数"></a> 15.7.1 虚析构函数</h3>
<ul>
<li>继承关系对基类拷贝控制最直接的影响时基类通常应该定义一个虚析构函数,能动态分配继承体系中的对象
<ul>
<li>通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本</li>
<li>虚析构函数的虚属性也会被继承</li>
</ul>
</li>
<li><strong>虚析构函数将阻止合成移动操作</strong>：如果一个类定义了析构函数,即使通过=default的形式使用了合成版本,编译器也不会为这个类使用合成移动操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>; <span class="comment">//动态绑定析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Quote *itemP = <span class="keyword">new</span> Quote;</span><br><span class="line"><span class="keyword">delete</span> itemP;   <span class="comment">//调用Quote的析构函数</span></span><br><span class="line">itemP = <span class="keyword">new</span> Bulk_quote;</span><br><span class="line"><span class="keyword">delete</span> itemP;   <span class="comment">//调用Bulk_quote的析构函数</span></span><br></pre></td></tr></table></figure>
<h3 id="1572-合成拷贝控制与继承"><a class="markdownIt-Anchor" href="#1572-合成拷贝控制与继承"></a> 15.7.2 合成拷贝控制与继承</h3>
<ul>
<li>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数,赋值运算符或析构函数类似
<ul>
<li>对类本身的成员依次进行初始化,赋值或销毁的操作,此外合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化,赋值或销毁操作</li>
</ul>
</li>
<li>对于派生类的析构函数来说,除了销毁派生类自己的成员外,还负责销毁派生类的直接基类</li>
<li><strong>派生类中删除的拷贝控制与基类的关系</strong>
<ul>
<li>基类或派生类能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数</li>
<li>某些定义基类的方式也可能导致派生类成员称为被删除的函数
<ul>
<li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问,则派生类中对应的成员将是被删除的,原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作</li>
<li>如果在基类中有一个不可访问或删除掉的析构函数,则派生类中合成的默认和拷贝构造函数将是被删除的,因为编译器无法销毁派生类对象的基类部分</li>
<li>和过去一样,编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时,如果基类中的对应操作是删除的或不可访问的,那么派生类中该函数将是被删除的,原因是派生类对象的基类部分不可移动。同样,如果基类的析构函数是删除的或不可访问的,则派生类的移动构造函数也将是被删除的</li>
</ul>
</li>
</ul>
</li>
<li><strong>移动操作与继承</strong>
<ul>
<li>大多数基类都会定义一个虚析构函数,默认情况下,基类通常不含有合成的移动操作,而且在它的派生类中没有合成的移动操作</li>
<li><mark>基类缺少移动操作会阻止派生类拥有自己的合成操作</mark></li>
<li><mark>一旦基类定义了自己的移动操作,那么必须同时显示地定义拷贝操作</mark></li>
</ul>
</li>
</ul>
<h3 id="1573-派生类的拷贝控制成员"><a class="markdownIt-Anchor" href="#1573-派生类的拷贝控制成员"></a> 15.7.3 派生类的拷贝控制成员</h3>
<ul>
<li>派生类的拷贝和移动构造函数在拷贝和移动自由成员的同时,也要拷贝和移动基类部分的成员
<ul>
<li><mark>析构函数只负责销毁派生类自己分配的资源,派生类对象的基类部分是被自动销毁的</mark></li>
</ul>
</li>
<li>定义派生类的拷贝或移动拷贝函数
<ul>
<li>使用基类的构造函数初始化对象的基类部分</li>
<li><mark>在默认情况下,基类默认构造函数初始化派生类对象的基类部分,如果需要拷贝或移动基类部分,则必须在派生类的构造函数初始化列表中显式地使用基类的拷贝或移动构造函数</mark></li>
</ul>
</li>
<li>派生类赋值运算符
<ul>
<li>派生类的赋值运算符必须显式的为其基类部分赋值</li>
</ul>
</li>
<li><strong>在构造函数和析构函数中调用虚函数</strong>
<ul>
<li>派生类对象的基类部分首先被构建,当执行基类的构造函数时,该对象的派生类部分还是未初始化的状态</li>
<li>为了处理该未完成状态,当构建一个对象时,需要把对象的类和构造函数的类看作是同一个;对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一个的要求;</li>
</ul>
</li>
<li><strong>如果构造函数或析构函数调用某个虚函数,应该执行与构造函数或析构函数所属类型对应的虚函数版本</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;<span class="comment">//....&#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">const</span> D&amp; d):<span class="built_in">Base</span>(d)   <span class="comment">//拷贝基类成员</span></span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; d):<span class="built_in">Base</span>(std::<span class="built_in">move</span>(d))   <span class="comment">//移动基类成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始值Base(d)将一个D对象传递给基类构造函数</span></span><br><span class="line"><span class="comment">// 尽管从道理上来说,Base可以包含一个参数类型为D的构造函数,但是在实际编程过程中通常不会这么做</span></span><br><span class="line"><span class="comment">// 相反,Base(d)一般会匹配Base的拷贝构造函数。D类型的对象d将被绑定到该构造函数的Base&amp;形参上。Base的拷贝构造函数负责将d的基类部分拷贝给要创建的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假如没有提供基类的初始值</span></span><br><span class="line"><span class="built_in">D</span>(<span class="type">const</span> D&amp; d) <span class="comment">//成员初始值,但没有提供基类初始值</span></span><br><span class="line"><span class="comment">// Base的默认构造函数将被用来初始化D对象的基类部分。假定D的构造函数从d中拷贝了派生类成员,则这个新构建的对象的配置将非常奇怪：它的Base成员被赋予了默认值,而D成员的值则是从其他对象拷贝得来的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Base::operator=(const BAse&amp;)不会被自动调用</span></span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="type">const</span> D &amp;rhs)&#123;</span><br><span class="line">  Base::operatr=(rhs);  <span class="comment">//为其基类部分赋值</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1574-继承的构造函数"><a class="markdownIt-Anchor" href="#1574-继承的构造函数"></a> 15.7.4 继承的构造函数</h3>
<ul>
<li>派生类能重用其直接基类定义的构造函数
<ul>
<li>一个类只能继承其直接基类的构造函数,类不能继承默认,拷贝和移动构造函数,若派生类未定义这些构造函数,则编译器将合成</li>
<li><strong>派生类继承基类构造函数使用using语句</strong></li>
</ul>
</li>
<li>继承的构造函数的特点
<ul>
<li><strong>一个构造函数的using声明不会改变该构造函数的访问等级</strong></li>
<li><strong>一个using声明语句不能指定explicit或constexpr</strong>
<ul>
<li>若基类的构造函数时explicit或constexpr,则继承的构造函数仍保持相同属性</li>
</ul>
</li>
<li>当一个基类构造函数含有默认实参,则实参不会被继承,<strong>派生类获得多个继承的构造函数,其中每个构造函数分别省略掉一个含有默认实参的形参</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>:<span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Disc_quote::Disc_quote;   <span class="comment">//继承基类的构造函数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">new_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="158-容器与继承"><a class="markdownIt-Anchor" href="#158-容器与继承"></a> 15.8 容器与继承</h2>
<ul>
<li><strong>使用容器存放继承体系中的对象,必须使用间接存储的方式</strong>
<ul>
<li>因为不允许在容器中保存不同类型的元素,故不能将具有继承关系的多种类型的对象直接存放在容器中</li>
</ul>
</li>
<li>在容器中放置(智能)指针而非对象
<ul>
<li>希望在容器中存放具有继承关系的对象时,实际上存放的通常是<strong>基类指针</strong>
<ul>
<li>指针的动态类型指向的可能是基类或者派生类</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Quote&gt; basket;</span><br><span class="line">basket.<span class="built_in">push_back</span>(<span class="built_in">Quote</span>(<span class="string">&quot;0-201-82470-1&quot;</span>,<span class="number">50</span>));</span><br><span class="line"><span class="comment">//正确,但只能把对象的Quote部分拷贝给basket</span></span><br><span class="line">basket.<span class="built_in">push_back</span>(<span class="built_in">Bulk_quote</span>(<span class="string">&quot;0-201-82470-1&quot;</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">.25</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//basket是Quote对象,向其中添加Bulk_quote对象是,派生类部分会被忽略</span></span><br><span class="line"></span><br><span class="line">vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;</span><br><span class="line">basket.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Quote&gt;(<span class="string">&quot;0-021-82470-1&quot;</span>,<span class="number">50</span>));</span><br><span class="line">basket.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Bulk_quote&gt;(<span class="string">&quot;0-021-82470-1&quot;</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">.25</span>));</span><br></pre></td></tr></table></figure>
<h1 id="16-模板与泛型编程"><a class="markdownIt-Anchor" href="#16-模板与泛型编程"></a> 16 模板与泛型编程</h1>
</div><div class="story post-story"><h2 id="161-定义模板"><a class="markdownIt-Anchor" href="#161-定义模板"></a> 16.1 定义模板</h2>
<h3 id="1611-函数模板"><a class="markdownIt-Anchor" href="#1611-函数模板"></a> 16.1.1 函数模板</h3>
<ul>
<li>定义一个通用的<strong>函数模板</strong>,而不是为每个类型都定义一个新函数
<ul>
<li>模板的定义以<strong>关键字template</strong>开始,后跟一个模板参数列表,这是一个逗号分割的一个或多个模板参数的列表,用&lt;&gt;包围起来</li>
<li>模板参数列表不能为空</li>
<li>模板参数表示在类或函数定义中用到的类型或值,使用模板时,(隐式地或显示地)指定模板实参</li>
</ul>
</li>
<li><strong>实例化函数模板</strong>
<ul>
<li>调用函数模板时,编译器用函数实参来推断模板实参(编译器使用实参的类型来确定绑定到模板参数T的类型)</li>
<li>编译器用推断出的模板参数来实例化一个特殊版本的函数</li>
</ul>
</li>
<li><strong>模板类型参数</strong>
<ul>
<li>可以将类型参数看作类型说明符</li>
<li>类型参数可以用来指定返回类型或函数的参数类型,以及在函数体内用于变量声明或类型转换</li>
</ul>
</li>
<li><strong>非类型模板参数</strong>
<ul>
<li>通过特定的类型名而非关键字class或typename来指定非类型参数</li>
<li><strong>可以在模板中定义非类型参数</strong>,一个非类型参数表示一个值而非一个类型,<strong>非类型参数必须是常量表达式</strong></li>
<li>一个非类型参数可以是一个整型,或者是一个指向对象或函数类型的指针或(左值)引用
<ul>
<li>绑定到非类型整型参数的实参必须是一个常量表达式</li>
<li>绑定到指针或引用非类型参数的实参必须具有静态的生存期</li>
<li>不能用一个普通(非static)局部变量或动态对象作为指针或引用非类型模板参数的实参</li>
<li>指针参数也可以用nullptr或一个值为0的常量表达式来实例化</li>
</ul>
</li>
</ul>
</li>
<li><strong>inline和constexpr的函数模板</strong>
<ul>
<li>函数模板可以声明称inline和constexpr,说明符放在模板参数列表之后,返回类型之前</li>
</ul>
</li>
<li><strong>编写泛型代码的两个重要原则</strong>
<ul>
<li>模板中的函数参数是const的引用</li>
<li>函数体中的条件判断仅使用&lt;比较运算符</li>
</ul>
</li>
<li><strong>模板编译</strong>
<ul>
<li>只有当实例化出模板的一个特定版本时,编译器才会生成代码</li>
<li><strong>函数模板和类模板成员函数的定义通常放在头文件中</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare的模板版本</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">0</span>)&lt;&lt;endl; <span class="comment">//T为int</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec2&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">compare</span>(vec1,vec2)&lt;&lt;endl; <span class="comment">//T为vector&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">foo</span><span class="params">(T* p)</span></span>&#123;</span><br><span class="line">  T tmp = *p;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误,U前面必须假声class或typename</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,U&gt; T <span class="title">calc</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> U&amp;)</span></span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">class</span> U&gt; T <span class="title">calc</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> U&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(onst <span class="type">char</span>(&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用时会用字面常量的大小来代替N,M</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;,<span class="type">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="1612-类模板"><a class="markdownIt-Anchor" href="#1612-类模板"></a> 16.1.2 类模板</h3>
<ul>
<li><strong>类模板</strong>是用来生成类的蓝图
<ul>
<li>与函数模板不同之处是,编译器不能为类模板推断模板参数类型</li>
</ul>
</li>
<li><strong>定义类模板</strong>
<ul>
<li>类似函数模板,类模板以关键字template开始,后跟模板参数列表</li>
<li>在类模板的定义中,将模板参数当作替身,代替使用模板时用户需要提供的类型或值</li>
</ul>
</li>
<li><strong>实例化类模板</strong>
<ul>
<li>使用类模板时,必须提供额外信息,<strong>额外信息是显式模板实参列表</strong>,其被绑定到模板参数使用模板实例化出特定的类</li>
<li><mark>一个类模板的每个实例都形成一个独立的类,两个独立的类不会关联,且不会对其他任何实例类的成员有特殊访问权限</mark></li>
</ul>
</li>
<li><strong>在模板作用域中引用模板类型</strong>
<ul>
<li>类模板用来实例化类型,而一个实例化的类型总是包含模板参数</li>
<li>一个类模板中的代码如果使用了另一个模板,通常不将一个实际类型的名字用作其模板实参。相反,通过将模板自己的参数当作被使用模板的实参</li>
</ul>
</li>
<li><strong>类模板的成员函数</strong>
<ul>
<li>既可以在类模板内部,也可以在类模板外部为其定义成员函数,且定义在类模板内的成员函数被隐式声明为内联函数</li>
<li>类模板的成员函数本身是一个函数,但类模板每个实例都有其自己版本的成员函数,因此类模板的成员函数具有和模板相同的模板参数</li>
<li>定义在类模板之外的成员函数就必须以关键字template开始,后接类模板参数列表</li>
</ul>
</li>
<li><strong>构造函数</strong>
<ul>
<li>与其他任何定义在类模板外的成员一样,构造函数的定义要以模板参数开始</li>
</ul>
</li>
<li><strong>类模板成员函数的实例化</strong>
<ul>
<li>默认情况下,一个类模板的成员函数只有当程序用到它时才能进行实例化</li>
<li>对于一个实例化的类模板,其成员只有在使用时才被实例化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::size_type size_type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Blob</span>();</span><br><span class="line">    <span class="built_in">Blob</span>(std::initializer&lt;T&gt; il);</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> data-&gt;<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> data-&gt;<span class="built_in">empty</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;t)</span> <span class="type">const</span> </span>&#123;data-&gt;<span class="built_in">push_back</span>(t);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;t)</span> <span class="type">const</span> </span>&#123;data-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(t));&#125;</span><br><span class="line">    <span class="type">void</span> pop_back;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string &amp;msg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data使用两个模板,vector和shared_ptr</span></span><br><span class="line">std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于StrBlob的一个给定的成员函数</span></span><br><span class="line">ret-type StrBlob::member-<span class="built_in">name</span>(parm-list);</span><br><span class="line"><span class="comment">// 对应的Blob成员：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; ret-type Blob&lt;T&gt;::member-<span class="built_in">name</span>(parm-list)</span><br><span class="line"></span><br><span class="line"><span class="comment">// check成员,检查一个给定的索引</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string &amp;msg) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;=data-&gt;<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板版本则返回一个引用,指向用来实例化Blob的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="built_in">back</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;back on empty Blob&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span>[](size_type i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">check</span>(i,<span class="string">&quot;subscipt out of range&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板版本则返回一个引用,指向用来实例化Blob的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">check</span>(<span class="number">0</span>,<span class="string">&quot;pop_back on empty Blob&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的定义要以模板参数开始</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Blob&lt;T&gt;::<span class="built_in">Blob</span>() :<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;())&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在类代码内简化模板类名的使用</strong>
<ul>
<li>使用一个类模板类型时,<strong>必须提供模板实参</strong></li>
<li><mark>在类模板自己的作用域中,可以使用模板名而不提供实参</mark></li>
<li>处于一个类模板的作用域中时,编译器处理模板自身引用时就好像已经提供了与模板参数匹配的实参一样</li>
</ul>
</li>
<li><strong>在类模板外使用类模板名</strong>
<ul>
<li>在类模板外定义其成员时,必须记住,并不在类的作用域中,直到遇到类名才表示进入类的作用域</li>
<li><mark>在一个类模板的作用域内,可以直接使用模板名而不必指定模板实参</mark></li>
</ul>
</li>
<li><strong>类模板和友元</strong>
<ul>
<li>当一个类包含一个友元声明时,类与友元各自是否是模板相互无关</li>
<li>如果一个类模板包含一个非模板友元,则友元被授权可以访问所有模板实例;如果友元自身是模板,类可以授权给所有友元模板实例,也可以只授权给特定实例</li>
</ul>
</li>
<li><strong>一对一友好关系</strong>
<ul>
<li>类模板与另一个模板间友好关系的最常见形式是建立对应实例及其友元间的友好关系</li>
</ul>
</li>
<li>通用和特定的模板友好关系
<ul>
<li>一个类也可以将另一个模板的每个实例都声明为自己的友元或限定特定的实例为友元</li>
<li>为了让所有实例称为友元,友元声明中必须使用与类模板本身不同的模板参数</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若试图访问一个不存在的元素,BlobPtr抛出一个异常</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlobPtr</span>() : <span class="built_in">curr</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">BlobPtr</span>(Blob&lt;T&gt; &amp;a, <span class="type">size_t</span> sz = <span class="number">0</span>):</span><br><span class="line">      <span class="built_in">wptr</span>(a.data),<span class="built_in">curr</span>(sz) &#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;deference past end&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处于一个类模板的作用域中时,编译器处理模板自身引用时就好像已经提供了与模板参数匹配的实参一样</span></span><br><span class="line">    <span class="comment">// 等效于BlobPtr&lt;T&gt;&amp; operator++();</span></span><br><span class="line">    BlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    BlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt;</span><br><span class="line">      <span class="built_in">check</span>(std::<span class="type">size_t</span>, <span class="type">const</span> std::string&amp;) <span class="type">const</span>;</span><br><span class="line">    std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;</span><br><span class="line">    std::<span class="type">size_t</span> curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置：递增/递减对象但返回原址</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">  BlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">  ++*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在函数体内,已经进入类的作用域,在定义ret时无需重复模板参数</span></span><br><span class="line"><span class="comment">// 不提供模板参数,则编译器将假定使用的类型与成员实例化所用类型一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对一友好关系</span></span><br><span class="line"><span class="comment">// 前置声明,在Blob中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Blob&lt;T&gt;&amp;, <span class="type">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>&#123;</span><br><span class="line">  <span class="comment">// 每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BlobPtr</span>&lt;T&gt;;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==&lt;T&gt;</span><br><span class="line">          (<span class="type">const</span> Blob&lt;T&gt;&amp;, <span class="type">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元的声明用Blob的模板形参作为自己的模板实参</span></span><br><span class="line"><span class="comment">// 友好关系被限定在用相同实例化的Blob和BlobPtr相等的运算符中</span></span><br><span class="line">Blob&lt;<span class="type">char</span>&gt; ca;</span><br><span class="line">Blob&lt;<span class="type">int</span>&gt; ia;</span><br><span class="line"><span class="comment">// BlobPtr&lt;char&gt;的成员可以访问ca的非public部分</span></span><br><span class="line"><span class="comment">// 但ca对ia没有特殊访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用和特定的模板友好关系</span></span><br><span class="line"><span class="comment">// 前置声明,在将模板的一个特定实例声明为友元时会用到</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Pal</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">  firend <span class="keyword">class</span> <span class="title class_">Pal</span>&lt;C&gt;;  <span class="comment">//用类C实例化的Pal时C的一个友元</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal2</span>;  <span class="comment">//Pal2的所有实例都是C的友元,无需前置声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span> T&gt; <span class="keyword">class</span> <span class="title class_">C2</span>&#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>&lt;T&gt;;  <span class="comment">//Pal的模板声明必须在作用域之内</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal2</span>;   <span class="comment">//Pal2的所有实例都是C2每个实例的友元,无需前置声明</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal3</span>;  <span class="comment">//Pal3是一个非模板类,它是C2所有实例的友元</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>令模板自己的类型参数成为友元</strong>
<ul>
<li>在新标准中,可以将模板类型参数声明为友元</li>
</ul>
</li>
<li><strong>模板类型别名</strong>
<ul>
<li>新标准允许为类模板定义一个类型别名</li>
</ul>
</li>
<li><strong>类模板的static成员</strong>
<ul>
<li>类模板可以声明static成员,static成员函数只有在使用时才会实例化</li>
<li>类模板的每个不同的实例都有其自己的static成员实例,类模板的相同类型的实例共享相同的成员实例</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板参数类型声明为友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt; <span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line">  <span class="keyword">friend</span> Type;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于某个类型Foo,Foo将成为Bar&lt;Foo&gt;的友元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用typedef定义模板类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> Blob&lt;string&gt; StrBlob;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用using定义模板类型别名</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line">twin&lt;string&gt; authors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T,<span class="type">unsigned</span>&gt;;</span><br><span class="line">partNo&lt;string&gt; books; <span class="comment">//pair&lt;string unsigned&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明static成员</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::<span class="type">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ctr;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::<span class="type">size_t</span> ctr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1613-模板参数"><a class="markdownIt-Anchor" href="#1613-模板参数"></a> 16.1.3 模板参数</h3>
<ul>
<li>模板参数的名字没有内在含义</li>
<li>模板参数名的可用范围时在其声明之后,至模板声明或定义结束之前</li>
<li><mark>模板参数会隐藏外层作用域中声明的相同的名字,但在模板内部不能重用模板参数名</mark></li>
<li><strong>模板声明</strong>
<ul>
<li>与函数参数相同,声明中的模板参数的名字不必与定义中相同</li>
</ul>
</li>
<li><strong>使用类的类型成员</strong>
<ul>
<li>使用一个模板类型参数的类型参数,就必须显式告诉编译器该名字是一个类型</li>
<li><strong>通过使用关键字typename来实现,不能使用class</strong></li>
</ul>
</li>
<li><strong>默认模板实参</strong>
<ul>
<li>在新标准中,可以为类模板和函数提供默认模板实参</li>
</ul>
</li>
<li><strong>模板默认实参与类模板</strong>
<ul>
<li>无论何时使用一个类模板,都必须在模板名之后接上尖括号,尖括号指出类必须从一个模板实例化而来</li>
<li>特别是,如果一个类模板为其所有模板参数都提供了默认实参,且希望使用这些默认实参,就必须在模板名之后跟一个空尖括号对</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>;</span><br><span class="line"><span class="comment">// 声明但不定义compare和Blob</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">calc</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; U <span class="title">calc</span><span class="params">(<span class="type">const</span> U&amp;, <span class="type">const</span> U&amp;)</span></span>;</span><br><span class="line"><span class="comment">// 模板的定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span></span><br><span class="line"><span class="function">      Type <span class="title">clac</span><span class="params">(<span class="type">const</span> Type&amp; a, <span class="type">const</span> Type&amp; b)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类的类型成员</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="type">const</span> T&amp; c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!c.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typename</span> T::<span class="built_in">value_type</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写compare</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2, F f = <span class="built_in">F</span>())&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">f</span>(v1,v2))  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">f</span>(v2,v1))  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用该模板时,可以自定义比较操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">int</span>&gt; <span class="keyword">class</span> Numbers&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Numbers</span>(T v = <span class="number">0</span>):<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="type">long</span> <span class="type">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision;  <span class="comment">//&lt;&gt;表示希望使用默认类型</span></span><br></pre></td></tr></table></figure>
<h3 id="1614-成员模板"><a class="markdownIt-Anchor" href="#1614-成员模板"></a> 16.1.4 成员模板</h3>
<ul>
<li>一个类可以包含本身是模板的成员函数,这种成员成为成员模板
<ul>
<li><mark>成员模板不能是虚函数</mark></li>
</ul>
</li>
<li><strong>普通(非模板)类的成员函数</strong></li>
<li>类模板的成员模板
<ul>
<li>可以为类模板定义成员模板,类和成员各自有自己独立的模板参数</li>
<li>与类模板的普通成员函数不同,成员模板是函数模板
<ul>
<li>在类模板外定义一个成员模板时,必须同时为类模板和成员模板提供模板参数列表,<mark>类模板的参数列表在前,成员模板参数列表在后</mark></li>
</ul>
</li>
</ul>
</li>
<li>实例化与成员模板
<ul>
<li>为了实例化一个类模板的成员模板,必须同时提供类和函数模板的实参</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为普通类包含成员模板的例子,定义一个类,类似unique_ptr所使用的默认删除器类型</span></span><br><span class="line"><span class="comment">// 类似默认删除器,类将包含一个重载的函数调用运算符,它接受一个指针并对此指针执行delete</span></span><br><span class="line"><span class="comment">// 与默认删除器不同,类还将在删除器被执行时打印一条信息。由于希望删除器适用于任何类型,所以将调用运算符定义为一个模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象类,对给定指针执行delete</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DebugDelete</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DebugDelete</span>(std::ostream &amp;s = std::cerr): <span class="built_in">os</span>(s) &#123; &#125;</span><br><span class="line">    <span class="comment">// 与任何函数模板相同,T的类型由编译器推断</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      os &lt;&lt; <span class="string">&quot;deleting unique_ptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::osream &amp;os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> *p = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">DebugDelete d;</span><br><span class="line"><span class="built_in">d</span>(p); <span class="comment">//调用DebugDelete::operator()(double*),释放p</span></span><br><span class="line"><span class="type">int</span>* ip = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="built_in">DebugDelete</span>()(ip);  <span class="comment">//在一个临时DebugDelete对象上调用operator()(int*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将DebugDelete用作unique_ptr的删除器</span></span><br><span class="line"><span class="comment">// 为了重载unique_ptr的删除器,在尖括号内给出删除器类型,并提供一个这种类型的对象给unique_ptr的构造函数</span></span><br><span class="line"><span class="comment">// 销毁p指向的对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>, DebugDelete&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>, DebugDelete())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的成员模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>&#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="built_in">Blob</span>(It b, It e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt; Blob&lt;T&gt;::<span class="built_in">Blob</span>(It b,Ite ):</span><br><span class="line">        <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b,e)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1615-控制实例化"><a class="markdownIt-Anchor" href="#1615-控制实例化"></a> 16.1.5 控制实例化</h3>
<ul>
<li>当模板被使用时才会进行实例化,这意味着相同的实例可能出现在多个对象文件中,独立编译的源文件使用了相同的模板,模板参数相同时会有多个模板的实例</li>
<li>可以使用<strong>显式实例化</strong>来避免多余的开销
<ul>
<li>将一个实例化声明为extern表示承诺在程序其他位置有该实例化的一个非extern声明,但必须只有一个定义</li>
<li><mark>对于每个实例化声明,在程序中某个位置必须有其显式的实例化定义</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;  <span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">//实例化定义</span></span><br><span class="line"><span class="comment">// declaration是一个类或函数声明,其中所有模板参数已被替换成模板实参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;;</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="162-模板实参推断"><a class="markdownIt-Anchor" href="#162-模板实参推断"></a> 16.2 模板实参推断</h2>
<ul>
<li>从函数实参来确定模板实参的过程称为<strong>模板实参推断</strong></li>
</ul>
<h3 id="1621-类型转换与模板类型参数"><a class="markdownIt-Anchor" href="#1621-类型转换与模板类型参数"></a> 16.2.1 类型转换与模板类型参数</h3>
<ul>
<li>与非模板函数一样,在一次调用中传递给函数模板的实参被用来初始化函数的形参</li>
<li>如果函数形参的类型使用了模板类型参数,则采用特殊的初始化规则</li>
<li><mark>顶层const无论在形参中还是实参中,都会被忽略</mark></li>
<li>在其他类型转换中,能在调用中应用于函数模板的包括：
<ul>
<li>const转换：可以将一个非const对象的引用传递给一个const的引用</li>
<li>数组和函数指针转换：若函数形参不是引用类型,则可以对数组或函数类型的实参引用正常的指针转换</li>
<li><mark>将实参传递给模板类型的函数形参是,能自动应用类型转换的只有const转换及数组或函数到指针的转换</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑函数fobj和fref的调用</span></span><br><span class="line"><span class="comment">// fobj函数拷贝它的参数,而fref的参数是引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">fobj</span><span class="params">(T, T)</span></span>;  <span class="comment">//实参被拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">fref</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">s2</span><span class="params">(<span class="string">&quot;another value&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1,s2);  <span class="comment">//调用fobj(string,string);const被呼呼额</span></span><br><span class="line"><span class="built_in">fref</span>(s1,s2); <span class="comment">//调用fobj(const string&amp;,const string&amp;);</span></span><br><span class="line">              <span class="comment">//将s1转换为const是允许的</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],b[<span class="number">42</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a,b);  <span class="comment">//调用f(int*,int*)</span></span><br><span class="line"><span class="built_in">fref</span>(a,b);  <span class="comment">//错误,数组类型不匹配</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用相同模板参数类型的函数形参</strong>
<ul>
<li>一个模板类型参数可以用作多个函数形参的类型</li>
<li>由于至允许有限的集中类型转换,因此传递给形参的实参必须具有相同的类型</li>
<li>若允许对函数实参进行正常的初始化,可以将函数模板定义成两个类型的参数
<ul>
<li>且必须定义能比较这些类型的&lt;运算符</li>
</ul>
</li>
</ul>
</li>
<li><strong>正常类型转换应用于普通函数实参</strong>
<ul>
<li>函数模板可以有用普通类型定义的参数
<ul>
<li><mark>不涉及模板类型参数的类型,这种函数实参不进行特殊处理,正常转换为对应形参的类型</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare函数接收两个const T&amp;参数,其实参类型必须具有相同类型</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="type">long</span>, <span class="number">1024</span>);  <span class="comment">//不能实例化,参数类型不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若允许对函数实参进行正常的初始化,可以将函数模板定义成两个类型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> A&amp; v1, <span class="type">const</span> B&amp; v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v1&lt;v2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (v2&lt;v1)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1622-函数模板显式实参"><a class="markdownIt-Anchor" href="#1622-函数模板显式实参"></a> 16.2.2 函数模板显式实参</h3>
<ul>
<li>当函数返回类型与参数列表中任何类型都不相同是,编译器无法推断出模板实参的类型</li>
<li><strong>指定显式模板实参</strong>
<ul>
<li>在调用时必须提供一个显式模板实参：显式实参在尖括号中给出,位于函数名之后,实参列表之前</li>
<li>显式模板实参按由左至右的顺序与对应的模板参数匹配</li>
</ul>
</li>
<li><strong>正常类型转换应用于显式指定的实参</strong>
<ul>
<li>对于模板类型参数已经显式指定了的函数实参,也进行正常的类型转换</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt; T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供显式模板实参,显式指明T1,但T2,T3由实参类型推断</span></span><br><span class="line"><span class="keyword">auto</span> val3 = <span class="built_in">sum</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(i,lng);</span><br></pre></td></tr></table></figure>
<h3 id="1623-尾置返回类型与类型转换"><a class="markdownIt-Anchor" href="#1623-尾置返回类型与类型转换"></a> 16.2.3 尾置返回类型与类型转换</h3>
<ul>
<li>显式模板实参表示模板函数的返回类型是很有效的,但在其他情况下,要求显式指定模板实参会添加额外的负担</li>
<li>使用尾置返回类型,<strong>由于尾置返回类型出现在参数列表之后,可以使用函数的参数</strong></li>
<li><strong>进行类型转换的标准库模板类</strong>
<ul>
<li>对于传递的参数的类型,但直到唯一可以使用的操作是迭代器操作,但所有迭代器操作都不会生成元素,只能使用元素的引用</li>
<li><strong>为了获得元素类型,使用标准库的类型转换模板</strong>
<ul>
<li>定义在头文件type_traits中,通常用于所谓的模板源程序设计</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个函数,接受表示序列的一对迭代器和返回序列中一个元素的引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;<span class="built_in">fcn</span>(It beg, It end)&#123;</span><br><span class="line">  <span class="comment">//处理序列</span></span><br><span class="line">  <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并不知道返回结果的类型,但知道所需类型是所处理的序列的元素类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Blob&lt;string&gt; ca = &#123;<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;i = <span class="built_in">fcn</span>(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>()); <span class="comment">//应该返回int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;s = <span class="built_in">fcn</span>(ca.<span class="built_in">begin</span>(),ca.<span class="built_in">end</span>()); <span class="comment">//应该返回string&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾置返回允许在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> &amp;<span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//处理序列</span></span><br><span class="line">  <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用remove_reference来获得元素类型</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合使用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> &amp;<span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//处理序列</span></span><br><span class="line">  <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type是一个类的成员,而该类依赖于一个模板参数,必须在返回类型的声明中使用typename来告知编译器,type表示一个类型</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>对Mod&lt;T&gt;,其中Mod为</th>
<th>T为</th>
<th>Mod&lt;T&gt;::type为</th>
</tr>
</thead>
<tbody>
<tr>
<td>remove_reference</td>
<td>X&amp;或X&amp;&amp;,否则</td>
<td>X,否则为T</td>
</tr>
<tr>
<td>add_const</td>
<td>X&amp;,const X,或函数,否则</td>
<td>T,否则为const T</td>
</tr>
<tr>
<td>add_lvalue_reference</td>
<td>X&amp;,X&amp;&amp;,否则</td>
<td>T,X&amp;,否则为T&amp;</td>
</tr>
<tr>
<td>add_rvalue_reference</td>
<td>X&amp;或X&amp;&amp;,否则</td>
<td>T,否则为T&amp;&amp;</td>
</tr>
<tr>
<td>remove_pointer</td>
<td>X*,否则</td>
<td>X,否则为T</td>
</tr>
<tr>
<td>add_pointer</td>
<td>X&amp;或X&amp;&amp;,否则</td>
<td>X*,否则为T*</td>
</tr>
<tr>
<td>make_signed</td>
<td>unsigned X,否则</td>
<td>X,否则为T</td>
</tr>
<tr>
<td>make_unsigned</td>
<td>带符号类型,否则</td>
<td>unsigned X,否则为T</td>
</tr>
<tr>
<td>remove_extent</td>
<td>X[n],否则</td>
<td>X,否则为T</td>
</tr>
<tr>
<td>remove_all_extent</td>
<td>X[n1][n2],否则</td>
<td>X,否则为T</td>
</tr>
</tbody>
</table>
<h3 id="1624-函数指针和实参推断"><a class="markdownIt-Anchor" href="#1624-函数指针和实参推断"></a> 16.2.4 函数指针和实参推断</h3>
<ul>
<li>用一个函数模板初始化一个函数指针或为一个函数指针赋值时,编译器使用指针的类型来推断模板实参</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定有一个函数指针,指向的函数返回int,接受两个参数,每个参数都是指向const int的引用</span></span><br><span class="line"><span class="comment">// 可以使用该指针指向compare的一个实例</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;,const int&amp;)</span></span><br><span class="line"><span class="built_in">int</span> (*pf1)(<span class="type">const</span> <span class="type">int</span>&amp;,<span class="type">const</span> <span class="type">int</span>&amp;) = compare;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能从函数指针类型确定模板实参,则产生错误</span></span><br><span class="line"><span class="comment">// func的重载版本：每个版本接受不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>(*) (<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>(*) (<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;))</span></span>;</span><br><span class="line"><span class="built_in">func</span>(compare);  <span class="comment">//错误,使用混乱</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(compare&lt;<span class="type">int</span>&gt;); <span class="comment">//传递compare(const int&amp;, const int&amp;)</span></span><br></pre></td></tr></table></figure>
<h3 id="1625-模板实参推断和引用"><a class="markdownIt-Anchor" href="#1625-模板实参推断和引用"></a> 16.2.5 模板实参推断和引用</h3>
<ul>
<li><strong>从左值引用函数参数推断类型</strong>
<ul>
<li>当一个函数参数是模板类型参数的普通(左值)引用时,只能传递一个左值,实参可以时const类型,也可以不是
<ul>
<li>如果实参是const的,则T将被推断称const类型</li>
<li>如果函数参数的类型是const T&amp;,正常可以传递任何类型的实参(对象,临时对象或字面值)</li>
<li>当函数参数本身是const时,T的类型推断结果不会是一个const类型</li>
</ul>
</li>
</ul>
</li>
<li><strong>从右值引用函数参数推断类型</strong>
<ul>
<li>函数参数时右值引用时,可以传递右值,类型推断推断的应为右值</li>
</ul>
</li>
<li><strong>引用折叠和右值引用参数</strong>
<ul>
<li>例外规则,允许非正常的绑定
<ul>
<li>第一条是：当将一个左值传递给函数的右值引用参数,且此右值引用指向模板类型参数时,编译器推断模板类型参数为实参的左值引用类型</li>
<li>如果间接创建一个引用的引用,则引用形成<strong>折叠</strong>：引用会折叠称一个普通的左值引用类型</li>
<li><mark>只有右值引用的右值引用会折叠称右值引用</mark></li>
<li><mark>引用折叠只能应用于间接创建的引用的引用,如类型别名或模板参数</mark></li>
<li><mark>若函数参数是指向模板参数类型的右值引用,则可以传递任意类型的实参;若将左值传递,则函数实参被实例化成一个普通的左值引用</mark></li>
</ul>
</li>
</ul>
</li>
<li><strong>右值引用常用于两种情况</strong>：模板转发其实参或模板被重载</li>
<li><strong>虽然不能隐式地将一个左值转换为右值引用,但可以用static_cast显式地将一个左值转换为一个右值引用</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;    <span class="comment">//实参必须时一个左值</span></span><br><span class="line"><span class="built_in">f1</span>(i);  <span class="comment">//i是int,则T为int</span></span><br><span class="line"><span class="built_in">f1</span>(ci);  <span class="comment">//i是const int,则T为const int</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>);    <span class="comment">//错误,传递的实参必须是左值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;    <span class="comment">//可以接受右值</span></span><br><span class="line"><span class="built_in">f2</span>(i);  <span class="comment">//i是int,则T为const int</span></span><br><span class="line"><span class="built_in">f2</span>(ci);  <span class="comment">//i是const int,则T为int</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);    <span class="comment">//T为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>);     <span class="comment">//T为int</span></span><br><span class="line"><span class="built_in">f3</span>(i);    <span class="comment">//实参为左值,T为int&amp;</span></span><br><span class="line"><span class="built_in">f3</span>(ci);    <span class="comment">//实参为左值,T为const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写接受右值引用参数的模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span>&#123;</span><br><span class="line">  T t = val;</span><br><span class="line">  t = <span class="built_in">fcn</span>(t);</span><br><span class="line">  <span class="keyword">if</span>(val == t)&#123;<span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1627-转发"><a class="markdownIt-Anchor" href="#1627-转发"></a> 16.2.7 转发</h3>
<ul>
<li>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数
<ul>
<li>需要保持被转发实参的所有性质,包括实参类型是否是const以及实参是左值还是右值</li>
</ul>
</li>
<li><strong>定义能保持类型信息的函数参数</strong>
<ul>
<li><mark>通过将一个函数参数定义为一个指向模板类型参数的右值引用,可以保持其对应实参的所有类型信息</mark></li>
<li>使用引用参数,使得可以保持const属性,因为在引用类型中的const是底层的</li>
<li>将函数参数定义为T1&amp;&amp;和T2&amp;&amp;,通过引用折叠就可以保持翻转实参的左值/右值属性</li>
<li><mark>如果一个函数参数是指向模板类型参数的右值引用(如T&amp;&amp;),它对应的实参的const属性和左值/右值属性将得到保持</mark></li>
</ul>
</li>
<li><strong>在调用中使用std::forward保持类型信息</strong>
<ul>
<li>使用名为forward的新标准库设施来传递flip2的参数,能保俶原始实参的类型</li>
<li>定义在utility中,必须通过显式模板实参来调用,forward返回该显式实参类型的右值引用</li>
<li>使用forward传递那些定义为模板类型参数的右值引用的函数参数
<ul>
<li>通过其返回类型上的引用折叠,forward可以保持给定实参的左值/右值属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个可调用对象和另外两个参数的模板</span></span><br><span class="line"><span class="comment">// 对翻转的参数调用给定的可调用对象</span></span><br><span class="line"><span class="comment">// flip1是一个不完整的实现：顶层const和引用丢失了</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(t2,t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用一个接受引用参数的函数时会出现问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> &amp;v2)</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;v1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; ++v2&lt;&lt;endl;</span><br><span class="line">  <span class="comment">// 改变了绑定到v2的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">42</span>,i);  <span class="comment">//f改变了实参i</span></span><br><span class="line"><span class="built_in">flip1</span>(f,j,<span class="number">42</span>);  <span class="comment">//通过flip1调用f不会改变j</span></span><br><span class="line"><span class="comment">// 问题在于j被传递给flip1的参数t1,此参数是一个普通的,非引用类型的int,而非int&amp;</span></span><br><span class="line"><span class="comment">// 被实例化为</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip1</span><span class="params">(<span class="type">void</span>(*fcn)(<span class="type">int</span>,<span class="type">int</span>&amp;),<span class="type">int</span> t1,<span class="type">int</span> t2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义能保持类型信息的函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(t2,t1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解决一半问题,但不能接受右值引用参数的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> &amp;&amp;i,<span class="type">int</span>&amp; j)</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; j&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 试图通过flip2调用g,则参数t2将被传递给g的右值引用参数。即使传递一个右值给flip2</span></span><br><span class="line"><span class="built_in">flip2</span>(g,i,<span class="number">42</span>);    <span class="comment">//错误,不能从一个左值实例化int&amp;&amp;</span></span><br><span class="line"><span class="comment">// 函数参数与其他任何变量一样,都是左值表达式</span></span><br><span class="line"><span class="comment">// 因此,flip2中对g的调用将传递给g的右值引用参数一个左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forward可以保持给定实参的左值/右值属性</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(std::forward&lt;T2&gt;(t2),std::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="163-重载与模板"><a class="markdownIt-Anchor" href="#163-重载与模板"></a> 16.3 重载与模板</h2>
<ul>
<li>函数模板可以被另一个模板或一个普通非模板函数重载(名字相同的函数必须具有不同数量或类型的参数)</li>
<li>当有多个重载模板对一个调用提供同样好的匹配时,应选择最特例化的版本</li>
<li>对于一个调用,如果一个非函数模板与一个函数模板提供同样好的匹配,则选择非模板版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写重载模板</span></span><br><span class="line"><span class="comment">// 打印任何不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="type">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">  ostringstream ret;</span><br><span class="line">  ret&lt;&lt;t;</span><br><span class="line">  <span class="keyword">return</span> ret.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此函数可以用来生成一个对象对应的string表示,该对象可以是任意具备输出运算符的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义打印指针的debug_rep版本</span></span><br><span class="line"><span class="comment">// 打印指针的值,后跟指针指向的对象</span></span><br><span class="line"><span class="comment">// 不能用于char*</span></span><br><span class="line"><span class="comment">// IO库为char*值定义了一个&lt;&lt;版本。此&lt;&lt;版本假定指针表示一个空字符结尾的字符数组,并打印数组的内容而非地址值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; string <span class="title">debug_rep</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line">  ostringstream ret;</span><br><span class="line">  ret &lt;&lt;<span class="string">&quot;pointer: &quot;</span>&lt;&lt;p;</span><br><span class="line">  <span class="keyword">if</span>(p)</span><br><span class="line">    ret&lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;<span class="built_in">debug_rep</span>(*p);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ret&lt;&lt; <span class="string">&quot; null pointer&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ret.str; <span class="comment">//返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下调用</span></span><br><span class="line"><span class="type">const</span> string *sp = &amp;s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个模板都是可行的,而且两个都是精确匹配：</span></span><br><span class="line"><span class="comment">// debug_rep(const string*&amp;),由第一个版本的debug_rep实例化而来,T被绑定到string*</span></span><br><span class="line"><span class="comment">// debug_rep(const string*),由第二个版本的debug_rep实例化而来,T被绑定到const string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析为debug_rep()T*),即第二个版本</span></span><br><span class="line"><span class="comment">// 设计这条规则的原因是,没有它,将无法对一个const的指针调用指针版本的debug_rep</span></span><br><span class="line"><span class="comment">// 问题在于模板debug_rep(const T&amp;)本质上可以用于任何类型,包括指针类型。此模板比debug_rep(T*)更通用,后者只能用于指针类型。没有这条规则,传递const的指针的调用永远是有歧义的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言风格字符串指针和字符串字面常量</span></span><br><span class="line">cout &lt;&lt;<span class="built_in">debug_rep</span>(<span class="string">&quot;hi world!&quot;</span>)&lt;&lt;endl;    <span class="comment">//调用debug_rep(T*)</span></span><br><span class="line"><span class="comment">// 对给定实参来说,两个模板都提供精确匹配</span></span><br><span class="line"><span class="comment">// 第二个模板需要进行一次(许可的)数组到指针的转换,而对于函数匹配来说,这种转换被认为是精确匹配</span></span><br><span class="line"><span class="comment">// 非模板版本是可行的,但需要进行一次用户定义的类型转换,因此它没有精确匹配那么好,所以两个模板成为可能调用的函数。与之前一样,T*版本更加特例化,编译器会选择它</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="164-可变参数模板"><a class="markdownIt-Anchor" href="#164-可变参数模板"></a> 16.4 可变参数模板</h2>
<ul>
<li><strong>一个可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类
<ul>
<li>可变数目的参数被称为参数包</li>
<li>存在两种参数包：<strong>模板参数包</strong>,表示零个或多个模板参数;<strong>函数参数包</strong>,表示零个或多个函数模板</li>
<li>用省略号来指出一个模板参数或函数参数表示一个包
<ul>
<li>在一个模板参数列表中class…或typename…指出接下来的参数表示零个或多个类型的列表;</li>
<li>一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数列表</li>
<li>在函数参数列表中,如果一个参数的类型是一个模板参数包,则此参数也是一个函数参数包</li>
</ul>
</li>
</ul>
</li>
<li><strong>sizeof运算符</strong>
<ul>
<li>需要直到包中有多少元素时,可以使用<strong>sizeof…运算符</strong>,sizeof…返回一个常量表达式,且不会对其实参求值</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包,rest是一个函数参数包</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args &amp;...rest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(Args ...args)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt;endl;</span><br><span class="line">  cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1641-编写可变参数函数模板"><a class="markdownIt-Anchor" href="#1641-编写可变参数函数模板"></a> 16.4.1 编写可变参数函数模板</h3>
<ul>
<li>可变参数函数通常是递归的
<ul>
<li>第一步调用处理包中的第一个实参,然后用剩余实参调用自身</li>
</ul>
</li>
<li><mark>当定义可变参数版本的函数时,非可变参数版本的声明必须在作用域中。否则可变参数版本会无限递归</mark></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">// 此函数必须在可变参数模板的print定义之前声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; t; <span class="comment">//包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">  os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">print</span>(os,rest);    <span class="comment">//递归调用,打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1642-包扩展"><a class="markdownIt-Anchor" href="#1642-包扩展"></a> 16.4.2 包扩展</h3>
<ul>
<li>对于一个参数包,除了获取其大小外,对它唯一能做的是<strong>扩展</strong>
<ul>
<li>当扩展一个包是,还需要提供用于每个扩展元素的模式</li>
<li>扩展一个包就是将它分解为构成的元素,对每个元素应用模式,获得扩展后的列表</li>
<li>在模式右边放一个省略号来触发扩展操作</li>
</ul>
</li>
<li>扩展中的模式会独立地应用于包中的每个元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对print做扩展操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;... rest)</span>  <span class="comment">//扩展Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">print</span>(os,rest...);    <span class="comment">//扩展rest</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在print调用中对每个实参调用debug_rep</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="type">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">print</span>(os,<span class="built_in">debug_rep</span>(rest)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题在于debug_rep调用中扩展了rest,等价于</span></span><br><span class="line"><span class="built_in">print</span>(cerr,<span class="built_in">debug_rep</span>(fcnName,code.<span class="built_in">num</span>(),otherData,<span class="string">&quot;otherData&quot;</span>,item));</span><br><span class="line"><span class="comment">// 试图用了一个五个实参的列表来调用debug_rep,但并不存在与此调用匹配的debug_rep版本</span></span><br><span class="line"><span class="comment">// debug_rep函数不是可变参数的,且没有哪个debg_rep接受五个参数</span></span><br></pre></td></tr></table></figure>
<h3 id="1643-转发参数包"><a class="markdownIt-Anchor" href="#1643-转发参数包"></a> 16.4.3 转发参数包</h3>
<ul>
<li>组合使用可变参数模板与forward机制来编写函数,实现将其实参不变地传递给其他函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将为StrVec类添加一个emplace_back成员</span></span><br><span class="line"><span class="comment">// 标准库容器的emplace_back成员是一个可变参数成员模板,它用其实参在容器管理的内存空间中直接构造一个元素</span></span><br><span class="line"><span class="comment">// 保持类型信息是一个两阶段的过程</span></span><br><span class="line"><span class="comment">// 首先为了保持实参中的类型信息,必须将emplace_back的函数定义为模板类型参数的右值引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt; <span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;...)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模板参数包扩展中的模式是&amp;&amp;,意味着每个函数参数将是一个指向其对应实参的右值引用</span></span><br><span class="line"><span class="comment">// 当emplace_back将实参传递给constrct时,必须使用forward来保持实参的原始类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">  <span class="built_in">chk_n_alloc</span>();    <span class="comment">//如果需要的话重新分配StrVec内存空间</span></span><br><span class="line">  alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假定svec是一个StrVec,如果调用</span></span><br><span class="line">svec.<span class="built_in">emplace_back</span>(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>);    <span class="comment">//将cccccccccc添加新的尾元素</span></span><br><span class="line"><span class="comment">// construct调用中的模式会扩展出</span></span><br><span class="line">std::forward&lt;<span class="type">int</span>&gt;(<span class="number">10</span>),std::forward&lt;<span class="type">char</span>&gt;(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用右值调用emplace_back,则construct会得到一个右值</span></span><br><span class="line">svec.<span class="built_in">emplace_back</span>(s1+s2);</span><br><span class="line"><span class="comment">// 传递右值</span></span><br><span class="line">std::forward&lt;string&gt;(<span class="built_in">string</span>(<span class="string">&quot;the end&quot;</span>))</span><br><span class="line"><span class="comment">// forward&lt;string&gt;的结果类型是string&amp;&amp;,因此construct将得到一个右值引用实参</span></span><br><span class="line"><span class="comment">// construct会继续将此实参传递给string的移动构造函数来创建新元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转发和可变参数模板</span></span><br><span class="line"><span class="comment">// func有零个或多个参数,每个参数都是一个模板参数类型的右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Args&amp;&amp;... args)</span>  <span class="comment">//将Args扩展为一个右值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// work的实参即扩展Args又扩展args</span></span><br><span class="line">  <span class="built_in">work</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于fun的参数是右值引用,因此可以传递给它任意类型的实参</span></span><br><span class="line"><span class="comment">// 由于使用std：：forward传递这些实参,因此它们的所有类型信息在调用work时都会得到保持</span></span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="165-模板特例化"><a class="markdownIt-Anchor" href="#165-模板特例化"></a> 16.5 模板特例化</h2>
<ul>
<li>编写单一模板,使之对任何可能的模板实参都是最合适的,都能实例化
<ul>
<li>在某些情况下,通用模板的定义对特定类型是不适合的：通用定义可能编译失败或做得不正确</li>
<li>当不能使用模板版本时,可定义类或函数模板得一个特例化版本</li>
</ul>
</li>
<li><strong>定义函数模板特例化</strong>
<ul>
<li>特例化一个函数模板时,必须为原模版中每个模板参数都提供实参</li>
<li>为了指出正在实例化一个模板,应该使用关键字template后跟一对空尖括号,空尖括号指出将为原模版的所有模板参数提供实参</li>
</ul>
</li>
<li><strong>函数重载与模板特例化</strong>
<ul>
<li>特例化的本质是实例化一个模板,而非重载它。特例化不影响函数匹配</li>
<li>将一个特殊的函数定义为一个特例化版本还是一个独立的非模板函数,会影响到函数匹配,
<ul>
<li>函数匹配会选择疼特例化的版本</li>
<li>当一个非模板函数提供与函数模板同样匹配好的情况下,编译器会选择非模板版本</li>
</ul>
</li>
</ul>
</li>
<li><strong>类模板特例化</strong>
<ul>
<li>可以特例化类模板,必须在原模版定义所在的命名空间中特例化</li>
</ul>
</li>
<li><strong>类模板部分特例化</strong>
<ul>
<li>可指定一部分而非所有模板参数,或是参数的一部分而非全部特性</li>
<li>一个类模板的部分特例化本身是一个模板,使用时用户必须为哪些在特例化版本中为指定的模板参数提供实参</li>
<li><mark>只能特例化类模板,不能部分特例化函数模板</mark></li>
</ul>
</li>
<li><strong>特例化成员而不是类</strong>：可以只特例化成员函数而不是特例化整个模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare函数的例子</span></span><br><span class="line"><span class="comment">// 第一个版本：可以比较任意两个类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">int</span> <span class="title">cmpare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// 第二个版本：处理字符串字面常量</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N, <span class="type">size_t</span> M&gt; <span class="type">int</span> <span class="title">cmpare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;)[N], <span class="type">const</span> <span class="type">char</span> (&amp;)[M])</span></span>;</span><br><span class="line"><span class="comment">// 只有当传递compare一个字符串字面常量或一个数组时,编译器才会调用接受两个非类型模板参数的模板</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p1 = <span class="string">&quot;hi&quot;</span>,*p2 = <span class="string">&quot;mom&quot;</span>;</span><br><span class="line"><span class="built_in">compare</span>(p1, p2);  <span class="comment">//调用第一个模板</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;mom&quot;</span>);  <span class="comment">//调用第二个模板</span></span><br><span class="line"><span class="comment">// 无法将一个指针转换为一个数组的引用</span></span><br><span class="line"><span class="comment">// 为了处理字符指针,可以为第一个版本的compare定义一个模板特例化版本</span></span><br><span class="line"><span class="comment">// 一个特例化版本就是模板的一个独立地定义,在其中一个或多个模板被指定为特定的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compare的特殊版本,处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p1, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当定义一个特殊化版本时,函数参数类型必须与一个先前声明的模板中对应的类型匹配</span></span><br><span class="line"><span class="comment">// 希望定义此函数的一个特例化版本,其中T为const char*</span></span><br><span class="line"><span class="comment">// 函数要求一个指向此类型const版本的引用。一个指针类型的const版本是一个常量指针而不是指向const类型的指针</span></span><br><span class="line"><span class="comment">// 需要在特例化版本中使用的类型是const char * const &amp;,即一个指向const char的const指针的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开std命名空间,以便特例化std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;   <span class="comment">//关闭std命名空间;注意右花括号之后没有分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开std命名空间,以便特例化std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;&gt; <span class="comment">//特例化版本,模板参数为Sales_data</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Sales_data&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> resule_type;</span><br><span class="line">    <span class="keyword">typedef</span> Sales_data argument_type;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> Sales_data&amp; s)</span> <span class="type">const</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">size_t</span> hash&lt;Sales_data&gt;::<span class="built_in">operator</span>() (<span class="type">const</span> Sales_data&amp; s) <span class="type">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;() (s.bookNo) ^</span><br><span class="line">           <span class="built_in">hash</span>&lt;<span class="type">unsigned</span>&gt;() (s.units_sold) ^</span><br><span class="line">           <span class="built_in">hash</span>&lt;<span class="type">double</span>&gt;() (s.revenue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   <span class="comment">//关闭std命名空间;注意右花括号之后没有分号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">std</span>::hash; <span class="comment">//友元声明所需要的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">std</span>::hash&lt;Sales_data&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指出特殊实例hash&lt;Sales_data&gt;是Sales_data的友元</span></span><br><span class="line"><span class="comment">// 由于此实例定义在std命名空间中,必须在友元声明中使用std::hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例化成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">const</span> T &amp;t = <span class="built_in">T</span>()) : <span class="built_in">mem</span>(t)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span>  </span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line">  T mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;    <span class="comment">//正在特例化模板</span></span><br><span class="line"><span class="type">void</span> Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">Bar</span>()&#123;</span><br><span class="line">  <span class="comment">// 特例化Foo&lt;int&gt;的成员Bar</span></span><br><span class="line">  <span class="comment">// 进行应用于int的特例化处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="17-标准库特殊设施"><a class="markdownIt-Anchor" href="#17-标准库特殊设施"></a> 17 标准库特殊设施</h1>
</div><div class="story post-story"><h2 id="171-tuple类型"><a class="markdownIt-Anchor" href="#171-tuple类型"></a> 17.1 tuple类型</h2>
<ul>
<li>tuple类似pair的模板,一个tuple可以有任意数量的成员,每个确定的tuple类型的成员数目是固定的,但一个tuple类型的成员数目可以与另一个tuple类型不同</li>
<li><mark>当希望将一些数据组合成成单一对象,但不想重新定义一个数据结构来表示数据时,tuple为较好的选择</mark>
<ul>
<li>定义在tuple头文件中</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>tuple支持的操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>tuple&lt;T1,T2,…,Tn&gt; t</td>
<td>t为n个不同成员类型的tuple</td>
</tr>
<tr>
<td>tuple&lt;T1,T2,…,Tn&gt; t(v1,v2,…vn)</td>
<td>t为n个不同成员类型初始化了的tuple,次构造函数时explicit</td>
</tr>
<tr>
<td>make_tuple(v1,v2,…vn)</td>
<td>返回一个初始值初始化的tuple</td>
</tr>
<tr>
<td>t1 == t2</td>
<td>当两个tuple具有相同数量的成员且成员对应相等时,两个相等</td>
</tr>
<tr>
<td>t1 != t2</td>
<td>当两个tuple具有相同数量的成员且成员对应相等时,两个相等</td>
</tr>
<tr>
<td>t1 relop t2</td>
<td>关系运算符,使用字典序进行</td>
</tr>
<tr>
<td>get&lt;i&gt;(t)</td>
<td>返回t第i个成员的引用,若t是一个左值,结果为左值,否则为右值</td>
</tr>
<tr>
<td>tuple_size&lt;tupleType&gt;::value</td>
<td>一个类模板,通过tuple类型初始化</td>
</tr>
<tr>
<td>tuple_element&lt;i,tupleType&gt;::type</td>
<td>一个类模板,通过一个整型常量和一个tuple类型来初始化,有一个type的成员,表示给定tuple类型中指定成员的类型</td>
</tr>
</tbody>
</table>
<h3 id="1711-定义和初始化tuple"><a class="markdownIt-Anchor" href="#1711-定义和初始化tuple"></a> 17.1.1 定义和初始化tuple</h3>
<ul>
<li>定义tuple时,需要指出每个成员的类型
<ul>
<li><strong>构造函数是explicit,必须使用直接初始化语法</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">size_t</span>,<span class="type">size_t</span>,<span class="type">size_t</span>&gt; threeD;</span><br><span class="line">tuple&lt;string, vector&lt;<span class="type">double</span>&gt;, <span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; = <span class="built_in">someVal</span>(<span class="string">&quot;constants&quot;</span>,&#123;<span class="number">3.14</span>,<span class="number">2.718</span>&#125;,<span class="number">42</span>,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接初始化</span></span><br><span class="line">tuple&lt;<span class="type">size_t</span>,<span class="type">size_t</span>,<span class="type">size_t</span>&gt; threeD&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make_tuple</span></span><br><span class="line"><span class="keyword">auto</span> item = <span class="built_in">make_tuple</span>(<span class="string">&quot;0-99-78345-X&quot;</span>,<span class="number">3</span>,<span class="number">20.00</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>访问tuple成员</strong>
<ul>
<li>使用get标准库函数模板,并指定显式模板实参(传递tuple对象,返回指定成员的引用)</li>
<li>尖括号的值必须是整型常量表达式</li>
<li>==不知道tuple准确的类型细节时,使用辅助类进行查询</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> book = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(item);</span><br><span class="line"><span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(item) *= <span class="number">0.8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(item)</span> trans</span>; <span class="comment">//trans是item的类型</span></span><br><span class="line"><span class="type">size_t</span> sz = tuple_size&lt;trans&gt;::value; <span class="comment">//返回trans类型对象中成员的数量</span></span><br><span class="line">tuple_element&lt;<span class="number">1</span>,trans&gt;::type cnt = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(item);</span><br></pre></td></tr></table></figure>
<h3 id="1712-使用tuple返回多个值"><a class="markdownIt-Anchor" href="#1712-使用tuple返回多个值"></a> 17.1.2 使用tuple返回多个值</h3>
<ul>
<li>最常见的用途是从一个函数返回多个值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// matches有三个成员：一家书店的索引和两个指向书店vector中元素的迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;vector&lt;Sales_data&gt;::size_type,</span><br><span class="line">              vector&lt;Sales_data&gt;::const_iterator,</span><br><span class="line">              vector&lt;Sales_data&gt;::const_iterator&gt; matches;</span><br><span class="line"><span class="comment">// files保存每家书店的销售记录</span></span><br><span class="line"><span class="comment">// findBook返回一个vector,每家销售了给定书籍的书店在其中都有一项</span></span><br><span class="line"><span class="function">vector&lt;matches&gt;</span></span><br><span class="line"><span class="function"><span class="title">findBook</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;Sales_data&gt;&gt; &amp;files, <span class="type">const</span> string &amp;book)</span></span>&#123;</span><br><span class="line">  vector&lt;matches&gt; ret;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it = files.<span class="built_in">cbegin</span>();it!=files.<span class="built_in">cend</span>();++it)&#123;</span><br><span class="line">    <span class="keyword">auto</span> found = <span class="built_in">equal_range</span>(it-&gt;<span class="built_in">cbegin</span>(),it-&gt;<span class="built_in">cend</span>(),book,compareIsbn);</span><br><span class="line">    <span class="keyword">if</span>(found.first != found.second)</span><br><span class="line">      ret.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(it - files.<span class="built_in">cbegin</span>(),found.first,found.second));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// equal_range的标准库算法:前两个实参是表示输入序列的迭代器(参见10.1节,第336页),第三个参数是一个值。默认情况下,equal_range使用&lt;运算符来比较元素,Sales_data没有&lt;运算符,则需要传递函数指针</span></span><br><span class="line"><span class="comment">// 返回迭代器表示pair表示元素范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印汇总销售信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reportResults</span><span class="params">(istream &amp;in, ostream &amp;os, <span class="type">const</span> vector&lt;vector&lt;Sales_data&gt;&gt; &amp;files)</span></span>&#123;</span><br><span class="line">  string s;</span><br><span class="line">  <span class="keyword">while</span>(in&gt;&gt;s)&#123;</span><br><span class="line">    <span class="keyword">auto</span> trans = <span class="built_in">findBook</span>(files,s);</span><br><span class="line">    <span class="keyword">if</span>(trans.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      cout &lt;&lt; s &lt;&lt; <span class="string">&quot; not found in any stores&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;store : trans)</span><br><span class="line">      os &lt;&lt; <span class="string">&quot;store &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(store) &lt;&lt; <span class="string">&quot; sales: &quot;</span>&lt;&lt; <span class="built_in">accumualte</span>(<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(store),<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(store),<span class="built_in">Sales_data</span>(s))&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="172-bitset类型"><a class="markdownIt-Anchor" href="#172-bitset类型"></a> 17.2 bitset类型</h2>
<ul>
<li>bitset类,可以使位运算更加容易,且能处理超过最长整数类型大小的位集合
<ul>
<li>定义在bitset头文件中</li>
</ul>
</li>
</ul>
<h3 id="1721-定义和初始化bitset"><a class="markdownIt-Anchor" href="#1721-定义和初始化bitset"></a> 17.2.1 定义和初始化bitset</h3>
<table>
<thead>
<tr>
<th>初始化bitset的方法</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>bitset&lt;n&gt; b;</td>
<td>b有n位,每一位均为0,此构造函数时constexpr</td>
</tr>
<tr>
<td>bitset&lt;n&gt; b(u);</td>
<td>b有unsigned long long值u的低n位的拷贝</td>
</tr>
<tr>
<td>bitset&lt;n&gt; b(s,pos,m,zero,one);</td>
<td>b是string s从pos开始m个字符的拷贝;s只能包含字符zero或one</td>
</tr>
<tr>
<td>bitset&lt;n&gt; b(cp,pos,m,zero,one);</td>
<td>同上,cp指向字符数组中拷贝字符</td>
</tr>
<tr>
<td>-</td>
<td><strong>接受一个string或字符指针的构造函数时explicit</strong></td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsigned初始化</span></span><br><span class="line"><span class="function">bitset&lt;13&gt; <span class="title">bitvec1</span><span class="params">(oxbeef)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// string初始化</span></span><br><span class="line"><span class="function">bitset&lt;32&gt; <span class="title">bitvec2</span><span class="params">(<span class="string">&quot;1100&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string的子串进行初始化</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;111111110000000011001101&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">bitset&lt;32&gt; <span class="title">bitset5</span><span class="params">(str,<span class="number">5</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">bitset&lt;32&gt; <span class="title">bitset5</span><span class="params">(str,str.size()<span class="number">-4</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="1722-bitset操作"><a class="markdownIt-Anchor" href="#1722-bitset操作"></a> 17.2.2 bitset操作</h3>
<table>
<thead>
<tr>
<th>bitset操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>b.any()</td>
<td>b中是否含有置位的二进制位</td>
</tr>
<tr>
<td>b.all()</td>
<td>b中所有位都置位了吗</td>
</tr>
<tr>
<td>b.none()</td>
<td>b中不存在置位的二进制位吗</td>
</tr>
<tr>
<td>b.count()</td>
<td>b中置位的位数</td>
</tr>
<tr>
<td>b.size()</td>
<td>b中的位数,constexpr函数</td>
</tr>
<tr>
<td>b.test(pos)</td>
<td>判断pos位是否置位</td>
</tr>
<tr>
<td>b.set(pos,v)</td>
<td>将pos处的位设置位bool值v</td>
</tr>
<tr>
<td>b.set()</td>
<td>将b中所有位置位</td>
</tr>
<tr>
<td>b.reset(pos)</td>
<td>将位置pos处的位复位</td>
</tr>
<tr>
<td>b.reset()</td>
<td>将b中所有的位复位</td>
</tr>
<tr>
<td>b.flip(pos)</td>
<td>改变pos处的位状态</td>
</tr>
<tr>
<td>b.flip()</td>
<td>改变每一位的状态</td>
</tr>
<tr>
<td>b[pos]</td>
<td>访问b中位置pos处的位</td>
</tr>
<tr>
<td>b.to_ulong()</td>
<td>返回一个unsigned long或unsigned long long值,其位模式与b相同</td>
</tr>
<tr>
<td>b.to_ullong()</td>
<td>返回一个unsigned long或unsigned long long值,其位模式与b相同</td>
</tr>
<tr>
<td>b.to_string(zero,one)</td>
<td>返回一个string,表示b中的位模式,zero和one的默认值分为0和1表示b中的0和1</td>
</tr>
<tr>
<td>os &lt;&lt; b</td>
<td>将b中二进制位打印为字符1或0,打印到流os</td>
</tr>
<tr>
<td>is &gt;&gt; b</td>
<td>从is读取字符并存入b</td>
</tr>
</tbody>
</table>
</div><div class="story post-story"><h2 id="174-正则表达式"><a class="markdownIt-Anchor" href="#174-正则表达式"></a> 17.4 正则表达式</h2>
<ul>
<li>是一种描述字符序列的方法,是一种强大的计算工具</li>
<li>使用C++正则表达式库(RE库),<strong>定义在头文件regex中,包含多个组件</strong></li>
</ul>
<table>
<thead>
<tr>
<th>正则表达式库组件</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>regex</td>
<td>表示有一个正则表达式的类</td>
</tr>
<tr>
<td>regex_match</td>
<td>将一个字符序列与一个正则表达式匹配</td>
</tr>
<tr>
<td>regex_search</td>
<td>寻找第一个与正则表达式匹配的子序列</td>
</tr>
<tr>
<td>regex_replace</td>
<td>使用给定格式替换一个正则表达式</td>
</tr>
<tr>
<td>sregex_iterator</td>
<td>迭代器适配器,使用regex_search遍历一个string中所有匹配的子串</td>
</tr>
<tr>
<td>smatch</td>
<td>容器类,保存在string中的搜索结果</td>
</tr>
<tr>
<td>ssub_match</td>
<td>string中匹配的子串表达式的结果</td>
</tr>
</tbody>
</table>
<ul>
<li>regex类表示一个正则表达式
<ul>
<li>函数regex_match和regexsearch确定了一个给定字符序列与一个给定regex是否匹配</li>
<li>regex_search和regex_match的参数
<ul>
<li>(seq,m,r,mft) /(seq,r,mft)</li>
<li>在字符序列seq中查找regex对象r中的正则表达式,seq可以是一个string,表示范围的一对迭代器以及一个指向空字符结尾的字符数组的指针,m是一个match对象,用来报讯匹配结果的相关细节,m和seq必须具有兼容的类型</li>
<li>mft是一个可选的regex_constants::match_flag_type值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1731-使用正则表达式库"><a class="markdownIt-Anchor" href="#1731-使用正则表达式库"></a> 17.3.1 使用正则表达式库</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找拼写规则,i除非在c之后,否则必须在e之前</span></span><br><span class="line"><span class="comment">// 查找不在字符c之后的字符串ei</span></span><br><span class="line"><span class="function">string <span class="title">pattern</span><span class="params">(<span class="string">&quot;[^c]ei&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 包含pattern的整个单词</span></span><br><span class="line">pattern = <span class="string">&quot;[[:alpha:]]*&quot;</span> + pattern + <span class="string">&quot;[[:alpha:]]*&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(pattern)</span></span>;   <span class="comment">//构造一个用于查找模式的regex</span></span><br><span class="line">smatch result;      <span class="comment">//定义一个对象保存搜索结果</span></span><br><span class="line"><span class="comment">// 定义一个string保存与模式匹配和不匹配的文本</span></span><br><span class="line">string test_str = <span class="string">&quot;receipt friend theif receive&quot;</span>;</span><br><span class="line"><span class="comment">// 用r在test_str中查找与pattern匹配的子串</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">regex_search</span>(test_str,result,r))</span><br><span class="line">  cout &lt;&lt; result.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>regex(和wregex)选项</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>regex r(re)</td>
<td>re时一个正则表达式</td>
</tr>
<tr>
<td>regex r(re,f)</td>
<td>re时一个正则表达式,f是指出对象如何处理的标志</td>
</tr>
<tr>
<td>r1 = re</td>
<td>将r1中的正则表达式替换成re</td>
</tr>
<tr>
<td>r1.assign(re,f)</td>
<td>与=效果相同</td>
</tr>
<tr>
<td>r1.mark_count()</td>
<td>r中子表达式的数目</td>
</tr>
<tr>
<td>r1.flags()</td>
<td>返回r的标志集</td>
</tr>
<tr>
<td><strong>定义regex时指定的标志</strong></td>
<td>定义在regex和regex_constans::syntax_option_type中</td>
</tr>
<tr>
<td>icase</td>
<td>在匹配过程中忽略大小写</td>
</tr>
<tr>
<td>nosubs</td>
<td>不保存匹配的子表达式</td>
</tr>
<tr>
<td>optimize</td>
<td>执行速度有限</td>
</tr>
<tr>
<td>ECMAScript</td>
<td>使用ECMAScipt指定的语法</td>
</tr>
<tr>
<td>basic</td>
<td>使用POSIX基本的正则表达式语法</td>
</tr>
<tr>
<td>extened</td>
<td>使用POSIX扩展的正则表达式语法</td>
</tr>
<tr>
<td>awk</td>
<td>使用POSIX版本的awk正则表达式语法</td>
</tr>
<tr>
<td>grep</td>
<td>使用POSIX版本的grep正则表达式语法</td>
</tr>
<tr>
<td>egrep</td>
<td>使用POSIX版本的egrep正则表达式语法</td>
</tr>
</tbody>
</table>
<ul>
<li>指定或使用正则表达式时的错误
<ul>
<li>正则表达式是在运行时,当一个regex对象被初始化或被赋予了一个新模式时,才会被编译</li>
<li><mark>正则表达式在运行时解析是否正确</mark></li>
<li>错误时,抛出regex_error的异常,what操作描述什么错误,code成员返回错误类型对应的数值编码</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>正则表达式库类</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>输入类型</strong></td>
<td><strong>使用正则表达式类</strong></td>
</tr>
<tr>
<td>string</td>
<td>regex,smatch,ssub_match和sregex_iterator</td>
</tr>
<tr>
<td>const char*</td>
<td>regex,cmatch,csub_match和cregex_iterator</td>
</tr>
<tr>
<td>wstring</td>
<td>wregex,wsmatch,wssub_match和wsregex_iterator</td>
</tr>
<tr>
<td>const wchar_t*</td>
<td>wregex,wcmatch,wcsub_match和wcregex_iterator</td>
</tr>
</tbody>
</table>
<h3 id="1732-匹配与regex迭代器类型"><a class="markdownIt-Anchor" href="#1732-匹配与regex迭代器类型"></a> 17.3.2 匹配与Regex迭代器类型</h3>
<table>
<thead>
<tr>
<th>sregex_iterator操作</th>
<th>同样适用cregex_iterator,wsregex_iterator,wcregex_iterator</th>
</tr>
</thead>
<tbody>
<tr>
<td>sregex_iterator</td>
<td>一个sregex_iterator,遍历迭代器b和e表示的string</td>
</tr>
<tr>
<td>it(b,e,r)</td>
<td>调用sregex_search(b,e,r)将it定位到输入中第一个匹配的位置</td>
</tr>
<tr>
<td>sregex_iterator end;</td>
<td>尾后迭代器</td>
</tr>
<tr>
<td>*it</td>
<td>返回一个smatch的对象的引用或指向stmatch对象的指针</td>
</tr>
<tr>
<td>it-&gt;</td>
<td>返回一个smatch的对象的引用或指向stmatch对象的指针</td>
</tr>
<tr>
<td>++it</td>
<td>前置返回递增后迭代器</td>
</tr>
<tr>
<td>it++</td>
<td>后置返回旧值</td>
</tr>
<tr>
<td>it1==it2</td>
<td>相等比较</td>
</tr>
<tr>
<td>it1!=it2</td>
<td>相等比较</td>
</tr>
</tbody>
</table>
<ul>
<li>当将一个sregex_iterator绑定到一个string和一个regex对象时,迭代器自动定位到给定string中第一个匹配位置
<ul>
<li>即,sregex_iterator构造函数对给定string和regex调用regex_search</li>
</ul>
</li>
<li>当解引用迭代器时,会得到一个对应最近一次搜索结果的smatch对象</li>
<li>当递增迭代器时,它调用regex_search在输入string中查找下一个匹配</li>
</ul>
<table>
<thead>
<tr>
<th>smatch操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.ready()</td>
<td>若已经通过调用regex_search或regex_match设置了m,则返回true</td>
</tr>
<tr>
<td>m.size()</td>
<td>匹配失败返回0,否则返回最近一次匹配的正则表达式中子表达式的数目</td>
</tr>
<tr>
<td>m.empty()</td>
<td>若m.size()为0,返回true</td>
</tr>
<tr>
<td>m.prefix()</td>
<td>ssub_match对象,表示当前匹配之前的序列</td>
</tr>
<tr>
<td>m.suffix()</td>
<td>ssub_match对象,表示当前匹配之后的序列</td>
</tr>
<tr>
<td>m.format()</td>
<td>-</td>
</tr>
<tr>
<td>m.length(n)</td>
<td>第n个匹配的子表达式的大小</td>
</tr>
<tr>
<td>m.position(n)</td>
<td>第n个子表达式距离序列开始的距离</td>
</tr>
<tr>
<td>m.str(n)</td>
<td>第n个子表达式匹配的string</td>
</tr>
<tr>
<td>m[n]</td>
<td>对应第n个子表达式的ssub_match地想</td>
</tr>
<tr>
<td>m.begin(),m.end()</td>
<td>迭代器</td>
</tr>
<tr>
<td>m.cbegin(),m.cend()</td>
<td>迭代器</td>
</tr>
</tbody>
</table>
<h3 id="1733-使用子表达式"><a class="markdownIt-Anchor" href="#1733-使用子表达式"></a> 17.3.3 使用子表达式</h3>
<ul>
<li>正则表达式中的模式通常包含一个或多个子表达式
<ul>
<li>一个子表达式是模式的一部分,本身也具有意义。正则表达式语法通常用括号表示子表达式</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电话号码匹配</span></span><br><span class="line">string phone = <span class="string">&quot;(\\()?(\\d&#123;3&#125;)(\\))?([-.])?(\\d&#123;3&#125;)([-.]?)(\\d&#123;4&#125;)&quot;</span>;</span><br><span class="line"><span class="comment">// 逐个剥离(括号包围的)子表达式：1.(\\()？表示区号部分可选的左括号;2.(\\d&#123;3&#125;)表示区号;3.(\\))？表示区号部分可选的右括号;4.([-.])？表示区号部分可选的分隔符;5.(\\d&#123;3&#125;)表示号码的下三位数字;6.([-.])？表示可选的分隔符;7.(\\d&#123;4&#125;)表示号码的最后四位数字</span></span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(phone)</span></span>;</span><br><span class="line">smatch m;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin,s))&#123;</span><br><span class="line">  <span class="keyword">for</span>(sregex_iterator <span class="built_in">it</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),r),end_it;it!end_it;++it)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">valid</span>(*it))</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;valid: &quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;not valid: &quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pattern有七个子表达式,每个smatch对象会包含八个ssub_match元素。位置[0]的元素表示整个匹配;元素[1]…[7]表示每个对应的子表达式</span></span><br><span class="line"><span class="comment">// 已经有一个完整的匹配,但不知道每个可选的子表达式是否是匹配的一部分</span></span><br><span class="line"><span class="comment">// 如果一个子表达式是完整匹配的一部分,则其对应的ssub_match对象的matched成员为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个合法的电话号码中,区号要么是完整括号包围的,要么完全没有括号。因此,valid要做什么工作依赖于号码是否以一个括号开始</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">const</span> smatch&amp; m)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 如果区号前有一个左括号</span></span><br><span class="line">  <span class="keyword">if</span>(m[<span class="number">1</span>].matched)</span><br><span class="line">    <span class="comment">// 则区号后必须有一个右括号,之后紧跟剩余号码或一个空格</span></span><br><span class="line">    <span class="keyword">return</span> m[<span class="number">3</span>].matched &amp;&amp; (m[<span class="number">4</span>].matched == <span class="number">0</span> || m[<span class="number">4</span>].<span class="built_in">str</span>() == <span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> !m[<span class="number">3</span>].matched &amp;&amp; m[<span class="number">4</span>].<span class="built_in">str</span>() == m[<span class="number">6</span>].<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1734-使用regex_replace"><a class="markdownIt-Anchor" href="#1734-使用regex_replace"></a> 17.3.4 使用regex_replace</h3>
<ul>
<li>希望在输入序列中查找并替换一个正则表达式时,使用regex_replace
<ul>
<li>接受一个输入序列,一个regex对象,和一个输出形式的字符串</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>正则表达式替换操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.format(dest,fmt,mft)</td>
<td>使用格式字符串 fmt 生成格式化输出,匹配在m中,可选的match_flag_type标志在mft中.第一个版本写入迭代器dest指向的目的位置并接受fmt参数,可以是string,也可以是表示字符数组中范围的一对指针</td>
</tr>
<tr>
<td>m.format(fmt,mft)</td>
<td>第二个版本返回string,保存输出,并接受fmt参数,可以是 一个string, 也可以是指向空字符结尾的字符数组的指针.mft的默认值为format_default</td>
</tr>
<tr>
<td>regex_replace(dest,seq,r,fmt,mft)</td>
<td>遍历seq,用regex_search查找与regex对象r匹配的子串</td>
</tr>
<tr>
<td>regex_replace(seq,r,fmt,mft)</td>
<td>遍历seq,用regex_search查找与regex对象r匹配的子串</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>匹配标志</th>
<th>定义在regex_constans::match_flag_type中</th>
</tr>
</thead>
<tbody>
<tr>
<td>match_default</td>
<td>等价于format_default</td>
</tr>
<tr>
<td>match_not_bol</td>
<td>不将首字符作为行首处理</td>
</tr>
<tr>
<td>match_not_eol</td>
<td>不将尾字符作为行首处理</td>
</tr>
<tr>
<td>match_not_bow</td>
<td>不将首字符作为单词首处理</td>
</tr>
<tr>
<td>match_not_eow</td>
<td>不将尾字符作为单词首处理</td>
</tr>
<tr>
<td>match_any</td>
<td>如果存在对于一个匹配,则可以返回任意一个匹配</td>
</tr>
<tr>
<td>match_not_null</td>
<td>不匹配任何空字符</td>
</tr>
<tr>
<td>match_continuous</td>
<td>匹配必须从输入的首字符开始</td>
</tr>
<tr>
<td>match_prev_avail</td>
<td>输入序列包含第一个匹配之前的内容</td>
</tr>
<tr>
<td>format_default</td>
<td>用ECMAScript规则替换字符串</td>
</tr>
<tr>
<td>format_sed</td>
<td>用POSIX sed规则替换字符串</td>
</tr>
<tr>
<td>format_no_copy</td>
<td>不输出输入序列中未匹配的部分</td>
</tr>
<tr>
<td>format_first_only</td>
<td>只替换子表达式的第一次出现</td>
</tr>
</tbody>
</table>
</div><div class="story post-story"><h2 id="174-随机数"><a class="markdownIt-Anchor" href="#174-随机数"></a> 17.4 随机数</h2>
<ul>
<li>头文件random中的随机数库通过一组协作式的类来解决随机数的范围,类型或分布问题
<ul>
<li>引入随机数引擎类和随机数分布类</li>
<li>一个引擎类可以生成unsigned随机数序列,一个分布类使用一个引擎类生成指定类型的在给定范围内的服从特定概率分布的随机数</li>
<li>C++中应该使用default_random_engine类和恰当的分布类对象</li>
</ul>
</li>
</ul>
<h3 id="1741-随机数引擎和分布"><a class="markdownIt-Anchor" href="#1741-随机数引擎和分布"></a> 17.4.1 随机数引擎和分布</h3>
<ul>
<li>随机数引擎时函数对象类,定义了一个调用运算符,不接受参数返回一个随机unsigned整数</li>
<li>每次程序运行都会生成不同的随机结果,可以通过<strong>种子</strong>来实现
<ul>
<li>种子时一个数值,引擎可以利用它从序列中一个新位置重新开始生成随机数</li>
<li>创建种子的两种方式
<ul>
<li>在创建引擎对象时提供种子</li>
<li>调用引擎的seed成员</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>随机数引擎操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>Engine e</td>
<td>默认构造函数,使用该引擎类型默认的种子</td>
</tr>
<tr>
<td>Engine e(s);</td>
<td>使用整数值s作为种子</td>
</tr>
<tr>
<td>e.seed(s);</td>
<td>使用种子s重置引擎的状态</td>
</tr>
<tr>
<td>e.min();</td>
<td>引擎可生成的最小值</td>
</tr>
<tr>
<td>e.max();</td>
<td>引擎可生成的最大值</td>
</tr>
<tr>
<td>Engine::result_type</td>
<td>此引擎生成的unsigned整数类型</td>
</tr>
<tr>
<td>e.discard(u)</td>
<td>此引擎推进u步;u的类型尾unsigned long long</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;  <span class="comment">//生成随机无符号数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">  cout &lt;&lt; <span class="built_in">e</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成0到9之间均匀分布的随机数</span></span><br><span class="line"><span class="function">uniform_int_distribution&lt;<span class="type">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">default_random_engine e;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i&gt;)</span><br><span class="line">  cout &lt;&lt; <span class="built_in">u</span>(e) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">default_random_engine e1; <span class="comment">//默认种子</span></span><br><span class="line"><span class="function">default_random_engine <span class="title">e2</span><span class="params">(<span class="number">2147483646</span>)</span></span>; <span class="comment">//使用给定的种子</span></span><br><span class="line"><span class="comment">// e3和e4将生成相同的序列,使用相同的种子</span></span><br><span class="line">default_random_engine e3;</span><br><span class="line">e3.<span class="built_in">seed</span>(<span class="number">32767</span>);</span><br><span class="line"><span class="function">default_random_engine <span class="title">e4</span><span class="params">(<span class="number">32767</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i!=<span class="number">100</span>;++i)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">e1</span>() == e2)</span><br><span class="line">    cout &lt;&lt; i&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">e3</span>() == e4)</span><br><span class="line">    cout &lt;&lt; i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1742-其他随机数分布"><a class="markdownIt-Anchor" href="#1742-其他随机数分布"></a> 17.4.2 其他随机数分布</h3>
<table>
<thead>
<tr>
<th>分布类型的操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dist d</td>
<td>默认构造函数,分布类型的构造函数时explicit</td>
</tr>
<tr>
<td>d(e)</td>
<td>使用相同的e连续调用d扽话,会根据d的分布式类型生成一个随机数序列;e随机数引擎对象</td>
</tr>
<tr>
<td>d.min()</td>
<td>最小值</td>
</tr>
<tr>
<td>d.max()</td>
<td>最大值</td>
</tr>
<tr>
<td>d.reset()</td>
<td>重建d的状态</td>
</tr>
</tbody>
</table>
<ul>
<li>一个分布不接受模板参数,即bernoulli_distribution,因为它是一个普通类,而非模板
<ul>
<li>此分布总是返回一个bool值。它返回true的概率是一个常数,此概率的默认值是0.5</li>
</ul>
</li>
<li>由于引擎返回相同的随机数序列,所以必须在循环外声明引擎对象
<ul>
<li>否则,每步循环都会创建一个新引擎,从而每步循环都会生成相同的值</li>
<li><mark>类似的,分布对象也要保持状态,因此也应该在循环外定义</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义0-1的随机均匀分布</span></span><br><span class="line"><span class="function">uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="175-io库再探"><a class="markdownIt-Anchor" href="#175-io库再探"></a> 17.5 IO库再探</h2>
<h3 id="1751-格式化输入与输出"><a class="markdownIt-Anchor" href="#1751-格式化输入与输出"></a> 17.5.1 格式化输入与输出</h3>
<ul>
<li>格式状态控制格式化的某些方面,如整数值是几进制,浮点值得精度,一个输出元素的宽度</li>
<li>操纵符来修改流的格式状态
<ul>
<li>一个操纵符是一个函数或是一个对象,会影响流的状态,并能用作输入或输出运算符的运算对象</li>
</ul>
</li>
<li><mark>当操纵符改变流的格式状态时,通常改变后的状态对所有后续IO都生效</mark></li>
<li><strong>改变布尔值的格式</strong>
<ul>
<li>boolalpha操纵符覆盖格式,输出true和false</li>
<li>noboolalpha取消cout格式状态的改变</li>
</ul>
</li>
<li><strong>指定整数值的进制</strong>
<ul>
<li>使用hex,oct和dec将其改成十六进制,八进制或十进制输出</li>
<li>浮点数不受影响</li>
</ul>
</li>
<li><strong>在输出中指出进制</strong>
<ul>
<li>需要打印八进制或十六进制,使用<strong>showbase操纵符</strong>,遵循与整数常量中指定进制相同的规范</li>
<li>使用noshowbase恢复,不再显示整数值的进制</li>
</ul>
</li>
<li><strong>控制浮点数格式</strong>
<ul>
<li>三种格式：
<ul>
<li>以多高精度(多少个数字)打印浮点值</li>
<li>数值是打印为十六进制、定点十进制还是科学记数法形式</li>
<li>对于没有小数部分的浮点值是否打印小数点</li>
</ul>
</li>
<li>默认情况下是六位数精度打印,</li>
</ul>
</li>
<li><strong>指定打印精度</strong>
<ul>
<li>可<strong>调用IO对象的precision成员</strong>或<strong>使用setprecision操纵符改变精度</strong>
<ul>
<li><mark>定义在iomanip中</mark></li>
<li>precision成员是重载的,接受一个int值将其设为精度,并返回旧精度,不接受参数返回当前精度值</li>
<li>setprecision接受一个参数,用来设置精度</li>
</ul>
</li>
</ul>
</li>
<li><strong>指定浮点数计数法</strong>
<ul>
<li>scientific改变流的状态使用科学计数法</li>
<li>fixed改变流的状态使用定点十进制</li>
<li>新标准库中的函数
<ul>
<li>hexfloat强制浮点数使用十六进制</li>
<li>defaultfloat恢复至默认状态</li>
</ul>
</li>
<li>精度值控制的是小数点后的数字位数,默认情况下控制的是数字总位数</li>
</ul>
</li>
<li><strong>打印小数点</strong>
<ul>
<li>showpoint操纵符强制打印小数点</li>
<li>noshowpoint恢复默认行为</li>
</ul>
</li>
<li><strong>输出补白</strong>
<ul>
<li>setw 指定下一个数字或字符串值得最小空间</li>
<li>left 表示左对齐输出</li>
<li>right 表示右对齐输出(默认格式</li>
<li>internal 控制负号符号得位置</li>
<li>setfill 允许指定一个字符代替默认的空格来补白输出</li>
</ul>
</li>
<li>定义在iomanip中的操纵符
<ul>
<li>setfill(ch) 用ch填充空白</li>
<li>setprecision(n) 将浮点精度设置为n</li>
<li>setw(w) 读或写值得宽度为w个字符</li>
<li>setbase(b) 将整数输出为b进制</li>
</ul>
</li>
<li>控制输入格式
<ul>
<li>noskipws 输入序列读取空白符,而不是跳过</li>
<li>skipws 恢复</li>
</ul>
</li>
</ul>
<h3 id="1752-未格式化的输入输出操作"><a class="markdownIt-Anchor" href="#1752-未格式化的输入输出操作"></a> 17.5.2 未格式化的输入/输出操作</h3>
<ul>
<li>低层操作,支持未格式化IO,允许将流仿作一个无解释的字节序列处理</li>
<li>三种方法退回字符,有着细微的差别：
<ul>
<li>peek返回输入流中下一个字符的副本,但不会将它从流中删除,peek返回的值仍然留在流中</li>
<li>unget使得输入流向后移动,从而最后读取的值又回到流中。即使不知道最后从流中读取什么值,仍然可以调用unget</li>
<li>putback是更特殊版本的unget：它退回从流中读取的最后一个值,但它接受一个参数,此参数必须与最后读取的值相同</li>
</ul>
</li>
<li>函数peek和无参的get版本都以int类型从输入流返回一个字符
<ul>
<li>函数返回一个int的原因是：可以返回文件尾标记,使用char范围中的每个值来表示一个真实字符,因此,取值范围中没有额外的值可以用来表示文件尾</li>
<li>返回int的函数将它们要返回的字符先转换为unsigned char,然后再将结果提升到int。因此,即使字符集中有字符映射到负值,这些操作返回的int也是正值。而标准库使用负值表示文件尾可以保证与任何合法字符的值都不同</li>
<li>头文件cstdio定义了一个名为EOF的const,可以用它来检测从get返回的值是否是文件尾,而不必记忆表示文件尾的实际数值</li>
</ul>
</li>
<li><mark>get将分隔符留作istream中的下一个字符,而getline则读取并丢弃分隔符</mark>
<ul>
<li>无论哪个函数都不会将分隔符保存在sink中</li>
</ul>
</li>
<li><strong>确定读取了多少个字符</strong>
<ul>
<li>某些操作从输入读取未知个数的字节。可以调用gcount来确定最后一个未格式化输入操作读取了多少个字符。应该在任何后续未格式化输入操作之前调用gcount</li>
<li>特别是,将字符退回流的单字符操作也属于未格式化输入操作。如果在调用gcount之前调用了peek、unget或putback,则gcount的返回值为0</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>单字节低层IO操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>is.get(ch)</td>
<td>从istream is读取下一个字节存入字符ch中返回is</td>
</tr>
<tr>
<td>os.put(ch)</td>
<td>将字符ch输出到ostream os,返回os</td>
</tr>
<tr>
<td>is.get()</td>
<td>将is的下一个字节作为int返回</td>
</tr>
<tr>
<td>is.putback(ch)</td>
<td>将字符ch放回is,返回is</td>
</tr>
<tr>
<td>is.unget()</td>
<td>将is向后移动一个字节,返回is</td>
</tr>
<tr>
<td>is.peek()</td>
<td>将下一个字节作为int返回,但不从流中删除</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>多字节低层IO操作</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>is.get(sink,size,delim)</td>
<td>从is中读取最多size个字节,保存在起始地址为sink的字符数组中,若读取到字符delim或读取了size个字节或文件尾时停止,若遇到了delim,则将其留在输入流中,不读取出来存入sink</td>
</tr>
<tr>
<td>is.getline(sink,size,delim)</td>
<td>与get相似,但会读取并舍弃delim</td>
</tr>
<tr>
<td>is.read(sink,size)</td>
<td>读取最多size个字节,存入字符数组sink中,返回is</td>
</tr>
<tr>
<td>is.gcount()</td>
<td>返回上一个未格式化读取操作从is读取的字节数</td>
</tr>
<tr>
<td>os.write(source, size)</td>
<td>将字符数组source中size个字节写入os,返回os</td>
</tr>
<tr>
<td>is.ignore(size, delim)</td>
<td>读取并忽略最多size个字符,包括delim</td>
</tr>
</tbody>
</table>
<h3 id="1753-流随机访问"><a class="markdownIt-Anchor" href="#1753-流随机访问"></a> 17.5.3 流随机访问</h3>
<ul>
<li>为了支持随机访问,提供了两个函数,一个函数通过将标记seek到一个给定位置来重定位它;另一个函数tell我们标记的当前位置</li>
<li>从逻辑上讲,只能对istream和派生自istream的类型ifstream和istringstream使用g版本,同样只能对ostream和派生自ostream的类型ofstream和ostringstream使用p版本;一个iostream、fstream或stringstream既能读又能写关联的流,因此对这些类型的对象既能使用g版本又能使用p版本</li>
<li><mark>由于只有单一的标记,因此只要在读写操作间切换,就必须进行seek操作来重定位标记</mark></li>
</ul>
<table>
<thead>
<tr>
<th><strong>seek和tell函数</strong></th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>tellg()</td>
<td>返回一个输入流标记的当前位置</td>
</tr>
<tr>
<td>tellp()</td>
<td>返回一个输出流标记的当前位置</td>
</tr>
<tr>
<td>seekg(pos)</td>
<td>在输入流将标记重新定位到给定的绝对位置,pos通常是前一个tellg或tellp返回的值</td>
</tr>
<tr>
<td>seekp(pos)</td>
<td>在输出流将标记重新定位到给定的绝对位置,pos通常是前一个tellg或tellp返回的值</td>
</tr>
<tr>
<td>seekg(off, from)</td>
<td>在一个输入流中将标记当味道from之前或之后off个字符</td>
</tr>
<tr>
<td>seekp(off, from)</td>
<td>在一个输出流中将标记当味道from之前或之后off个字符</td>
</tr>
</tbody>
</table>
<h1 id="18-用于大型程序的工具"><a class="markdownIt-Anchor" href="#18-用于大型程序的工具"></a> 18 用于大型程序的工具</h1>
</div><div class="story post-story"><h2 id="181-异常处理"><a class="markdownIt-Anchor" href="#181-异常处理"></a> 18.1 异常处理</h2>
<h3 id="1811-抛出异常"><a class="markdownIt-Anchor" href="#1811-抛出异常"></a> 18.1.1 抛出异常</h3>
<ul>
<li>C++语言中，通过<strong>抛出</strong>一条表达式来<strong>引发</strong>一个异常
<ul>
<li>被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码被用来处理该异常</li>
<li>被选中的处理代码是在调用链中与对象类型匹配的最近的处理代码</li>
</ul>
</li>
<li><strong>栈展开</strong>
<ul>
<li>栈展开过程：
<ul>
<li>当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句。当throw出现在一个try语句块内时，检查与该try块关联的catch子句</li>
<li>如果找到了匹配的catch，就使用该catch处理异常</li>
<li>如果这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句</li>
<li>如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找</li>
</ul>
</li>
<li>栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch子句为止；或者没有皮皮额的catch语句，程序调用标准库函数terminate，终止程序执行</li>
</ul>
</li>
<li><strong>栈展开过程中对象被自动销毁</strong>
<ul>
<li>在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正常地销毁</li>
<li>如果异常发生在构造函数中，则需要确保已构造地成员能被正常地销毁</li>
</ul>
</li>
<li><strong>析构函数与异常</strong>
<ul>
<li>若使用类来控制资源地分配，就能确保无论函数正常结束还是异常时，资源都能被正确释放</li>
<li>析构函数不应该抛出自身不能处理地异常
<ul>
<li>析构函数需要执行某个可能抛出异常地操作，则操作应该被放置在一个try语句块中，并且在析构函数内部得到处理</li>
</ul>
</li>
<li>在栈展开的过程中，运行类类型的局部对象的析构函数
<ul>
<li>析构函数自动执行，不应该抛出异常。一旦析构函数抛出异常，且析构函数自身没能捕捉到该异常，则程序将被终止</li>
</ul>
</li>
</ul>
</li>
<li>异常对象
<ul>
<li>异常对象位于编译器管理的空间中，当异常处理完毕后，异常对象被销毁</li>
<li>抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型
<ul>
<li><mark>如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1812-捕获异常"><a class="markdownIt-Anchor" href="#1812-捕获异常"></a> 18.1.2 捕获异常</h3>
<ul>
<li>当进入一个catch语句之后，通过异常对象初始化异常声明中的参数，通过异常初始化异常声明中的参数
<ul>
<li>和函数的参数类似，若catch的参数类型是非引用类型，则该参数是异常对象的一个副本，在catch语句内改变该参数实际上改变的是局部副本而非异常对象本身</li>
<li>如果catch的参数是基类类型，可以使用其派生类类型的异常对象对其进行初始化
<ul>
<li>若catch的参数是非引用，则异常对象将被且一部分</li>
</ul>
</li>
<li><mark>异常声明的静态类型将决定catch语句所能执行的操作，若catch的参数是基类类型，则catch无法使用派生类特有的任何成员</mark></li>
</ul>
</li>
<li><strong>查找匹配的处理代码</strong>
<ul>
<li>搜寻catch语句时，找到的catch语句是第一个异常匹配的语句</li>
<li>当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，使得派生类异常的处理代码出现在基类异常的处理代码之前</li>
<li>在匹配时允许的转换
<ul>
<li>允许从非常量向常量的类型转换，也就是说，一条非常量对象的throw语句可以匹配一个接受常量引用的catch语句</li>
<li>允许从派生类向基类的类型转换</li>
<li>数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针</li>
</ul>
</li>
<li><mark>应该把继承链最底层的类放在前面，而将继承链最顶端的类放在后面</mark></li>
</ul>
</li>
<li><strong>重新抛出</strong>
<ul>
<li>一条catch语句通过重新抛出的操作将异常传递给另一个catch语句</li>
<li>重新抛出使用throw语句，但不包含任何表达式
<ul>
<li>一个重新抛出语句并不指定新的表达式，而是将当前异常对象沿调用链向上传递</li>
</ul>
</li>
</ul>
</li>
<li>捕获所有异常的处理代码
<ul>
<li>一次性捕获所有异常，使用省略号作为异常声明，这样的处理代码称为捕获所有异常的代码(catch…)</li>
<li>一条捕获所有异常的语句可以与任意类型的异常匹配</li>
<li>如果catch(…)与其他几个catch语句一起出现，则catch(…)必须在最后的位置
<ul>
<li><mark>出现在捕获所有异常语句后面的catch语句将永远不会被匹配</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mainp</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="built_in">catch</span>(...)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的某些特殊操作</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1813-函数try语句块与构造函数"><a class="markdownIt-Anchor" href="#1813-函数try语句块与构造函数"></a> 18.1.3 函数try语句块与构造函数</h3>
<ul>
<li>构造函数在进入其函数体之前首先初始化列表，在初始化列表抛出异常时构造函数体内的try语句块未生效
<ul>
<li>构造函数体内的catch语句无法处理构造函数初始化列表抛出的异常</li>
<li><strong>将构造函数写成函数try语句块</strong>
<ul>
<li>函数try语句块使得一组catch语句既能处理构造函数体，也能处理构造函数的初始化过程</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il) <span class="keyword">try</span>:</span><br><span class="line">      <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt; il)&#123;</span><br><span class="line">        <span class="comment">//空函数体</span></span><br><span class="line">      &#125;<span class="built_in">catch</span>(<span class="type">const</span> std::bad_alloc &amp;e) &#123;<span class="built_in">handle_out_of_memory</span>(e);&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1814-noexcept异常说明"><a class="markdownIt-Anchor" href="#1814-noexcept异常说明"></a> 18.1.4 noexcept异常说明</h3>
<ul>
<li>通过提供noexcept说明指定某个函数不会抛出异常
<ul>
<li>关键字noexcept紧跟在函数的参数列表后面，表示函数不会抛出异常</li>
</ul>
</li>
<li><strong>违反异常说明</strong>
<ul>
<li>编译器并不会在编译时检查noexcept说明
<ul>
<li>实际上若一个函数说明了noexcept的同时又含有throw语句也能顺利编译</li>
</ul>
</li>
<li>noexcept可接受一个可选的实参，该实参必须转换成bool类型，若为true函数不会抛出异常</li>
</ul>
</li>
<li>noexcept运算符
<ul>
<li>noexcept运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常</li>
<li>不会对其运算对象求值</li>
</ul>
</li>
<li><strong>异常说明与指针，虚函数和拷贝控制</strong>
<ul>
<li>函数指针及该指针所指的函数必须具有一致的异常说明</li>
<li>虚函数承诺了不会抛出异常，则派生的虚函数也必须不能抛出任何异常</li>
<li>若基类的虚函数允许抛出异常，则派生类的对应函数既可以抛出异常，也可以不允许抛出异常</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">noexcept</span>(<span class="built_in">recoup</span>(i));  <span class="comment">//若recoup不跑出异常结果为true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">noexcept</span>(e);</span><br><span class="line"><span class="comment">// 当e调用的所有函数都做了不抛出说明且e本身不含有throw语句时，表达式为true</span></span><br></pre></td></tr></table></figure>
<h3 id="1815-异常类层次"><a class="markdownIt-Anchor" href="#1815-异常类层次"></a> 18.1.5 异常类层次</h3>
<ul>
<li>exception
<ul>
<li>bad_cast</li>
<li>runtime_error
<ul>
<li>overflow_error</li>
<li>underflow_error</li>
<li>range_error</li>
</ul>
</li>
<li>logic_error
<ul>
<li>domain_error</li>
<li>invalid_argument</li>
<li>out_of_range</li>
<li>length_error</li>
</ul>
</li>
<li>bad_alloc</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="182-命名空间"><a class="markdownIt-Anchor" href="#182-命名空间"></a> 18.2 命名空间</h2>
<ul>
<li>命名空间为了防止名字冲突而提供了可控的机制，分割了全局命名空间，其中每个命名空间是一个作用域</li>
</ul>
<h3 id="1821-命名空间的定义"><a class="markdownIt-Anchor" href="#1821-命名空间的定义"></a> 18.2.1 命名空间的定义</h3>
<ul>
<li>命名空间的定义包含
<ul>
<li>首先是关键字namespace</li>
<li>随后是命名空间的名字</li>
<li>在命名空间后市一系列由花括号括起来的声明和定义</li>
<li><mark>命名空间后无需分号</mark></li>
</ul>
</li>
<li>每一个命名空间都是一个作用域
<ul>
<li>命名空间中每个名字必须表示该空间的唯一实体</li>
<li>定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问</li>
<li>位于命名空间之外的代码必须使用作用域说明符(::)指出所用的名字属于哪个命名空间</li>
</ul>
</li>
<li>命名空间的定义可以不连续的特性
<ul>
<li>使得可以将几个独立的接口和实现文件组成一个命名空间</li>
<li>命名空间的管理
<ul>
<li>命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中</li>
<li>命名空间成员的定义部分则置于另外的源文件中</li>
</ul>
</li>
</ul>
</li>
<li>定义命名空间成员
<ul>
<li><strong>命名空间之外定义的成员必须使用含有前缀的名字</strong></li>
</ul>
</li>
<li><strong>模板特例化</strong>
<ul>
<li>模板特例化必须定义在原始模板所属的空间</li>
<li><mark>只要在命名空间中声明了特例化，就能在命名空间外部定义</mark></li>
</ul>
</li>
<li>全局命名空间
<ul>
<li>全局命名空间为隐式的方式声明的，全局作用域中定义的名字被隐式地添加到全局命名空间中</li>
</ul>
</li>
<li>嵌套的命名空间：是定义在其他命名空间中的命名空间
<ul>
<li>调用时嵌套调用</li>
</ul>
</li>
<li>内联命名空间
<ul>
<li>内联命名空间中的名字可被外层命名空间直接使用</li>
<li><mark>无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它</mark></li>
<li><mark>关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间时可不写inline</mark></li>
<li>应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名空间</li>
</ul>
</li>
<li>未命名的命名空间
<ul>
<li>namespace后紧跟着花括号的一系列声明</li>
<li>未命名的命名空间中定义的变量拥有静态声明周期：再第一次使用前创建，并且直到程序结束才销毁</li>
<li><mark>未命名的命名空间不能跨越文件</mark></li>
<li><mark>未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同</mark>
<ul>
<li>如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别</li>
</ul>
</li>
<li><strong>未命名的命名空间可以嵌套在其他命名空间中，使用外层命名空间的名字来访问</strong></li>
</ul>
</li>
<li><strong>可使用未命名的命名空间代替文件中的静态声明</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_pimer&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;<span class="comment">//...&#125;;</span></span><br><span class="line">  Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data&amp;,<span class="type">const</span> Sales_data&amp;);</span><br><span class="line">  <span class="function"><span class="keyword">class</span> <span class="title">Query</span><span class="params">(<span class="comment">//...);</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">class</span> Query_base&#123;<span class="comment">//..&#125;</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// 声明模板特例化</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">namespace</span> std&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> hash&lt;Sales_data&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// 在std中添加了模板特例化声明后，就可以在命名空间的外部定义</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> std::hash&lt;Sales_data&gt;&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="1822-使用命名空间成员"><a class="markdownIt-Anchor" href="#1822-使用命名空间成员"></a> 18.2.2 使用命名空间成员</h3>
<ul>
<li>命名空间的别名以关键字nameapace开始，后接别名，=，命名空间原来的名字和分号</li>
<li><strong>using声明</strong>
<ul>
<li>有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止</li>
</ul>
</li>
<li>头文件与using声明
<ul>
<li>头文件如果在其顶层作用域中含有using指示或using声明，则会将名字注入到所有包含了该头文件的文件中</li>
</ul>
</li>
</ul>
<h3 id="1823-类命名空间与作用域"><a class="markdownIt-Anchor" href="#1823-类命名空间与作用域"></a> 18.2.3 类，命名空间与作用域</h3>
<ul>
<li>对命名空间内部名字的查找遵循常规的查找规则：即由内向外依次查找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止</li>
<li>查找与std::move和std::forward
<ul>
<li>通常情况下，如果在应用程序中定义了一个标准库中已有的名字，则将出现以下两种情况中的一种：要么根据一般的重载规则确定某次调用应该执行函数的哪个版本；要么应用程序根本就不会执行函数的标准库版本</li>
<li>在函数模板中，右值引用形参可以匹配任何类型。如果应用程序也定义了一个接受单一形参的move函数，则不管该形参是什么类型，应用程序的move函数都将与标准库的版本冲突。forward函数也是如此</li>
</ul>
</li>
<li>友元声明与实参相关的查找
<ul>
<li>当类声明了一个友元时，该友元声明并没有使得友元本身可见。然而，一个另外的未声明的类或函数如果第一次出现在友元声明中，则认为它是最近的外层命名空间的成员</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;     <span class="comment">//除非另有声明，否则不会被找到</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>; <span class="comment">//根据实参相关的查找规则可被找到</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A::C cobj;</span><br><span class="line">  <span class="built_in">f</span>(cobj);    <span class="comment">//通过再A::C中的友元声明找到</span></span><br><span class="line">  <span class="built_in">f2</span>(cobj);    <span class="comment">//错误，未声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为f接受一个类类型的实参，而且f在C所属的命名空间进行了隐式的声明，所以f能被找到。相反，因为f2没有形参，所以它无法被找到</span></span><br></pre></td></tr></table></figure>
<h3 id="1824-重载与命名空间"><a class="markdownIt-Anchor" href="#1824-重载与命名空间"></a> 18.2.4 重载与命名空间</h3>
<ul>
<li><strong>与实参相关的查找与重载</strong>
<ul>
<li>对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行</li>
<li>这条规则对于如何确定候选函数集同样也有影响：将在每个实参类（以及实参类的基类）所属的命名空间中搜寻候选函数；在这些命名空间中所有与被调用函数同名的函数都将被添加到候选集当中，即使其中某些函数在调用语句处不可见也是如此</li>
</ul>
</li>
<li><strong>重载与using声明</strong>
<ul>
<li>using声明语句声明的是一个名字，而非一个特定的函数</li>
<li>一个using声明囊括了重载函数的所有版本以确保不违反命名空间的接口。库的作者为某项任务提供了好几个不同的函数，允许用户选择性地忽略重载函数中的一部分但不是全部有可能导致意想不到的程序行为</li>
<li>一个using声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数
<ul>
<li>如果using声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明</li>
<li>如果using声明所在的作用域中已经有一个函数与新引入的函数同名且形参列表相同，则该using声明将引发错误</li>
<li>除此之外，using声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模</li>
</ul>
</li>
</ul>
</li>
<li>重载与using指示
<ul>
<li>using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中</li>
</ul>
</li>
<li>跨越多个using指示的重载
<ul>
<li>如果存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="183-多重继承与虚继承"><a class="markdownIt-Anchor" href="#183-多重继承与虚继承"></a> 18.3 多重继承与虚继承</h2>
<ul>
<li><strong>多重继承</strong>：从多个直接基类中产生派生类的能力
<ul>
<li>继承了所有父类的属性</li>
</ul>
</li>
</ul>
<h3 id="1831-多重继承"><a class="markdownIt-Anchor" href="#1831-多重继承"></a> 18.3.1 多重继承</h3>
<ul>
<li>在派生类的派生列表中可以包含多个基类
<ul>
<li>每个基类包含一个可选的说明符，若忽略，则class为private，struct为public</li>
<li>多继承的派生列表只能包含已经被定义过的类，而且类不能是final的</li>
<li>在某个给定的派生列表中，同一个基类只能出现一次</li>
</ul>
</li>
<li><strong>多重继承的派生类从每个基类中继承状态</strong></li>
<li><strong>派生类构造函数初始化所有基类</strong>
<ul>
<li>构造一个派生类对象将同时构造并初始化它的所有基类子对象</li>
<li>多重继承的派生类的构造函数初始值只能初始化它的直接基类</li>
</ul>
</li>
<li><strong>继承的构造函数与多重继承</strong>
<ul>
<li>允许派生类从一个或几个基类中继承构造函数，但从不能从多个基类继承相同的构造函数，需为这个类自定义构造函数</li>
</ul>
</li>
<li><strong>多重继承的派生类的拷贝与移动操作</strong>
<ul>
<li>多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作</li>
<li>只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作</li>
<li>在合成的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span>: <span class="keyword">public</span> ZooAnimal&#123;</span><br><span class="line">  lass Panda:<span class="keyword">public</span> Bear, <span class="keyword">public</span> Endangered&#123;<span class="comment">//....&#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1832-类型转换与多个基类"><a class="markdownIt-Anchor" href="#1832-类型转换与多个基类"></a> 18.3.2 类型转换与多个基类</h3>
<ul>
<li>可以使用可访问基类的指针或引用直接指向派生类的对象</li>
<li>基于指针类型或引用类型的查找
<ul>
<li>对象，指针和引用的静态类型决定了能使用哪些成员</li>
</ul>
</li>
</ul>
<h3 id="1833-多重继承下的类作用域"><a class="markdownIt-Anchor" href="#1833-多重继承下的类作用域"></a> 18.3.3 多重继承下的类作用域</h3>
<ul>
<li>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义</li>
</ul>
<h3 id="1834-虚继承"><a class="markdownIt-Anchor" href="#1834-虚继承"></a> 18.3.4 虚继承</h3>
<ul>
<li>实际上派生类可以多次继承同一类，派生类可以通过它的两个直接基类分别继承同一个简介积累，也可以直接继承某个基类，然后通过某一个基类再一次间接继承该类
<ul>
<li>在默认情况下，派生类中含有继承链上每个类对应的子部分</li>
<li><mark>如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象</mark></li>
</ul>
</li>
<li><strong>虚继承</strong>机制：令某个类做出声明，承诺愿意共享它的基类，其中共享的基类子对象称为虚基类
<ul>
<li>无论虚基类在继承体系中出现多少次，在派生类中都只含有唯一一个共享的虚基类</li>
<li>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，不影响派生类本身</li>
</ul>
</li>
<li><strong>使用虚基类</strong>
<ul>
<li>指定虚基类的方式是在派生列表中添加virtual</li>
<li>virtual说明符表示在后续的派生类当中共享虚基类的同一份实例</li>
</ul>
</li>
<li><strong>虚基类成员的可见性</strong>
<ul>
<li>在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字public和virtual的顺序随意</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Raccon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ZooAnimal</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个类指定了虚基类，该类的派生按常规方式进行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Panda</span>:<span class="keyword">public</span> Bear,<span class="keyword">public</span> Raccoon,<span class="keyword">public</span> Endangered&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Panda通过Raccoon和Bear继承了ZooAnimal，因为Raccoon和Bear继承ZooAnimal的方式都是虚继承，所以在Panda中只有一个ZooAnimal基类部分</span></span><br></pre></td></tr></table></figure>
<h3 id="1835-构造函数与虚继承"><a class="markdownIt-Anchor" href="#1835-构造函数与虚继承"></a> 18.3.5 构造函数与虚继承</h3>
<ul>
<li>在虚派生中，虚基类是最低层的派生类初始化的</li>
<li><strong>虚继承的对象的构造方式</strong>
<ul>
<li>含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化</li>
<li><mark>虚基类总是先于非虚基类的构造</mark></li>
</ul>
</li>
<li><strong>构造函数与析构函数的次序</strong>
<ul>
<li>一个类可以由多个虚基类，虚的子对象按照在派生列表中出现的顺序从左向右一次构造</li>
</ul>
</li>
</ul>
<h1 id="19-特殊工具与技术"><a class="markdownIt-Anchor" href="#19-特殊工具与技术"></a> 19 特殊工具与技术</h1>
</div><div class="story post-story"><h2 id="191-控制内存分配"><a class="markdownIt-Anchor" href="#191-控制内存分配"></a> 19.1 控制内存分配</h2>
<ul>
<li>重载new运算符和delete运算符控制内存分配的过程</li>
</ul>
<h3 id="1911-重载new和delete"><a class="markdownIt-Anchor" href="#1911-重载new和delete"></a> 19.1.1 重载new和delete</h3>
<ul>
<li>使用new表达式的实际操作
<ul>
<li>new盗用了operator new的标准库函数，分配一块足够大的原始的未命名的内存空间一遍存储特定类型的对象</li>
<li>编译器运行相应的构造函数构造这些对象，并传入初始值</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针</li>
</ul>
</li>
<li>使用delete的实际操作
<ul>
<li>对指向的对象或数组执行对象的析构函数</li>
<li>编译器调用operator delete的标准库函数释放内存空间</li>
</ul>
</li>
<li>当自定义了全局的operator new函数和operator delete函数后，我们就担负起了控制动态内存分配的职责。这两个函数必须是正确的：因为它们是程序整个处理过程中至关重要的一部分</li>
<li><strong>operator new接口和operator delete接口</strong>
<ul>
<li>可自定义上面函数版本的任意一个，前提是自定义的版本必须位于全局作用域或类作用域中
<ul>
<li>使用上面的运算符函数定义成类的成员时时隐式静态的，无需显示声明为static</li>
<li><mark>因为operator new用在对象构造之前而operator delete用在对象销毁之后，所以这两个成员(new和delete)必须是静态的，而且它们不能操纵类的任何数据成员</mark></li>
</ul>
</li>
</ul>
</li>
<li>想要<strong>自定义operator new函数</strong>，则可以为它定义额外的形参
<ul>
<li>此时用到这些自定义函数的new表达式必须使用new的定位形式将实参传给新增的形参</li>
</ul>
</li>
<li>malloc和free函数
<ul>
<li>C++从C中继承了这些函数，并将其定义在cstdlib头文件中
<ul>
<li>malloc函数接受一个表示待分配字节数的size_t,返回指向分配空间的指针或者返回0以表示分配失败</li>
<li>free函数接受一个void*，是malloc返回的指针的副本，free将相关内存返回给系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库中的重载版本</span></span><br><span class="line"><span class="comment">// 可能会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;   <span class="comment">//分配一个对象</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>);   <span class="comment">//分配一个数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*)</span> <span class="keyword">noexcept</span></span>;   <span class="comment">//释放一个对象</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>*) <span class="keyword">noexcept</span>;   <span class="comment">//释放一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 承诺不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>,<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;   <span class="comment">//分配一个对象</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>,<span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;   <span class="comment">//分配一个数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*, <span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;   <span class="comment">//释放一个对象</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>*, <span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;   <span class="comment">//释放一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span>*)</span></span>;  <span class="comment">//不允许重新定义这个版本</span></span><br><span class="line"><span class="comment">// 该版本只供标准库使用，不能被用户重新定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义operator new和operator delete的简单方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="type">void</span> *mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *mem)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1912-定位new表达式"><a class="markdownIt-Anchor" href="#1912-定位new表达式"></a> 19.1.2 定位new表达式</h3>
<ul>
<li>与allocator不同的是，对于operator new分配的内存空间来说无法使用construct函数构造对象</li>
<li><strong>应该使用new的定位new形式构造对象</strong>，为分配函数提供了额外的信息
<ul>
<li><mark>定位new允许在一个特定的，预先分配的内存地址上构造对象</mark></li>
</ul>
</li>
<li><strong>定位new与allocator的construct成员相似</strong>，但一个重要区别
<ul>
<li>传给construct的指针必须指向同一个allocator对象分配的空间，但是传给定位new的指针无需指向operator new分配的内存</li>
</ul>
</li>
<li><strong>显式的析构函数调用</strong>
<ul>
<li>定位new与使用allocate类似一样，对析构函数的显式调用也与使用destroy类似</li>
<li>既可以通过对象调用析构函数，也可以通过对象的指针或引用调用析构函数</li>
<li>和调用destroy类似，调用析构函数可以清除给定的对象但是不会释放该对象所在的空间</li>
<li><strong>需要的话可以重新使用该空间</strong>
<ul>
<li><mark>调用析构函数会销毁对象，但是不会释放内存</mark></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位new的形式</span></span><br><span class="line"><span class="keyword">new</span> (place_address) type</span><br><span class="line"><span class="built_in">new</span> (place_address) <span class="built_in">type</span> (initializers)</span><br><span class="line"><span class="built_in">new</span> (place_address) type [size]</span><br><span class="line"><span class="built_in">new</span> (place_address) type [size] &#123; braced initializer list&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// place_address必须是一个指针，同时在initializers中提供一个以逗号分割的初始值列表，该初始值列表用于构造新分配的对象</span></span><br><span class="line"></span><br><span class="line">string *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;a value&quot;</span>);</span><br><span class="line">sp-&gt;~<span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="192-运行时类型识别"><a class="markdownIt-Anchor" href="#192-运行时类型识别"></a> 19.2 运行时类型识别</h2>
<ul>
<li><strong>运行时类型识别</strong>的功能由两个运算符实现
<ul>
<li>typeid运算符用于返回表达式的类型</li>
<li>dynamic_cast运算符用于将基类的指针或引用安全地转换成派生类的指针或引用</li>
</ul>
</li>
<li>将两个运算符用于某种类型的指针或引用，并且该类型含有虚函数是，运算符将使用指针或引用所绑定对象的动态类型</li>
<li>两个运算符特别适用的情况
<ul>
<li>想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数</li>
<li>一般来说，只要有可能应该尽量使用虚函数
<ul>
<li>当操作被定义成虚函数时，编译器将根据对象的动态类型自动地选择正确的函数版本</li>
</ul>
</li>
<li>假设我们使用虚函数，则可以使用一个RTTI运算符
<ul>
<li>另一方面，与虚成员函数相比，使用RTTI运算符蕴含着更多潜在的风险：程序员必须清楚地知道转换的目标类型并且必须检查类型转换是否被成功执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1921-dynamic_cast运算符"><a class="markdownIt-Anchor" href="#1921-dynamic_cast运算符"></a> 19.2.1 dynamic_cast运算符</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dynamic_cast运算符的使用形式</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type*&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)</span><br><span class="line"><span class="comment">// 其中，type必须是一个类类型，并且通常情况下该类型应该含有虚函数</span></span><br><span class="line"><span class="comment">// e的类型必须符合以下三个条件中的任意一个：</span></span><br><span class="line"><span class="comment">// e的类型是目标type的公有派生类、e的类型是目标type的公有基类或者e的类型就是目标type的类型</span></span><br><span class="line"><span class="comment">// 如果符合，则类型转换可以成功。否则，转换失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假定Base类至少含有一个虚函数，Derived是Base的公有派生类</span></span><br><span class="line"><span class="comment">// 如果有一个指向Base的指针bp，则可以在运行时将它转换成指向Derived的指针</span></span><br><span class="line"><span class="keyword">if</span>(Derived *dp = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(bp))&#123;</span><br><span class="line">  <span class="comment">//使用dp指向的Derived对象</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  <span class="comment">//bp指向一个Base对象</span></span><br><span class="line">  <span class="comment">//使用bp指向的Base对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1922-typeid运算符"><a class="markdownIt-Anchor" href="#1922-typeid运算符"></a> 19.2.2 typeid运算符</h3>
<ul>
<li>typeid表达式的形式是typeid(e)，其中e可以是任意表达式或类型的名字
<ul>
<li>typeid操作的结果是一个常量对象的引用，该对象的类型是标准库类型type_info或者type_info的公有派生类型</li>
<li>定义在typeinfo头文件</li>
<li>可以作用于任意类型的表达式，顶层const被忽略</li>
<li>当typeid作用于引用返回该引用所引对象的类型</li>
<li>当typeid作用于数组或函数时，并不会执行向指针的标准类型转换</li>
</ul>
</li>
<li>当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型</li>
<li>当typeid作用于指针时(而非指针所指的对象)，返回的结果是该指针的静态编译时类型
<ul>
<li>typeid是否需要运行时检查决定了表达式是否会被求值
<ul>
<li>只有当类型含有虚函数时，编译器才会对表达式求值。反之，如果类型不含有虚函数，则typeid返回表达式的静态类型;编译器无须对表达式求值也能知道表达式的静态类型</li>
</ul>
</li>
<li>如果表达式的动态类型可能与静态类型不同，则必须在运行时对表达式求值以确定返回的类型
<ul>
<li>这条规则适用于typeid(*p)的情况。如果指针p所指的类型不含有虚函数，则p不必非得是一个有效的指针。否则，*p将在运行时求值，此时p必须是一个有效的指针</li>
<li>如果p是一个空指针，则typeid(*p)将抛出一个名为bad_typeid的异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Derived *dp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base *bp = dp;      <span class="comment">//两个指针都指向Derived对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">typeid</span>(*bp)==<span class="built_in">typeid</span>(*dp))&#123;</span><br><span class="line">  <span class="comment">//bp和dp指向同一类型的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查运行时类型是否是某种指定的类型</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(Derived))&#123;</span><br><span class="line">  <span class="comment">//bp实际指向Derived对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1923-使用rtti"><a class="markdownIt-Anchor" href="#1923-使用rtti"></a> 19.2.3 使用RTTI</h3>
<ul>
<li>在某些情况下RTTI非常有用
<ul>
<li>比如想为具有继承关系的类实现相等运算符时，对于两个对象来说，如果它们的类型相同并且对应的数据成员取值相同，则说这两个对象是相等的</li>
<li>在类的继承体系中，每个派生类负责添加自己的数据成员，因此派生类的相等运算符必须把派生类的新成员考虑进来</li>
</ul>
</li>
<li><strong>定义比较操作</strong>
<ul>
<li>如果参与比较的两个对象类型不同，则比较结果为false
<ul>
<li>例如，如果试图比较一个基类对象和一个派生类对象，则==运算符应该返回false</li>
</ul>
</li>
<li>基于上述推论，可以使用RTTI解决问题了
<ul>
<li>定义的相等运算符的形参是基类的引用，然后使用typeid检查两个运算对象的类型是否一致</li>
<li>如果运算对象的类型不一致，则==返回false；类型一致才调用equal函数。每个类定义的equal函数负责比较类型自己的成员。这些运算符接受Base&amp;形参，但是在进行比较操作前先把运算对象转换成运算符所属的类类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个示例类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Base&amp;, <span class="type">const</span> Base&amp;);</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Base的接口成员</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> Base&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//Base的数据成员和其他用于实现的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Derived的其他接口成员</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> Base&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// Derived的数据成员和其他用于实现的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义整体相等运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Base &amp;lhs, <span class="type">const</span> Base &amp;rhs)&#123;</span><br><span class="line">  <span class="comment">//如果typeid不相同,返回false;否则虚调用equal</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">typeid</span>(lhs) == <span class="built_in">typeid</span>(rhs) &amp;&amp; lhs.<span class="built_in">equal</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚equal函数</span></span><br><span class="line"><span class="comment">// 继承体系中的每个类必须定义自己的equal函数</span></span><br><span class="line"><span class="comment">// 派生类的所有函数要做的第一件事都是相同的，那就是将实参的类型转换为派生类类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Derived::equal</span><span class="params">(<span class="type">const</span> Base &amp;rhs)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">  <span class="comment">//清除这两个类型是相等的，所以转换过程不会抛出异常</span></span><br><span class="line">  <span class="keyword">auto</span> r = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derivd&amp;&gt;(rhs);</span><br><span class="line">  <span class="comment">// 执行比较两个Derived对象的操作并返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类equal函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Base::equal</span><span class="params">(<span class="type">const</span> Base &amp;rhs)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">  <span class="comment">//执行比较Base对象的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1924-type_info类"><a class="markdownIt-Anchor" href="#1924-type_info类"></a> 19.2.4 type_info类</h3>
<table>
<thead>
<tr>
<th>type_info的操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1 == t2</td>
<td>如果type_info对象t1和t2表示同一种类型，返回true</td>
</tr>
<tr>
<td>t1 != t2</td>
<td>如果type_info对象t1和t2表示不同类型，返回true</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://t.name">t.name</a>()</td>
<td>返回C风格字符串，表示类型名字的可打印形式。类似名字的生成方式因系统而异</td>
</tr>
<tr>
<td>t1.before(t2)</td>
<td>返回一个bool值，表示t1是否位于t2之前。before所采用的顺序关系是依赖于编译器</td>
</tr>
</tbody>
</table>
</div><div class="story post-story"><h2 id="193-枚举类型"><a class="markdownIt-Anchor" href="#193-枚举类型"></a> 19.3 枚举类型</h2>
<ul>
<li>枚举类型将一组整型常量组织在一起
<ul>
<li>和类一样，每个枚举类型定义了一种新的类型，枚举属于字面值常量类型</li>
</ul>
</li>
<li><strong>限定作用域的枚举类型</strong>：首先是关键字enum class随后是枚举类型名字以及花括号括起来的以逗号分割的枚举成员，最后是一个分号</li>
<li><strong>不限定作用域的枚举类型</strong>：省略class</li>
<li><strong>枚举成员</strong>
<ul>
<li>在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的</li>
<li>在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同</li>
<li><mark>默认情况下，枚举值从0开始，依次加1</mark></li>
</ul>
</li>
<li>初始化enum对象或者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象</li>
<li><mark>一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整型</mark></li>
<li><strong>指定enum的大小</strong>
<ul>
<li>实际上enum是由某种整数类型表示的</li>
<li>在enum后面加上冒号以及想要在enum中使用的类型</li>
</ul>
</li>
<li><strong>枚举类型的前置声明</strong>
<ul>
<li>可以提前声明enum，enum的前置声明必须指定其成员的大小</li>
</ul>
</li>
<li><strong>形参匹配与枚举类型</strong>
<ul>
<li>要想初始化一个enum对象，必须使用该enum类型的另一个对象或者它的一个枚举成员</li>
<li>即使某个整型值恰好与枚举成员的值相等也不能作为函数的enum实参使用</li>
<li>尽管不能直接将整型值传给enum形参，但是可以将一个不限定作用域的枚举类型的对象或枚举成员传给整型形参</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义限定作用域的枚举类型</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">open_modes</span> &#123;input, output, append&#125;;</span><br><span class="line"><span class="comment">// 定义不限定作用域的枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123;red, yellow, green&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">intTypes</span>&#123;</span><br><span class="line">  charTyp = <span class="number">8</span>,shortTyp = <span class="number">16</span>, intTyp = <span class="number">16</span>, longTyp = <span class="number">32</span>, long_longTyp = <span class="number">64</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> intTypes charbits = intTypes::charTyp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化enum对象或者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象</span></span><br><span class="line">om = open_mode::input;    <span class="comment">//input是open_modes的一个枚举成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不限定作用域的枚举类型intValues的前置声明</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">intValues</span> : <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;  <span class="comment">//不限定作用于的必须指定成员类型</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">open_modes</span>;      <span class="comment">//限定作用域的枚举类型可以使用默认成员类型int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不限定作用域的枚举类型，潜在类型因机器而已</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Tokens</span> &#123;INLINE = <span class="number">18</span>,VIRTUAL = <span class="number">129</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(Tokens)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Tokens curTok = INLINE;</span><br><span class="line">  <span class="built_in">ff</span>(<span class="number">128</span>);</span><br><span class="line">  <span class="built_in">ff</span>(INLINE);</span><br><span class="line">  <span class="built_in">ff</span>(curTok);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="194-类成员指针"><a class="markdownIt-Anchor" href="#194-类成员指针"></a> 19.4 类成员指针</h2>
<ul>
<li><strong>成员指针</strong>是指可以指向类的非静态成员的指针
<ul>
<li>一般情况下，指针指向一个对象，但是成员指针指示的是类的成员，而非类的对象</li>
<li>类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针与普通指针没有什么区别</li>
<li><mark>初始化这样的指针时，令其指向类的某个成员，但是不指定该对象所属的对象，直到使用成员指针时，才提供成员所属的对象</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Screen类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get_curosor</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> contents[cursor];&#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string contents;</span><br><span class="line">    pos cursor;</span><br><span class="line">    pos height, width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1941-数据成员函数"><a class="markdownIt-Anchor" href="#1941-数据成员函数"></a> 19.4.1 数据成员函数</h3>
<ul>
<li>和其他指针一样，在声明成员指针时可以使用*来表示当前声明对象的名字是一个指针，成员指针必须包含成员所属的类
<ul>
<li>在*之前添加classname::以表示当前定义的指针可以指向classname的成员</li>
<li>初始化一个成员指针时，需要指定所指向的成员</li>
<li>新标准中声明成员指针简答的方法是使用auto或decltype</li>
</ul>
</li>
<li><strong>使用数据成员指针</strong>
<ul>
<li>当初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据</li>
<li>成员指针指定了成员而非该成员所属的对象，只有当解引用成员指针时我们才提供对象的信息</li>
<li>与成员访问运算符.和-&gt;类似，也有两种成员指针访问运算符：.*和-&gt;*，这两个运算符使得我们可以解引用指针并获得该对象的成员</li>
</ul>
</li>
<li><strong>返回数据成员指针的函数</strong>
<ul>
<li>常规的访问控制规则对成员指针同样有效</li>
<li>因为数据成员一般情况下是私有的，所以通常不直接获得数据成员的指针</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string Screen::*pdata;</span><br><span class="line"></span><br><span class="line">pdata = &amp;Screen::contents;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pdata = &amp;Screen::contents;</span><br><span class="line"></span><br><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br><span class="line">s = pScreen-&gt;*pdata;</span><br></pre></td></tr></table></figure>
<h3 id="1942-成员函数指针"><a class="markdownIt-Anchor" href="#1942-成员函数指针"></a> 19.4.2 成员函数指针</h3>
<ul>
<li>和指向数据成员的指针一样，使用classname::*的形式声明一个指向成员函数的指针
<ul>
<li>类似于任何其他函数指针，指向成员函数的指针也需要指定目标函数的返回类型和形参列表</li>
<li>如果成员函数是const成员或者引用成员，则必须将const限定符或引用限定符包含进来</li>
</ul>
</li>
<li>和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则</li>
<li><strong>使用成员函数指针</strong>
<ul>
<li>和使用指向数据成员的指针一样，使用. *或者-&gt;*运算符作用于指向成员函数的指针，以调用类的成员函数</li>
</ul>
</li>
<li><strong>使用成员指针的别名</strong>
<ul>
<li>使用类型别名或typedef可以让成员指针更容易理解</li>
<li>和其他函数指针类似，可以将指向成员函数的指针作为某个函数的返回类型或形参类型
<ul>
<li>其中，指向成员的指针形参也可以拥有默认实参</li>
</ul>
</li>
</ul>
</li>
<li><strong>成员指针函数表</strong>
<ul>
<li>对于普通函数指针和指向成员函数的指针来说，一种常见的用法是将其存入一个函数表当中。如果一个类含有几个相同类型的成员，则这样一张表可以帮助我们从这些成员中选择一个</li>
</ul>
</li>
</ul>
<h3 id="1943-将成员函数用作可调用对象"><a class="markdownIt-Anchor" href="#1943-将成员函数用作可调用对象"></a> 19.4.3 将成员函数用作可调用对象</h3>
<ul>
<li>要想通过一个指向成员函数的指针进行函数调用，必须首先利用.*运算符或-&gt;*运算符将该指针绑定到特定的对象上</li>
<li>因此与普通的函数指针不同，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符</li>
<li>因为成员指针不是可调用对象，所以不能直接将一个指向成员函数的指针传递给算法</li>
<li><strong>使用function生成一个可调用对象</strong>
<ul>
<li>从指向成员函数的指针获取可调用对象的一种方法是<strong>使用标准库模板function</strong></li>
<li>使用function必须提供成员的调用形式
<ul>
<li><strong>使用mem_fn可以让编译器负责推断成员的类型</strong>，可以从成员指针生成一个可调用对象
<ul>
<li>mem_fn可根据成员指针的类型推断出可调用对象的类型，而无需用户显式地指定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用bind生成一个可调用对象</strong>
<ul>
<li>出于完整性的考虑使用bind从成员函数生成一个可调用对象</li>
<li>和function类似的地方是，当使用bind时，必须将函数中用于表示执行对象的隐式形参转换成显式的</li>
<li>和mem_fn类似的地方是，bind生成的可调用对象的第一个实参既可以是string的指针，也可以是string的引用</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="195-嵌套类"><a class="markdownIt-Anchor" href="#195-嵌套类"></a> 19.5 嵌套类</h2>
<ul>
<li>一个类定义在另一个类的内部，前者称为<strong>嵌套类或嵌套类型</strong>
<ul>
<li>嵌套类常用于定义作为实现部分的类</li>
<li>嵌套类是一个独立的类，与外层类基本没什么关系
<ul>
<li>特别是，外层类的对象和嵌套类的对象是相互独立的</li>
</ul>
</li>
<li>在嵌套类的对象中不包含任何外层类定义的成员
<ul>
<li>类似的，在外层类的对象中也不包含任何嵌套类定义的成员</li>
</ul>
</li>
<li>嵌套类中成员的种类与非嵌套类是一样的
<ul>
<li>和其他类类似，嵌套类也使用访问限定符来控制外界对其成员的访问权限</li>
<li>外层类对嵌套类的成员没有特殊的访问权限，同样，嵌套类对外层类的成员也没有特殊的访问权限</li>
</ul>
</li>
<li>嵌套类在其外层类中定义了一个类型成员
<ul>
<li>和其他成员类似，该类型的访问权限由外层类决定</li>
<li>位于外层类public部分的嵌套类实际上定义了一种可以随处访问的类型</li>
<li>位于外层类protected部分的嵌套类定义的类型只能被外层类及其友元和派生类访问</li>
<li>位于外层类private部分的嵌套类定义的类型只能被外层类的成员和友元访问</li>
</ul>
</li>
</ul>
</li>
<li>在外层类之外定义一个嵌套类
<ul>
<li>在嵌套类在其外层类之外完成真正的定义之前，它都是一个不完全类型</li>
</ul>
</li>
<li>定义嵌套类的成员
<ul>
<li>为其定义构造函数，必须指明QueryResult是嵌套在TextQuery的作用域之内的</li>
<li>具体的做法是使用外层类的名字限定嵌套类的名字</li>
</ul>
</li>
<li><strong>嵌套类作用域中的名字查找规则</strong>
<ul>
<li>名字查找的一般规则在嵌套类中同样适用</li>
<li>嵌套类本身是一个嵌套作用域，所以还必须查找嵌套类的外层作用域
<ul>
<li>可以说明为什么我们不在QueryResult的嵌套版本中定义line_no</li>
<li>原来的QueryResult类定义了该成员，从而使其成员可以避免使用TextQuery：：line_no的形式。然而QueryResult的嵌套类版本本身就是定义在TextQuery中的，所以我们不需要再使用typedef。嵌套的QueryResult无须说明line_no属于TextQuery就可以直接使用它</li>
</ul>
</li>
<li><mark>嵌套类是其外层类的一个类型成员，外层类的成员可以像使用任何其他类型成员一样使用嵌套类的名字</mark></li>
</ul>
</li>
<li><strong>嵌套类和外层类型是相互独立的</strong>
<ul>
<li>尽管嵌套类定义在其外层类的作用域中，但是外层类的对象和嵌套类的对象没有任何关系</li>
<li><mark>嵌套类的对象只包含嵌套类定义的成员；同样，外层类的对象只包含外层类定义的成员，在外层类对象中不会有任何嵌套类的成员</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明嵌套类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextQuery</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">QueryResult</span>;    <span class="comment">//嵌套类稍后定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在外层类之外定义一个嵌套类</span></span><br><span class="line"><span class="comment">// QueryResult的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextQuery</span>::QueryResult&#123;</span><br><span class="line">  <span class="comment">// 在类的作用域内，不必对QueryResult形参进行限定</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> std::ostream&amp;</span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">QueryResult</span>(std::string,std::shared_ptr&lt;std::set&lt;line_no&gt;&gt;,std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;)；</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TextQuery::QueryResult::<span class="built_in">QueryResult</span>(string s,shhared_ptr&lt;set&lt;line_no&gt;&gt; p, shared_ptr&lt;vector&lt;string&gt;&gt; f):</span><br><span class="line">        <span class="built_in">sought</span>(s),<span class="built_in">lines</span>(p),<span class="built_in">file</span>(f)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套类的静态成员定义</span></span><br><span class="line"><span class="type">int</span> textQuery::QueryResult::static_mem = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="196-union一种节省空间的类"><a class="markdownIt-Anchor" href="#196-union一种节省空间的类"></a> 19.6 union:一种节省空间的类</h2>
<ul>
<li><strong>联合</strong>是一种特殊的类，可以有多个数据成员，但在任意时刻只有一个数据成员可以有值
<ul>
<li>当给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了</li>
<li>分配给一个union对象的存储空间至少要能容纳它的最大的数据成员</li>
</ul>
</li>
<li><strong>union不能含有引用类型的成员</strong>，可以为成员指定public,protect和private等保护标记
<ul>
<li>默认情况下，union的成员都是共有的</li>
<li><mark>union不能继承自其他类，也不能作为基类使用，不能含有虚函数</mark></li>
</ul>
</li>
<li>匿名union是一个未命名的union，并且在右花括号和分号之间没有任何声明
<ul>
<li>在匿名union的定义所在的作用域内该union的成员都是可以直接访问的</li>
</ul>
</li>
<li><strong>含有类类型成员的union</strong>
<ul>
<li>当union包含的是内置类型的成员时，可以使用普通的赋值语句改变union保存的值
<ul>
<li>但是对于含有特殊类类型成员的union就没这么简单了。如果我们想将union的值改为类类型成员对应的值，或者将类类型成员的值改为一个其他值，则必须分别构造或析构该类类型的成员：当将union的值改为类类型成员对应的值时，必须运行该类型的构造函数；反之，当将类类型成员的值改为一个其他值时，必须运行该类型的析构函数</li>
</ul>
</li>
<li>当union包含的是内置类型的成员时，编译器将按照成员的次序依次合成默认构造函数或拷贝控制成员
<ul>
<li>但是如果union含有类类型的成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器将为union合成对应的版本并将其声明为删除的</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用类管理union成员</strong>
<ul>
<li>把含有类类型成员的union内嵌在另一个类中，可以管理并控制与union的类类型成员有关的状态转换</li>
<li>为了追踪union中存储什么类型的值，通常会定义一个<strong>union的判别式</strong>(独立的对象)
<ul>
<li>可以使用判别式辨别union存储的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义union</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Token</span>&#123;</span><br><span class="line">  <span class="type">char</span> cval;</span><br><span class="line">  <span class="type">int</span> ival;</span><br><span class="line">  <span class="type">double</span> dval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用union类型</span></span><br><span class="line">Token first_token = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;    <span class="comment">//初始化</span></span><br><span class="line">Token last_token;</span><br><span class="line">Token *pt = <span class="keyword">new</span> Token;    <span class="comment">//指向一个未初始化的Token对象的指针</span></span><br><span class="line"></span><br><span class="line">last_token.cval = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">pt-&gt;ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
</div><div class="story post-story"><h2 id="197-局部类"><a class="markdownIt-Anchor" href="#197-局部类"></a> 19.7 局部类</h2>
<ul>
<li><strong>局部类</strong>：类可以定义在某个函数的内部
<ul>
<li>定义只在作用域内可见，成员受到严格的限制</li>
<li>局部类中不允许声明静态数据成员</li>
</ul>
</li>
<li><strong>局部类不能使用函数作用域中的变量</strong>
<ul>
<li>局部类对其外层作用域中的名字的访问权限受到很多限制：局部类只能访问外层作用域定义的类型名,静态变量,枚举成员</li>
<li>如果局部类定义在某个函数内部，该函数的普通局部变量不能被局部类使用</li>
</ul>
</li>
<li><strong>常规的访问保护规则对局部类同样适用</strong>
<ul>
<li>外层函数对局部类的私有成员没有任何访问特权</li>
<li>当然，局部类可以将外层函数声明为友元；或者更常见的情况是局部类将其成员声明成公有的</li>
<li>在程序中有权访问局部类的代码非常有限。局部类已经封装在函数作用域中，通过信息隐藏进一步封装就显得没什么必要了</li>
<li>外层函数对局部类的私有成员没有任何访问特权。当然，局部类可以将外层函数声明为友元；或者更常见的情况是局部类将其成员声明成公有的。在程序中有权访问局部类的代码非常有限。局部类已经封装在函数作用域中，通过信息隐藏进一步封装就显得没什么必要了</li>
</ul>
</li>
<li><strong>局部类中的名字查找</strong>
<ul>
<li>局部类内部的名字查找次序与其他类相似</li>
<li>在声明类的成员时，必须先确保用到的名字位于作用域中，然后再使用该名字</li>
<li>定义成员时用到的名字可以出现在类的任意位置
<ul>
<li>如果某个名字不是局部类的成员，则继续在外层函数作用域中查找；如果还没有找到，则在外层函数所在的作用域中查找</li>
</ul>
</li>
</ul>
</li>
<li><strong>嵌套的局部类</strong>
<ul>
<li>可以在局部类的内部再嵌套一个类</li>
<li>此时，嵌套类的定义可以出现在局部类之外。不过，嵌套类必须定义在与局部类相同的作用域中</li>
</ul>
</li>
</ul>
</div><div class="story post-story"><h2 id="198-固有的不可移植的特性"><a class="markdownIt-Anchor" href="#198-固有的不可移植的特性"></a> 19.8 固有的不可移植的特性</h2>
<h3 id="1981-位域"><a class="markdownIt-Anchor" href="#1981-位域"></a> 19.8.1 位域</h3>
<ul>
<li>类可以将其（非静态）数据成员定义成位域，在一个位域中含有一定数量的二进制位
<ul>
<li>当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域</li>
</ul>
</li>
</ul>
<h3 id="1982-volatile限定符"><a class="markdownIt-Anchor" href="#1982-volatile限定符"></a> 19.8.2 volatile限定符</h3>
<ul>
<li>直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制</li>
<li>当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为<strong>volatile</strong>
<ul>
<li>关键字volatile告诉编译器不应对这样的对象进行优化</li>
</ul>
</li>
</ul>
<h3 id="1983-链接指示extern-c"><a class="markdownIt-Anchor" href="#1983-链接指示extern-c"></a> 19.8.3 链接指示:extern “C”</h3>
<ul>
<li>使用链接指示指出任意非C++函数所用的语言</li>
</ul>

</div>
  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateModified" datetime="2023-04-09T21:36:47+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2023年4月9日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/C/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>C++</p></a></div>
  <span hidden itemprop="keywords">C++</span>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://jay1060950003.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++Primer/&title=C++Primer - CodingStudio&summary= 引言

C++ Primer的学习笔记
"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://jay1060950003.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++Primer/&title=C++Primer - CodingStudio&summary= 引言

C++ Primer的学习笔记
"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://jay1060950003.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++Primer/&title=C++Primer - CodingStudio&summary= 引言

C++ Primer的学习笔记
"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2022/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i>操作系统</p>
          <p class='content'> 引言

《极客时间操作系统45讲》学习笔记






 1 从hello到另一个hello
 1.1 程序的运行过程:从代码到机器运行
 程序编译过程
1234567891011// Hel...</p>
        </a>
      
      
        <a class='next' href='/2022/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/'>
          <p class='title'>计算机网络<i class="fa-solid fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'> 引言

《计算机网络|自顶向下方法|第七版》学习笔记



 1. 计算机网络和因特网
 1.1 什么是因特网
 1.1.1 具体构成描述

节点:

主机及其上运行的应用程序
路由器,交换机...</p>
        </a>
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  


  <article class="post white-box shadow floatable blur" id="comments">
    <span hidden>
      <meta itemprop="discussionUrl" content="/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++Primer/index.html#comments">
    </span>
    <p ct><i class='fa-solid fa-comments'></i> 评论</p>
    

    <div id="layoutHelper-comments"></div>

  </article>






</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky pjax">

  
  


  <section class="widget toc-wrapper desktop mobile " id="toc-div" >
    
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text"> 引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%BC%80%E5%A7%8B"><span class="toc-number">2.</span> <span class="toc-text"> 1 开始</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%88%9D%E5%A7%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">2.1.</span> <span class="toc-text"> 1.2 初始输入输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text"> 2 变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text"> 2.1 基本内置类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text"> 2.2 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text"> 2.3 复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#231-%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 2.3.1 引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232-%E6%8C%87%E9%92%88"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 2.3.2 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#233-%E7%90%86%E8%A7%A3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text"> 2.3.3 理解复合类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text"> 2.4 const限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#241-const%E5%BC%95%E7%94%A8%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 2.4.1 const引用(常量引用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242-const%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 2.4.2 const和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#243-%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-number">3.4.3.</span> <span class="toc-text"> 2.4.3 顶层const和底层const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#244-constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.4.4.</span> <span class="toc-text"> 2.4.4 constexpr和常量表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text"> 2.5 处理类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#251-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.5.1.</span> <span class="toc-text"> 2.5.1 类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#252-auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">3.5.2.</span> <span class="toc-text"> 2.5.2 auto类型说明符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#253-decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">3.5.3.</span> <span class="toc-text"> 2.5.3 decltype类型指示符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.</span> <span class="toc-text"> 2.6 自定义数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text"> 3 字符串,向量和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text"> 3.1 命名空间的using声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring"><span class="toc-number">4.2.</span> <span class="toc-text"> 3.2 标准库类型string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector"><span class="toc-number">4.3.</span> <span class="toc-text"> 3.3 标准库类型vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.4.</span> <span class="toc-text"> 3.4 迭代器介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.</span> <span class="toc-text"> 3.5 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#353-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.1.</span> <span class="toc-text"> 3.5.3 指针和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#354-c%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.5.2.</span> <span class="toc-text"> 3.5.4 C风格字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#355-%E4%B8%8E%E6%97%A7%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.5.3.</span> <span class="toc-text"> 3.5.5 与旧代码的接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.6.</span> <span class="toc-text"> 3.6 多维数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text"> 4 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E5%9F%BA%E7%A1%80"><span class="toc-number">5.1.</span> <span class="toc-text"> 4.1 基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text"> 4.2 算数运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.</span> <span class="toc-text"> 4.3 逻辑和关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.4.</span> <span class="toc-text"> 4.4 赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.5.</span> <span class="toc-text"> 4.5 递增和递减运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.6.</span> <span class="toc-text"> 4.6 成员访问运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.7.</span> <span class="toc-text"> 4.7 条件运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.8.</span> <span class="toc-text"> 4.8 位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.9.</span> <span class="toc-text"> 4.9 sizeof运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#410-%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.10.</span> <span class="toc-text"> 4.10 逗号运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#411-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.11.</span> <span class="toc-text"> 4.11 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4113-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.11.1.</span> <span class="toc-text"> 4.11.3 显式转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.</span> <span class="toc-text"> 5 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.1.</span> <span class="toc-text"> 5.3 条件语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%BF%AD%E4%BB%A3%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.2.</span> <span class="toc-text"> 5.4 迭代语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.3.</span> <span class="toc-text"> 5.5 跳转语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-try%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text"> 5.6 try语句块和异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#561-throw%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.4.1.</span> <span class="toc-text"> 5.6.1 throw表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#562-try%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-number">6.4.2.</span> <span class="toc-text"> 5.6.2 try语句块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#563-%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-number">6.4.3.</span> <span class="toc-text"> 5.6.3 标准异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text"> 6 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-number">7.1.</span> <span class="toc-text"> 6.1 函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#611-%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.1.1.</span> <span class="toc-text"> 6.1.1 局部对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#612-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">7.1.2.</span> <span class="toc-text"> 6.1.2 函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#613-%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91"><span class="toc-number">7.1.3.</span> <span class="toc-text"> 6.1.3 分离式编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">7.2.</span> <span class="toc-text"> 6.2 参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621-%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text"> 6.2.1 传值参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622-%E4%BC%A0%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">7.2.2.</span> <span class="toc-text"> 6.2.2 传引用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#623-const%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">7.2.3.</span> <span class="toc-text"> 6.2.3 const形参和实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#624-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-number">7.2.4.</span> <span class="toc-text"> 6.2.4 数组形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#625-main%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-number">7.2.5.</span> <span class="toc-text"> 6.2.5 main:处理命令行选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#626-%E5%90%AB%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.6.</span> <span class="toc-text"> 6.2.6 含有可变形参的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.3.</span> <span class="toc-text"> 6.3 返回类型和return语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#631-%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.1.</span> <span class="toc-text"> 6.3.1 无返回值函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#632-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.2.</span> <span class="toc-text"> 6.3.2 有返回值的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#633-%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">7.3.3.</span> <span class="toc-text"> 6.3.3 返回数组指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">7.4.</span> <span class="toc-text"> 6.4 函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">7.5.</span> <span class="toc-text"> 6.5 特殊用途语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#651-%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-number">7.5.1.</span> <span class="toc-text"> 6.5.1 默认实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#652-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.2.</span> <span class="toc-text"> 6.5.2 内联函数和constexpr函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#653-%E8%B0%83%E8%AF%95%E5%B8%AE%E5%8A%A9"><span class="toc-number">7.5.3.</span> <span class="toc-text"> 6.5.3 调试帮助</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-number">7.6.</span> <span class="toc-text"> 6.6 函数匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#661-%E5%AE%9E%E5%8F%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.6.1.</span> <span class="toc-text"> 6.6.1 实参类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">7.7.</span> <span class="toc-text"> 6.7 函数指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text"> 7 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.1.</span> <span class="toc-text"> 7.1 定义抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#711-%E5%AE%9A%E4%B9%89%E6%94%B9%E8%BF%9B%E7%9A%84%E7%B1%BB"><span class="toc-number">8.1.1.</span> <span class="toc-text"> 7.1.1 定义改进的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#713-%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.2.</span> <span class="toc-text"> 7.1.3 定义类相关的非成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#714-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.3.</span> <span class="toc-text"> 7.1.4 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#715-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">8.1.4.</span> <span class="toc-text"> 7.1.5 拷贝,赋值和析构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">8.2.</span> <span class="toc-text"> 7.2 访问控制与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#721-%E5%8F%8B%E5%85%83"><span class="toc-number">8.2.1.</span> <span class="toc-text"> 7.2.1 友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">8.3.</span> <span class="toc-text"> 7.3 类的其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#731-%E7%B1%BB%E6%88%90%E5%91%98%E5%86%8D%E6%8E%A2"><span class="toc-number">8.3.1.</span> <span class="toc-text"> 7.3.1 类成员再探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#732-%E8%BF%94%E5%9B%9Ethis%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.2.</span> <span class="toc-text"> 7.3.2 返回*this的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#733-%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.3.3.</span> <span class="toc-text"> 7.3.3 类类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#734-%E5%8F%8B%E5%85%83%E5%86%8D%E6%8E%A2"><span class="toc-number">8.3.4.</span> <span class="toc-text"> 7.3.4 友元再探</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">8.4.</span> <span class="toc-text"> 7.4 类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#741-%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">8.4.1.</span> <span class="toc-text"> 7.4.1 名字查找与类的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2"><span class="toc-number">8.5.</span> <span class="toc-text"> 7.5 构造函数再探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#751-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">8.5.1.</span> <span class="toc-text"> 7.5.1 构造函数初始值列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#752-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.5.2.</span> <span class="toc-text"> 7.5.2 委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#753-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.5.3.</span> <span class="toc-text"> 7.5.3 默认构造函数的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#754-%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.5.4.</span> <span class="toc-text"> 7.5.4 隐式的类类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#755-%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-number">8.5.5.</span> <span class="toc-text"> 7.5.5 聚合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#756-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="toc-number">8.5.6.</span> <span class="toc-text"> 7.5.6 字面值常量类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">8.6.</span> <span class="toc-text"> 7.6 类的静态成员</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-io%E5%BA%93"><span class="toc-number">9.</span> <span class="toc-text"> 8 IO库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-io%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text"> 8.1 IO类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#811-io%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%8B%B7%E8%B4%9D%E6%88%96%E8%B5%8B%E5%80%BC"><span class="toc-number">9.1.1.</span> <span class="toc-text"> 8.1.1 IO对象无拷贝或赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#812-%E6%9D%A1%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">9.1.2.</span> <span class="toc-text"> 8.1.2 条件状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#813-%E7%AE%A1%E7%90%86%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2"><span class="toc-number">9.1.3.</span> <span class="toc-text"> 8.1.3 管理输出缓冲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">9.2.</span> <span class="toc-text"> 8.2 文件输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#821-%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.2.1.</span> <span class="toc-text"> 8.2.1 使用文件流对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#822-%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.2.2.</span> <span class="toc-text"> 8.2.2 文件模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-string%E6%B5%81"><span class="toc-number">9.3.</span> <span class="toc-text"> 8.3 string流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text"> 9 序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text"> 9.1 顺序容器概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88"><span class="toc-number">10.2.</span> <span class="toc-text"> 9.2 容器库概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#921-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.2.1.</span> <span class="toc-text"> 9.2.1 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#923-begin%E5%92%8Cend%E6%88%90%E5%91%98"><span class="toc-number">10.2.2.</span> <span class="toc-text"> 9.2.3 begin和end成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#924-%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">10.2.3.</span> <span class="toc-text"> 9.2.4 容器定义和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#925-%E8%B5%8B%E5%80%BC%E5%92%8Cswap"><span class="toc-number">10.2.4.</span> <span class="toc-text"> 9.2.5 赋值和swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#927-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.2.5.</span> <span class="toc-text"> 9.2.7 关系运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">10.3.</span> <span class="toc-text"> 9.3 顺序容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#931-%E5%90%91%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">10.3.1.</span> <span class="toc-text"> 9.3.1 向顺序容器添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#932-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">10.3.2.</span> <span class="toc-text"> 9.3.2 访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#933-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">10.3.3.</span> <span class="toc-text"> 9.3.3 删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#934-%E7%89%B9%E6%AE%8A%E7%9A%84forward_list%E6%93%8D%E4%BD%9C"><span class="toc-number">10.3.4.</span> <span class="toc-text"> 9.3.4 特殊的forward_list操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#935-%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="toc-number">10.3.5.</span> <span class="toc-text"> 9.3.5 改变容器大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#936-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-number">10.3.6.</span> <span class="toc-text"> 9.3.6 容器操作可能是迭代器失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-vector%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%A2%9E%E9%95%BF%E7%9A%84"><span class="toc-number">10.4.</span> <span class="toc-text"> 9.4 vector对象是如何增长的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-%E9%A2%9D%E5%A4%96%E7%9A%84string%E6%93%8D%E4%BD%9C"><span class="toc-number">10.5.</span> <span class="toc-text"> 9.5 额外的string操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#951-%E6%9E%84%E9%80%A0string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">10.5.1.</span> <span class="toc-text"> 9.5.1 构造string的其他方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#952-%E6%94%B9%E5%8F%98string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">10.5.2.</span> <span class="toc-text"> 9.5.2 改变string的其他方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#953-string%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">10.5.3.</span> <span class="toc-text"> 9.5.3 string搜索操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#954-compare%E5%87%BD%E6%95%B0"><span class="toc-number">10.5.4.</span> <span class="toc-text"> 9.5.4 compare函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#955-%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.5.5.</span> <span class="toc-text"> 9.5.5 数值转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">10.6.</span> <span class="toc-text"> 9.6 容器适配器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text"> 10 泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E6%A6%82%E8%BF%B0"><span class="toc-number">11.1.</span> <span class="toc-text"> 10.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E5%88%9D%E5%A7%8B%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text"> 10.2 初始泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1021-%E5%8F%AA%E8%AF%BB%E7%AE%97%E6%B3%95"><span class="toc-number">11.2.1.</span> <span class="toc-text"> 10.2.1 只读算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1022-%E5%86%99%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">11.2.2.</span> <span class="toc-text"> 10.2.2 写容器元素的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1023-%E9%87%8D%E6%8E%92%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">11.2.3.</span> <span class="toc-text"> 10.2.3 重排容器元素的算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103-%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">11.3.</span> <span class="toc-text"> 10.3 定制操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1031-%E5%90%91%E7%AE%97%E6%B3%95%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="toc-number">11.3.1.</span> <span class="toc-text"> 10.3.1 向算法传递函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1032-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.3.2.</span> <span class="toc-text"> 10.3.2 lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1033-lambda%E6%8D%95%E8%8E%B7%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="toc-number">11.3.3.</span> <span class="toc-text"> 10.3.3 lambda捕获和返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1034-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-number">11.3.4.</span> <span class="toc-text"> 10.3.4 参数绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">11.4.</span> <span class="toc-text"> 10.4 再探迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1041-%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">11.4.1.</span> <span class="toc-text"> 10.4.1 插入迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1042-iostream%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">11.4.2.</span> <span class="toc-text"> 10.4.2 iostream迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1043-%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">11.4.3.</span> <span class="toc-text"> 10.4.3 反向迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">11.5.</span> <span class="toc-text"> 10.5 泛型算法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1051-5%E7%B1%BB%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">11.5.1.</span> <span class="toc-text"> 10.5.1 5类迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1053-%E7%AE%97%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">11.5.2.</span> <span class="toc-text"> 10.5.3 算法命名规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95"><span class="toc-number">11.6.</span> <span class="toc-text"> 10.6 特定容器算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">12.</span> <span class="toc-text"> 11 关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">12.1.</span> <span class="toc-text"> 11.1 使用关联容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">12.2.</span> <span class="toc-text"> 11.2 关联容器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1121-%E5%AE%9A%E4%B9%89%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">12.2.1.</span> <span class="toc-text"> 11.2.1 定义关联容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1122-%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">12.2.2.</span> <span class="toc-text"> 11.2.2 关键字类型的要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1123-pair%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.3.</span> <span class="toc-text"> 11.2.3 pair类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">12.3.</span> <span class="toc-text"> 11.3 关联容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1131-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">12.3.1.</span> <span class="toc-text"> 11.3.1 关联容器迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1132-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">12.3.2.</span> <span class="toc-text"> 11.3.2 添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1133-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">12.3.3.</span> <span class="toc-text"> 11.3.3 删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1134-map%E7%9A%84%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C"><span class="toc-number">12.3.4.</span> <span class="toc-text"> 11.3.4 map的下标操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1135-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-number">12.3.5.</span> <span class="toc-text"> 11.3.5 访问元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">12.4.</span> <span class="toc-text"> 11.4 无序容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">13.</span> <span class="toc-text"> 12 动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">13.1.</span> <span class="toc-text"> 12.1 动态内存与智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1211-shared_ptr%E7%B1%BB"><span class="toc-number">13.1.1.</span> <span class="toc-text"> 12.1.1 shared_ptr类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1212-%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-number">13.1.2.</span> <span class="toc-text"> 12.1.2 直接管理内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1213-shared_ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">13.1.3.</span> <span class="toc-text"> 12.1.3 shared_ptr和new结合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1214-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">13.1.4.</span> <span class="toc-text"> 12.1.4 智能指针和异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1215-unique_ptr"><span class="toc-number">13.1.5.</span> <span class="toc-text"> 12.1.5 unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1216-weak_ptr"><span class="toc-number">13.1.6.</span> <span class="toc-text"> 12.1.6 weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">13.2.</span> <span class="toc-text"> 12.2 动态数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1221-new%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">13.2.1.</span> <span class="toc-text"> 12.2.1 new和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1222-allocator%E7%B1%BB"><span class="toc-number">13.2.2.</span> <span class="toc-text"> 12.2.2 allocator类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">14.</span> <span class="toc-text"> 13 拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81"><span class="toc-number">14.1.</span> <span class="toc-text"> 13.1 拷贝,赋值与销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1311-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">14.1.1.</span> <span class="toc-text"> 13.1.1 拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1312-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.1.2.</span> <span class="toc-text"> 13.1.2 拷贝赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1313-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">14.1.3.</span> <span class="toc-text"> 13.1.3 析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1314-%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-number">14.1.4.</span> <span class="toc-text"> 13.1.4 三&#x2F;五法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1315-%E4%BD%BF%E7%94%A8default"><span class="toc-number">14.1.5.</span> <span class="toc-text"> 13.1.5 使用&#x3D;default</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1316-%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D"><span class="toc-number">14.1.6.</span> <span class="toc-text"> 13.1.6 阻止拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#132-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">14.2.</span> <span class="toc-text"> 13.2 拷贝控制和资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1321-%E8%A1%8C%E4%B8%BA%E5%83%8F%E5%80%BC%E7%9A%84%E7%B1%BB"><span class="toc-number">14.2.1.</span> <span class="toc-text"> 13.2.1 行为像值的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1322-%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA%E5%83%8F%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB"><span class="toc-number">14.2.2.</span> <span class="toc-text"> 13.2.2 定义行为像指针的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#133-%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">14.3.</span> <span class="toc-text"> 13.3 交换操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#135-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB"><span class="toc-number">14.4.</span> <span class="toc-text"> 13.5 *动态内存管理类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#136-%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="toc-number">14.5.</span> <span class="toc-text"> 13.6 对象移动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1361-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">14.5.1.</span> <span class="toc-text"> 13.6.1 右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1362-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.5.2.</span> <span class="toc-text"> 13.6.2 移动构造函数和移动赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1363-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">14.5.3.</span> <span class="toc-text"> 13.6.3 右值引用和成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">15.</span> <span class="toc-text"> 14 重载运算与类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">15.1.</span> <span class="toc-text"> 14.1 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.2.</span> <span class="toc-text"> 14.2 输入和输出运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1421-%E9%87%8D%E8%BD%BD%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.2.1.</span> <span class="toc-text"> 14.2.1 重载输出运算符&lt;&lt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1422-%E9%87%8D%E8%BD%BD%E8%BE%93%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.2.2.</span> <span class="toc-text"> 14.2.2 重载输入运算符&gt;&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#143-%E7%AE%97%E6%9C%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.3.</span> <span class="toc-text"> 14.3 算术和关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1431-%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.3.1.</span> <span class="toc-text"> 14.3.1 相等运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1432-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.3.2.</span> <span class="toc-text"> 14.3.2 关系运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.4.</span> <span class="toc-text"> 14.4 赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#145-%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.5.</span> <span class="toc-text"> 14.5 下标运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.6.</span> <span class="toc-text"> 14.6 递增和递减运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#147-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.7.</span> <span class="toc-text"> 14.7 成员访问运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.8.</span> <span class="toc-text"> 14.8 函数调用运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1481-lambda%E6%98%AF%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.8.1.</span> <span class="toc-text"> 14.8.1 lambda是函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1482-%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.8.2.</span> <span class="toc-text"> 14.8.2 标准库定义的函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1483-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8Efunction"><span class="toc-number">15.8.3.</span> <span class="toc-text"> 14.8.3 可调用对象与function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#149-%E9%87%8D%E8%BD%BD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.9.</span> <span class="toc-text"> 14.9 重载,类型转换与运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1491-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.9.1.</span> <span class="toc-text"> 14.9.1 类型转换运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1492-%E9%81%BF%E5%85%8D%E6%9C%89%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">15.9.2.</span> <span class="toc-text"> 14.9.2 避免有二义性的类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1493-%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">15.9.3.</span> <span class="toc-text"> 14.9.3 函数匹配与重载运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">16.</span> <span class="toc-text"> 15 面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#151-oop%E6%A6%82%E8%BF%B0"><span class="toc-number">16.1.</span> <span class="toc-text"> 15.1 OOP概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#152-%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">16.2.</span> <span class="toc-text"> 15.2 定义基类和派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1521-%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB"><span class="toc-number">16.2.1.</span> <span class="toc-text"> 15.2.1 定义基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1522-%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">16.2.2.</span> <span class="toc-text"> 15.2.2 定义派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1523-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">16.2.3.</span> <span class="toc-text"> 15.2.3 类型转换与继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">16.3.</span> <span class="toc-text"> 15.3 虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#154-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">16.4.</span> <span class="toc-text"> 15.4 抽象基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">16.5.</span> <span class="toc-text"> 15.5 访问控制与继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#156-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">16.6.</span> <span class="toc-text"> 15.6 继承中的类作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#157-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">16.7.</span> <span class="toc-text"> 15.7 构造函数与拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1571-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">16.7.1.</span> <span class="toc-text"> 15.7.1 虚析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1572-%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">16.7.2.</span> <span class="toc-text"> 15.7.2 合成拷贝控制与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1573-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98"><span class="toc-number">16.7.3.</span> <span class="toc-text"> 15.7.3 派生类的拷贝控制成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1574-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">16.7.4.</span> <span class="toc-text"> 15.7.4 继承的构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#158-%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">16.8.</span> <span class="toc-text"> 15.8 容器与继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">17.</span> <span class="toc-text"> 16 模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#161-%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF"><span class="toc-number">17.1.</span> <span class="toc-text"> 16.1 定义模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1611-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">17.1.1.</span> <span class="toc-text"> 16.1.1 函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1612-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">17.1.2.</span> <span class="toc-text"> 16.1.2 类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1613-%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">17.1.3.</span> <span class="toc-text"> 16.1.3 模板参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1614-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">17.1.4.</span> <span class="toc-text"> 16.1.4 成员模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1615-%E6%8E%A7%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">17.1.5.</span> <span class="toc-text"> 16.1.5 控制实例化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#162-%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD"><span class="toc-number">17.2.</span> <span class="toc-text"> 16.2 模板实参推断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1621-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">17.2.1.</span> <span class="toc-text"> 16.2.1 类型转换与模板类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1622-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%98%BE%E5%BC%8F%E5%AE%9E%E5%8F%82"><span class="toc-number">17.2.2.</span> <span class="toc-text"> 16.2.2 函数模板显式实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1623-%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">17.2.3.</span> <span class="toc-text"> 16.2.3 尾置返回类型与类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1624-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD"><span class="toc-number">17.2.4.</span> <span class="toc-text"> 16.2.4 函数指针和实参推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1625-%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">17.2.5.</span> <span class="toc-text"> 16.2.5 模板实参推断和引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1627-%E8%BD%AC%E5%8F%91"><span class="toc-number">17.2.6.</span> <span class="toc-text"> 16.2.7 转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#163-%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%A8%A1%E6%9D%BF"><span class="toc-number">17.3.</span> <span class="toc-text"> 16.3 重载与模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#164-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">17.4.</span> <span class="toc-text"> 16.4 可变参数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1641-%E7%BC%96%E5%86%99%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">17.4.1.</span> <span class="toc-text"> 16.4.1 编写可变参数函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1642-%E5%8C%85%E6%89%A9%E5%B1%95"><span class="toc-number">17.4.2.</span> <span class="toc-text"> 16.4.2 包扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1643-%E8%BD%AC%E5%8F%91%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-number">17.4.3.</span> <span class="toc-text"> 16.4.3 转发参数包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#165-%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-number">17.5.</span> <span class="toc-text"> 16.5 模板特例化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E6%A0%87%E5%87%86%E5%BA%93%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD"><span class="toc-number">18.</span> <span class="toc-text"> 17 标准库特殊设施</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#171-tuple%E7%B1%BB%E5%9E%8B"><span class="toc-number">18.1.</span> <span class="toc-text"> 17.1 tuple类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1711-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96tuple"><span class="toc-number">18.1.1.</span> <span class="toc-text"> 17.1.1 定义和初始化tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1712-%E4%BD%BF%E7%94%A8tuple%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="toc-number">18.1.2.</span> <span class="toc-text"> 17.1.2 使用tuple返回多个值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#172-bitset%E7%B1%BB%E5%9E%8B"><span class="toc-number">18.2.</span> <span class="toc-text"> 17.2 bitset类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1721-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96bitset"><span class="toc-number">18.2.1.</span> <span class="toc-text"> 17.2.1 定义和初始化bitset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1722-bitset%E6%93%8D%E4%BD%9C"><span class="toc-number">18.2.2.</span> <span class="toc-text"> 17.2.2 bitset操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#174-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">18.3.</span> <span class="toc-text"> 17.4 正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1731-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%93"><span class="toc-number">18.3.1.</span> <span class="toc-text"> 17.3.1 使用正则表达式库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1732-%E5%8C%B9%E9%85%8D%E4%B8%8Eregex%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">18.3.2.</span> <span class="toc-text"> 17.3.2 匹配与Regex迭代器类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1733-%E4%BD%BF%E7%94%A8%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">18.3.3.</span> <span class="toc-text"> 17.3.3 使用子表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1734-%E4%BD%BF%E7%94%A8regex_replace"><span class="toc-number">18.3.4.</span> <span class="toc-text"> 17.3.4 使用regex_replace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#174-%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">18.4.</span> <span class="toc-text"> 17.4 随机数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1741-%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%BC%95%E6%93%8E%E5%92%8C%E5%88%86%E5%B8%83"><span class="toc-number">18.4.1.</span> <span class="toc-text"> 17.4.1 随机数引擎和分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1742-%E5%85%B6%E4%BB%96%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%88%86%E5%B8%83"><span class="toc-number">18.4.2.</span> <span class="toc-text"> 17.4.2 其他随机数分布</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#175-io%E5%BA%93%E5%86%8D%E6%8E%A2"><span class="toc-number">18.5.</span> <span class="toc-text"> 17.5 IO库再探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1751-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">18.5.1.</span> <span class="toc-text"> 17.5.1 格式化输入与输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1752-%E6%9C%AA%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">18.5.2.</span> <span class="toc-text"> 17.5.2 未格式化的输入&#x2F;输出操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1753-%E6%B5%81%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">18.5.3.</span> <span class="toc-text"> 17.5.3 流随机访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">19.</span> <span class="toc-text"> 18 用于大型程序的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#181-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">19.1.</span> <span class="toc-text"> 18.1 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1811-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">19.1.1.</span> <span class="toc-text"> 18.1.1 抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1812-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">19.1.2.</span> <span class="toc-text"> 18.1.2 捕获异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1813-%E5%87%BD%E6%95%B0try%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">19.1.3.</span> <span class="toc-text"> 18.1.3 函数try语句块与构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1814-noexcept%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="toc-number">19.1.4.</span> <span class="toc-text"> 18.1.4 noexcept异常说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1815-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1"><span class="toc-number">19.1.5.</span> <span class="toc-text"> 18.1.5 异常类层次</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#182-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">19.2.</span> <span class="toc-text"> 18.2 命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1821-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">19.2.1.</span> <span class="toc-text"> 18.2.1 命名空间的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1822-%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%88%90%E5%91%98"><span class="toc-number">19.2.2.</span> <span class="toc-text"> 18.2.2 使用命名空间成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1823-%E7%B1%BB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">19.2.3.</span> <span class="toc-text"> 18.2.3 类，命名空间与作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1824-%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">19.2.4.</span> <span class="toc-text"> 18.2.4 重载与命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#183-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">19.3.</span> <span class="toc-text"> 18.3 多重继承与虚继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1831-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">19.3.1.</span> <span class="toc-text"> 18.3.1 多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1832-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%9A%E4%B8%AA%E5%9F%BA%E7%B1%BB"><span class="toc-number">19.3.2.</span> <span class="toc-text"> 18.3.2 类型转换与多个基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1833-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">19.3.3.</span> <span class="toc-text"> 18.3.3 多重继承下的类作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1834-%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">19.3.4.</span> <span class="toc-text"> 18.3.4 虚继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1835-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">19.3.5.</span> <span class="toc-text"> 18.3.5 构造函数与虚继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF"><span class="toc-number">20.</span> <span class="toc-text"> 19 特殊工具与技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#191-%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">20.1.</span> <span class="toc-text"> 19.1 控制内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1911-%E9%87%8D%E8%BD%BDnew%E5%92%8Cdelete"><span class="toc-number">20.1.1.</span> <span class="toc-text"> 19.1.1 重载new和delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1912-%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">20.1.2.</span> <span class="toc-text"> 19.1.2 定位new表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#192-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-number">20.2.</span> <span class="toc-text"> 19.2 运行时类型识别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1921-dynamic_cast%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">20.2.1.</span> <span class="toc-text"> 19.2.1 dynamic_cast运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1922-typeid%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">20.2.2.</span> <span class="toc-text"> 19.2.2 typeid运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1923-%E4%BD%BF%E7%94%A8rtti"><span class="toc-number">20.2.3.</span> <span class="toc-text"> 19.2.3 使用RTTI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1924-type_info%E7%B1%BB"><span class="toc-number">20.2.4.</span> <span class="toc-text"> 19.2.4 type_info类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#193-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">20.3.</span> <span class="toc-text"> 19.3 枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#194-%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="toc-number">20.4.</span> <span class="toc-text"> 19.4 类成员指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1941-%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">20.4.1.</span> <span class="toc-text"> 19.4.1 数据成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1942-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">20.4.2.</span> <span class="toc-text"> 19.4.2 成员函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1943-%E5%B0%86%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%94%A8%E4%BD%9C%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">20.4.3.</span> <span class="toc-text"> 19.4.3 将成员函数用作可调用对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#195-%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">20.5.</span> <span class="toc-text"> 19.5 嵌套类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#196-union%E4%B8%80%E7%A7%8D%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4%E7%9A%84%E7%B1%BB"><span class="toc-number">20.6.</span> <span class="toc-text"> 19.6 union:一种节省空间的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#197-%E5%B1%80%E9%83%A8%E7%B1%BB"><span class="toc-number">20.7.</span> <span class="toc-text"> 19.7 局部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">20.8.</span> <span class="toc-text"> 19.8 固有的不可移植的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1981-%E4%BD%8D%E5%9F%9F"><span class="toc-number">20.8.1.</span> <span class="toc-text"> 19.8.1 位域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1982-volatile%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">20.8.2.</span> <span class="toc-text"> 19.8.2 volatile限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1983-%E9%93%BE%E6%8E%A5%E6%8C%87%E7%A4%BAextern-c"><span class="toc-number">20.8.3.</span> <span class="toc-text"> 19.8.3 链接指示:extern “C”</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>

  

</div>


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.remove("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="half";
      cover_wrapper.style.display="";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.4'
      loop='all'
      order='random'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='5062959861'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
              <a href="mailto:jay1060950003@gmail.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
            
              <a href="https://github.com/jay1060950003/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
        </div>
      
    
      
        <p>本站使用 <a target="_blank" rel="noopener" href="https://github.com/volantis-x/hexo-theme-volantis/#5.8.0">Volantis</a> 作为主题，您可以在 GitHub 找到<a target="_blank" rel="noopener" href="https://github.com/volantis-x/volantis-docs">本站源码</a>。</p>

      
    
      
        <div class='copyright'>
        <p>Copyright © Since 2017</p>

        </div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fortawesome/fontawesome-pro/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="/js/app.js"></script>





  













<div id="rightmenu-wrapper">
  <ul class="list-v rightmenu" id="rightmenu-content">
    
  <li class='navigation menuNavigation-Content'>


    <a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa-duotone fa-arrow-left PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa-duotone fa-arrow-right PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa-duotone fa-redo PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" href="/"><i class="fa-duotone fa-home PETERRIVE fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)"><i class="fa-duotone fa-arrow-up PETERRIVE fa-fw"></i></a>


  </li>


    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyPaste" data-event="copyPaste" data-group="inputBox">
      <i class="fa-duotone PETERRIVE fa-paste fa-fw"></i>
      粘贴文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyAll" data-event="copyAll" data-group="inputBox">
      <i class="fa-duotone PETERRIVE fa-object-ungroup fa-fw"></i>
      全选文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyCut" data-event="copyCut" data-group="inputBox">
      <i class="fa-duotone PETERRIVE fa-cut fa-fw"></i>
      剪切文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyText" data-event="copyText" data-group="seletctText">
      <i class="fa-duotone PETERRIVE fa-copy fa-fw"></i>
      复制文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="searchWord" data-event="OpenSearch(__text__)" data-group="seletctText">
      <i class="fa-duotone PETERRIVE fa-search fa-fw"></i>
      站内搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="bingSearch" data-event="window.open(`https://cn.bing.com/search?q=${__text__}`)" data-group="seletctText">
      <i class="fa-duotone PETERRIVE fa-search fa-fw"></i>
      必应搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="openTab" data-event="window.open(__link__)" data-group="elementCheck">
      <i class="fa-duotone PETERRIVE fa-external-link-square-alt fa-fw"></i>
      新标签页打开
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyLink" data-event="copyLink" data-group="elementCheck">
      <i class="fa-duotone PETERRIVE fa-link fa-fw"></i>
      复制链接地址
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyImg" data-event="copyImg" data-group="elementImage">
      <i class="fa-duotone PETERRIVE fa-image fa-fw"></i>
      复制图片
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="googleImg" data-event="window.open(`https://www.google.com/searchbyimage?image_url=${__link__}`)" data-group="elementImage">
      <i class="fa-duotone PETERRIVE fa-images fa-fw"></i>
      谷歌识图
    </span>
  </li>



    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="darkMode" data-event="volantis.dark.toggle()" data-group="darkMode">
      <i class="fa-duotone fa-eclipse-alt WISTERIA fa-fw"></i>
      暗黑模式
    </span>
  </li>



    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="printMode" data-event="printMode" data-group="articlePage">
      <i class="fa-duotone fa-print TURQUOISE fa-fw"></i>
      打印页面
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="readMode" data-event="readMode" data-group="articlePage">
      <i class="fa-duotone fa-book-open EMERALD fa-fw"></i>
      阅读模式
    </span>
  </li>



    <hr class="menuLoad-Content" >


<div id="menuMusic">
  <li class='music name menuOption-Content'>
    <p class='nav music-title fix-cursor-default'></p>
  </li>
  <li class='music ctrl'>
    <a class='nav icon-only backward fix-cursor-default' href="/" onclick="return false;" title="backward">
      <i class='fa-duotone PETERRIVE fa-step-backward fa-fw'></i>
    </a>
    <a class='nav icon-only toggle fix-cursor-default' href="/" onclick="return false;" title="toggle">
      <i class='fa-duotone PETERRIVE fa-play fa-fw'></i>
    </a>
    <a class='nav icon-only forward fix-cursor-default' href="/" onclick="return false;" title="forward">
      <i class='fa-duotone PETERRIVE fa-step-forward fa-fw'></i>
    </a>
  </li>
  <li class='music volume'>
    <div class='nav volume'>
      <div class="aplayer-volume-bar-wrap">
        <div class="aplayer-volume-bar fix-cursor-pointer">
          <div class="aplayer-volume"></div>
          <i class='left fa-duotone PETERRIVE fa-volume-off fa-fw'></i>
          <i class='right fa-duotone PETERRIVE fa-volume-up fa-fw'></i>
        </div>
      </div>
    </div>
  </li>
</div>

  </ul>
</div>
<script src="/js/plugins/rightMenus.js"></script>
<script>
  const RightMenusFunction = {};
  














  //RightMenusFunction['copyPaste'] = (fun) => {fun()}





  //RightMenusFunction['copyAll'] = (fun) => {fun()}





  //RightMenusFunction['copyCut'] = (fun) => {fun()}





  //RightMenusFunction['copyText'] = (fun) => {fun()}





  RightMenusFunction['searchWord'] = (__text__) => {OpenSearch(__text__)}





  RightMenusFunction['bingSearch'] = (__text__) => {window.open(`https://cn.bing.com/search?q=${__text__}`)}





  RightMenusFunction['openTab'] = (__link__) => {window.open(__link__)}





  //RightMenusFunction['copyLink'] = (fun) => {fun()}





  //RightMenusFunction['copyImg'] = (fun) => {fun()}





  RightMenusFunction['googleImg'] = (__link__) => {window.open(`https://www.google.com/searchbyimage?image_url=${__link__}`)}







  RightMenusFunction['darkMode'] = () => {volantis.dark.toggle()}







  //RightMenusFunction['printMode'] = (fun) => {fun()}





  //RightMenusFunction['readMode'] = (fun) => {fun()}







</script>



<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->

  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "color-scheme";
const rootElementDarkModeAttributeName = "color-scheme";
const setLS = (k, v) => {
    localStorage.setItem(k, v);
};
const removeLS = (k) => {
    localStorage.removeItem(k);
};
const getLS = (k) => {
    return localStorage.getItem(k);
};
const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};
const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};
const validColorModeKeys = {
  dark: true,
  light: true,
};
const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);
  getCustomDarkMode();
  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};
const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};
/**
 * get target mode
 */
 const getCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  if(currentSetting=="dark"){
    volantis.dark.mode="light";
  }else{
    volantis.dark.mode="dark";
  }
  // console.log(volantis.dark.mode)
};
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};
/**
 * 暗黑模式触发器
 */
volantis.dark.toggle=()=>{
  const mode = toggleCustomDarkMode();
  applyCustomDarkModeSettings(mode);
  // 使用 volantis.dark.push 方法传入volantis.dark.toggle回调函数 参见layout/_partial/scripts/global.ejs
  volantis.dark.method.toggle.start();
}
/**
 * bind event for toggle button
 */

function bindToggleButton() {
  var btn= document.querySelectorAll("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn")
  btn.forEach(function (e) {
    volantis.dom.$(e).on('click',volantis.dark.toggle);
  })
}
applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", ()=>{
  volantis.requestAnimationFrame(bindToggleButton)
});
volantis.pjax.push(bindToggleButton);

const darkModelListeners={
  dark:(mediaQueryList )=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "dark";
    }
    volantis.dark.method.toggle.start();
  },
  light:(mediaQueryList)=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "light";
    }
    volantis.dark.method.toggle.start();
  }
}
window.matchMedia('(prefers-color-scheme: dark)').addListener(darkModelListeners.dark)
window.matchMedia('(prefers-color-scheme: light)').addListener(darkModelListeners.light)
</script>




<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/js/plugins/tags/sites.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/js/plugins/tags/friends.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/js/plugins/tags/contributors.js")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/flying-pages/flying-pages.min.js"></script>





   <script type="text/javascript">
  function pjax_scrollrebeal() {
    ScrollReveal().reveal("#l_main .reveal", {
      distance: "32px",
      duration: "800",
      interval: "20",
      scale: "1",
      easing: "ease-out",
    });
  }
  function init_scrollrebeal() {
    if (typeof ScrollReveal == "undefined") {
      volantis.requestAnimationFrame(init_scrollrebeal);
    } else {
      pjax_scrollrebeal();
    }
  }
  volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/scrollreveal/dist/scrollreveal.min.js");
  document.addEventListener("DOMContentLoaded", init_scrollrebeal);
  volantis.pjax.push(
    pjax_scrollrebeal,
    "pjax_scrollrebeal",
    (setRequestAnimationFrame = false)
  );
</script>




  <script>
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/aplayer/dist/APlayer.min.css");
  (async () => {
    // APlayer 需要在  MetingJS 之前加载
    await volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/aplayer/dist/APlayer.min.js")
    await volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/meting/dist/Meting.min.js")
  
    // 右键 music 需要在 APlayer  MetingJS 之后加载
    await volantis.js('/js/plugins/aplayer.js')
  
  })();

  function SetAPlayerPlugin(){
    let Metings = document.querySelectorAll('meting-js');
    if (Metings.length === 0) {return;};
    if (Metings[0].aplayer && Metings[0].aplayer.on) {
      // improve the accessibility https://web.dev/button-name/
      document.querySelectorAll(".aplayer-icon-menu").forEach(e=>{
        e.setAttribute("aria-label","Aplayer Menu")
      })
      // message see: /layout/_plugins/message/script.ejs
      
        try {
          setTimeout(() => {
            Metings.forEach((item, index) => {
              const aplayerItem = item.aplayer; if(!aplayerItem) return;
              const rightAplayerCheck = 'true' === 'true'
                && item.meta.id === '5062959861';
              if(rightAplayerCheck && typeof RightMenuAplayer !="undefined") RightMenuAplayer.checkAPlayer();
              if(aplayerItem.events.events.play.every(item => {return item.name !== 'messagePlay'})) {
                aplayerItem.on('play', function messagePlay() {
                  let index = aplayerItem.list.index;
                  let title = aplayerItem.list.audios[index].title;
                  let artist = aplayerItem.list.audios[index].artist;
                  setTimeout(() => {
                    VolantisApp.message('音乐通知', title + ' - ' + artist, {
                      icon: 'fa-light fa-play light-blue',
                      transitionIn: 'flipInX',
                      transitionOut: 'flipOutX'
                    });
                  }, 100)
                });
              }
              if(aplayerItem.events.events.pause.every(item => {return item.name !== 'messagePause'})) {
                aplayerItem.on('pause', function messagePause() {
                  let index = aplayerItem.list.index;
                  let title = aplayerItem.list.audios[index].title;
                  let artist = aplayerItem.list.audios[index].artist;
                  setTimeout(() => {
                    // 歌曲播放结束也会触发 pause 事件，为了避免错误提示，等待一会儿
                    if(aplayerItem.paused) {
                      VolantisApp.message('音乐通知', title + ' - ' + artist, {
                        icon: 'fa-light fa-pause light-blue',
                        transitionIn: 'flipInX',
                        transitionOut: 'flipOutX'
                      });
                    }
                  }, 100)
                });
              }
            });
          }, 500)
        } catch (error) { console.error(error); }
      
    }else{
      volantis.requestAnimationFrame(SetAPlayerPlugin)
    }
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    SetAPlayerPlugin();
  });
  volantis.pjax.push(SetAPlayerPlugin);
</script>




      <script>
  volantis.layoutHelper("comments",`<div id="giscus_container"></div>`)

  volantis.giscus = {};

  function check_giscus() {
    if (volantis.dark.mode === "dark") {
      volantis.giscus.Theme = 'dark';
    } else {
      volantis.giscus.Theme = 'light';
    }

    return document.getElementById("giscus_container");
  }

  function pjax_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;
    let cfg = Object.assign({"theme":{"light":"light","dark":"dark"},"repo":"jay1060950003/comments","repo-id":"R_kgDOJfmU6A","category":"Announcements","category-id":"DIC_kwDOJfmU6M4CWTdE","mapping":"pathname","reactions-enabled":"1","emit-metadata":"0","lang":"zh-CN"},pdata.commentConfig)
    const script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    Object.keys(cfg).forEach(k=>{
      if (k != "theme") {
        script.setAttribute('data-'+k, cfg[k]);
      }
    })
    script.setAttribute('data-theme', volantis.giscus.Theme);
    script.setAttribute('crossorigin', "anonymous");
    HEAD.appendChild(script);
  }

  function dark_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;

    const message = {
      setConfig: {
        theme: volantis.giscus.Theme
      }
    };
    const giscusIframe = document.querySelector('iframe.giscus-frame');
    giscusIframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  pjax_giscus();
  volantis.pjax.push(pjax_giscus);
  volantis.dark.push(dark_giscus);
</script>

    




  <script defer src="https://gcore.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>


<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/") ?
    "/" || "/" :
    "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("/js/search/hexo.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>







  <script>



  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>










  <script>
  let imgs = ["https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/006.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/056.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/042.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/033.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/001.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/046.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/025.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/052.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/003.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/039.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/051.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/016.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/019.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/005.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/035.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/034.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/004.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/054.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/038.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/002.webp","https://unpkg.com/volantis-static@0.0.1654736714924/media/wallpaper/minimalist/2020/012.webp"];
  let index = 0;
  let IntervalParallax = null;

  function parallax(){
    let ParallaxWindow = document.querySelector("#parallax-window");
    
    Parallax.window = ParallaxWindow;
    Parallax.options.fade = 1500;
    Parallax.cache = 1;
    next_parallax();
    Parallax.init();
    if (imgs.length>1) {
      IntervalParallax = setInterval(function () {
        next_parallax();
      }, '10000');
    }
  }

  function next_parallax() {
    if (typeof Parallax == "undefined") {
      return
    }
    
      if (!document.querySelector("#full")&&!document.querySelector("#half")) {
        return
      }
    
    if (imgs.length>=1) {
      Parallax.options.src = imgs[index % imgs.length];
      Parallax.start();
      index++;
      if (Parallax.cache) {
        fetch(imgs[index % imgs.length] +"?t=" + new Date().getTime());
        if (index == imgs.length) {
          Parallax.cache = 0;
        }
      }
    }
  }
  var runningOnBrowser = typeof window !== "undefined";
  var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
  if (!isBot) {
    volantis.js('/js/plugins/parallax.js').then(()=>{
      parallax()
    })
    volantis.pjax.send(()=>{
      clearInterval(IntervalParallax)
    },"clearIntervalParallax");
    volantis.pjax.push(parallax);
  }
</script>




  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    let targets = []
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:true})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex=0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    volantis.scroll.push(()=>{
      if (targets[0].getBoundingClientRect().top >= 0) {
        volantis.activateNavIndex = 0
      }else if (targets[targets.length-1].getBoundingClientRect().top < 0) {
        volantis.activateNavIndex = targets.length-1
      } else {
        for (let index = 0; index < targets.length; index++) {
          const target0 = targets[index];
          const target1 = targets[(index+1)%targets.length];
          if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) {
            volantis.activateNavIndex=index
            break;
          }
        }
      }
      activateNavByIndex(navItems[volantis.activateNavIndex])
    })

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>


  <script>
  try {
    // https://web.dev/content-visibility/
    // https://www.caniuse.com/?search=content-visibility
    // https://infrequently.org/2020/12/content-visibility-scroll-fix/
    // https://infrequently.org/2020/12/resize-resilient-deferred-rendering/

    // 备注 目前已知的问题:
    // 动态修改导致的内容高度变化(例如评论框异步渲染的外部盒子高度变化) 无法提前获知, 进而导致的首次滚动条跳动无法去除 (wontfix) 事实上不使用 content-visibility 也会有跳动, 不过是比使用 content-visibility 跳动提前
    // scrollreveal 插件潜在问题 目前尚不明确

    let eqIsh = (a, b, fuzz = 2) => {
      return Math.abs(a - b) <= fuzz;
    };

    let rectNotEQ = (a, b) => {
      return !eqIsh(a.width, b.width) || !eqIsh(a.height, b.height);
    };

    // Keep a map of elements and the dimensions of
    // their place-holders, re-setting the element's
    // intrinsic size when we get updated measurements
    // from observers.
    let spaced = new WeakMap();

    // Only call this when known cheap, post layout
    let reserveSpace = (el, rect = el.getClientBoundingRect()) => {
      let old = spaced.get(el);
      // Set intrinsic size to prevent jumping on un-painting:
      //    https://drafts.csswg.org/css-sizing-4/#intrinsic-size-override
      if (!old || rectNotEQ(old, rect)) {
        spaced.set(el, rect);
        el.style["contain-intrinsic-size"] = `${rect.width}px ${rect.height}px`;
      }
    };

    let iObs = new IntersectionObserver(
      (entries, o) => {
        entries.forEach((entry) => {
          // We don't care if the element is intersecting or
          // has been laid out as our page structure ensures
          // they'll get the right width.
          reserveSpace(entry.target, entry.boundingClientRect);
        });
      },
      { rootMargin: "500px 0px 500px 0px" }
    );

    let rObs = new ResizeObserver((entries, o) => {
      entries.forEach((entry) => {
        reserveSpace(entry.target, entry.contentRect);
      });
    });

    let resizeResilientDeferredRendering = (Selector) => {
      let articles = document.querySelectorAll(Selector);

      if (articles.length) {
        articles.forEach((el) => {
          iObs.observe(el);
          rObs.observe(el);
        });

        // Workaround for Chrome bug, part 2.
        //
        // Re-enable browser management of rendering for the
        // first article after the first paint. Double-rAF
        // to ensure we get called after a layout.
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            articles[0].style["content-visibility"] = "auto";
          });
        });
      }
    };

    let contentVisibilityScrollFix = () => {
      if (!("content-visibility" in document.documentElement.style)) {
        return;
      }
      resizeResilientDeferredRendering(".post-story");
    };
    contentVisibilityScrollFix();
    volantis.pjax.push(contentVisibilityScrollFix);
  } catch (error) {
    console.log(error);
  }
</script>



<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"CodingStudio","url":"http://jay1060950003.github.io/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"jay1060950003","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://jay1060950003.github.io/","sameAs":["https://github.com/volantis-x"],"description":"自己的创作及学习空间"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"http://jay1060950003.github.io/","name":"CodingStudio"}},{"@type":"ListItem","position":2,"item":{"@id":"http://jay1060950003.github.io/categories/C/","name":"C++"}},{"@type":"ListItem","position":3,"item":{"@id":"http://jay1060950003.github.io/2022/03/31/计算机基础知识/C++Primer/","name":"C++Primer"}}]},{"@context":"http://schema.org","@type":"WebSite","name":"CodingStudio","url":"http://jay1060950003.github.io/","keywords":"C++,Java,Qt,OpenCV,后端,开发者,程序猿,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder, 摄影","description":"自己的创作及学习空间","author":{"@type":"Person","name":"jay1060950003","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://jay1060950003.github.io/","description":"自己的创作及学习空间"},"publisher":{"@type":"Organization","name":"CodingStudio","url":"http://jay1060950003.github.io/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"http://jay1060950003.github.io?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"http://schema.org","@type":"BlogPosting","headline":"C++Primer","description":" 引言\n\nC++ Primer的学习笔记\n","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http://jay1060950003.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++Primer/"},"author":{"@type":"Person","name":"jay1060950003","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://jay1060950003.github.io/"},"publisher":{"@type":"Organization","name":"CodingStudio","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"http://jay1060950003.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/C++Primer/","wordCount":21,"datePublished":"2022-03-31T08:52:28.000Z","dateModified":"2023-04-09T13:36:47.123Z","articleSection":"C++","keywords":"C++","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>



      
        <!--
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name=keywords]",
          "head meta[name=description]",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
    <!-- import body_end begin-->
    <!-- import body_end end-->
    <!-- Custom Files bodyEnd begin-->
    
    <!-- Custom Files bodyEnd end-->
    <!-- front-matter body_end begin -->
    <!-- front-matter body_end end -->
  </body>
</html>
